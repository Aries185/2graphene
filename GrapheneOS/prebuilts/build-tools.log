commit 29504cb973eb81ddf3e6a17008effa3534ee1d93 (grafted, HEAD, tag: RQ3A.210605.005.2021.06.08.06, tag: RQ2A.210505.002.2021.05.04.01, tag: RQ2A.210405.005.2021.04.05.20, tag: RQ2A.210305.006.2021.03.02.10, m/master)
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Mon 2021-01-11 07:22:52-0500

    update toybox to ab/7064006 build
---
 Android.bp (new)                                 |    9 +
 OWNERS (new)                                     |    2 +
 build-prebuilts.sh (new +x)                      |  202 ++
 build-tools-kzip.sh (new +x)                     |   28 +
 common/bin/dx (new +x)                           |   89 +
 common/bison/NOTICE (new)                        |  674 +++++
 common/bison/README.md (new)                     |  192 ++
 common/bison/bison-default.css (new)             |   31 +
 common/bison/local.mk (new)                      |   57 +
 common/bison/m4sugar/foreach.m4 (new)            |  362 +++
 common/bison/m4sugar/m4sugar.m4 (new)            | 3308 ++++++++++++++++++++++
 common/bison/skeletons/README-D.txt (new)        |   60 +
 common/bison/skeletons/bison.m4 (new)            | 1118 ++++++++
 common/bison/skeletons/c++-skel.m4 (new)         |   27 +
 common/bison/skeletons/c++.m4 (new)              |  645 +++++
 common/bison/skeletons/c-like.m4 (new)           |   66 +
 common/bison/skeletons/c-skel.m4 (new)           |   27 +
 common/bison/skeletons/c.m4 (new)                |  991 +++++++
 common/bison/skeletons/d-skel.m4 (new)           |   26 +
 common/bison/skeletons/d.m4 (new)                |  332 +++
 common/bison/skeletons/glr.c (new)               | 2642 +++++++++++++++++
 common/bison/skeletons/glr.cc (new)              |  383 +++
 common/bison/skeletons/java-skel.m4 (new)        |   27 +
 common/bison/skeletons/java.m4 (new)             |  364 +++
 common/bison/skeletons/lalr1.cc (new)            | 1463 ++++++++++
 common/bison/skeletons/lalr1.d (new)             |  895 ++++++
 common/bison/skeletons/lalr1.java (new)          | 1045 +++++++
 common/bison/skeletons/location.cc (new)         |  373 +++
 common/bison/skeletons/stack.hh (new)            |  152 +
 common/bison/skeletons/variant.hh (new)          |  453 +++
 common/bison/skeletons/yacc.c (new)              | 1966 +++++++++++++
 common/bison/xslt/bison.xsl (new)                |  105 +
 common/bison/xslt/xml2dot.xsl (new)              |  401 +++
 common/bison/xslt/xml2text.xsl (new)             |  564 ++++
 common/bison/xslt/xml2xhtml.xsl (new)            |  741 +++++
 common/flex/FlexLexer.h (new)                    |  220 ++
 common/flex/NOTICE (new)                         |   42 +
 common/framework/desugar.jar (new)               |  Bin 0 -> 3098024 bytes
 common/framework/dx.jar (new)                    |  Bin 0 -> 1038021 bytes
 common/framework/javac_extractor.jar (new)       |  Bin 0 -> 5454988 bytes
 common/framework/turbine.jar (new)               |  Bin 0 -> 5142998 bytes
 darwin-x86/bin/acp (new +x)                      |  Bin 0 -> 18372 bytes
 darwin-x86/bin/aidl (new +x)                     |  Bin 0 -> 2865512 bytes
 darwin-x86/bin/bison (new +x)                    |  Bin 0 -> 422556 bytes
 darwin-x86/bin/bpfmt (new +x)                    |  Bin 0 -> 2738456 bytes
 darwin-x86/bin/bzip2 (new +x)                    |  Bin 0 -> 106204 bytes
 darwin-x86/bin/ckati (new +x)                    |  Bin 0 -> 363440 bytes
 darwin-x86/bin/ckati_stamp_dump (new +x)         |  Bin 0 -> 252644 bytes
 darwin-x86/bin/flex (new +x)                     |  Bin 0 -> 326972 bytes
 darwin-x86/bin/gavinhoward-bc (new +x)           |  Bin 0 -> 78868 bytes
 darwin-x86/bin/go_extractor (new +x)             |  Bin 0 -> 12006804 bytes
 darwin-x86/bin/hidl-lint (new +x)                |  Bin 0 -> 3694604 bytes
 darwin-x86/bin/m4 (new +x)                       |  Bin 0 -> 238220 bytes
 darwin-x86/bin/make (new +x)                     |  Bin 0 -> 210904 bytes
 darwin-x86/bin/ninja (new +x)                    |  Bin 0 -> 323212 bytes
 darwin-x86/bin/one-true-awk (new +x)             |  Bin 0 -> 143908 bytes
 darwin-x86/bin/py2-cmd (new +x)                  |  Bin 0 -> 8613660 bytes
 darwin-x86/bin/py3-cmd (new +x)                  |  Bin 0 -> 8665020 bytes
 darwin-x86/bin/soong_zip (new +x)                |  Bin 0 -> 3082296 bytes
 darwin-x86/bin/toybox (new +x)                   |  Bin 0 -> 237164 bytes
 darwin-x86/bin/xz (new +x)                       |  Bin 0 -> 194836 bytes
 darwin-x86/bin/zip2zip (new +x)                  |  Bin 0 -> 2735848 bytes
 darwin-x86/bin/zipalign (new +x)                 |  Bin 0 -> 207664 bytes
 darwin-x86/bin/ziptime (new +x)                  |  Bin 0 -> 13656 bytes
 darwin-x86/bin/ziptool (new +x)                  |  Bin 0 -> 29604 bytes
 darwin-x86/lib64/libbase.dylib (new +x)          |  Bin 0 -> 438392 bytes
 darwin-x86/lib64/libc++.dylib (new +x)           |  Bin 0 -> 658420 bytes
 darwin-x86/lib64/libcrypto-host.dylib (new +x)   |  Bin 0 -> 1103032 bytes
 darwin-x86/lib64/libcutils.dylib (new +x)        |  Bin 0 -> 40376 bytes
 darwin-x86/lib64/libjsoncpp.dylib (new +x)       |  Bin 0 -> 113332 bytes
 darwin-x86/lib64/liblog.dylib (new +x)           |  Bin 0 -> 51308 bytes
 darwin-x86/lib64/libssl-host.dylib (new +x)      |  Bin 0 -> 328092 bytes
 darwin-x86/lib64/libz-host.dylib (new +x)        |  Bin 0 -> 101036 bytes
 darwin-x86/lib64/libziparchive.dylib (new +x)    |  Bin 0 -> 65244 bytes
 linux-x86/asan/bin/acp (new +x)                  |  Bin 0 -> 1111024 bytes
 linux-x86/asan/bin/aidl (new +x)                 |  Bin 0 -> 8448064 bytes
 linux-x86/asan/bin/ckati (new +x)                |  Bin 0 -> 2426064 bytes
 linux-x86/asan/bin/gavinhoward-bc (new +x)       |  Bin 0 -> 1309376 bytes
 linux-x86/asan/bin/ninja (new +x)                |  Bin 0 -> 2278264 bytes
 linux-x86/asan/bin/toybox (new +x)               |  Bin 0 -> 2139760 bytes
 linux-x86/asan/bin/zipalign (new +x)             |  Bin 0 -> 1690976 bytes
 linux-x86/asan/bin/ziptime (new +x)              |  Bin 0 -> 1103096 bytes
 linux-x86/asan/bin/ziptool (new +x)              |  Bin 0 -> 1137416 bytes
 linux-x86/asan/lib64/libbase.so (new +x)         |  Bin 0 -> 2297016 bytes
 linux-x86/asan/lib64/libc++.so (new +x)          |  Bin 0 -> 2048896 bytes
 linux-x86/asan/lib64/libcrypto-host.so (new +x)  |  Bin 0 -> 3217480 bytes
 linux-x86/asan/lib64/libcutils.so (new +x)       |  Bin 0 -> 131448 bytes
 linux-x86/asan/lib64/libjemalloc.so (new +x)     |  Bin 0 -> 763712 bytes
 linux-x86/asan/lib64/liblog.so (new +x)          |  Bin 0 -> 161592 bytes
 linux-x86/asan/lib64/libz-host.so (new +x)       |  Bin 0 -> 345768 bytes
 linux-x86/asan/lib64/libziparchive.so (new +x)   |  Bin 0 -> 228912 bytes
 linux-x86/bin/acp (new +x)                       |  Bin 0 -> 15112 bytes
 linux-x86/bin/aidl (new +x)                      |  Bin 0 -> 3073440 bytes
 linux-x86/bin/bison (new +x)                     |  Bin 0 -> 461232 bytes
 linux-x86/bin/bpfmt (new +x)                     |  Bin 0 -> 2771288 bytes
 linux-x86/bin/bzip2 (new +x)                     |  Bin 0 -> 109760 bytes
 linux-x86/bin/ckati (new +x)                     |  Bin 0 -> 410608 bytes
 linux-x86/bin/ckati_stamp_dump (new +x)          |  Bin 0 -> 284152 bytes
 linux-x86/bin/flex (new +x)                      |  Bin 0 -> 441056 bytes
 linux-x86/bin/gavinhoward-bc (new +x)            |  Bin 0 -> 87760 bytes
 linux-x86/bin/go_extractor (new +x)              |  Bin 0 -> 12161765 bytes
 linux-x86/bin/hidl-lint (new +x)                 |  Bin 0 -> 4394112 bytes
 linux-x86/bin/m4 (new +x)                        |  Bin 0 -> 174864 bytes
 linux-x86/bin/make (new +x)                      |  Bin 0 -> 229480 bytes
 linux-x86/bin/ninja (new +x)                     |  Bin 0 -> 380072 bytes
 linux-x86/bin/nsjail (new +x)                    |  Bin 0 -> 243528 bytes
 linux-x86/bin/one-true-awk (new +x)              |  Bin 0 -> 157264 bytes
 linux-x86/bin/py2-cmd (new +x)                   |  Bin 0 -> 9696854 bytes
 linux-x86/bin/py3-cmd (new +x)                   |  Bin 0 -> 9604912 bytes
 linux-x86/bin/soong_zip (new +x)                 |  Bin 0 -> 3110176 bytes
 linux-x86/bin/toybox (new +x)                    |  Bin 0 -> 282496 bytes
 linux-x86/bin/xz (new +x)                        |  Bin 0 -> 216488 bytes
 linux-x86/bin/zip2zip (new +x)                   |  Bin 0 -> 2739917 bytes
 linux-x86/bin/zipalign (new +x)                  |  Bin 0 -> 222224 bytes
 linux-x86/bin/ziptime (new +x)                   |  Bin 0 -> 10704 bytes
 linux-x86/bin/ziptool (new +x)                   |  Bin 0 -> 268488 bytes
 linux-x86/lib64/libbase.so (new +x)              |  Bin 0 -> 574600 bytes
 linux-x86/lib64/libc++.so (new +x)               |  Bin 0 -> 932608 bytes
 linux-x86/lib64/libcrypto-host.so (new +x)       |  Bin 0 -> 1702656 bytes
 linux-x86/lib64/libcutils.so (new +x)            |  Bin 0 -> 50336 bytes
 linux-x86/lib64/libjemalloc.so (new +x)          |  Bin 0 -> 270976 bytes
 linux-x86/lib64/libjsoncpp.so (new +x)           |  Bin 0 -> 145296 bytes
 linux-x86/lib64/liblog.so (new +x)               |  Bin 0 -> 64192 bytes
 linux-x86/lib64/libprotobuf-cpp-full.so (new +x) |  Bin 0 -> 2694496 bytes
 linux-x86/lib64/libssl-host.so (new +x)          |  Bin 0 -> 399240 bytes
 linux-x86/lib64/libz-host.so (new +x)            |  Bin 0 -> 108352 bytes
 linux-x86/lib64/libziparchive.so (new +x)        |  Bin 0 -> 87008 bytes
 manifest.xml (new)                               |  175 ++
 path/README (new)                                |    3 +
 path/darwin-x86/awk (new +l)                     |    1 +
 path/darwin-x86/basename (new +l)                |    1 +
 path/darwin-x86/bc (new +l)                      |    1 +
 path/darwin-x86/bzcat (new +l)                   |    1 +
 path/darwin-x86/bzip2 (new +l)                   |    1 +
 path/darwin-x86/cat (new +l)                     |    1 +
 path/darwin-x86/chmod (new +l)                   |    1 +
 path/darwin-x86/cmp (new +l)                     |    1 +
 path/darwin-x86/comm (new +l)                    |    1 +
 path/darwin-x86/cp (new +l)                      |    1 +
 path/darwin-x86/cut (new +l)                     |    1 +
 path/darwin-x86/date (new +l)                    |    1 +
 path/darwin-x86/dirname (new +l)                 |    1 +
 path/darwin-x86/du (new +l)                      |    1 +
 path/darwin-x86/echo (new +l)                    |    1 +
 path/darwin-x86/egrep (new +l)                   |    1 +
 path/darwin-x86/env (new +l)                     |    1 +
 path/darwin-x86/find (new +l)                    |    1 +
 path/darwin-x86/getconf (new +l)                 |    1 +
 path/darwin-x86/grep (new +l)                    |    1 +
 path/darwin-x86/gzip (new +l)                    |    1 +
 path/darwin-x86/head (new +l)                    |    1 +
 path/darwin-x86/hostname (new +l)                |    1 +
 path/darwin-x86/id (new +l)                      |    1 +
 path/darwin-x86/ln (new +l)                      |    1 +
 path/darwin-x86/ls (new +l)                      |    1 +
 path/darwin-x86/md5sum (new +l)                  |    1 +
 path/darwin-x86/mkdir (new +l)                   |    1 +
 path/darwin-x86/mktemp (new +l)                  |    1 +
 path/darwin-x86/mv (new +l)                      |    1 +
 path/darwin-x86/od (new +l)                      |    1 +
 path/darwin-x86/paste (new +l)                   |    1 +
 path/darwin-x86/pwd (new +l)                     |    1 +
 path/darwin-x86/python (new +l)                  |    1 +
 path/darwin-x86/python2 (new +l)                 |    1 +
 path/darwin-x86/python2.7 (new +l)               |    1 +
 path/darwin-x86/python3 (new +l)                 |    1 +
 path/darwin-x86/readlink (new +l)                |    1 +
 path/darwin-x86/realpath (new +l)                |    1 +
 path/darwin-x86/rm (new +l)                      |    1 +
 path/darwin-x86/rmdir (new +l)                   |    1 +
 path/darwin-x86/sed (new +l)                     |    1 +
 path/darwin-x86/seq (new +l)                     |    1 +
 path/darwin-x86/setsid (new +l)                  |    1 +
 path/darwin-x86/sha1sum (new +l)                 |    1 +
 path/darwin-x86/sha256sum (new +l)               |    1 +
 path/darwin-x86/sha512sum (new +l)               |    1 +
 path/darwin-x86/sleep (new +l)                   |    1 +
 path/darwin-x86/sort (new +l)                    |    1 +
 path/darwin-x86/stat (new +l)                    |    1 +
 path/darwin-x86/tail (new +l)                    |    1 +
 path/darwin-x86/tar (new +l)                     |    1 +
 path/darwin-x86/tee (new +l)                     |    1 +
 path/darwin-x86/timeout (new +l)                 |    1 +
 path/darwin-x86/touch (new +l)                   |    1 +
 path/darwin-x86/true (new +l)                    |    1 +
 path/darwin-x86/truncate (new +l)                |    1 +
 path/darwin-x86/uname (new +l)                   |    1 +
 path/darwin-x86/uniq (new +l)                    |    1 +
 path/darwin-x86/unix2dos (new +l)                |    1 +
 path/darwin-x86/wc (new +l)                      |    1 +
 path/darwin-x86/which (new +l)                   |    1 +
 path/darwin-x86/whoami (new +l)                  |    1 +
 path/darwin-x86/xargs (new +l)                   |    1 +
 path/darwin-x86/xxd (new +l)                     |    1 +
 path/darwin-x86/xz (new +l)                      |    1 +
 path/darwin-x86/xzcat (new +l)                   |    1 +
 path/darwin-x86/zipinfo (new +l)                 |    1 +
 path/linux-x86/awk (new +l)                      |    1 +
 path/linux-x86/basename (new +l)                 |    1 +
 path/linux-x86/bc (new +l)                       |    1 +
 path/linux-x86/bzcat (new +l)                    |    1 +
 path/linux-x86/bzip2 (new +l)                    |    1 +
 path/linux-x86/cat (new +l)                      |    1 +
 path/linux-x86/chmod (new +l)                    |    1 +
 path/linux-x86/cmp (new +l)                      |    1 +
 path/linux-x86/comm (new +l)                     |    1 +
 path/linux-x86/cp (new +l)                       |    1 +
 path/linux-x86/cut (new +l)                      |    1 +
 path/linux-x86/date (new +l)                     |    1 +
 path/linux-x86/dirname (new +l)                  |    1 +
 path/linux-x86/du (new +l)                       |    1 +
 path/linux-x86/echo (new +l)                     |    1 +
 path/linux-x86/egrep (new +l)                    |    1 +
 path/linux-x86/env (new +l)                      |    1 +
 path/linux-x86/find (new +l)                     |    1 +
 path/linux-x86/getconf (new +l)                  |    1 +
 path/linux-x86/grep (new +l)                     |    1 +
 path/linux-x86/gzip (new +l)                     |    1 +
 path/linux-x86/head (new +l)                     |    1 +
 path/linux-x86/hostname (new +l)                 |    1 +
 path/linux-x86/id (new +l)                       |    1 +
 path/linux-x86/ln (new +l)                       |    1 +
 path/linux-x86/ls (new +l)                       |    1 +
 path/linux-x86/md5sum (new +l)                   |    1 +
 path/linux-x86/mkdir (new +l)                    |    1 +
 path/linux-x86/mktemp (new +l)                   |    1 +
 path/linux-x86/mv (new +l)                       |    1 +
 path/linux-x86/od (new +l)                       |    1 +
 path/linux-x86/paste (new +l)                    |    1 +
 path/linux-x86/pgrep (new +l)                    |    1 +
 path/linux-x86/pkill (new +l)                    |    1 +
 path/linux-x86/ps (new +l)                       |    1 +
 path/linux-x86/pwd (new +l)                      |    1 +
 path/linux-x86/python (new +l)                   |    1 +
 path/linux-x86/python2 (new +l)                  |    1 +
 path/linux-x86/python2.7 (new +l)                |    1 +
 path/linux-x86/python3 (new +l)                  |    1 +
 path/linux-x86/readlink (new +l)                 |    1 +
 path/linux-x86/realpath (new +l)                 |    1 +
 path/linux-x86/rm (new +l)                       |    1 +
 path/linux-x86/rmdir (new +l)                    |    1 +
 path/linux-x86/sed (new +l)                      |    1 +
 path/linux-x86/seq (new +l)                      |    1 +
 path/linux-x86/setsid (new +l)                   |    1 +
 path/linux-x86/sha1sum (new +l)                  |    1 +
 path/linux-x86/sha256sum (new +l)                |    1 +
 path/linux-x86/sha512sum (new +l)                |    1 +
 path/linux-x86/sleep (new +l)                    |    1 +
 path/linux-x86/sort (new +l)                     |    1 +
 path/linux-x86/stat (new +l)                     |    1 +
 path/linux-x86/tail (new +l)                     |    1 +
 path/linux-x86/tar (new +l)                      |    1 +
 path/linux-x86/tee (new +l)                      |    1 +
 path/linux-x86/timeout (new +l)                  |    1 +
 path/linux-x86/touch (new +l)                    |    1 +
 path/linux-x86/true (new +l)                     |    1 +
 path/linux-x86/truncate (new +l)                 |    1 +
 path/linux-x86/uname (new +l)                    |    1 +
 path/linux-x86/uniq (new +l)                     |    1 +
 path/linux-x86/unix2dos (new +l)                 |    1 +
 path/linux-x86/wc (new +l)                       |    1 +
 path/linux-x86/which (new +l)                    |    1 +
 path/linux-x86/whoami (new +l)                   |    1 +
 path/linux-x86/xargs (new +l)                    |    1 +
 path/linux-x86/xxd (new +l)                      |    1 +
 path/linux-x86/xz (new +l)                       |    1 +
 path/linux-x86/xzcat (new +l)                    |    1 +
 path/linux-x86/zipinfo (new +l)                  |    1 +
 update-prebuilts.sh (new +x)                     |   52 +
 269 files changed, 20451 insertions(+)

diff --git a/Android.bp b/Android.bp
new file mode 100644
index 0000000000000000000000000000000000000000..758bd469011fdb971c4c06d13ed1408e81385b75
--- /dev/null
+++ b/Android.bp
@@ -0,0 +1,9 @@
+cc_library_headers {
+    name: "FlexLexer",
+    host_supported: true,
+    vendor_available: true,
+    // TODO(b/153609531): remove when no longer needed.
+    native_bridge_supported: true,
+    export_include_dirs: ["common/flex"],
+    notice: "common/flex/NOTICE",
+}
diff --git a/OWNERS b/OWNERS
new file mode 100644
index 0000000000000000000000000000000000000000..89b446a634f7716ec54c001e47519796ca37663e
--- /dev/null
+++ b/OWNERS
@@ -0,0 +1,2 @@
+ccross@android.com
+dwillemsen@google.com
diff --git a/build-prebuilts.sh b/build-prebuilts.sh
new file mode 100755
index 0000000000000000000000000000000000000000..b12d3c6fb0c861e92c8d09eee200435b0779b888
--- /dev/null
+++ b/build-prebuilts.sh
@@ -0,0 +1,202 @@
+#!/bin/bash -ex
+
+: "${OUT_DIR:?Must set OUT_DIR}"
+TOP=$(pwd)
+
+UNAME="$(uname)"
+case "$UNAME" in
+Linux)
+    OS='linux'
+    ;;
+Darwin)
+    OS='darwin'
+    ;;
+*)
+    exit 1
+    ;;
+esac
+
+build_soong=1
+[[ ! -d ${TOP}/toolchain/go ]] || build_go=1
+clean=t
+[[ "${1:-}" != '--resume' ]] || clean=''
+
+if [ -n ${build_soong} ]; then
+    SOONG_OUT=${OUT_DIR}/soong
+    SOONG_HOST_OUT=${OUT_DIR}/soong/host/${OS}-x86
+    [[ -z "${clean}" ]] || rm -rf ${SOONG_OUT}
+    mkdir -p ${SOONG_OUT}
+    cat > ${SOONG_OUT}/soong.variables << EOF
+{
+    "Allow_missing_dependencies": true,
+    "HostArch":"x86_64"
+}
+EOF
+    SOONG_BINARIES=(
+        acp
+        aidl
+        bison
+        bpfmt
+        bzip2
+        ckati
+        ckati_stamp_dump
+        flex
+        gavinhoward-bc
+        go_extractor
+        hidl-lint
+        m4
+        make
+        ninja
+        one-true-awk
+        py2-cmd
+        py3-cmd
+        soong_zip
+        toybox
+        xz
+        zip2zip
+        zipalign
+        ziptime
+        ziptool
+    )
+    SOONG_ASAN_BINARIES=(
+        acp
+        aidl
+        ckati
+        gavinhoward-bc
+        ninja
+        toybox
+        zipalign
+        ziptime
+        ziptool
+    )
+    SOONG_JAVA_LIBRARIES=(
+        desugar.jar
+        dx.jar
+        turbine.jar
+        javac_extractor.jar
+    )
+    SOONG_JAVA_WRAPPERS=(
+        dx
+    )
+    if [[ $OS == "linux" ]]; then
+        SOONG_BINARIES+=(
+            nsjail
+        )
+    fi
+
+    binaries="${SOONG_BINARIES[@]/#/${SOONG_HOST_OUT}/bin/}"
+    asan_binaries="${SOONG_ASAN_BINARIES[@]/#/${SOONG_HOST_OUT}/bin/}"
+    jars="${SOONG_JAVA_LIBRARIES[@]/#/${SOONG_HOST_OUT}/framework/}"
+    wrappers="${SOONG_JAVA_WRAPPERS[@]/#/${SOONG_HOST_OUT}/bin/}"
+
+    # Build everything
+    build/soong/soong_ui.bash --make-mode --skip-make \
+        ${binaries} \
+        ${wrappers} \
+        ${jars} \
+        ${SOONG_HOST_OUT}/nativetest64/ninja_test/ninja_test \
+        ${SOONG_HOST_OUT}/nativetest64/ckati_test/find_test \
+        soong_docs
+
+    # Run ninja tests
+    ${SOONG_HOST_OUT}/nativetest64/ninja_test/ninja_test
+
+    # Run ckati tests
+    ${SOONG_HOST_OUT}/nativetest64/ckati_test/find_test
+
+    # Copy arch-specific binaries
+    mkdir -p ${SOONG_OUT}/dist/bin
+    cp ${binaries} ${SOONG_OUT}/dist/bin/
+    cp -R ${SOONG_HOST_OUT}/lib* ${SOONG_OUT}/dist/
+
+    # Copy jars and wrappers
+    mkdir -p ${SOONG_OUT}/dist-common/{bin,flex,framework}
+    cp ${wrappers} ${SOONG_OUT}/dist-common/bin
+    cp ${jars} ${SOONG_OUT}/dist-common/framework
+
+    cp -r external/bison/data ${SOONG_OUT}/dist-common/bison
+    cp external/bison/NOTICE ${SOONG_OUT}/dist-common/bison/
+    cp -r external/flex/src/FlexLexer.h ${SOONG_OUT}/dist-common/flex/
+    cp external/flex/NOTICE ${SOONG_OUT}/dist-common/flex/
+
+    if [[ $OS == "linux" ]]; then
+        # Build ASAN versions
+        export ASAN_OPTIONS=detect_leaks=0
+        cat > ${SOONG_OUT}/soong.variables << EOF
+{
+    "Allow_missing_dependencies": true,
+    "HostArch":"x86_64",
+    "SanitizeHost": ["address"]
+}
+EOF
+
+        export ASAN_SYMBOLIZER_PATH=${PWD}/prebuilts/clang/host/linux-x86/llvm-binutils-stable/llvm-symbolizer
+
+        # Clean up non-ASAN installed versions
+        rm -rf ${SOONG_HOST_OUT}
+
+        # Build everything with ASAN
+        build/soong/soong_ui.bash --make-mode --skip-make \
+            ${asan_binaries} \
+            ${SOONG_HOST_OUT}/nativetest64/ninja_test/ninja_test \
+            ${SOONG_HOST_OUT}/nativetest64/ckati_test/find_test
+
+        # Run ninja tests
+        ${SOONG_HOST_OUT}/nativetest64/ninja_test/ninja_test
+
+        # Run ckati tests
+        ${SOONG_HOST_OUT}/nativetest64/ckati_test/find_test
+
+        # Copy arch-specific binaries
+        mkdir -p ${SOONG_OUT}/dist/asan/bin
+        cp ${asan_binaries} ${SOONG_OUT}/dist/asan/bin/
+        cp -R ${SOONG_HOST_OUT}/lib* ${SOONG_OUT}/dist/asan/
+    fi
+
+    # Package arch-specific prebuilts
+    (
+        cd ${SOONG_OUT}/dist
+        zip -qryX build-prebuilts.zip *
+    )
+
+    # Package common prebuilts
+    (
+        cd ${SOONG_OUT}/dist-common
+        zip -qryX build-common-prebuilts.zip *
+    )
+fi
+
+# Go
+if [ -n ${build_go} ]; then
+    GO_OUT=${OUT_DIR}/obj/go
+    rm -rf ${GO_OUT}
+    mkdir -p ${GO_OUT}
+    cp -a ${TOP}/toolchain/go/* ${GO_OUT}/
+    (
+        cd ${GO_OUT}/src
+        export GOROOT_BOOTSTRAP=${TOP}/prebuilts/go/${OS}-x86
+        export GOROOT_FINAL=./prebuilts/go/${OS}-x86
+        export GO_TEST_TIMEOUT_SCALE=100
+        ./make.bash
+        rm -rf ../pkg/bootstrap
+        rm -rf ../pkg/obj
+        GOROOT=$(pwd)/.. ../bin/go install -race std
+    )
+    (
+        cd ${GO_OUT}
+        zip -qryX go.zip *
+    )
+fi
+
+if [ -n "${DIST_DIR}" ]; then
+    mkdir -p ${DIST_DIR} || true
+
+    if [ -n ${build_soong} ]; then
+        cp ${SOONG_OUT}/dist/build-prebuilts.zip ${DIST_DIR}/
+        cp ${SOONG_OUT}/dist-common/build-common-prebuilts.zip ${DIST_DIR}/
+        cp ${SOONG_OUT}/docs/*.html ${DIST_DIR}/
+    fi
+    if [ -n ${build_go} ]; then
+        cp ${GO_OUT}/go.zip ${DIST_DIR}/
+    fi
+fi
diff --git a/build-tools-kzip.sh b/build-tools-kzip.sh
new file mode 100755
index 0000000000000000000000000000000000000000..ac11630cbfffb36272bff121164e4c3b83e87ad9
--- /dev/null
+++ b/build-tools-kzip.sh
@@ -0,0 +1,28 @@
+#!/bin/bash -eu
+#
+# Builds cumulative cross-reference extraction file (.kzip) for all the 
+# modules defined and buildable in this repository.
+# Usage:
+#   cd <repository top> && OUT_DIR=<output dir> prebuilts/build-tools-kzip.sh
+# Generates $OUT_DIR/all.zkip
+
+declare -r corpus=android.googlesource.com/platform/superproject
+mkdir -p "${OUT_DIR:?Specify output directory}/soong"
+
+# Build for x86, ignore missing references.
+printf '{"Allow_missing_dependencies": true, "HostArch":"x86_64" }\n' >"${OUT_DIR}/soong/soong.variables"
+
+# Some of targets will fail because of the missing references, but there
+# will be sufficient number of successfully compiled modules.
+XREF_CORPUS="${corpus}" build/soong/soong_ui.bash --make-mode --skip-make -k xref_java xref_cxx || echo Ignoring errors
+
+# Package it all into a single .kzip, ignoring duplicates.
+allkzip=$(realpath "${OUT_DIR}/all.kzip")
+rm -f "${allkzip}"
+tempdir=$(mktemp -d)
+for zip in $(find "${OUT_DIR}" -name '*.kzip'); do
+    unzip -qn "${zip}" -d "${tempdir}"
+done
+(cd "${tempdir}" && zip -9rmq "${allkzip}" . && rmdir "${tempdir}")
+printf "Created %s with %d compilation units\n" "${allkzip}" $(zipinfo "${allkzip}" 'root/units/?*' | wc -l)
+
diff --git a/common/bin/dx b/common/bin/dx
new file mode 100755
index 0000000000000000000000000000000000000000..632af438ff5d3f7b04283a7c7b1056e84e634e92
--- /dev/null
+++ b/common/bin/dx
@@ -0,0 +1,89 @@
+#!/bin/bash
+#
+# Copyright (C) 2007 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Set up prog to be the path of this script, including following symlinks,
+# and set up progdir to be the fully-qualified pathname of its directory.
+prog="$0"
+while [ -h "${prog}" ]; do
+    newProg=`/bin/ls -ld "${prog}"`
+    newProg=`expr "${newProg}" : ".* -> \(.*\)$"`
+    if expr "x${newProg}" : 'x/' >/dev/null; then
+        prog="${newProg}"
+    else
+        progdir=`dirname "${prog}"`
+        prog="${progdir}/${newProg}"
+    fi
+done
+oldwd=`pwd`
+progdir=`dirname "${prog}"`
+cd "${progdir}"
+progdir=`pwd`
+prog="${progdir}"/`basename "${prog}"`
+cd "${oldwd}"
+
+jarfile=dx.jar
+libdir="$progdir"
+
+if [ ! -r "$libdir/$jarfile" ]; then
+    # set dx.jar location for the SDK case
+    libdir="$libdir/lib"
+fi
+
+
+if [ ! -r "$libdir/$jarfile" ]; then
+    # set dx.jar location for the Android tree case
+    libdir=`dirname "$progdir"`/framework
+fi
+
+if [ ! -r "$libdir/$jarfile" ]; then
+    echo `basename "$prog"`": can't find $jarfile"
+    exit 1
+fi
+
+# By default, give dx a max heap size of 1 gig. This can be overridden
+# by using a "-J" option (see below).
+defaultMx="-Xmx1024M"
+
+# The following will extract any initial parameters of the form
+# "-J<stuff>" from the command line and pass them to the Java
+# invocation (instead of to dx). This makes it possible for you to add
+# a command-line parameter such as "-JXmx256M" in your scripts, for
+# example. "java" (with no args) and "java -X" give a summary of
+# available options.
+
+javaOpts=""
+
+while expr "x$1" : 'x-J' >/dev/null; do
+    opt=`expr "x$1" : 'x-J\(.*\)'`
+    javaOpts="${javaOpts} -${opt}"
+    if expr "x${opt}" : "xXmx[0-9]" >/dev/null; then
+        defaultMx="no"
+    fi
+    shift
+done
+
+if [ "${defaultMx}" != "no" ]; then
+    javaOpts="${javaOpts} ${defaultMx}"
+fi
+
+if [ "$OSTYPE" = "cygwin" ]; then
+    # For Cygwin, convert the jarfile path into native Windows style.
+    jarpath=`cygpath -w "$libdir/$jarfile"`
+else
+    jarpath="$libdir/$jarfile"
+fi
+
+exec java $javaOpts -jar "$jarpath" "$@"
diff --git a/common/bison/NOTICE b/common/bison/NOTICE
new file mode 100644
index 0000000000000000000000000000000000000000..94a9ed024d3859793618152ea559a168bbcbb5e2
--- /dev/null
+++ b/common/bison/NOTICE
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/common/bison/README.md b/common/bison/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..94e9891b3ed59341c78710941f931064d4197e82
--- /dev/null
+++ b/common/bison/README.md
@@ -0,0 +1,192 @@
+This directory contains data needed by Bison.
+
+# Directory content
+## Skeletons
+Bison skeletons: the general shapes of the different parser kinds, that are
+specialized for specific grammars by the bison program.
+
+Currently, the supported skeletons are:
+
+- yacc.c
+  It used to be named bison.simple: it corresponds to C Yacc
+  compatible LALR(1) parsers.
+
+- lalr1.cc
+  Produces a C++ parser class.
+
+- lalr1.java
+  Produces a Java parser class.
+
+- glr.c
+  A Generalized LR C parser based on Bison's LALR(1) tables.
+
+- glr.cc
+  A Generalized LR C++ parser.  Actually a C++ wrapper around glr.c.
+
+These skeletons are the only ones supported by the Bison team.  Because the
+interface between skeletons and the bison program is not finished, *we are
+not bound to it*.  In particular, Bison is not mature enough for us to
+consider that "foreign skeletons" are supported.
+
+## m4sugar
+This directory contains M4sugar, sort of an extended library for M4, which
+is used by Bison to instantiate the skeletons.
+
+## xslt
+This directory contains XSLT programs that transform Bison's XML output into
+various formats.
+
+- bison.xsl
+  A library of routines used by the other XSLT programs.
+
+- xml2dot.xsl
+  Conversion into GraphViz's dot format.
+
+- xml2text.xsl
+  Conversion into text.
+
+- xml2xhtml.xsl
+  Conversion into XHTML.
+
+# Implementation note about the skeletons
+
+"Skeleton" in Bison parlance means "backend": a skeleton is fed by the bison
+executable with LR tables, facts about the symbols, etc. and they generate
+the output (say parser.cc, parser.hh, location.hh, etc.).  They are only in
+charge of generating the parser and its auxiliary files, they do not
+generate the XML output, the parser.output reports, nor the graphical
+rendering.
+
+The bits of information passing from bison to the backend is named
+"muscles".  Muscles are passed to M4 via its standard input: it's a set of
+m4 definitions.  To see them, use `--trace=muscles`.
+
+Except for muscles, whose names are generated by bison, the skeletons have
+no constraint at all on the macro names: there is no technical/theoretical
+limitation, as long as you generate the output, you can do what you want.
+However, of course, that would be a bad idea if, say, the C and C++
+skeletons used different approaches and had completely different
+implementations.  That would be a maintenance nightmare.
+
+Below, we document some of the macros that we use in several of the
+skeletons.  If you are to write a new skeleton, please, implement them for
+your language.  Overall, be sure to follow the same patterns as the existing
+skeletons.
+
+## Symbols
+
+### `b4_symbol(NUM, FIELD)`
+In order to unify the handling of the various aspects of symbols (tag, type
+name, whether terminal, etc.), bison.exe defines one macro per (token,
+field), where field can `has_id`, `id`, etc.: see
+`prepare_symbols_definitions()` in `src/output.c`.
+
+The macro `b4_symbol(NUM, FIELD)` gives access to the following FIELDS:
+
+- `has_id`: 0 or 1.
+
+  Whether the symbol has an id.
+
+- `id`: string
+  If has_id, the id (prefixed by api.token.prefix if defined), otherwise
+  defined as empty.  Guaranteed to be usable as a C identifier.
+
+- `tag`: string.
+  A representation of the symbol.  Can be 'foo', 'foo.id', '"foo"' etc.
+
+- `user_number`: integer
+  The external number as used by yylex.  Can be ASCII code when a character,
+  some number chosen by bison, or some user number in the case of
+  %token FOO <NUM>.  Corresponds to yychar in yacc.c.
+
+- `is_token`: 0 or 1
+  Whether this is a terminal symbol.
+
+- `number`: integer
+  The internal number (computed from the external number by yytranslate).
+  Corresponds to yytoken in yacc.c.  This is the same number that serves as
+  key in b4_symbol(NUM, FIELD).
+
+  In bison, symbols are first assigned increasing numbers in order of
+  appearance (but tokens first, then nterms).  After grammar reduction,
+  unused nterms are then renumbered to appear last (i.e., first tokens, then
+  used nterms and finally unused nterms).  This final number NUM is the one
+  contained in this field, and it is the one used as key in `b4_symbol(NUM,
+  FIELD)`.
+
+  The code of the rule actions, however, is emitted before we know what
+  symbols are unused, so they use the original numbers.  To avoid confusion,
+  they actually use "orig NUM" instead of just "NUM".  bison also emits
+  definitions for `b4_symbol(orig NUM, number)` that map from original
+  numbers to the new ones.  `b4_symbol` actually resolves `orig NUM` in the
+  other case, i.e., `b4_symbol(orig 42, tag)` would return the tag of the
+  symbols whose original number was 42.
+
+- `has_type`: 0, 1
+  Whether has a semantic value.
+
+- `type_tag`: string
+  When api.value.type=union, the generated name for the union member.
+  yytype_INT etc. for symbols that has_id, otherwise yytype_1 etc.
+
+- `type`
+  If it has a semantic value, its type tag, or, if variant are used,
+  its type.
+  In the case of api.value.type=union, type is the real type (e.g. int).
+
+- `has_printer`: 0, 1
+- `printer`: string
+- `printer_file`: string
+- `printer_line`: integer
+- `printer_loc`: location
+  If the symbol has a printer, everything about it.
+
+- `has_destructor`, `destructor`, `destructor_file`, `destructor_line`, `destructor_loc`
+  Likewise.
+
+### `b4_symbol_value(VAL, [SYMBOL-NUM], [TYPE-TAG])`
+Expansion of $$, $1, $<TYPE-TAG>3, etc.
+
+The semantic value from a given VAL.
+- `VAL`: some semantic value storage (typically a union).  e.g., `yylval`
+- `SYMBOL-NUM`: the symbol number from which we extract the type tag.
+- `TYPE-TAG`, the user forced the `<TYPE-TAG>`.
+
+The result can be used safely, it is put in parens to avoid nasty precedence
+issues.
+
+### `b4_lhs_value(SYMBOL-NUM, [TYPE])`
+Expansion of `$$` or `$<TYPE>$`, for symbol `SYMBOL-NUM`.
+
+### `b4_rhs_data(RULE-LENGTH, POS)`
+The data corresponding to the symbol `#POS`, where the current rule has
+`RULE-LENGTH` symbols on RHS.
+
+### `b4_rhs_value(RULE-LENGTH, POS, SYMBOL-NUM, [TYPE])`
+Expansion of `$<TYPE>POS`, where the current rule has `RULE-LENGTH` symbols
+on RHS.
+
+-----
+
+Local Variables:
+mode: markdown
+fill-column: 76
+ispell-dictionary: "american"
+End:
+
+Copyright (C) 2002, 2008-2015, 2018-2019 Free Software Foundation, Inc.
+
+This file is part of GNU Bison.
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
diff --git a/common/bison/bison-default.css b/common/bison/bison-default.css
new file mode 100644
index 0000000000000000000000000000000000000000..68df166ae514fed0bc45da870c8efb4d3fc49d2d
--- /dev/null
+++ b/common/bison/bison-default.css
@@ -0,0 +1,31 @@
+/* Default styling rules for Bison when doing terminal output.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* This is an experimental feature.  The class names may change in the
+   future.  */
+
+/* Diagnostics.  */
+.warning   { color: purple; }
+.error     { color: red; }
+.note      { color: cyan; }
+
+.fixit-insert { color: green; }
+
+/* Semantic values in Bison's own parser traces.  */
+.value     { color: green; }
+
+/* "Sections" in traces (--trace).  */
+.trace0    { color: green; }
diff --git a/common/bison/local.mk b/common/bison/local.mk
new file mode 100644
index 0000000000000000000000000000000000000000..f82aee7ef55e65561d14a488a6dd59ccd0a59698
--- /dev/null
+++ b/common/bison/local.mk
@@ -0,0 +1,57 @@
+## Copyright (C) 2002, 2005-2015, 2018-2019 Free Software Foundation,
+## Inc.
+
+## This program is free software: you can redistribute it and/or modify
+## it under the terms of the GNU General Public License as published by
+## the Free Software Foundation, either version 3 of the License, or
+## (at your option) any later version.
+##
+## This program is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+dist_pkgdata_DATA =                             \
+  data/README.md                                \
+  data/bison-default.css
+
+skeletonsdir = $(pkgdatadir)/skeletons
+dist_skeletons_DATA =                           \
+  data/skeletons/bison.m4                       \
+  data/skeletons/c++-skel.m4                    \
+  data/skeletons/c++.m4                         \
+  data/skeletons/c-like.m4                      \
+  data/skeletons/c-skel.m4                      \
+  data/skeletons/c.m4                           \
+  data/skeletons/glr.c                          \
+  data/skeletons/glr.cc                         \
+  data/skeletons/java-skel.m4                   \
+  data/skeletons/java.m4                        \
+  data/skeletons/lalr1.cc                       \
+  data/skeletons/lalr1.java                     \
+  data/skeletons/location.cc                    \
+  data/skeletons/stack.hh                       \
+  data/skeletons/variant.hh                     \
+  data/skeletons/yacc.c
+
+# Experimental support for the D language.
+dist_skeletons_DATA +=                          \
+  data/skeletons/README-D.txt                   \
+  data/skeletons/d-skel.m4                      \
+  data/skeletons/d.m4                           \
+  data/skeletons/lalr1.d
+
+m4sugardir = $(pkgdatadir)/m4sugar
+dist_m4sugar_DATA =                             \
+  data/m4sugar/foreach.m4                       \
+  data/m4sugar/m4sugar.m4
+
+xsltdir = $(pkgdatadir)/xslt
+dist_xslt_DATA =                                \
+  data/xslt/bison.xsl                           \
+  data/xslt/xml2dot.xsl                         \
+  data/xslt/xml2text.xsl                        \
+  data/xslt/xml2xhtml.xsl
diff --git a/common/bison/m4sugar/foreach.m4 b/common/bison/m4sugar/foreach.m4
new file mode 100644
index 0000000000000000000000000000000000000000..7093d0fcc4e858a997be57094ddf5df7d4103713
--- /dev/null
+++ b/common/bison/m4sugar/foreach.m4
@@ -0,0 +1,362 @@
+#                                                  -*- Autoconf -*-
+# This file is part of Autoconf.
+# foreach-based replacements for recursive functions.
+# Speeds up GNU M4 1.4.x by avoiding quadratic $@ recursion, but penalizes
+# GNU M4 1.6 by requiring more memory and macro expansions.
+#
+# Copyright (C) 2008-2017 Free Software Foundation, Inc.
+
+# This file is part of Autoconf.  This program is free
+# software; you can redistribute it and/or modify it under the
+# terms of the GNU General Public License as published by the
+# Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# Under Section 7 of GPL version 3, you are granted additional
+# permissions described in the Autoconf Configure Script Exception,
+# version 3.0, as published by the Free Software Foundation.
+#
+# You should have received a copy of the GNU General Public License
+# and a copy of the Autoconf Configure Script Exception along with
+# this program; see the files COPYINGv3 and COPYING.EXCEPTION
+# respectively.  If not, see <https://www.gnu.org/licenses/>.
+
+# Written by Eric Blake.
+
+# In M4 1.4.x, every byte of $@ is rescanned.  This means that an
+# algorithm on n arguments that recurses with one less argument each
+# iteration will scan n * (n + 1) / 2 arguments, for O(n^2) time.  In
+# M4 1.6, this was fixed so that $@ is only scanned once, then
+# back-references are made to information stored about the scan.
+# Thus, n iterations need only scan n arguments, for O(n) time.
+# Additionally, in M4 1.4.x, recursive algorithms did not clean up
+# memory very well, requiring O(n^2) memory rather than O(n) for n
+# iterations.
+#
+# This file is designed to overcome the quadratic nature of $@
+# recursion by writing a variant of m4_foreach that uses m4_for rather
+# than $@ recursion to operate on the list.  This involves more macro
+# expansions, but avoids the need to rescan a quadratic number of
+# arguments, making these replacements very attractive for M4 1.4.x.
+# On the other hand, in any version of M4, expanding additional macros
+# costs additional time; therefore, in M4 1.6, where $@ recursion uses
+# fewer macros, these replacements actually pessimize performance.
+# Additionally, the use of $10 to mean the tenth argument violates
+# POSIX; although all versions of m4 1.4.x support this meaning, a
+# future m4 version may switch to take it as the first argument
+# concatenated with a literal 0, so the implementations in this file
+# are not future-proof.  Thus, this file is conditionally included as
+# part of m4_init(), only when it is detected that M4 probably has
+# quadratic behavior (ie. it lacks the macro __m4_version__).
+#
+# Please keep this file in sync with m4sugar.m4.
+
+# _m4_foreach(PRE, POST, IGNORED, ARG...)
+# ---------------------------------------
+# Form the common basis of the m4_foreach and m4_map macros.  For each
+# ARG, expand PRE[ARG]POST[].  The IGNORED argument makes recursion
+# easier, and must be supplied rather than implicit.
+#
+# This version minimizes the number of times that $@ is evaluated by
+# using m4_for to generate a boilerplate into _m4_f then passing $@ to
+# that temporary macro.  Thus, the recursion is done in m4_for without
+# reparsing any user input, and is not quadratic.  For an idea of how
+# this works, note that m4_foreach(i,[1,2],[i]) calls
+#   _m4_foreach([m4_define([i],],[)i],[],[1],[2])
+# which defines _m4_f:
+#   $1[$4]$2[]$1[$5]$2[]_m4_popdef([_m4_f])
+# then calls _m4_f([m4_define([i],],[)i],[],[1],[2]) for a net result:
+#   m4_define([i],[1])i[]m4_define([i],[2])i[]_m4_popdef([_m4_f]).
+m4_define([_m4_foreach],
+[m4_if([$#], [3], [],
+       [m4_pushdef([_m4_f], _m4_for([4], [$#], [1],
+   [$0_([1], [2],], [)])[_m4_popdef([_m4_f])])_m4_f($@)])])
+
+m4_define([_m4_foreach_],
+[[$$1[$$3]$$2[]]])
+
+# m4_case(SWITCH, VAL1, IF-VAL1, VAL2, IF-VAL2, ..., DEFAULT)
+# -----------------------------------------------------------
+# Find the first VAL that SWITCH matches, and expand the corresponding
+# IF-VAL.  If there are no matches, expand DEFAULT.
+#
+# Use m4_for to create a temporary macro in terms of a boilerplate
+# m4_if with final cleanup.  If $# is even, we have DEFAULT; if it is
+# odd, then rounding the last $# up in the temporary macro is
+# harmless.  For example, both m4_case(1,2,3,4,5) and
+# m4_case(1,2,3,4,5,6) result in the intermediate _m4_case being
+#   m4_if([$1],[$2],[$3],[$1],[$4],[$5],_m4_popdef([_m4_case])[$6])
+m4_define([m4_case],
+[m4_if(m4_eval([$# <= 2]), [1], [$2],
+[m4_pushdef([_$0], [m4_if(]_m4_for([2], m4_eval([($# - 1) / 2 * 2]), [2],
+     [_$0_(], [)])[_m4_popdef(
+	 [_$0])]m4_dquote($m4_eval([($# + 1) & ~1]))[)])_$0($@)])])
+
+m4_define([_m4_case_],
+[$0_([1], [$1], m4_incr([$1]))])
+
+m4_define([_m4_case__],
+[[[$$1],[$$2],[$$3],]])
+
+# m4_bmatch(SWITCH, RE1, VAL1, RE2, VAL2, ..., DEFAULT)
+# -----------------------------------------------------
+# m4 equivalent of
+#
+# if (SWITCH =~ RE1)
+#   VAL1;
+# elif (SWITCH =~ RE2)
+#   VAL2;
+# elif ...
+#   ...
+# else
+#   DEFAULT
+#
+# We build the temporary macro _m4_b:
+#   m4_define([_m4_b], _m4_defn([_m4_bmatch]))_m4_b([$1], [$2], [$3])...
+#   _m4_b([$1], [$m-1], [$m])_m4_b([], [], [$m+1]_m4_popdef([_m4_b]))
+# then invoke m4_unquote(_m4_b($@)), for concatenation with later text.
+m4_define([m4_bmatch],
+[m4_if([$#], 0, [m4_fatal([$0: too few arguments: $#])],
+       [$#], 1, [m4_fatal([$0: too few arguments: $#: $1])],
+       [$#], 2, [$2],
+       [m4_pushdef([_m4_b], [m4_define([_m4_b],
+  _m4_defn([_$0]))]_m4_for([3], m4_eval([($# + 1) / 2 * 2 - 1]),
+  [2], [_$0_(], [)])[_m4_b([], [],]m4_dquote([$]m4_eval(
+  [($# + 1) / 2 * 2]))[_m4_popdef([_m4_b]))])m4_unquote(_m4_b($@))])])
+
+m4_define([_m4_bmatch],
+[m4_if(m4_bregexp([$1], [$2]), [-1], [], [[$3]m4_define([$0])])])
+
+m4_define([_m4_bmatch_],
+[$0_([1], m4_decr([$1]), [$1])])
+
+m4_define([_m4_bmatch__],
+[[_m4_b([$$1], [$$2], [$$3])]])
+
+
+# m4_cond(TEST1, VAL1, IF-VAL1, TEST2, VAL2, IF-VAL2, ..., [DEFAULT])
+# -------------------------------------------------------------------
+# Similar to m4_if, except that each TEST is expanded when encountered.
+# If the expansion of TESTn matches the string VALn, the result is IF-VALn.
+# The result is DEFAULT if no tests passed.  This macro allows
+# short-circuiting of expensive tests, where it pays to arrange quick
+# filter tests to run first.
+#
+# m4_cond already guarantees either 3*n or 3*n + 1 arguments, 1 <= n.
+# We only have to speed up _m4_cond, by building the temporary _m4_c:
+#   m4_define([_m4_c], _m4_defn([m4_unquote]))_m4_c([m4_if(($1), [($2)],
+#   [[$3]m4_define([_m4_c])])])_m4_c([m4_if(($4), [($5)],
+#   [[$6]m4_define([_m4_c])])])..._m4_c([m4_if(($m-2), [($m-1)],
+#   [[$m]m4_define([_m4_c])])])_m4_c([[$m+1]]_m4_popdef([_m4_c]))
+# We invoke m4_unquote(_m4_c($@)), for concatenation with later text.
+m4_define([_m4_cond],
+[m4_pushdef([_m4_c], [m4_define([_m4_c],
+  _m4_defn([m4_unquote]))]_m4_for([2], m4_eval([$# / 3 * 3 - 1]), [3],
+  [$0_(], [)])[_m4_c(]m4_dquote(m4_dquote(
+  [$]m4_eval([$# / 3 * 3 + 1])))[_m4_popdef([_m4_c]))])m4_unquote(_m4_c($@))])
+
+m4_define([_m4_cond_],
+[$0_(m4_decr([$1]), [$1], m4_incr([$1]))])
+
+m4_define([_m4_cond__],
+[[_m4_c([m4_if(($$1), [($$2)], [[$$3]m4_define([_m4_c])])])]])
+
+# m4_bpatsubsts(STRING, RE1, SUBST1, RE2, SUBST2, ...)
+# ----------------------------------------------------
+# m4 equivalent of
+#
+#   $_ = STRING;
+#   s/RE1/SUBST1/g;
+#   s/RE2/SUBST2/g;
+#   ...
+#
+# m4_bpatsubsts already validated an odd number of arguments; we only
+# need to speed up _m4_bpatsubsts.  To avoid nesting, we build the
+# temporary _m4_p:
+#   m4_define([_m4_p], [$1])m4_define([_m4_p],
+#   m4_bpatsubst(m4_dquote(_m4_defn([_m4_p])), [$2], [$3]))m4_define([_m4_p],
+#   m4_bpatsubst(m4_dquote(_m4_defn([_m4_p])), [$4], [$5]))m4_define([_m4_p],...
+#   m4_bpatsubst(m4_dquote(_m4_defn([_m4_p])), [$m-1], [$m]))m4_unquote(
+#   _m4_defn([_m4_p])_m4_popdef([_m4_p]))
+m4_define([_m4_bpatsubsts],
+[m4_pushdef([_m4_p], [m4_define([_m4_p],
+  ]m4_dquote([$]1)[)]_m4_for([3], [$#], [2], [$0_(],
+  [)])[m4_unquote(_m4_defn([_m4_p])_m4_popdef([_m4_p]))])_m4_p($@)])
+
+m4_define([_m4_bpatsubsts_],
+[$0_(m4_decr([$1]), [$1])])
+
+m4_define([_m4_bpatsubsts__],
+[[m4_define([_m4_p],
+m4_bpatsubst(m4_dquote(_m4_defn([_m4_p])), [$$1], [$$2]))]])
+
+# m4_shiftn(N, ...)
+# -----------------
+# Returns ... shifted N times.  Useful for recursive "varargs" constructs.
+#
+# m4_shiftn already validated arguments; we only need to speed up
+# _m4_shiftn.  If N is 3, then we build the temporary _m4_s, defined as
+#   ,[$5],[$6],...,[$m]_m4_popdef([_m4_s])
+# before calling m4_shift(_m4_s($@)).
+m4_define([_m4_shiftn],
+[m4_if(m4_incr([$1]), [$#], [], [m4_pushdef([_m4_s],
+  _m4_for(m4_eval([$1 + 2]), [$#], [1],
+  [[,]m4_dquote($], [)])[_m4_popdef([_m4_s])])m4_shift(_m4_s($@))])])
+
+# m4_do(STRING, ...)
+# ------------------
+# This macro invokes all its arguments (in sequence, of course).  It is
+# useful for making your macros more structured and readable by dropping
+# unnecessary dnl's and have the macros indented properly.
+#
+# Here, we use the temporary macro _m4_do, defined as
+#   $1[]$2[]...[]$n[]_m4_popdef([_m4_do])
+m4_define([m4_do],
+[m4_if([$#], [0], [],
+       [m4_pushdef([_$0], _m4_for([1], [$#], [1],
+		   [$], [[[]]])[_m4_popdef([_$0])])_$0($@)])])
+
+# m4_dquote_elt(ARGS)
+# -------------------
+# Return ARGS as an unquoted list of double-quoted arguments.
+#
+# _m4_foreach to the rescue.
+m4_define([m4_dquote_elt],
+[m4_if([$#], [0], [], [[[$1]]_m4_foreach([,m4_dquote(], [)], $@)])])
+
+# m4_reverse(ARGS)
+# ----------------
+# Output ARGS in reverse order.
+#
+# Invoke _m4_r($@) with the temporary _m4_r built as
+#   [$m], [$m-1], ..., [$2], [$1]_m4_popdef([_m4_r])
+m4_define([m4_reverse],
+[m4_if([$#], [0], [], [$#], [1], [[$1]],
+[m4_pushdef([_m4_r], [[$$#]]_m4_for(m4_decr([$#]), [1], [-1],
+    [[, ]m4_dquote($], [)])[_m4_popdef([_m4_r])])_m4_r($@)])])
+
+
+# m4_map_args_pair(EXPRESSION, [END-EXPR = EXPRESSION], ARG...)
+# -------------------------------------------------------------
+# Perform a pairwise grouping of consecutive ARGs, by expanding
+# EXPRESSION([ARG1], [ARG2]).  If there are an odd number of ARGs, the
+# final argument is expanded with END-EXPR([ARGn]).
+#
+# Build the temporary macro _m4_map_args_pair, with the $2([$m+1])
+# only output if $# is odd:
+#   $1([$3], [$4])[]$1([$5], [$6])[]...$1([$m-1],
+#   [$m])[]m4_default([$2], [$1])([$m+1])[]_m4_popdef([_m4_map_args_pair])
+m4_define([m4_map_args_pair],
+[m4_if([$#], [0], [m4_fatal([$0: too few arguments: $#])],
+       [$#], [1], [m4_fatal([$0: too few arguments: $#: $1])],
+       [$#], [2], [],
+       [$#], [3], [m4_default([$2], [$1])([$3])[]],
+       [m4_pushdef([_$0], _m4_for([3],
+   m4_eval([$# / 2 * 2 - 1]), [2], [_$0_(], [)])_$0_end(
+   [1], [2], [$#])[_m4_popdef([_$0])])_$0($@)])])
+
+m4_define([_m4_map_args_pair_],
+[$0_([1], [$1], m4_incr([$1]))])
+
+m4_define([_m4_map_args_pair__],
+[[$$1([$$2], [$$3])[]]])
+
+m4_define([_m4_map_args_pair_end],
+[m4_if(m4_eval([$3 & 1]), [1], [[m4_default([$$2], [$$1])([$$3])[]]])])
+
+# m4_join(SEP, ARG1, ARG2...)
+# ---------------------------
+# Produce ARG1SEPARG2...SEPARGn.  Avoid back-to-back SEP when a given ARG
+# is the empty string.  No expansion is performed on SEP or ARGs.
+#
+# Use a self-modifying separator, since we don't know how many
+# arguments might be skipped before a separator is first printed, but
+# be careful if the separator contains $.  _m4_foreach to the rescue.
+m4_define([m4_join],
+[m4_pushdef([_m4_sep], [m4_define([_m4_sep], _m4_defn([m4_echo]))])]dnl
+[_m4_foreach([_$0([$1],], [)], $@)_m4_popdef([_m4_sep])])
+
+m4_define([_m4_join],
+[m4_if([$2], [], [], [_m4_sep([$1])[$2]])])
+
+# m4_joinall(SEP, ARG1, ARG2...)
+# ------------------------------
+# Produce ARG1SEPARG2...SEPARGn.  An empty ARG results in back-to-back SEP.
+# No expansion is performed on SEP or ARGs.
+#
+# A bit easier than m4_join.  _m4_foreach to the rescue.
+m4_define([m4_joinall],
+[[$2]m4_if(m4_eval([$# <= 2]), [1], [],
+	   [_m4_foreach([$1], [], m4_shift($@))])])
+
+# m4_list_cmp(A, B)
+# -----------------
+# Compare the two lists of integer expressions A and B.
+#
+# m4_list_cmp takes care of any side effects; we only override
+# _m4_list_cmp_raw, where we can safely expand lists multiple times.
+# First, insert padding so that both lists are the same length; the
+# trailing +0 is necessary to handle a missing list.  Next, create a
+# temporary macro to perform pairwise comparisons until an inequality
+# is found.  For example, m4_list_cmp([1], [1,2]) creates _m4_cmp as
+#   m4_if(m4_eval([($1) != ($3)]), [1], [m4_cmp([$1], [$3])],
+#         m4_eval([($2) != ($4)]), [1], [m4_cmp([$2], [$4])],
+#         [0]_m4_popdef([_m4_cmp]))
+# then calls _m4_cmp([1+0], [0*2], [1], [2+0])
+m4_define([_m4_list_cmp_raw],
+[m4_if([$1], [$2], 0,
+       [_m4_list_cmp($1+0_m4_list_pad(m4_count($1), m4_count($2)),
+		     $2+0_m4_list_pad(m4_count($2), m4_count($1)))])])
+
+m4_define([_m4_list_pad],
+[m4_if(m4_eval($1 < $2), [1],
+       [_m4_for(m4_incr([$1]), [$2], [1], [,0*])])])
+
+m4_define([_m4_list_cmp],
+[m4_pushdef([_m4_cmp], [m4_if(]_m4_for(
+   [1], m4_eval([$# >> 1]), [1], [$0_(], [,]m4_eval([$# >> 1])[)])[
+      [0]_m4_popdef([_m4_cmp]))])_m4_cmp($@)])
+
+m4_define([_m4_list_cmp_],
+[$0_([$1], m4_eval([$1 + $2]))])
+
+m4_define([_m4_list_cmp__],
+[[m4_eval([($$1) != ($$2)]), [1], [m4_cmp([$$1], [$$2])],
+]])
+
+# m4_max(EXPR, ...)
+# m4_min(EXPR, ...)
+# -----------------
+# Return the decimal value of the maximum (or minimum) in a series of
+# integer expressions.
+#
+# _m4_foreach to the rescue; we only need to replace _m4_minmax.  Here,
+# we need a temporary macro to track the best answer so far, so that
+# the foreach expression is tractable.
+m4_define([_m4_minmax],
+[m4_pushdef([_m4_best], m4_eval([$2]))_m4_foreach(
+  [m4_define([_m4_best], $1(_m4_best,], [))], m4_shift($@))]dnl
+[_m4_best[]_m4_popdef([_m4_best])])
+
+# m4_set_add_all(SET, VALUE...)
+# -----------------------------
+# Add each VALUE into SET.  This is O(n) in the number of VALUEs, and
+# can be faster than calling m4_set_add for each VALUE.
+#
+# _m4_foreach to the rescue.  If no deletions have occurred, then
+# avoid the speed penalty of m4_set_add.
+m4_define([m4_set_add_all],
+[m4_if([$#], [0], [], [$#], [1], [],
+       [m4_define([_m4_set_size($1)], m4_eval(m4_set_size([$1])
+	  + m4_len(_m4_foreach(m4_ifdef([_m4_set_cleanup($1)],
+  [[m4_set_add]], [[_$0]])[([$1],], [)], $@))))])])
+
+m4_define([_m4_set_add_all],
+[m4_ifdef([_m4_set([$1],$2)], [],
+	  [m4_define([_m4_set([$1],$2)],
+		     [1])m4_pushdef([_m4_set([$1])], [$2])-])])
diff --git a/common/bison/m4sugar/m4sugar.m4 b/common/bison/m4sugar/m4sugar.m4
new file mode 100644
index 0000000000000000000000000000000000000000..bbd695836a27d9ab0598c34c6473955ee69f9084
--- /dev/null
+++ b/common/bison/m4sugar/m4sugar.m4
@@ -0,0 +1,3308 @@
+divert(-1)#                                                  -*- Autoconf -*-
+# This file is part of Autoconf.
+# Base M4 layer.
+# Requires GNU M4.
+#
+# Copyright (C) 1999-2017 Free Software Foundation, Inc.
+
+# This file is part of Autoconf.  This program is free
+# software; you can redistribute it and/or modify it under the
+# terms of the GNU General Public License as published by the
+# Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# Under Section 7 of GPL version 3, you are granted additional
+# permissions described in the Autoconf Configure Script Exception,
+# version 3.0, as published by the Free Software Foundation.
+#
+# You should have received a copy of the GNU General Public License
+# and a copy of the Autoconf Configure Script Exception along with
+# this program; see the files COPYINGv3 and COPYING.EXCEPTION
+# respectively.  If not, see <https://www.gnu.org/licenses/>.
+
+# Written by Akim Demaille.
+
+# Set the quotes, whatever the current quoting system.
+changequote()
+changequote([, ])
+
+# Some old m4's don't support m4exit.  But they provide
+# equivalent functionality by core dumping because of the
+# long macros we define.
+ifdef([__gnu__], ,
+[errprint(M4sugar requires GNU M4. Install it before installing M4sugar or
+set the M4 environment variable to its absolute file name.)
+m4exit(2)])
+
+
+## ------------------------------- ##
+## 1. Simulate --prefix-builtins.  ##
+## ------------------------------- ##
+
+# m4_define
+# m4_defn
+# m4_undefine
+define([m4_define],   defn([define]))
+define([m4_defn],     defn([defn]))
+define([m4_undefine], defn([undefine]))
+
+m4_undefine([define])
+m4_undefine([defn])
+m4_undefine([undefine])
+
+
+# m4_copy(SRC, DST)
+# -----------------
+# Define DST as the definition of SRC.
+# What's the difference between:
+# 1. m4_copy([from], [to])
+# 2. m4_define([to], [from($@)])
+# Well, obviously 1 is more expensive in space.  Maybe 2 is more expensive
+# in time, but because of the space cost of 1, it's not that obvious.
+# Nevertheless, one huge difference is the handling of `$0'.  If `from'
+# uses `$0', then with 1, `to''s `$0' is `to', while it is `from' in 2.
+# The user would certainly prefer to see `to'.
+#
+# This definition is in effect during m4sugar initialization, when
+# there are no pushdef stacks; later on, we redefine it to something
+# more powerful for all other clients to use.
+m4_define([m4_copy],
+[m4_define([$2], m4_defn([$1]))])
+
+
+# m4_rename(SRC, DST)
+# -------------------
+# Rename the macro SRC to DST.
+m4_define([m4_rename],
+[m4_copy([$1], [$2])m4_undefine([$1])])
+
+
+# m4_rename_m4(MACRO-NAME)
+# ------------------------
+# Rename MACRO-NAME to m4_MACRO-NAME.
+m4_define([m4_rename_m4],
+[m4_rename([$1], [m4_$1])])
+
+
+# m4_copy_unm4(m4_MACRO-NAME)
+# ---------------------------
+# Copy m4_MACRO-NAME to MACRO-NAME.
+m4_define([m4_copy_unm4],
+[m4_copy([$1], m4_bpatsubst([$1], [^m4_\(.*\)], [[\1]]))])
+
+
+# Some m4 internals have names colliding with tokens we might use.
+# Rename them a` la `m4 --prefix-builtins'.  Conditionals first, since
+# some subsequent renames are conditional.
+m4_rename_m4([ifdef])
+m4_rename([ifelse], [m4_if])
+
+m4_rename_m4([builtin])
+m4_rename_m4([changecom])
+m4_rename_m4([changequote])
+m4_ifdef([changeword],dnl conditionally available in 1.4.x
+[m4_undefine([changeword])])
+m4_rename_m4([debugfile])
+m4_rename_m4([debugmode])
+m4_rename_m4([decr])
+m4_rename_m4([divnum])
+m4_rename_m4([dumpdef])
+m4_rename_m4([errprint])
+m4_rename_m4([esyscmd])
+m4_rename_m4([eval])
+m4_rename_m4([format])
+m4_undefine([include])
+m4_rename_m4([incr])
+m4_rename_m4([index])
+m4_rename_m4([indir])
+m4_rename_m4([len])
+m4_rename([m4exit], [m4_exit])
+m4_undefine([m4wrap])
+m4_ifdef([mkstemp],dnl added in M4 1.4.8
+[m4_rename_m4([mkstemp])
+m4_copy([m4_mkstemp], [m4_maketemp])
+m4_undefine([maketemp])],
+[m4_rename_m4([maketemp])
+m4_copy([m4_maketemp], [m4_mkstemp])])
+m4_rename([patsubst], [m4_bpatsubst])
+m4_rename_m4([popdef])
+m4_rename_m4([pushdef])
+m4_rename([regexp], [m4_bregexp])
+m4_rename_m4([shift])
+m4_undefine([sinclude])
+m4_rename_m4([substr])
+m4_ifdef([symbols],dnl present only in alpha-quality 1.4o
+[m4_rename_m4([symbols])])
+m4_rename_m4([syscmd])
+m4_rename_m4([sysval])
+m4_rename_m4([traceoff])
+m4_rename_m4([traceon])
+m4_rename_m4([translit])
+
+# _m4_defn(ARG)
+# -------------
+# _m4_defn is for internal use only - it bypasses the wrapper, so it
+# must only be used on one argument at a time, and only on macros
+# known to be defined.  Make sure this still works if the user renames
+# m4_defn but not _m4_defn.
+m4_copy([m4_defn], [_m4_defn])
+
+# _m4_divert_raw(NUM)
+# -------------------
+# _m4_divert_raw is for internal use only.  Use this instead of
+# m4_builtin([divert], NUM), so that tracing diversion flow is easier.
+m4_rename([divert], [_m4_divert_raw])
+
+# _m4_popdef(ARG...)
+# ------------------
+# _m4_popdef is for internal use only - it bypasses the wrapper, so it
+# must only be used on macros known to be defined.  Make sure this
+# still works if the user renames m4_popdef but not _m4_popdef.
+m4_copy([m4_popdef], [_m4_popdef])
+
+# _m4_undefine(ARG...)
+# --------------------
+# _m4_undefine is for internal use only - it bypasses the wrapper, so
+# it must only be used on macros known to be defined.  Make sure this
+# still works if the user renames m4_undefine but not _m4_undefine.
+m4_copy([m4_undefine], [_m4_undefine])
+
+# _m4_undivert(NUM...)
+# --------------------
+# _m4_undivert is for internal use only, and should always be given
+# arguments.  Use this instead of m4_builtin([undivert], NUM...), so
+# that tracing diversion flow is easier.
+m4_rename([undivert], [_m4_undivert])
+
+
+## ------------------- ##
+## 2. Error messages.  ##
+## ------------------- ##
+
+
+# m4_location
+# -----------
+# Output the current file, colon, and the current line number.
+m4_define([m4_location],
+[__file__:__line__])
+
+
+# m4_errprintn(MSG)
+# -----------------
+# Same as `errprint', but with the missing end of line.
+m4_define([m4_errprintn],
+[m4_errprint([$1
+])])
+
+
+# m4_warning(MSG)
+# ---------------
+# Warn the user.
+m4_define([m4_warning],
+[m4_errprintn(m4_location[: warning: $1])])
+
+
+# m4_fatal(MSG, [EXIT-STATUS])
+# ----------------------------
+# Fatal the user.                                                      :)
+m4_define([m4_fatal],
+[m4_errprintn(m4_location[: error: $1]
+m4_expansion_stack)m4_exit(m4_if([$2],, 1, [$2]))])
+
+
+# m4_assert(EXPRESSION, [EXIT-STATUS = 1])
+# ----------------------------------------
+# This macro ensures that EXPRESSION evaluates to true, and exits if
+# EXPRESSION evaluates to false.
+m4_define([m4_assert],
+[m4_if(m4_eval([$1]), 0,
+       [m4_fatal([assert failed: $1], [$2])])])
+
+
+
+## ------------- ##
+## 3. Warnings.  ##
+## ------------- ##
+
+
+# _m4_warn(CATEGORY, MESSAGE, [STACK-TRACE])
+# ------------------------------------------
+# Report a MESSAGE to the user if the CATEGORY of warnings is enabled.
+# This is for traces only.
+# If present, STACK-TRACE is a \n-separated list of "LOCATION: MESSAGE",
+# where the last line (and no other) ends with "the top level".
+#
+# Within m4, the macro is a no-op.  This macro really matters
+# when autom4te post-processes the trace output.
+m4_define([_m4_warn], [])
+
+
+# m4_warn(CATEGORY, MESSAGE)
+# --------------------------
+# Report a MESSAGE to the user if the CATEGORY of warnings is enabled.
+m4_define([m4_warn],
+[_m4_warn([$1], [$2],
+m4_ifdef([_m4_expansion_stack], [m4_expansion_stack]))])
+
+
+
+## ------------------- ##
+## 4. File inclusion.  ##
+## ------------------- ##
+
+
+# We also want to neutralize include (and sinclude for symmetry),
+# but we want to extend them slightly: warn when a file is included
+# several times.  This is, in general, a dangerous operation, because
+# too many people forget to quote the first argument of m4_define.
+#
+# For instance in the following case:
+#   m4_define(foo, [bar])
+# then a second reading will turn into
+#   m4_define(bar, [bar])
+# which is certainly not what was meant.
+
+# m4_include_unique(FILE)
+# -----------------------
+# Declare that the FILE was loading; and warn if it has already
+# been included.
+m4_define([m4_include_unique],
+[m4_ifdef([m4_include($1)],
+	  [m4_warn([syntax], [file `$1' included several times])])dnl
+m4_define([m4_include($1)])])
+
+
+# m4_include(FILE)
+# ----------------
+# Like the builtin include, but warns against multiple inclusions.
+m4_define([m4_include],
+[m4_include_unique([$1])dnl
+m4_builtin([include], [$1])])
+
+
+# m4_sinclude(FILE)
+# -----------------
+# Like the builtin sinclude, but warns against multiple inclusions.
+m4_define([m4_sinclude],
+[m4_include_unique([$1])dnl
+m4_builtin([sinclude], [$1])])
+
+
+
+## ------------------------------------ ##
+## 5. Additional branching constructs.  ##
+## ------------------------------------ ##
+
+# Both `m4_ifval' and `m4_ifset' tests against the empty string.  The
+# difference is that `m4_ifset' is specialized on macros.
+#
+# In case of arguments of macros, eg. $1, it makes little difference.
+# In the case of a macro `FOO', you don't want to check `m4_ifval(FOO,
+# TRUE)', because if `FOO' expands with commas, there is a shifting of
+# the arguments.  So you want to run `m4_ifval([FOO])', but then you just
+# compare the *string* `FOO' against `', which, of course fails.
+#
+# So you want the variation `m4_ifset' that expects a macro name as $1.
+# If this macro is both defined and defined to a non empty value, then
+# it runs TRUE, etc.
+
+
+# m4_ifblank(COND, [IF-BLANK], [IF-TEXT])
+# m4_ifnblank(COND, [IF-TEXT], [IF-BLANK])
+# ----------------------------------------
+# If COND is empty, or consists only of blanks (space, tab, newline),
+# then expand IF-BLANK, otherwise expand IF-TEXT.  This differs from
+# m4_ifval only if COND has just whitespace, but it helps optimize in
+# spite of users who mistakenly leave trailing space after what they
+# thought was an empty argument:
+#   macro(
+#         []
+#        )
+#
+# Writing one macro in terms of the other causes extra overhead, so
+# we inline both definitions.
+m4_define([m4_ifblank],
+[m4_if(m4_translit([[$1]],  [ ][	][
+]), [], [$2], [$3])])
+
+m4_define([m4_ifnblank],
+[m4_if(m4_translit([[$1]],  [ ][	][
+]), [], [$3], [$2])])
+
+
+# m4_ifval(COND, [IF-TRUE], [IF-FALSE])
+# -------------------------------------
+# If COND is not the empty string, expand IF-TRUE, otherwise IF-FALSE.
+# Comparable to m4_ifdef.
+m4_define([m4_ifval],
+[m4_if([$1], [], [$3], [$2])])
+
+
+# m4_n(TEXT)
+# ----------
+# If TEXT is not empty, return TEXT and a new line, otherwise nothing.
+m4_define([m4_n],
+[m4_if([$1],
+       [], [],
+	   [$1
+])])
+
+
+# m4_ifvaln(COND, [IF-TRUE], [IF-FALSE])
+# --------------------------------------
+# Same as `m4_ifval', but add an extra newline to IF-TRUE or IF-FALSE
+# unless that argument is empty.
+m4_define([m4_ifvaln],
+[m4_if([$1],
+       [],   [m4_n([$3])],
+	     [m4_n([$2])])])
+
+
+# m4_ifset(MACRO, [IF-TRUE], [IF-FALSE])
+# --------------------------------------
+# If MACRO has no definition, or of its definition is the empty string,
+# expand IF-FALSE, otherwise IF-TRUE.
+m4_define([m4_ifset],
+[m4_ifdef([$1],
+	  [m4_ifval(_m4_defn([$1]), [$2], [$3])],
+	  [$3])])
+
+
+# m4_ifndef(NAME, [IF-NOT-DEFINED], [IF-DEFINED])
+# -----------------------------------------------
+m4_define([m4_ifndef],
+[m4_ifdef([$1], [$3], [$2])])
+
+
+# m4_case(SWITCH, VAL1, IF-VAL1, VAL2, IF-VAL2, ..., DEFAULT)
+# -----------------------------------------------------------
+# m4 equivalent of
+# switch (SWITCH)
+# {
+#   case VAL1:
+#     IF-VAL1;
+#     break;
+#   case VAL2:
+#     IF-VAL2;
+#     break;
+#   ...
+#   default:
+#     DEFAULT;
+#     break;
+# }.
+# All the values are optional, and the macro is robust to active
+# symbols properly quoted.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_case],
+[m4_if([$#], 0, [],
+       [$#], 1, [],
+       [$#], 2, [$2],
+       [$1], [$2], [$3],
+       [$0([$1], m4_shift3($@))])])
+
+
+# m4_bmatch(SWITCH, RE1, VAL1, RE2, VAL2, ..., DEFAULT)
+# -----------------------------------------------------
+# m4 equivalent of
+#
+# if (SWITCH =~ RE1)
+#   VAL1;
+# elif (SWITCH =~ RE2)
+#   VAL2;
+# elif ...
+#   ...
+# else
+#   DEFAULT
+#
+# All the values are optional, and the macro is robust to active symbols
+# properly quoted.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_bmatch],
+[m4_if([$#], 0, [m4_fatal([$0: too few arguments: $#])],
+       [$#], 1, [m4_fatal([$0: too few arguments: $#: $1])],
+       [$#], 2, [$2],
+       [m4_if(m4_bregexp([$1], [$2]), -1, [$0([$1], m4_shift3($@))],
+	      [$3])])])
+
+# m4_argn(N, ARGS...)
+# -------------------
+# Extract argument N (greater than 0) from ARGS.  Example:
+#   m4_define([b], [B])
+#   m4_argn([2], [a], [b], [c]) => b
+#
+# Rather than using m4_car(m4_shiftn([$1], $@)), we exploit the fact that
+# GNU m4 can directly reference any argument, through an indirect macro.
+m4_define([m4_argn],
+[m4_assert([0 < $1])]dnl
+[m4_pushdef([_$0], [_m4_popdef([_$0])]m4_dquote([$]m4_incr([$1])))_$0($@)])
+
+
+# m4_car(ARGS...)
+# m4_cdr(ARGS...)
+# ---------------
+# Manipulate m4 lists.  m4_car returns the first argument.  m4_cdr
+# bundles all but the first argument into a quoted list.  These two
+# macros are generally used with list arguments, with quoting removed
+# to break the list into multiple m4 ARGS.
+m4_define([m4_car], [[$1]])
+m4_define([m4_cdr],
+[m4_if([$#], 0, [m4_fatal([$0: cannot be called without arguments])],
+       [$#], 1, [],
+       [m4_dquote(m4_shift($@))])])
+
+# _m4_cdr(ARGS...)
+# ----------------
+# Like m4_cdr, except include a leading comma unless only one argument
+# remains.  Why?  Because comparing a large list against [] is more
+# expensive in expansion time than comparing the number of arguments; so
+# _m4_cdr can be used to reduce the number of arguments when it is time
+# to end recursion.
+m4_define([_m4_cdr],
+[m4_if([$#], 1, [],
+       [, m4_dquote(m4_shift($@))])])
+
+
+
+# m4_cond(TEST1, VAL1, IF-VAL1, TEST2, VAL2, IF-VAL2, ..., [DEFAULT])
+# -------------------------------------------------------------------
+# Similar to m4_if, except that each TEST is expanded when encountered.
+# If the expansion of TESTn matches the string VALn, the result is IF-VALn.
+# The result is DEFAULT if no tests passed.  This macro allows
+# short-circuiting of expensive tests, where it pays to arrange quick
+# filter tests to run first.
+#
+# For an example, consider a previous implementation of _AS_QUOTE_IFELSE:
+#
+#    m4_if(m4_index([$1], [\]), [-1], [$2],
+#          m4_eval(m4_index([$1], [\\]) >= 0), [1], [$2],
+#          m4_eval(m4_index([$1], [\$]) >= 0), [1], [$2],
+#          m4_eval(m4_index([$1], [\`]) >= 0), [1], [$3],
+#          m4_eval(m4_index([$1], [\"]) >= 0), [1], [$3],
+#          [$2])
+#
+# Here, m4_index is computed 5 times, and m4_eval 4, even if $1 contains
+# no backslash.  It is more efficient to do:
+#
+#    m4_cond([m4_index([$1], [\])], [-1], [$2],
+#            [m4_eval(m4_index([$1], [\\]) >= 0)], [1], [$2],
+#            [m4_eval(m4_index([$1], [\$]) >= 0)], [1], [$2],
+#            [m4_eval(m4_index([$1], [\`]) >= 0)], [1], [$3],
+#            [m4_eval(m4_index([$1], [\"]) >= 0)], [1], [$3],
+#            [$2])
+#
+# In the common case of $1 with no backslash, only one m4_index expansion
+# occurs, and m4_eval is avoided altogether.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_cond],
+[m4_if([$#], [0], [m4_fatal([$0: cannot be called without arguments])],
+       [$#], [1], [$1],
+       m4_eval([$# % 3]), [2], [m4_fatal([$0: missing an argument])],
+       [_$0($@)])])
+
+m4_define([_m4_cond],
+[m4_if(($1), [($2)], [$3],
+       [$#], [3], [],
+       [$#], [4], [$4],
+       [$0(m4_shift3($@))])])
+
+
+## ---------------------------------------- ##
+## 6. Enhanced version of some primitives.  ##
+## ---------------------------------------- ##
+
+# m4_bpatsubsts(STRING, RE1, SUBST1, RE2, SUBST2, ...)
+# ----------------------------------------------------
+# m4 equivalent of
+#
+#   $_ = STRING;
+#   s/RE1/SUBST1/g;
+#   s/RE2/SUBST2/g;
+#   ...
+#
+# All the values are optional, and the macro is robust to active symbols
+# properly quoted.
+#
+# I would have liked to name this macro `m4_bpatsubst', unfortunately,
+# due to quotation problems, I need to double quote $1 below, therefore
+# the anchors are broken :(  I can't let users be trapped by that.
+#
+# Recall that m4_shift3 always results in an argument.  Hence, we need
+# to distinguish between a final deletion vs. ending recursion.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_bpatsubsts],
+[m4_if([$#], 0, [m4_fatal([$0: too few arguments: $#])],
+       [$#], 1, [m4_fatal([$0: too few arguments: $#: $1])],
+       [$#], 2, [m4_unquote(m4_builtin([patsubst], [[$1]], [$2]))],
+       [$#], 3, [m4_unquote(m4_builtin([patsubst], [[$1]], [$2], [$3]))],
+       [_$0($@m4_if(m4_eval($# & 1), 0, [,]))])])
+m4_define([_m4_bpatsubsts],
+[m4_if([$#], 2, [$1],
+       [$0(m4_builtin([patsubst], [[$1]], [$2], [$3]),
+	   m4_shift3($@))])])
+
+
+# m4_copy(SRC, DST)
+# -----------------
+# Define the pushdef stack DST as a copy of the pushdef stack SRC;
+# give an error if DST is already defined.  This is particularly nice
+# for copying self-modifying pushdef stacks, where the top definition
+# includes one-shot initialization that is later popped to the normal
+# definition.  This version intentionally does nothing if SRC is
+# undefined.
+#
+# Some macros simply can't be renamed with this method: namely, anything
+# involved in the implementation of m4_stack_foreach_sep.
+m4_define([m4_copy],
+[m4_ifdef([$2], [m4_fatal([$0: won't overwrite defined macro: $2])],
+	  [m4_stack_foreach_sep([$1], [m4_pushdef([$2],], [)])])]dnl
+[m4_ifdef([m4_location($1)], [m4_define([m4_location($2)], m4_location)])])
+
+
+# m4_copy_force(SRC, DST)
+# m4_rename_force(SRC, DST)
+# -------------------------
+# Like m4_copy/m4_rename, except blindly overwrite any existing DST.
+# Note that m4_copy_force tolerates undefined SRC, while m4_rename_force
+# does not.
+m4_define([m4_copy_force],
+[m4_ifdef([$2], [_m4_undefine([$2])])m4_copy($@)])
+
+m4_define([m4_rename_force],
+[m4_ifdef([$2], [_m4_undefine([$2])])m4_rename($@)])
+
+
+# m4_define_default(MACRO, VALUE)
+# -------------------------------
+# If MACRO is undefined, set it to VALUE.
+m4_define([m4_define_default],
+[m4_ifndef([$1], [m4_define($@)])])
+
+
+# m4_default(EXP1, EXP2)
+# m4_default_nblank(EXP1, EXP2)
+# -----------------------------
+# Returns EXP1 if not empty/blank, otherwise EXP2.  Expand the result.
+#
+# m4_default is called on hot paths, so inline the contents of m4_ifval,
+# for one less round of expansion.
+m4_define([m4_default],
+[m4_if([$1], [], [$2], [$1])])
+
+m4_define([m4_default_nblank],
+[m4_ifblank([$1], [$2], [$1])])
+
+
+# m4_default_quoted(EXP1, EXP2)
+# m4_default_nblank_quoted(EXP1, EXP2)
+# ------------------------------------
+# Returns EXP1 if non empty/blank, otherwise EXP2.  Leave the result quoted.
+#
+# For comparison:
+#   m4_define([active], [ACTIVE])
+#   m4_default([active], [default]) => ACTIVE
+#   m4_default([], [active]) => ACTIVE
+#   -m4_default([ ], [active])- => - -
+#   -m4_default_nblank([ ], [active])- => -ACTIVE-
+#   m4_default_quoted([active], [default]) => active
+#   m4_default_quoted([], [active]) => active
+#   -m4_default_quoted([ ], [active])- => - -
+#   -m4_default_nblank_quoted([ ], [active])- => -active-
+#
+# m4_default macro is called on hot paths, so inline the contents of m4_ifval,
+# for one less round of expansion.
+m4_define([m4_default_quoted],
+[m4_if([$1], [], [[$2]], [[$1]])])
+
+m4_define([m4_default_nblank_quoted],
+[m4_ifblank([$1], [[$2]], [[$1]])])
+
+
+# m4_defn(NAME)
+# -------------
+# Like the original, except guarantee a warning when using something which is
+# undefined (unlike M4 1.4.x).  This replacement is not a full-featured
+# replacement: if any of the defined macros contain unbalanced quoting, but
+# when pasted together result in a well-quoted string, then only native m4
+# support is able to get it correct.  But that's where quadrigraphs come in
+# handy, if you really need unbalanced quotes inside your macros.
+#
+# This macro is called frequently, so minimize the amount of additional
+# expansions by skipping m4_ifndef.  Better yet, if __m4_version__ exists,
+# (added in M4 1.6), then let m4 do the job for us (see m4_init).
+m4_define([m4_defn],
+[m4_if([$#], [0], [[$0]],
+       [$#], [1], [m4_ifdef([$1], [_m4_defn([$1])],
+			    [m4_fatal([$0: undefined macro: $1])])],
+       [m4_map_args([$0], $@)])])
+
+
+# m4_dumpdef(NAME...)
+# -------------------
+# In m4 1.4.x, dumpdef writes to the current debugfile, rather than
+# stderr.  This in turn royally confuses autom4te; so we follow the
+# lead of newer m4 and always dump to stderr.  Unlike the original,
+# this version requires an argument, since there is no convenient way
+# in m4 1.4.x to grab the names of all defined macros.  Newer m4
+# always dumps to stderr, regardless of the current debugfile; it also
+# provides m4symbols as a way to grab all current macro names.  But
+# dumpdefs is not frequently called, so we don't need to worry about
+# conditionally using these newer features.  Also, this version
+# doesn't sort multiple arguments.
+#
+# If we detect m4 1.6 or newer, then provide an alternate definition,
+# installed during m4_init, that allows builtins through.
+# Unfortunately, there is no nice way in m4 1.4.x to dump builtins.
+m4_define([m4_dumpdef],
+[m4_if([$#], [0], [m4_fatal([$0: missing argument])],
+       [$#], [1], [m4_ifdef([$1], [m4_errprintn(
+  [$1:	]m4_dquote(_m4_defn([$1])))], [m4_fatal([$0: undefined macro: $1])])],
+       [m4_map_args([$0], $@)])])
+
+m4_define([_m4_dumpdef],
+[m4_if([$#], [0], [m4_fatal([$0: missing argument])],
+       [$#], [1], [m4_builtin([dumpdef], [$1])],
+       [m4_map_args_sep([m4_builtin([dumpdef],], [)], [], $@)])])
+
+
+# m4_dumpdefs(NAME...)
+# --------------------
+# Similar to `m4_dumpdef(NAME)', but if NAME was m4_pushdef'ed, display its
+# value stack (most recent displayed first).  Also, this version silently
+# ignores undefined macros, rather than erroring out.
+#
+# This macro cheats, because it relies on the current definition of NAME
+# while the second argument of m4_stack_foreach_lifo is evaluated (which
+# would be undefined according to the API).
+m4_define([m4_dumpdefs],
+[m4_if([$#], [0], [m4_fatal([$0: missing argument])],
+       [$#], [1], [m4_stack_foreach_lifo([$1], [m4_dumpdef([$1])m4_ignore])],
+       [m4_map_args([$0], $@)])])
+
+# m4_esyscmd_s(COMMAND)
+# ---------------------
+# Like m4_esyscmd, except strip any trailing newlines, thus behaving
+# more like shell command substitution.
+m4_define([m4_esyscmd_s],
+[m4_chomp_all(m4_esyscmd([$1]))])
+
+
+# m4_popdef(NAME)
+# ---------------
+# Like the original, except guarantee a warning when using something which is
+# undefined (unlike M4 1.4.x).
+#
+# This macro is called frequently, so minimize the amount of additional
+# expansions by skipping m4_ifndef.  Better yet, if __m4_version__ exists,
+# (added in M4 1.6), then let m4 do the job for us (see m4_init).
+m4_define([m4_popdef],
+[m4_if([$#], [0], [[$0]],
+       [$#], [1], [m4_ifdef([$1], [_m4_popdef([$1])],
+			    [m4_fatal([$0: undefined macro: $1])])],
+       [m4_map_args([$0], $@)])])
+
+
+# m4_shiftn(N, ...)
+# -----------------
+# Returns ... shifted N times.  Useful for recursive "varargs" constructs.
+#
+# Autoconf does not use this macro, because it is inherently slower than
+# calling the common cases of m4_shift2 or m4_shift3 directly.  But it
+# might as well be fast for other clients, such as Libtool.  One way to
+# do this is to expand $@ only once in _m4_shiftn (otherwise, for long
+# lists, the expansion of m4_if takes twice as much memory as what the
+# list itself occupies, only to throw away the unused branch).  The end
+# result is strictly equivalent to
+#   m4_if([$1], 1, [m4_shift(,m4_shift(m4_shift($@)))],
+#         [_m4_shiftn(m4_decr([$1]), m4_shift(m4_shift($@)))])
+# but with the final `m4_shift(m4_shift($@)))' shared between the two
+# paths.  The first leg uses a no-op m4_shift(,$@) to balance out the ().
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_shiftn],
+[m4_assert(0 < $1 && $1 < $#)_$0($@)])
+
+m4_define([_m4_shiftn],
+[m4_if([$1], 1, [m4_shift(],
+       [$0(m4_decr([$1])]), m4_shift(m4_shift($@)))])
+
+# m4_shift2(...)
+# m4_shift3(...)
+# --------------
+# Returns ... shifted twice, and three times.  Faster than m4_shiftn.
+m4_define([m4_shift2], [m4_shift(m4_shift($@))])
+m4_define([m4_shift3], [m4_shift(m4_shift(m4_shift($@)))])
+
+# _m4_shift2(...)
+# _m4_shift3(...)
+# ---------------
+# Like m4_shift2 or m4_shift3, except include a leading comma unless shifting
+# consumes all arguments.  Why?  Because in recursion, it is nice to
+# distinguish between 1 element left and 0 elements left, based on how many
+# arguments this shift expands to.
+m4_define([_m4_shift2],
+[m4_if([$#], [2], [],
+       [, m4_shift(m4_shift($@))])])
+m4_define([_m4_shift3],
+[m4_if([$#], [3], [],
+       [, m4_shift(m4_shift(m4_shift($@)))])])
+
+
+# m4_undefine(NAME)
+# -----------------
+# Like the original, except guarantee a warning when using something which is
+# undefined (unlike M4 1.4.x).
+#
+# This macro is called frequently, so minimize the amount of additional
+# expansions by skipping m4_ifndef.  Better yet, if __m4_version__ exists,
+# (added in M4 1.6), then let m4 do the job for us (see m4_init).
+m4_define([m4_undefine],
+[m4_if([$#], [0], [[$0]],
+       [$#], [1], [m4_ifdef([$1], [_m4_undefine([$1])],
+			    [m4_fatal([$0: undefined macro: $1])])],
+       [m4_map_args([$0], $@)])])
+
+# _m4_wrap(PRE, POST)
+# -------------------
+# Helper macro for m4_wrap and m4_wrap_lifo.  Allows nested calls to
+# m4_wrap within wrapped text.  Use _m4_defn and _m4_popdef for speed.
+m4_define([_m4_wrap],
+[m4_ifdef([$0_text],
+	  [m4_define([$0_text], [$1]_m4_defn([$0_text])[$2])],
+	  [m4_builtin([m4wrap], [m4_unquote(
+  _m4_defn([$0_text])_m4_popdef([$0_text]))])m4_define([$0_text], [$1$2])])])
+
+# m4_wrap(TEXT)
+# -------------
+# Append TEXT to the list of hooks to be executed at the end of input.
+# Whereas the order of the original may be LIFO in the underlying m4,
+# this version is always FIFO.
+m4_define([m4_wrap],
+[_m4_wrap([], [$1[]])])
+
+# m4_wrap_lifo(TEXT)
+# ------------------
+# Prepend TEXT to the list of hooks to be executed at the end of input.
+# Whereas the order of m4_wrap may be FIFO in the underlying m4, this
+# version is always LIFO.
+m4_define([m4_wrap_lifo],
+[_m4_wrap([$1[]])])
+
+## ------------------------- ##
+## 7. Quoting manipulation.  ##
+## ------------------------- ##
+
+
+# m4_apply(MACRO, LIST)
+# ---------------------
+# Invoke MACRO, with arguments provided from the quoted list of
+# comma-separated quoted arguments.  If LIST is empty, invoke MACRO
+# without arguments.  The expansion will not be concatenated with
+# subsequent text.
+m4_define([m4_apply],
+[m4_if([$2], [], [$1], [$1($2)])[]])
+
+# _m4_apply(MACRO, LIST)
+# ----------------------
+# Like m4_apply, except do nothing if LIST is empty.
+m4_define([_m4_apply],
+[m4_if([$2], [], [], [$1($2)[]])])
+
+
+# m4_count(ARGS)
+# --------------
+# Return a count of how many ARGS are present.
+m4_define([m4_count], [$#])
+
+
+# m4_curry(MACRO, ARG...)
+# -----------------------
+# Perform argument currying.  The expansion of this macro is another
+# macro that takes exactly one argument, appends it to the end of the
+# original ARG list, then invokes MACRO.  For example:
+#   m4_curry([m4_curry], [m4_reverse], [1])([2])([3]) => 3, 2, 1
+# Not quite as practical as m4_incr, but you could also do:
+#   m4_define([add], [m4_eval(([$1]) + ([$2]))])
+#   m4_define([add_one], [m4_curry([add], [1])])
+#   add_one()([2]) => 3
+m4_define([m4_curry], [$1(m4_shift($@,)_$0])
+m4_define([_m4_curry],               [[$1])])
+
+
+# m4_do(STRING, ...)
+# ------------------
+# This macro invokes all its arguments (in sequence, of course).  It is
+# useful for making your macros more structured and readable by dropping
+# unnecessary dnl's and have the macros indented properly.  No concatenation
+# occurs after a STRING; use m4_unquote(m4_join(,STRING)) for that.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_do],
+[m4_if([$#], 0, [],
+       [$#], 1, [$1[]],
+       [$1[]$0(m4_shift($@))])])
+
+
+# m4_dquote(ARGS)
+# ---------------
+# Return ARGS as a quoted list of quoted arguments.
+m4_define([m4_dquote],  [[$@]])
+
+
+# m4_dquote_elt(ARGS)
+# -------------------
+# Return ARGS as an unquoted list of double-quoted arguments.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_dquote_elt],
+[m4_if([$#], [0], [],
+       [$#], [1], [[[$1]]],
+       [[[$1]],$0(m4_shift($@))])])
+
+
+# m4_echo(ARGS)
+# -------------
+# Return the ARGS, with the same level of quoting.  Whitespace after
+# unquoted commas are consumed.
+m4_define([m4_echo], [$@])
+
+
+# m4_expand(ARG)
+# _m4_expand(ARG)
+# ---------------
+# Return the expansion of ARG as a single string.  Unlike
+# m4_quote($1), this preserves whitespace following single-quoted
+# commas that appear within ARG.  It also deals with shell case
+# statements.
+#
+#   m4_define([active], [ACT, IVE])
+#   m4_define([active2], [[ACT, IVE]])
+#   m4_quote(active, active2)
+#   => ACT,IVE,ACT, IVE
+#   m4_expand([active, active2])
+#   => ACT, IVE, ACT, IVE
+#
+# Unfortunately, due to limitations in m4, ARG must expand to
+# something with balanced quotes (use quadrigraphs to get around
+# this), and should not contain the unlikely delimiters -=<{( or
+# )}>=-.  It is possible to have unbalanced quoted `(' or `)', as well
+# as unbalanced unquoted `)'.  m4_expand can handle unterminated
+# comments or dnl on the final line, at the expense of speed; it also
+# aids in detecting attempts to incorrectly change the current
+# diversion inside ARG.  Meanwhile, _m4_expand is faster but must be
+# given a terminated expansion, and has no safety checks for
+# mis-diverted text.
+#
+# Exploit that extra unquoted () will group unquoted commas and the
+# following whitespace.  m4_bpatsubst can't handle newlines inside $1,
+# and m4_substr strips quoting.  So we (ab)use m4_changequote, using
+# temporary quotes to remove the delimiters that conveniently included
+# the unquoted () that were added prior to the changequote.
+#
+# Thanks to shell case statements, too many people are prone to pass
+# underquoted `)', so we try to detect that by passing a marker as a
+# fourth argument; if the marker is not present, then we assume that
+# we encountered an early `)', and re-expand the first argument, but
+# this time with one more `(' in the second argument and in the
+# open-quote delimiter.  We must also ignore the slop from the
+# previous try.  The final macro is thus half line-noise, half art.
+m4_define([m4_expand],
+[m4_pushdef([m4_divert], _m4_defn([_m4_divert_unsafe]))]dnl
+[m4_pushdef([m4_divert_push], _m4_defn([_m4_divert_unsafe]))]dnl
+[m4_chomp(_$0([$1
+]))_m4_popdef([m4_divert], [m4_divert_push])])
+
+m4_define([_m4_expand], [$0_([$1], [(], -=<{($1)}>=-, [}>=-])])
+
+m4_define([_m4_expand_],
+[m4_if([$4], [}>=-],
+       [m4_changequote([-=<{$2], [)}>=-])$3m4_changequote([, ])],
+       [$0([$1], [($2], -=<{($2$1)}>=-, [}>=-])m4_ignore$2])])
+
+
+# m4_ignore(ARGS)
+# ---------------
+# Expands to nothing.  Useful for conditionally ignoring an arbitrary
+# number of arguments (see _m4_list_cmp for an example).
+m4_define([m4_ignore])
+
+
+# m4_make_list(ARGS)
+# ------------------
+# Similar to m4_dquote, this creates a quoted list of quoted ARGS.  This
+# version is less efficient than m4_dquote, but separates each argument
+# with a comma and newline, rather than just comma, for readability.
+# When developing an m4sugar algorithm, you could temporarily use
+#   m4_pushdef([m4_dquote],m4_defn([m4_make_list]))
+# around your code to make debugging easier.
+m4_define([m4_make_list], [m4_join([,
+], m4_dquote_elt($@))])
+
+
+# m4_noquote(STRING)
+# ------------------
+# Return the result of ignoring all quotes in STRING and invoking the
+# macros it contains.  Among other things, this is useful for enabling
+# macro invocations inside strings with [] blocks (for instance regexps
+# and help-strings).  On the other hand, since all quotes are disabled,
+# any macro expanded during this time that relies on nested [] quoting
+# will likely crash and burn.  This macro is seldom useful; consider
+# m4_unquote or m4_expand instead.
+m4_define([m4_noquote],
+[m4_changequote([-=<{(],[)}>=-])$1-=<{()}>=-m4_changequote([,])])
+
+
+# m4_quote(ARGS)
+# --------------
+# Return ARGS as a single argument.  Any whitespace after unquoted commas
+# is stripped.  There is always output, even when there were no arguments.
+#
+# It is important to realize the difference between `m4_quote(exp)' and
+# `[exp]': in the first case you obtain the quoted *result* of the
+# expansion of EXP, while in the latter you just obtain the string
+# `exp'.
+m4_define([m4_quote],  [[$*]])
+
+
+# _m4_quote(ARGS)
+# ---------------
+# Like m4_quote, except that when there are no arguments, there is no
+# output.  For conditional scenarios (such as passing _m4_quote as the
+# macro name in m4_mapall), this feature can be used to distinguish between
+# one argument of the empty string vs. no arguments.  However, in the
+# normal case with arguments present, this is less efficient than m4_quote.
+m4_define([_m4_quote],
+[m4_if([$#], [0], [], [[$*]])])
+
+
+# m4_reverse(ARGS)
+# ----------------
+# Output ARGS in reverse order.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_reverse],
+[m4_if([$#], [0], [], [$#], [1], [[$1]],
+       [$0(m4_shift($@)), [$1]])])
+
+
+# m4_unquote(ARGS)
+# ----------------
+# Remove one layer of quotes from each ARG, performing one level of
+# expansion.  For one argument, m4_unquote([arg]) is more efficient than
+# m4_do([arg]), but for multiple arguments, the difference is that
+# m4_unquote separates arguments with commas while m4_do concatenates.
+# Follow this macro with [] if concatenation with subsequent text is
+# undesired.
+m4_define([m4_unquote], [$*])
+
+
+## -------------------------- ##
+## 8. Implementing m4 loops.  ##
+## -------------------------- ##
+
+
+# m4_for(VARIABLE, FIRST, LAST, [STEP = +/-1], EXPRESSION)
+# --------------------------------------------------------
+# Expand EXPRESSION defining VARIABLE to FROM, FROM + 1, ..., TO with
+# increments of STEP.  Both limits are included, and bounds are
+# checked for consistency.  The algorithm is robust to indirect
+# VARIABLE names.  Changing VARIABLE inside EXPRESSION will not impact
+# the number of iterations.
+#
+# Uses _m4_defn for speed, and avoid dnl in the macro body.  Factor
+# the _m4_for call so that EXPRESSION is only parsed once.
+m4_define([m4_for],
+[m4_pushdef([$1], m4_eval([$2]))]dnl
+[m4_cond([m4_eval(([$3]) > ([$2]))], 1,
+	   [m4_pushdef([_m4_step], m4_eval(m4_default_quoted([$4],
+	      1)))m4_assert(_m4_step > 0)_$0(_m4_defn([$1]),
+  m4_eval((([$3]) - ([$2])) / _m4_step * _m4_step + ([$2])), _m4_step,],
+	 [m4_eval(([$3]) < ([$2]))], 1,
+	   [m4_pushdef([_m4_step], m4_eval(m4_default_quoted([$4],
+	      -1)))m4_assert(_m4_step < 0)_$0(_m4_defn([$1]),
+  m4_eval((([$2]) - ([$3])) / -(_m4_step) * _m4_step + ([$2])), _m4_step,],
+	 [m4_pushdef([_m4_step])_$0(_m4_defn([$1]), _m4_defn([$1]), 0,])]dnl
+[[m4_define([$1],], [)$5])m4_popdef([_m4_step], [$1])])
+
+# _m4_for(COUNT, LAST, STEP, PRE, POST)
+# -------------------------------------
+# Core of the loop, no consistency checks, all arguments are plain
+# numbers.  Expand PRE[COUNT]POST, then alter COUNT by STEP and
+# iterate if COUNT is not LAST.
+m4_define([_m4_for],
+[$4[$1]$5[]m4_if([$1], [$2], [],
+		 [$0(m4_eval([$1 + $3]), [$2], [$3], [$4], [$5])])])
+
+
+# Implementing `foreach' loops in m4 is much more tricky than it may
+# seem.  For example, the old M4 1.4.4 manual had an incorrect example,
+# which looked like this (when translated to m4sugar):
+#
+# | # foreach(VAR, (LIST), STMT)
+# | m4_define([foreach],
+# |   [m4_pushdef([$1])_foreach([$1], [$2], [$3])m4_popdef([$1])])
+# | m4_define([_arg1], [$1])
+# | m4_define([_foreach],
+# |   [m4_if([$2], [()], ,
+# |     [m4_define([$1], _arg1$2)$3[]_foreach([$1], (m4_shift$2), [$3])])])
+#
+# But then if you run
+#
+# | m4_define(a, 1)
+# | m4_define(b, 2)
+# | m4_define(c, 3)
+# | foreach([f], [([a], [(b], [c)])], [echo f
+# | ])
+#
+# it gives
+#
+#  => echo 1
+#  => echo (2,3)
+#
+# which is not what is expected.
+#
+# Of course the problem is that many quotes are missing.  So you add
+# plenty of quotes at random places, until you reach the expected
+# result.  Alternatively, if you are a quoting wizard, you directly
+# reach the following implementation (but if you really did, then
+# apply to the maintenance of m4sugar!).
+#
+# | # foreach(VAR, (LIST), STMT)
+# | m4_define([foreach], [m4_pushdef([$1])_foreach($@)m4_popdef([$1])])
+# | m4_define([_arg1], [[$1]])
+# | m4_define([_foreach],
+# |  [m4_if($2, [()], ,
+# |    [m4_define([$1], [_arg1$2])$3[]_foreach([$1], [(m4_shift$2)], [$3])])])
+#
+# which this time answers
+#
+#  => echo a
+#  => echo (b
+#  => echo c)
+#
+# Bingo!
+#
+# Well, not quite.
+#
+# With a better look, you realize that the parens are more a pain than
+# a help: since anyway you need to quote properly the list, you end up
+# with always using an outermost pair of parens and an outermost pair
+# of quotes.  Rejecting the parens both eases the implementation, and
+# simplifies the use:
+#
+# | # foreach(VAR, (LIST), STMT)
+# | m4_define([foreach], [m4_pushdef([$1])_foreach($@)m4_popdef([$1])])
+# | m4_define([_arg1], [$1])
+# | m4_define([_foreach],
+# |  [m4_if($2, [], ,
+# |    [m4_define([$1], [_arg1($2)])$3[]_foreach([$1], [m4_shift($2)], [$3])])])
+#
+#
+# Now, just replace the `$2' with `m4_quote($2)' in the outer `m4_if'
+# to improve robustness, and you come up with a nice implementation
+# that doesn't require extra parentheses in the user's LIST.
+#
+# But wait -  now the algorithm is quadratic, because every recursion of
+# the algorithm keeps the entire LIST and merely adds another m4_shift to
+# the quoted text.  If the user has a lot of elements in LIST, you can
+# bring the system to its knees with the memory m4 then requires, or trip
+# the m4 --nesting-limit recursion factor.  The only way to avoid
+# quadratic growth is ensure m4_shift is expanded prior to the recursion.
+# Hence the design below.
+#
+# The M4 manual now includes a chapter devoted to this issue, with
+# the lessons learned from m4sugar.  And still, this design is only
+# optimal for M4 1.6; see foreach.m4 for yet more comments on why
+# M4 1.4.x uses yet another implementation.
+
+
+# m4_foreach(VARIABLE, LIST, EXPRESSION)
+# --------------------------------------
+#
+# Expand EXPRESSION assigning each value of the LIST to VARIABLE.
+# LIST should have the form `item_1, item_2, ..., item_n', i.e. the
+# whole list must *quoted*.  Quote members too if you don't want them
+# to be expanded.
+#
+# This macro is robust to active symbols:
+#      | m4_define(active, [ACT, IVE])
+#      | m4_foreach(Var, [active, active], [-Var-])
+#     => -ACT--IVE--ACT--IVE-
+#
+#      | m4_foreach(Var, [[active], [active]], [-Var-])
+#     => -ACT, IVE--ACT, IVE-
+#
+#      | m4_foreach(Var, [[[active]], [[active]]], [-Var-])
+#     => -active--active-
+#
+# This macro is called frequently, so avoid extra expansions such as
+# m4_ifval and dnl.  Also, since $2 might be quite large, try to use it
+# as little as possible in _m4_foreach; each extra use requires that much
+# more memory for expansion.  So, rather than directly compare $2 against
+# [] and use m4_car/m4_cdr for recursion, we instead unbox the list (which
+# requires swapping the argument order in the helper), insert an ignored
+# third argument, and use m4_shift3 to detect when recursion is complete,
+# at which point this looks very much like m4_map_args.
+m4_define([m4_foreach],
+[m4_if([$2], [], [],
+       [m4_pushdef([$1])_$0([m4_define([$1],], [)$3], [],
+  $2)m4_popdef([$1])])])
+
+# _m4_foreach(PRE, POST, IGNORED, ARG...)
+# ---------------------------------------
+# Form the common basis of the m4_foreach and m4_map macros.  For each
+# ARG, expand PRE[ARG]POST[].  The IGNORED argument makes recursion
+# easier, and must be supplied rather than implicit.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([_m4_foreach],
+[m4_if([$#], [3], [],
+       [$1[$4]$2[]$0([$1], [$2], m4_shift3($@))])])
+
+
+# m4_foreach_w(VARIABLE, LIST, EXPRESSION)
+# ----------------------------------------
+# Like m4_foreach, but the list is whitespace separated.  Depending on
+# EXPRESSION, it may be more efficient to use m4_map_args_w.
+#
+# This macro is robust to active symbols:
+#    m4_foreach_w([Var], [ active
+#    b	act\
+#    ive  ], [-Var-])end
+#    => -active--b--active-end
+#
+# This used to use a slower implementation based on m4_foreach:
+#   m4_foreach([$1], m4_split(m4_normalize([$2]), [ ]), [$3])
+m4_define([m4_foreach_w],
+[m4_pushdef([$1])m4_map_args_w([$2],
+  [m4_define([$1],], [)$3])m4_popdef([$1])])
+
+
+# m4_map(MACRO, LIST)
+# m4_mapall(MACRO, LIST)
+# ----------------------
+# Invoke MACRO($1), MACRO($2) etc. where $1, $2... are the elements of
+# LIST.  $1, $2... must in turn be lists, appropriate for m4_apply.
+# If LIST contains an empty sublist, m4_map skips the expansion of
+# MACRO, while m4_mapall expands MACRO with no arguments.
+#
+# Since LIST may be quite large, we want to minimize how often it
+# appears in the expansion.  Rather than use m4_car/m4_cdr iteration,
+# we unbox the list, and use _m4_foreach for iteration.  For m4_map,
+# an empty list behaves like an empty sublist and gets ignored; for
+# m4_mapall, we must special-case the empty list.
+m4_define([m4_map],
+[_m4_foreach([_m4_apply([$1],], [)], [], $2)])
+
+m4_define([m4_mapall],
+[m4_if([$2], [], [],
+       [_m4_foreach([m4_apply([$1],], [)], [], $2)])])
+
+
+# m4_map_sep(MACRO, [SEPARATOR], LIST)
+# m4_mapall_sep(MACRO, [SEPARATOR], LIST)
+# ---------------------------------------
+# Invoke MACRO($1), SEPARATOR, MACRO($2), ..., MACRO($N) where $1,
+# $2... $N are the elements of LIST, and are in turn lists appropriate
+# for m4_apply.  SEPARATOR is expanded, in order to allow the creation
+# of a list of arguments by using a single-quoted comma as the
+# separator.  For each empty sublist, m4_map_sep skips the expansion
+# of MACRO and SEPARATOR, while m4_mapall_sep expands MACRO with no
+# arguments.
+#
+# For m4_mapall_sep, merely expand the first iteration without the
+# separator, then include separator as part of subsequent recursion;
+# but avoid extra expansion of LIST's side-effects via a helper macro.
+# For m4_map_sep, things are trickier - we don't know if the first
+# list element is an empty sublist, so we must define a self-modifying
+# helper macro and use that as the separator instead.
+m4_define([m4_map_sep],
+[m4_pushdef([m4_Sep], [m4_define([m4_Sep], _m4_defn([m4_unquote]))])]dnl
+[_m4_foreach([_m4_apply([m4_Sep([$2])[]$1],], [)], [], $3)m4_popdef([m4_Sep])])
+
+m4_define([m4_mapall_sep],
+[m4_if([$3], [], [], [_$0([$1], [$2], $3)])])
+
+m4_define([_m4_mapall_sep],
+[m4_apply([$1], [$3])_m4_foreach([m4_apply([$2[]$1],], [)], m4_shift2($@))])
+
+# m4_map_args(EXPRESSION, ARG...)
+# -------------------------------
+# Expand EXPRESSION([ARG]) for each argument.  More efficient than
+#   m4_foreach([var], [ARG...], [EXPRESSION(m4_defn([var]))])
+# Shorthand for m4_map_args_sep([EXPRESSION(], [)], [], ARG...).
+m4_define([m4_map_args],
+[m4_if([$#], [0], [m4_fatal([$0: too few arguments: $#])],
+       [$#], [1], [],
+       [$#], [2], [$1([$2])[]],
+       [_m4_foreach([$1(], [)], $@)])])
+
+
+# m4_map_args_pair(EXPRESSION, [END-EXPR = EXPRESSION], ARG...)
+# -------------------------------------------------------------
+# Perform a pairwise grouping of consecutive ARGs, by expanding
+# EXPRESSION([ARG1], [ARG2]).  If there are an odd number of ARGs, the
+# final argument is expanded with END-EXPR([ARGn]).
+#
+# For example:
+#   m4_define([show], [($*)m4_newline])dnl
+#   m4_map_args_pair([show], [], [a], [b], [c], [d], [e])dnl
+#   => (a,b)
+#   => (c,d)
+#   => (e)
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_map_args_pair],
+[m4_if([$#], [0], [m4_fatal([$0: too few arguments: $#])],
+       [$#], [1], [m4_fatal([$0: too few arguments: $#: $1])],
+       [$#], [2], [],
+       [$#], [3], [m4_default([$2], [$1])([$3])[]],
+       [$#], [4], [$1([$3], [$4])[]],
+       [$1([$3], [$4])[]$0([$1], [$2], m4_shift(m4_shift3($@)))])])
+
+
+# m4_map_args_sep([PRE], [POST], [SEP], ARG...)
+# ---------------------------------------------
+# Expand PRE[ARG]POST for each argument, with SEP between arguments.
+m4_define([m4_map_args_sep],
+[m4_if([$#], [0], [m4_fatal([$0: too few arguments: $#])],
+       [$#], [1], [],
+       [$#], [2], [],
+       [$#], [3], [],
+       [$#], [4], [$1[$4]$2[]],
+       [$1[$4]$2[]_m4_foreach([$3[]$1], [$2], m4_shift3($@))])])
+
+
+# m4_map_args_w(STRING, [PRE], [POST], [SEP])
+# -------------------------------------------
+# Perform the expansion of PRE[word]POST[] for each word in STRING
+# separated by whitespace.  More efficient than:
+#   m4_foreach_w([var], [STRING], [PRE[]m4_defn([var])POST])
+# Additionally, expand SEP between words.
+#
+# As long as we have to use m4_bpatsubst to split the string, we might
+# as well make it also apply PRE and POST; this avoids iteration
+# altogether.  But we must be careful of any \ in PRE or POST.
+# _m4_strip returns a quoted string, but that's okay, since it also
+# supplies an empty leading and trailing argument due to our
+# intentional whitespace around STRING.  We use m4_substr to strip the
+# empty elements and remove the extra layer of quoting.
+m4_define([m4_map_args_w],
+[_$0(_m4_split([ ]m4_flatten([$1])[ ], [[	 ]+],
+	       m4_if(m4_index([$2$3$4], [\]), [-1], [[$3[]$4[]$2]],
+		     [m4_bpatsubst([[$3[]$4[]$2]], [\\], [\\\\])])),
+     m4_len([[]$3[]$4]), m4_len([$4[]$2[]]))])
+
+m4_define([_m4_map_args_w],
+[m4_substr([$1], [$2], m4_eval(m4_len([$1]) - [$2] - [$3]))])
+
+
+# m4_stack_foreach(MACRO, FUNC)
+# m4_stack_foreach_lifo(MACRO, FUNC)
+# ----------------------------------
+# Pass each stacked definition of MACRO to the one-argument macro FUNC.
+# m4_stack_foreach proceeds in FIFO order, while m4_stack_foreach_lifo
+# processes the topmost definitions first.  In addition, FUNC should
+# not push or pop definitions of MACRO, and should not expect anything about
+# the active definition of MACRO (it will not be the topmost, and may not
+# be the one passed to FUNC either).
+#
+# Some macros simply can't be examined with this method: namely,
+# anything involved in the implementation of _m4_stack_reverse.
+m4_define([m4_stack_foreach],
+[_m4_stack_reverse([$1], [m4_tmp-$1])]dnl
+[_m4_stack_reverse([m4_tmp-$1], [$1], [$2(_m4_defn([m4_tmp-$1]))])])
+
+m4_define([m4_stack_foreach_lifo],
+[_m4_stack_reverse([$1], [m4_tmp-$1], [$2(_m4_defn([m4_tmp-$1]))])]dnl
+[_m4_stack_reverse([m4_tmp-$1], [$1])])
+
+# m4_stack_foreach_sep(MACRO, [PRE], [POST], [SEP])
+# m4_stack_foreach_sep_lifo(MACRO, [PRE], [POST], [SEP])
+# ------------------------------------------------------
+# Similar to m4_stack_foreach and m4_stack_foreach_lifo, in that every
+# definition of a pushdef stack will be visited.  But rather than
+# passing the definition as a single argument to a macro, this variant
+# expands the concatenation of PRE[]definition[]POST, and expands SEP
+# between consecutive expansions.  Note that m4_stack_foreach([a], [b])
+# is equivalent to m4_stack_foreach_sep([a], [b(], [)]).
+m4_define([m4_stack_foreach_sep],
+[_m4_stack_reverse([$1], [m4_tmp-$1])]dnl
+[_m4_stack_reverse([m4_tmp-$1], [$1], [$2[]_m4_defn([m4_tmp-$1])$3], [$4[]])])
+
+m4_define([m4_stack_foreach_sep_lifo],
+[_m4_stack_reverse([$1], [m4_tmp-$1], [$2[]_m4_defn([m4_tmp-$1])$3], [$4[]])]dnl
+[_m4_stack_reverse([m4_tmp-$1], [$1])])
+
+
+# _m4_stack_reverse(OLD, NEW, [ACTION], [SEP])
+# --------------------------------------------
+# A recursive worker for pushdef stack manipulation.  Destructively
+# copy the OLD stack into the NEW, and expanding ACTION for each
+# iteration.  After the first iteration, SEP is promoted to the front
+# of ACTION (note that SEP should include a trailing [] if it is to
+# avoid interfering with ACTION).  The current definition is examined
+# after the NEW has been pushed but before OLD has been popped; this
+# order is important, as ACTION is permitted to operate on either
+# _m4_defn([OLD]) or _m4_defn([NEW]).  Since the operation is
+# destructive, this macro is generally used twice, with a temporary
+# macro name holding the swapped copy.
+m4_define([_m4_stack_reverse],
+[m4_ifdef([$1], [m4_pushdef([$2],
+  _m4_defn([$1]))$3[]_m4_popdef([$1])$0([$1], [$2], [$4$3])])])
+
+
+
+## --------------------------- ##
+## 9. More diversion support.  ##
+## --------------------------- ##
+
+
+# m4_cleardivert(DIVERSION-NAME...)
+# ---------------------------------
+# Discard any text in DIVERSION-NAME.
+#
+# This works even inside m4_expand.
+m4_define([m4_cleardivert],
+[m4_if([$#], [0], [m4_fatal([$0: missing argument])],
+       [_m4_divert_raw([-1])m4_undivert($@)_m4_divert_raw(
+	 _m4_divert(_m4_defn([_m4_divert_diversion]), [-]))])])
+
+
+# _m4_divert(DIVERSION-NAME or NUMBER, [NOWARN])
+# ----------------------------------------------
+# If DIVERSION-NAME is the name of a diversion, return its number,
+# otherwise if it is a NUMBER return it.  Issue a warning about
+# the use of a number instead of a name, unless NOWARN is provided.
+m4_define([_m4_divert],
+[m4_ifdef([_m4_divert($1)],
+	  [m4_indir([_m4_divert($1)])],
+	  [m4_if([$2], [], [m4_warn([syntax],
+	     [prefer named diversions])])$1])])
+
+# KILL is only used to suppress output.
+m4_define([_m4_divert(KILL)],           -1)
+
+# The empty diversion name is a synonym for 0.
+m4_define([_m4_divert()],                0)
+
+
+# m4_divert_stack
+# ---------------
+# Print the diversion stack, if it's nonempty.  The caller is
+# responsible for any leading or trailing newline.
+m4_define([m4_divert_stack],
+[m4_stack_foreach_sep_lifo([_m4_divert_stack], [], [], [
+])])
+
+
+# m4_divert_stack_push(MACRO-NAME, DIVERSION-NAME)
+# ------------------------------------------------
+# Form an entry of the diversion stack from caller MACRO-NAME and
+# entering DIVERSION-NAME and push it.
+m4_define([m4_divert_stack_push],
+[m4_pushdef([_m4_divert_stack], m4_location[: $1: $2])])
+
+
+# m4_divert(DIVERSION-NAME)
+# -------------------------
+# Change the diversion stream to DIVERSION-NAME.
+m4_define([m4_divert],
+[m4_popdef([_m4_divert_stack])]dnl
+[m4_define([_m4_divert_diversion], [$1])]dnl
+[m4_divert_stack_push([$0], [$1])]dnl
+[_m4_divert_raw(_m4_divert([$1]))])
+
+
+# m4_divert_push(DIVERSION-NAME, [NOWARN])
+# ----------------------------------------
+# Change the diversion stream to DIVERSION-NAME, while stacking old values.
+# For internal use only: if NOWARN is not empty, DIVERSION-NAME can be a
+# number instead of a name.
+m4_define([m4_divert_push],
+[m4_divert_stack_push([$0], [$1])]dnl
+[m4_pushdef([_m4_divert_diversion], [$1])]dnl
+[_m4_divert_raw(_m4_divert([$1], [$2]))])
+
+
+# m4_divert_pop([DIVERSION-NAME])
+# -------------------------------
+# Change the diversion stream to its previous value, unstacking it.
+# If specified, verify we left DIVERSION-NAME.
+# When we pop the last value from the stack, we divert to -1.
+m4_define([m4_divert_pop],
+[m4_if([$1], [], [],
+       [$1], _m4_defn([_m4_divert_diversion]), [],
+       [m4_fatal([$0($1): diversion mismatch:
+]m4_divert_stack)])]dnl
+[_m4_popdef([_m4_divert_stack], [_m4_divert_diversion])]dnl
+[m4_ifdef([_m4_divert_diversion], [],
+	   [m4_fatal([too many m4_divert_pop])])]dnl
+[_m4_divert_raw(_m4_divert(_m4_defn([_m4_divert_diversion]), [-]))])
+
+
+# m4_divert_text(DIVERSION-NAME, CONTENT)
+# ---------------------------------------
+# Output CONTENT into DIVERSION-NAME (which may be a number actually).
+# An end of line is appended for free to CONTENT.
+m4_define([m4_divert_text],
+[m4_divert_push([$1])$2
+m4_divert_pop([$1])])
+
+
+# m4_divert_once(DIVERSION-NAME, CONTENT)
+# ---------------------------------------
+# Output CONTENT into DIVERSION-NAME once, if not already there.
+# An end of line is appended for free to CONTENT.
+m4_define([m4_divert_once],
+[m4_expand_once([m4_divert_text([$1], [$2])])])
+
+
+# _m4_divert_unsafe(DIVERSION-NAME)
+# ---------------------------------
+# Issue a warning that the attempt to change the current diversion to
+# DIVERSION-NAME is unsafe, because this macro is being expanded
+# during argument collection of m4_expand.
+m4_define([_m4_divert_unsafe],
+[m4_fatal([$0: cannot change diversion to `$1' inside m4_expand])])
+
+
+# m4_undivert(DIVERSION-NAME...)
+# ------------------------------
+# Undivert DIVERSION-NAME.  Unlike the M4 version, this requires at
+# least one DIVERSION-NAME; also, due to support for named diversions,
+# this should not be used to undivert files.
+m4_define([m4_undivert],
+[m4_if([$#], [0], [m4_fatal([$0: missing argument])],
+       [$#], [1], [_m4_undivert(_m4_divert([$1]))],
+       [m4_map_args([$0], $@)])])
+
+
+## --------------------------------------------- ##
+## 10. Defining macros with bells and whistles.  ##
+## --------------------------------------------- ##
+
+# `m4_defun' is basically `m4_define' but it equips the macro with the
+# needed machinery for `m4_require'.  A macro must be m4_defun'd if
+# either it is m4_require'd, or it m4_require's.
+#
+# Two things deserve attention and are detailed below:
+#  1. Implementation of m4_require
+#  2. Keeping track of the expansion stack
+#
+# 1. Implementation of m4_require
+# ===============================
+#
+# Of course m4_defun calls m4_provide, so that a macro which has
+# been expanded is not expanded again when m4_require'd, but the
+# difficult part is the proper expansion of macros when they are
+# m4_require'd.
+#
+# The implementation is based on three ideas, (i) using diversions to
+# prepare the expansion of the macro and its dependencies (by Franc,ois
+# Pinard), (ii) expand the most recently m4_require'd macros _after_
+# the previous macros (by Axel Thimm), and (iii) track instances of
+# provide before require (by Eric Blake).
+#
+#
+# The first idea: why use diversions?
+# -----------------------------------
+#
+# When a macro requires another, the other macro is expanded in new
+# diversion, GROW.  When the outer macro is fully expanded, we first
+# undivert the most nested diversions (GROW - 1...), and finally
+# undivert GROW.  To understand why we need several diversions,
+# consider the following example:
+#
+# | m4_defun([TEST1], [Test...m4_require([TEST2])1])
+# | m4_defun([TEST2], [Test...m4_require([TEST3])2])
+# | m4_defun([TEST3], [Test...3])
+#
+# Because m4_require is not required to be first in the outer macros, we
+# must keep the expansions of the various levels of m4_require separated.
+# Right before executing the epilogue of TEST1, we have:
+#
+#	   GROW - 2: Test...3
+#	   GROW - 1: Test...2
+#	   GROW:     Test...1
+#	   BODY:
+#
+# Finally the epilogue of TEST1 undiverts GROW - 2, GROW - 1, and
+# GROW into the regular flow, BODY.
+#
+#	   GROW - 2:
+#	   GROW - 1:
+#	   GROW:
+#	   BODY:        Test...3; Test...2; Test...1
+#
+# (The semicolons are here for clarification, but of course are not
+# emitted.)  This is what Autoconf 2.0 (I think) to 2.13 (I'm sure)
+# implement.
+#
+#
+# The second idea: first required first out
+# -----------------------------------------
+#
+# The natural implementation of the idea above is buggy and produces
+# very surprising results in some situations.  Let's consider the
+# following example to explain the bug:
+#
+# | m4_defun([TEST1],  [m4_require([TEST2a])m4_require([TEST2b])])
+# | m4_defun([TEST2a], [])
+# | m4_defun([TEST2b], [m4_require([TEST3])])
+# | m4_defun([TEST3],  [m4_require([TEST2a])])
+# |
+# | AC_INIT
+# | TEST1
+#
+# The dependencies between the macros are:
+#
+#		 3 --- 2b
+#		/        \              is m4_require'd by
+#	       /          \       left -------------------- right
+#	    2a ------------ 1
+#
+# If you strictly apply the rules given in the previous section you get:
+#
+#	   GROW - 2: TEST3
+#	   GROW - 1: TEST2a; TEST2b
+#	   GROW:     TEST1
+#	   BODY:
+#
+# (TEST2a, although required by TEST3 is not expanded in GROW - 3
+# because is has already been expanded before in GROW - 1, so it has
+# been AC_PROVIDE'd, so it is not expanded again) so when you undivert
+# the stack of diversions, you get:
+#
+#	   GROW - 2:
+#	   GROW - 1:
+#	   GROW:
+#	   BODY:        TEST3; TEST2a; TEST2b; TEST1
+#
+# i.e., TEST2a is expanded after TEST3 although the latter required the
+# former.
+#
+# Starting from 2.50, we use an implementation provided by Axel Thimm.
+# The idea is simple: the order in which macros are emitted must be the
+# same as the one in which macros are expanded.  (The bug above can
+# indeed be described as: a macro has been m4_provide'd before its
+# dependent, but it is emitted after: the lack of correlation between
+# emission and expansion order is guilty).
+#
+# How to do that?  You keep the stack of diversions to elaborate the
+# macros, but each time a macro is fully expanded, emit it immediately.
+#
+# In the example above, when TEST2a is expanded, but it's epilogue is
+# not run yet, you have:
+#
+#	   GROW - 2:
+#	   GROW - 1: TEST2a
+#	   GROW:     Elaboration of TEST1
+#	   BODY:
+#
+# The epilogue of TEST2a emits it immediately:
+#
+#	   GROW - 2:
+#	   GROW - 1:
+#	   GROW:     Elaboration of TEST1
+#	   BODY:     TEST2a
+#
+# TEST2b then requires TEST3, so right before the epilogue of TEST3, you
+# have:
+#
+#	   GROW - 2: TEST3
+#	   GROW - 1: Elaboration of TEST2b
+#	   GROW:     Elaboration of TEST1
+#	   BODY:      TEST2a
+#
+# The epilogue of TEST3 emits it:
+#
+#	   GROW - 2:
+#	   GROW - 1: Elaboration of TEST2b
+#	   GROW:     Elaboration of TEST1
+#	   BODY:     TEST2a; TEST3
+#
+# TEST2b is now completely expanded, and emitted:
+#
+#	   GROW - 2:
+#	   GROW - 1:
+#	   GROW:     Elaboration of TEST1
+#	   BODY:     TEST2a; TEST3; TEST2b
+#
+# and finally, TEST1 is finished and emitted:
+#
+#	   GROW - 2:
+#	   GROW - 1:
+#	   GROW:
+#	   BODY:     TEST2a; TEST3; TEST2b: TEST1
+#
+# The idea is simple, but the implementation is a bit involved.  If
+# you are like me, you will want to see the actual functioning of this
+# implementation to be convinced.  The next section gives the full
+# details.
+#
+#
+# The Axel Thimm implementation at work
+# -------------------------------------
+#
+# We consider the macros above, and this configure.ac:
+#
+#	    AC_INIT
+#	    TEST1
+#
+# You should keep the definitions of _m4_defun_pro, _m4_defun_epi, and
+# m4_require at hand to follow the steps.
+#
+# This implementation tries not to assume that the current diversion is
+# BODY, so as soon as a macro (m4_defun'd) is expanded, we first
+# record the current diversion under the name _m4_divert_dump (denoted
+# DUMP below for short).  This introduces an important difference with
+# the previous versions of Autoconf: you cannot use m4_require if you
+# are not inside an m4_defun'd macro, and especially, you cannot
+# m4_require directly from the top level.
+#
+# We have not tried to simulate the old behavior (better yet, we
+# diagnose it), because it is too dangerous: a macro m4_require'd from
+# the top level is expanded before the body of `configure', i.e., before
+# any other test was run.  I let you imagine the result of requiring
+# AC_STDC_HEADERS for instance, before AC_PROG_CC was actually run....
+#
+# After AC_INIT was run, the current diversion is BODY.
+# * AC_INIT was run
+#   DUMP:                undefined
+#   diversion stack:     BODY |-
+#
+# * TEST1 is expanded
+# The prologue of TEST1 sets _m4_divert_dump, which is the diversion
+# where the current elaboration will be dumped, to the current
+# diversion.  It also m4_divert_push to GROW, where the full
+# expansion of TEST1 and its dependencies will be elaborated.
+#   DUMP:        BODY
+#   BODY:        empty
+#   diversions:  GROW, BODY |-
+#
+# * TEST1 requires TEST2a
+# _m4_require_call m4_divert_pushes another temporary diversion,
+# GROW - 1, and expands TEST2a in there.
+#   DUMP:        BODY
+#   BODY:        empty
+#   GROW - 1:    TEST2a
+#   diversions:  GROW - 1, GROW, BODY |-
+# Then the content of the temporary diversion is moved to DUMP and the
+# temporary diversion is popped.
+#   DUMP:        BODY
+#   BODY:        TEST2a
+#   diversions:  GROW, BODY |-
+#
+# * TEST1 requires TEST2b
+# Again, _m4_require_call pushes GROW - 1 and heads to expand TEST2b.
+#   DUMP:        BODY
+#   BODY:        TEST2a
+#   diversions:  GROW - 1, GROW, BODY |-
+#
+# * TEST2b requires TEST3
+# _m4_require_call pushes GROW - 2 and expands TEST3 here.
+# (TEST3 requires TEST2a, but TEST2a has already been m4_provide'd, so
+# nothing happens.)
+#   DUMP:        BODY
+#   BODY:        TEST2a
+#   GROW - 2:    TEST3
+#   diversions:  GROW - 2, GROW - 1, GROW, BODY |-
+# Then the diversion is appended to DUMP, and popped.
+#   DUMP:        BODY
+#   BODY:        TEST2a; TEST3
+#   diversions:  GROW - 1, GROW, BODY |-
+#
+# * TEST1 requires TEST2b (contd.)
+# The content of TEST2b is expanded...
+#   DUMP:        BODY
+#   BODY:        TEST2a; TEST3
+#   GROW - 1:    TEST2b,
+#   diversions:  GROW - 1, GROW, BODY |-
+# ... and moved to DUMP.
+#   DUMP:        BODY
+#   BODY:        TEST2a; TEST3; TEST2b
+#   diversions:  GROW, BODY |-
+#
+# * TEST1 is expanded: epilogue
+# TEST1's own content is in GROW...
+#   DUMP:        BODY
+#   BODY:        TEST2a; TEST3; TEST2b
+#   GROW:        TEST1
+#   diversions:  BODY |-
+# ... and it's epilogue moves it to DUMP and then undefines DUMP.
+#   DUMP:       undefined
+#   BODY:       TEST2a; TEST3; TEST2b; TEST1
+#   diversions: BODY |-
+#
+#
+# The third idea: track macros provided before they were required
+# ---------------------------------------------------------------
+#
+# Using just the first two ideas, Autoconf 2.50 through 2.63 still had
+# a subtle bug for more than seven years.  Let's consider the
+# following example to explain the bug:
+#
+# | m4_defun([TEST1], [1])
+# | m4_defun([TEST2], [2[]m4_require([TEST1])])
+# | m4_defun([TEST3], [3 TEST1 m4_require([TEST2])])
+# | TEST3
+#
+# After the prologue of TEST3, we are collecting text in GROW with the
+# intent of dumping it in BODY during the epilogue.  Next, we
+# encounter the direct invocation of TEST1, which provides the macro
+# in place in GROW.  From there, we encounter a requirement for TEST2,
+# which must be collected in a new diversion.  While expanding TEST2,
+# we encounter a requirement for TEST1, but since it has already been
+# expanded, the Axel Thimm algorithm states that we can treat it as a
+# no-op.  But that would lead to an end result of `2 3 1', meaning
+# that we have once again output a macro (TEST2) prior to its
+# requirements (TEST1).
+#
+# The problem can only occur if a single defun'd macro first provides,
+# then later indirectly requires, the same macro.  Note that directly
+# expanding then requiring a macro is okay: because the dependency was
+# met, the require phase can be a no-op.  For that matter, the outer
+# macro can even require two helpers, where the first helper expands
+# the macro, and the second helper indirectly requires the macro.
+# Out-of-order expansion is only present if the inner macro is
+# required by something that will be hoisted in front of where the
+# direct expansion occurred.  In other words, we must be careful not
+# to warn on:
+#
+# | m4_defun([TEST4], [4])
+# | m4_defun([TEST5], [5 TEST4 m4_require([TEST4])])
+# | TEST5 => 5 4
+#
+# or even the more complex:
+#
+# | m4_defun([TEST6], [6])
+# | m4_defun([TEST7], [7 TEST6])
+# | m4_defun([TEST8], [8 m4_require([TEST6])])
+# | m4_defun([TEST9], [9 m4_require([TEST8])])
+# | m4_defun([TEST10], [10 m4_require([TEST7]) m4_require([TEST9])])
+# | TEST10 => 7 6 8 9 10
+#
+# So, to detect whether a require was direct or indirect, m4_defun and
+# m4_require track the name of the macro that caused a diversion to be
+# created (using the stack _m4_diverting, coupled with an O(1) lookup
+# _m4_diverting([NAME])), and m4_provide stores the name associated
+# with the diversion at which a macro was provided.  A require call is
+# direct if it occurs within the same diversion where the macro was
+# provided, or if the diversion associated with the providing context
+# has been collected.
+#
+# The implementation of the warning involves tracking the set of
+# macros which have been provided since the start of the outermost
+# defun'd macro (the set is named _m4_provide).  When starting an
+# outermost macro, the set is emptied; when a macro is provided, it is
+# added to the set; when require expands the body of a macro, it is
+# removed from the set; and when a macro is indirectly required, the
+# set is checked.  If a macro is in the set, then it has been provided
+# before it was required, and we satisfy dependencies by expanding the
+# macro as if it had never been provided; in the example given above,
+# this means we now output `1 2 3 1'.  Meanwhile, a warning is issued
+# to inform the user that her macros trigger the bug in older autoconf
+# versions, and that her output file now contains redundant contents
+# (and possibly new problems, if the repeated macro was not
+# idempotent).  Meanwhile, macros defined by m4_defun_once instead of
+# m4_defun are idempotent, avoiding any warning or duplicate output.
+#
+#
+# 2. Keeping track of the expansion stack
+# =======================================
+#
+# When M4 expansion goes wrong it is often extremely hard to find the
+# path amongst macros that drove to the failure.  What is needed is
+# the stack of macro `calls'. One could imagine that GNU M4 would
+# maintain a stack of macro expansions, unfortunately it doesn't, so
+# we do it by hand.  This is of course extremely costly, but the help
+# this stack provides is worth it.  Nevertheless to limit the
+# performance penalty this is implemented only for m4_defun'd macros,
+# not for define'd macros.
+#
+# Each time we enter an m4_defun'd macros, we add a definition in
+# _m4_expansion_stack, and when we exit the macro, we remove it (thanks
+# to pushdef/popdef).  m4_stack_foreach is used to print the expansion
+# stack in the rare cases when it's needed.
+#
+# In addition, we want to detect circular m4_require dependencies.
+# Each time we expand a macro FOO we define _m4_expanding(FOO); and
+# m4_require(BAR) simply checks whether _m4_expanding(BAR) is defined.
+
+
+# m4_expansion_stack
+# ------------------
+# Expands to the entire contents of the expansion stack.  The caller
+# must supply a trailing newline.  This macro always prints a
+# location; check whether _m4_expansion_stack is defined to filter out
+# the case when no defun'd macro is in force.
+m4_define([m4_expansion_stack],
+[m4_stack_foreach_sep_lifo([_$0], [_$0_entry(], [)
+])m4_location[: the top level]])
+
+# _m4_expansion_stack_entry(MACRO)
+# --------------------------------
+# Format an entry for MACRO found on the expansion stack.
+m4_define([_m4_expansion_stack_entry],
+[_m4_defn([m4_location($1)])[: $1 is expanded from...]])
+
+# m4_expansion_stack_push(MACRO)
+# ------------------------------
+# Form an entry of the expansion stack on entry to MACRO and push it.
+m4_define([m4_expansion_stack_push],
+[m4_pushdef([_m4_expansion_stack], [$1])])
+
+
+# _m4_divert(GROW)
+# ----------------
+# This diversion is used by the m4_defun/m4_require machinery.  It is
+# important to keep room before GROW because for each nested
+# AC_REQUIRE we use an additional diversion (i.e., two m4_require's
+# will use GROW - 2.  More than 3 levels has never seemed to be
+# needed.)
+#
+# ...
+# - GROW - 2
+#   m4_require'd code, 2 level deep
+# - GROW - 1
+#   m4_require'd code, 1 level deep
+# - GROW
+#   m4_defun'd macros are elaborated here.
+
+m4_define([_m4_divert(GROW)],       10000)
+
+
+# _m4_defun_pro(MACRO-NAME)
+# -------------------------
+# The prologue for Autoconf macros.
+#
+# This is called frequently, so minimize the number of macro invocations
+# by avoiding dnl and m4_defn overhead.
+m4_define([_m4_defun_pro],
+[m4_ifdef([_m4_expansion_stack], [], [_m4_defun_pro_outer([$1])])]dnl
+[m4_expansion_stack_push([$1])m4_pushdef([_m4_expanding($1)])])
+
+m4_define([_m4_defun_pro_outer],
+[m4_set_delete([_m4_provide])]dnl
+[m4_pushdef([_m4_diverting([$1])])m4_pushdef([_m4_diverting], [$1])]dnl
+[m4_pushdef([_m4_divert_dump], m4_divnum)m4_divert_push([GROW])])
+
+# _m4_defun_epi(MACRO-NAME)
+# -------------------------
+# The Epilogue for Autoconf macros.  MACRO-NAME only helps tracing
+# the PRO/EPI pairs.
+#
+# This is called frequently, so minimize the number of macro invocations
+# by avoiding dnl and m4_popdef overhead.
+m4_define([_m4_defun_epi],
+[_m4_popdef([_m4_expanding($1)], [_m4_expansion_stack])]dnl
+[m4_ifdef([_m4_expansion_stack], [], [_m4_defun_epi_outer([$1])])]dnl
+[m4_provide([$1])])
+
+m4_define([_m4_defun_epi_outer],
+[_m4_popdef([_m4_divert_dump], [_m4_diverting([$1])], [_m4_diverting])]dnl
+[m4_divert_pop([GROW])m4_undivert([GROW])])
+
+
+# _m4_divert_dump
+# ---------------
+# If blank, we are outside of any defun'd macro.  Otherwise, expands
+# to the diversion number (not name) where require'd macros should be
+# moved once completed.
+m4_define([_m4_divert_dump])
+
+
+# m4_divert_require(DIVERSION, NAME-TO-CHECK, [BODY-TO-EXPAND])
+# -------------------------------------------------------------
+# Same as m4_require, but BODY-TO-EXPAND goes into the named DIVERSION;
+# requirements still go in the current diversion though.
+#
+m4_define([m4_divert_require],
+[m4_ifdef([_m4_expanding($2)],
+  [m4_fatal([$0: circular dependency of $2])])]dnl
+[m4_if(_m4_divert_dump, [],
+  [m4_fatal([$0($2): cannot be used outside of an m4_defun'd macro])])]dnl
+[m4_provide_if([$2], [],
+  [_m4_require_call([$2], [$3], _m4_divert([$1], [-]))])])
+
+
+# m4_defun(NAME, EXPANSION, [MACRO = m4_define])
+# ----------------------------------------------
+# Define a macro NAME which automatically provides itself.  Add
+# machinery so the macro automatically switches expansion to the
+# diversion stack if it is not already using it, prior to EXPANSION.
+# In this case, once finished, it will bring back all the code
+# accumulated in the diversion stack.  This, combined with m4_require,
+# achieves the topological ordering of macros.  We don't use this
+# macro to define some frequently called macros that are not involved
+# in ordering constraints, to save m4 processing.
+#
+# MACRO is an undocumented argument; when set to m4_pushdef, and NAME
+# is already defined, the new definition is added to the pushdef
+# stack, rather than overwriting the current definition.  It can thus
+# be used to write self-modifying macros, which pop themselves to a
+# previously m4_define'd definition so that subsequent use of the
+# macro is faster.
+m4_define([m4_defun],
+[m4_define([m4_location($1)], m4_location)]dnl
+[m4_default([$3], [m4_define])([$1],
+  [_m4_defun_pro(]m4_dquote($[0])[)$2[]_m4_defun_epi(]m4_dquote($[0])[)])])
+
+
+# m4_defun_init(NAME, INIT, COMMON)
+# ---------------------------------
+# Like m4_defun, but split EXPANSION into two portions: INIT which is
+# done only the first time NAME is invoked, and COMMON which is
+# expanded every time.
+#
+# For now, the COMMON definition is always m4_define'd, giving an even
+# lighter-weight definition.  m4_defun allows self-providing, but once
+# a macro is provided, m4_require no longer cares if it is m4_define'd
+# or m4_defun'd.  m4_defun also provides location tracking to identify
+# dependency bugs, but once the INIT has been expanded, we know there
+# are no dependency bugs.  However, if a future use needs COMMON to be
+# m4_defun'd, we can add a parameter, similar to the third parameter
+# to m4_defun.
+m4_define([m4_defun_init],
+[m4_define([$1], [$3[]])m4_defun([$1],
+   [$2[]_m4_popdef(]m4_dquote($[0])[)m4_indir(]m4_dquote($[0])dnl
+[m4_if(]m4_dquote($[#])[, [0], [], ]m4_dquote([,$]@)[))], [m4_pushdef])])
+
+
+# m4_defun_once(NAME, EXPANSION)
+# ------------------------------
+# Like m4_defun, but guarantee that EXPANSION only happens once
+# (thereafter, using NAME is a no-op).
+#
+# If _m4_divert_dump is empty, we are called at the top level;
+# otherwise, we must ensure that we are required in front of the
+# current defun'd macro.  Use a helper macro so that EXPANSION need
+# only occur once in the definition of NAME, since it might be large.
+m4_define([m4_defun_once],
+[m4_define([m4_location($1)], m4_location)]dnl
+[m4_define([$1], [_m4_defun_once([$1], [$2], m4_if(_m4_divert_dump, [],
+  [[_m4_defun_pro([$1])m4_unquote(], [)_m4_defun_epi([$1])]],
+m4_ifdef([_m4_diverting([$1])], [-]), [-], [[m4_unquote(], [)]],
+  [[_m4_require_call([$1],], [, _m4_divert_dump)]]))])])
+
+m4_define([_m4_defun_once],
+[m4_pushdef([$1])$3[$2[]m4_provide([$1])]$4])
+
+
+# m4_pattern_forbid(ERE, [WHY])
+# -----------------------------
+# Declare that no token matching the forbidden perl extended regular
+# expression ERE should be seen in the output unless...
+m4_define([m4_pattern_forbid], [])
+
+
+# m4_pattern_allow(ERE)
+# ---------------------
+# ... that token also matches the allowed extended regular expression ERE.
+# Both used via traces, by autom4te post-processing.
+m4_define([m4_pattern_allow], [])
+
+
+## --------------------------------- ##
+## 11. Dependencies between macros.  ##
+## --------------------------------- ##
+
+
+# m4_before(THIS-MACRO-NAME, CALLED-MACRO-NAME)
+# ---------------------------------------------
+# Issue a warning if CALLED-MACRO-NAME was called before THIS-MACRO-NAME.
+m4_define([m4_before],
+[m4_provide_if([$2],
+	       [m4_warn([syntax], [$2 was called before $1])])])
+
+
+# m4_require(NAME-TO-CHECK, [BODY-TO-EXPAND = NAME-TO-CHECK])
+# -----------------------------------------------------------
+# If NAME-TO-CHECK has never been expanded (actually, if it is not
+# m4_provide'd), expand BODY-TO-EXPAND *before* the current macro
+# expansion; follow the expansion with a newline.  Once expanded, emit
+# it in _m4_divert_dump.  Keep track of the m4_require chain in
+# _m4_expansion_stack.
+#
+# The normal cases are:
+#
+# - NAME-TO-CHECK == BODY-TO-EXPAND
+#   Which you can use for regular macros with or without arguments, e.g.,
+#     m4_require([AC_PROG_CC], [AC_PROG_CC])
+#     m4_require([AC_CHECK_HEADERS(threads.h)], [AC_CHECK_HEADERS(threads.h)])
+#   which is just the same as
+#     m4_require([AC_PROG_CC])
+#     m4_require([AC_CHECK_HEADERS(threads.h)])
+#
+# - BODY-TO-EXPAND == m4_indir([NAME-TO-CHECK])
+#   In the case of macros with irregular names.  For instance:
+#     m4_require([AC_LANG_COMPILER(C)], [indir([AC_LANG_COMPILER(C)])])
+#   which means `if the macro named `AC_LANG_COMPILER(C)' (the parens are
+#   part of the name, it is not an argument) has not been run, then
+#   call it.'
+#   Had you used
+#     m4_require([AC_LANG_COMPILER(C)], [AC_LANG_COMPILER(C)])
+#   then m4_require would have tried to expand `AC_LANG_COMPILER(C)', i.e.,
+#   call the macro `AC_LANG_COMPILER' with `C' as argument.
+#
+#   You could argue that `AC_LANG_COMPILER', when it receives an argument
+#   such as `C' should dispatch the call to `AC_LANG_COMPILER(C)'.  But this
+#   `extension' prevents `AC_LANG_COMPILER' from having actual arguments that
+#   it passes to `AC_LANG_COMPILER(C)'.
+#
+# This is called frequently, so minimize the number of macro invocations
+# by avoiding dnl and other overhead on the common path.
+m4_define([m4_require],
+[m4_ifdef([_m4_expanding($1)],
+  [m4_fatal([$0: circular dependency of $1])])]dnl
+[m4_if(_m4_divert_dump, [],
+  [m4_fatal([$0($1): cannot be used outside of an ]dnl
+m4_if([$0], [m4_require], [[m4_defun]], [[AC_DEFUN]])['d macro])])]dnl
+[m4_provide_if([$1], [m4_set_contains([_m4_provide], [$1],
+    [_m4_require_check([$1], _m4_defn([m4_provide($1)]), [$0])], [m4_ignore])],
+  [_m4_require_call])([$1], [$2], _m4_divert_dump)])
+
+
+# _m4_require_call(NAME-TO-CHECK, [BODY-TO-EXPAND = NAME-TO-CHECK],
+#                  DIVERSION-NUMBER)
+# -----------------------------------------------------------------
+# If m4_require decides to expand the body, it calls this macro.  The
+# expansion is placed in DIVERSION-NUMBER.
+#
+# This is called frequently, so minimize the number of macro invocations
+# by avoiding dnl and other overhead on the common path.
+# The use of a witness macro protecting the warning allows aclocal
+# to silence any warnings when probing for what macros are required
+# and must therefore be located, when using the Autoconf-without-aclocal-m4
+# autom4te language.  For more background, see:
+# https://lists.gnu.org/archive/html/automake-patches/2012-11/msg00035.html
+m4_define([_m4_require_call],
+[m4_pushdef([_m4_divert_grow], m4_decr(_m4_divert_grow))]dnl
+[m4_pushdef([_m4_diverting([$1])])m4_pushdef([_m4_diverting], [$1])]dnl
+[m4_divert_push(_m4_divert_grow, [-])]dnl
+[m4_if([$2], [], [$1], [$2])
+m4_provide_if([$1], [m4_set_remove([_m4_provide], [$1])],
+  [m4_ifndef([m4_require_silent_probe],
+    [m4_warn([syntax], [$1 is m4_require'd but not m4_defun'd])])])]dnl
+[_m4_divert_raw($3)_m4_undivert(_m4_divert_grow)]dnl
+[m4_divert_pop(_m4_divert_grow)_m4_popdef([_m4_divert_grow],
+[_m4_diverting([$1])], [_m4_diverting])])
+
+
+# _m4_require_check(NAME-TO-CHECK, OWNER, CALLER)
+# -----------------------------------------------
+# NAME-TO-CHECK has been identified as previously expanded in the
+# diversion owned by OWNER.  If this is a problem, warn on behalf of
+# CALLER and return _m4_require_call; otherwise return m4_ignore.
+m4_define([_m4_require_check],
+[m4_if(_m4_defn([_m4_diverting]), [$2], [m4_ignore],
+       m4_ifdef([_m4_diverting([$2])], [-]), [-], [m4_warn([syntax],
+   [$3: `$1' was expanded before it was required
+https://www.gnu.org/software/autoconf/manual/autoconf.html#Expanded-Before-Required])_m4_require_call],
+       [m4_ignore])])
+
+
+# _m4_divert_grow
+# ---------------
+# The counter for _m4_require_call.
+m4_define([_m4_divert_grow], _m4_divert([GROW]))
+
+
+# m4_expand_once(TEXT, [WITNESS = TEXT])
+# --------------------------------------
+# If TEXT has never been expanded, expand it *here*.  Use WITNESS as
+# as a memory that TEXT has already been expanded.
+m4_define([m4_expand_once],
+[m4_provide_if(m4_default_quoted([$2], [$1]),
+	       [],
+	       [m4_provide(m4_default_quoted([$2], [$1]))[]$1])])
+
+
+# m4_provide(MACRO-NAME)
+# ----------------------
+m4_define([m4_provide],
+[m4_ifdef([m4_provide($1)], [],
+[m4_set_add([_m4_provide], [$1], [m4_define([m4_provide($1)],
+  m4_ifdef([_m4_diverting], [_m4_defn([_m4_diverting])]))])])])
+
+
+# m4_provide_if(MACRO-NAME, IF-PROVIDED, IF-NOT-PROVIDED)
+# -------------------------------------------------------
+# If MACRO-NAME is provided do IF-PROVIDED, else IF-NOT-PROVIDED.
+# The purpose of this macro is to provide the user with a means to
+# check macros which are provided without letting her know how the
+# information is coded.
+m4_define([m4_provide_if],
+[m4_ifdef([m4_provide($1)],
+	  [$2], [$3])])
+
+
+## --------------------- ##
+## 12. Text processing.  ##
+## --------------------- ##
+
+
+# m4_cr_letters
+# m4_cr_LETTERS
+# m4_cr_Letters
+# -------------
+m4_define([m4_cr_letters], [abcdefghijklmnopqrstuvwxyz])
+m4_define([m4_cr_LETTERS], [ABCDEFGHIJKLMNOPQRSTUVWXYZ])
+m4_define([m4_cr_Letters],
+m4_defn([m4_cr_letters])dnl
+m4_defn([m4_cr_LETTERS])dnl
+)
+
+
+# m4_cr_digits
+# ------------
+m4_define([m4_cr_digits], [0123456789])
+
+
+# m4_cr_alnum
+# -----------
+m4_define([m4_cr_alnum],
+m4_defn([m4_cr_Letters])dnl
+m4_defn([m4_cr_digits])dnl
+)
+
+
+# m4_cr_symbols1
+# m4_cr_symbols2
+# --------------
+m4_define([m4_cr_symbols1],
+m4_defn([m4_cr_Letters])dnl
+_)
+
+m4_define([m4_cr_symbols2],
+m4_defn([m4_cr_symbols1])dnl
+m4_defn([m4_cr_digits])dnl
+)
+
+# m4_cr_all
+# ---------
+# The character range representing everything, with `-' as the last
+# character, since it is special to m4_translit.  Use with care, because
+# it contains characters special to M4 (fortunately, both ASCII and EBCDIC
+# have [] in order, so m4_defn([m4_cr_all]) remains a valid string).  It
+# also contains characters special to terminals, so it should never be
+# displayed in an error message.  Also, attempts to map [ and ] to other
+# characters via m4_translit must deal with the fact that m4_translit does
+# not add quotes to the output.
+#
+# In EBCDIC, $ is immediately followed by *, which leads to problems
+# if m4_cr_all is inlined into a macro definition; so swap them.
+#
+# It is mainly useful in generating inverted character range maps, for use
+# in places where m4_translit is faster than an equivalent m4_bpatsubst;
+# the regex `[^a-z]' is equivalent to:
+#  m4_translit(m4_dquote(m4_defn([m4_cr_all])), [a-z])
+m4_define([m4_cr_all],
+m4_translit(m4_dquote(m4_format(m4_dquote(m4_for(
+  ,1,255,,[[%c]]))m4_for([i],1,255,,[,i]))), [$*-], [*$])-)
+
+
+# _m4_define_cr_not(CATEGORY)
+# ---------------------------
+# Define m4_cr_not_CATEGORY as the inverse of m4_cr_CATEGORY.
+m4_define([_m4_define_cr_not],
+[m4_define([m4_cr_not_$1],
+	   m4_translit(m4_dquote(m4_defn([m4_cr_all])),
+		       m4_defn([m4_cr_$1])))])
+
+
+# m4_cr_not_letters
+# m4_cr_not_LETTERS
+# m4_cr_not_Letters
+# m4_cr_not_digits
+# m4_cr_not_alnum
+# m4_cr_not_symbols1
+# m4_cr_not_symbols2
+# ------------------
+# Inverse character sets
+_m4_define_cr_not([letters])
+_m4_define_cr_not([LETTERS])
+_m4_define_cr_not([Letters])
+_m4_define_cr_not([digits])
+_m4_define_cr_not([alnum])
+_m4_define_cr_not([symbols1])
+_m4_define_cr_not([symbols2])
+
+
+# m4_newline([STRING])
+# --------------------
+# Expands to a newline, possibly followed by STRING.  Exists mostly for
+# formatting reasons.
+m4_define([m4_newline], [
+$1])
+
+
+# m4_re_escape(STRING)
+# --------------------
+# Escape RE active characters in STRING.
+m4_define([m4_re_escape],
+[m4_bpatsubst([$1],
+	      [[][*+.?\^$]], [\\\&])])
+
+
+# m4_re_string
+# ------------
+# Regexp for `[a-zA-Z_0-9]*'
+# m4_dquote provides literal [] for the character class.
+m4_define([m4_re_string],
+m4_dquote(m4_defn([m4_cr_symbols2]))dnl
+[*]dnl
+)
+
+
+# m4_re_word
+# ----------
+# Regexp for `[a-zA-Z_][a-zA-Z_0-9]*'
+m4_define([m4_re_word],
+m4_dquote(m4_defn([m4_cr_symbols1]))dnl
+m4_defn([m4_re_string])dnl
+)
+
+
+# m4_tolower(STRING)
+# m4_toupper(STRING)
+# ------------------
+# These macros convert STRING to lowercase or uppercase.
+#
+# Rather than expand the m4_defn each time, we inline them up front.
+m4_define([m4_tolower],
+[m4_translit([[$1]], ]m4_dquote(m4_defn([m4_cr_LETTERS]))[,
+		     ]m4_dquote(m4_defn([m4_cr_letters]))[)])
+m4_define([m4_toupper],
+[m4_translit([[$1]], ]m4_dquote(m4_defn([m4_cr_letters]))[,
+		     ]m4_dquote(m4_defn([m4_cr_LETTERS]))[)])
+
+
+# m4_split(STRING, [REGEXP])
+# --------------------------
+# Split STRING into an m4 list of quoted elements.  The elements are
+# quoted with [ and ].  Beginning spaces and end spaces *are kept*.
+# Use m4_strip to remove them.
+#
+# REGEXP specifies where to split.  Default is [\t ]+.
+#
+# If STRING is empty, the result is an empty list.
+#
+# Pay attention to the m4_changequotes.  When m4 reads the definition of
+# m4_split, it still has quotes set to [ and ].  Luckily, these are matched
+# in the macro body, so the definition is stored correctly.  Use the same
+# alternate quotes as m4_noquote; it must be unlikely to appear in $1.
+#
+# Also, notice that $1 is quoted twice, since we want the result to
+# be quoted.  Then you should understand that the argument of
+# patsubst is -=<{(STRING)}>=- (i.e., with additional -=<{( and )}>=-).
+#
+# This macro is safe on active symbols, i.e.:
+#   m4_define(active, ACTIVE)
+#   m4_split([active active ])end
+#   => [active], [active], []end
+#
+# Optimize on regex of ` ' (space), since m4_foreach_w already guarantees
+# that the list contains single space separators, and a common case is
+# splitting a single-element list.  This macro is called frequently,
+# so avoid unnecessary dnl inside the definition.
+m4_define([m4_split],
+[m4_if([$1], [], [],
+       [$2], [ ], [m4_if(m4_index([$1], [ ]), [-1], [[[$1]]],
+			 [_$0([$1], [$2], [, ])])],
+       [$2], [], [_$0([$1], [[	 ]+], [, ])],
+       [_$0([$1], [$2], [, ])])])
+
+m4_define([_m4_split],
+[m4_changequote([-=<{(],[)}>=-])]dnl
+[[m4_bpatsubst(-=<{(-=<{($1)}>=-)}>=-, -=<{($2)}>=-,
+	       -=<{(]$3[)}>=-)]m4_changequote([, ])])
+
+
+# m4_chomp(STRING)
+# m4_chomp_all(STRING)
+# --------------------
+# Return STRING quoted, but without a trailing newline.  m4_chomp
+# removes at most one newline, while m4_chomp_all removes all
+# consecutive trailing newlines.  Embedded newlines are not touched,
+# and a trailing backslash-newline leaves just a trailing backslash.
+#
+# m4_bregexp is slower than m4_index, and we don't always want to
+# remove all newlines; hence the two variants.  We massage characters
+# to give a nicer pattern to match, particularly since m4_bregexp is
+# line-oriented.  Both versions must guarantee a match, to avoid bugs
+# with precision -1 in m4_format in older m4.
+m4_define([m4_chomp],
+[m4_format([[%.*s]], m4_index(m4_translit([[$1]], [
+/.], [/  ])[./.], [/.]), [$1])])
+
+m4_define([m4_chomp_all],
+[m4_format([[%.*s]], m4_bregexp(m4_translit([[$1]], [
+/], [/ ]), [/*$]), [$1])])
+
+
+# m4_flatten(STRING)
+# ------------------
+# If STRING contains end of lines, replace them with spaces.  If there
+# are backslashed end of lines, remove them.  This macro is safe with
+# active symbols.
+#    m4_define(active, ACTIVE)
+#    m4_flatten([active
+#    act\
+#    ive])end
+#    => active activeend
+#
+# In m4, m4_bpatsubst is expensive, so first check for a newline.
+m4_define([m4_flatten],
+[m4_if(m4_index([$1], [
+]), [-1], [[$1]],
+       [m4_translit(m4_bpatsubst([[[$1]]], [\\
+]), [
+], [ ])])])
+
+
+# m4_strip(STRING)
+# ----------------
+# Expands into STRING with tabs and spaces singled out into a single
+# space, and removing leading and trailing spaces.
+#
+# This macro is robust to active symbols.
+#    m4_define(active, ACTIVE)
+#    m4_strip([  active <tab> <tab>active ])end
+#    => active activeend
+#
+# First, notice that we guarantee trailing space.  Why?  Because regular
+# expressions are greedy, and `.* ?' would always group the space into the
+# .* portion.  The algorithm is simpler by avoiding `?' at the end.  The
+# algorithm correctly strips everything if STRING is just ` '.
+#
+# Then notice the second pattern: it is in charge of removing the
+# leading/trailing spaces.  Why not just `[^ ]'?  Because they are
+# applied to over-quoted strings, i.e. more or less [STRING], due
+# to the limitations of m4_bpatsubsts.  So the leading space in STRING
+# is the *second* character; equally for the trailing space.
+m4_define([m4_strip],
+[m4_bpatsubsts([$1 ],
+	       [[	 ]+], [ ],
+	       [^. ?\(.*\) .$], [[[\1]]])])
+
+
+# m4_normalize(STRING)
+# --------------------
+# Apply m4_flatten and m4_strip to STRING.
+#
+# The argument is quoted, so that the macro is robust to active symbols:
+#
+#    m4_define(active, ACTIVE)
+#    m4_normalize([  act\
+#    ive
+#    active ])end
+#    => active activeend
+
+m4_define([m4_normalize],
+[m4_strip(m4_flatten([$1]))])
+
+
+
+# m4_join(SEP, ARG1, ARG2...)
+# ---------------------------
+# Produce ARG1SEPARG2...SEPARGn.  Avoid back-to-back SEP when a given ARG
+# is the empty string.  No expansion is performed on SEP or ARGs.
+#
+# Since the number of arguments to join can be arbitrarily long, we
+# want to avoid having more than one $@ in the macro definition;
+# otherwise, the expansion would require twice the memory of the already
+# long list.  Hence, m4_join merely looks for the first non-empty element,
+# and outputs just that element; while _m4_join looks for all non-empty
+# elements, and outputs them following a separator.  The final trick to
+# note is that we decide between recursing with $0 or _$0 based on the
+# nested m4_if ending with `_'.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_join],
+[m4_if([$#], [1], [],
+       [$#], [2], [[$2]],
+       [m4_if([$2], [], [], [[$2]_])$0([$1], m4_shift2($@))])])
+m4_define([_m4_join],
+[m4_if([$#$2], [2], [],
+       [m4_if([$2], [], [], [[$1$2]])$0([$1], m4_shift2($@))])])
+
+# m4_joinall(SEP, ARG1, ARG2...)
+# ------------------------------
+# Produce ARG1SEPARG2...SEPARGn.  An empty ARG results in back-to-back SEP.
+# No expansion is performed on SEP or ARGs.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_joinall], [[$2]_$0([$1], m4_shift($@))])
+m4_define([_m4_joinall],
+[m4_if([$#], [2], [], [[$1$3]$0([$1], m4_shift2($@))])])
+
+# m4_combine([SEPARATOR], PREFIX-LIST, [INFIX], SUFFIX...)
+# --------------------------------------------------------
+# Produce the pairwise combination of every element in the quoted,
+# comma-separated PREFIX-LIST with every element from the SUFFIX arguments.
+# Each pair is joined with INFIX, and pairs are separated by SEPARATOR.
+# No expansion occurs on SEPARATOR, INFIX, or elements of either list.
+#
+# For example:
+#   m4_combine([, ], [[a], [b], [c]], [-], [1], [2], [3])
+#   => a-1, a-2, a-3, b-1, b-2, b-3, c-1, c-2, c-3
+#
+# This definition is a bit hairy; the thing to realize is that we want
+# to construct m4_map_args_sep([[prefix$3]], [], [[$1]], m4_shift3($@))
+# as the inner loop, using each prefix generated by the outer loop,
+# and without recalculating m4_shift3 every outer iteration.
+m4_define([m4_combine],
+[m4_if([$2], [], [], m4_eval([$# > 3]), [1],
+[m4_map_args_sep([m4_map_args_sep(m4_dquote(], [)[[$3]], [], [[$1]],]]]dnl
+[m4_dquote(m4_dquote(m4_shift3($@)))[[)], [[$1]], $2)])])
+
+
+# m4_append(MACRO-NAME, STRING, [SEPARATOR])
+# ------------------------------------------
+# Redefine MACRO-NAME to hold its former content plus `SEPARATOR`'STRING'
+# at the end.  It is valid to use this macro with MACRO-NAME undefined,
+# in which case no SEPARATOR is added.  Be aware that the criterion is
+# `not being defined', and not `not being empty'.
+#
+# Note that neither STRING nor SEPARATOR are expanded here; rather, when
+# you expand MACRO-NAME, they will be expanded at that point in time.
+#
+# This macro is robust to active symbols.  It can be used to grow
+# strings.
+#
+#    | m4_define(active, ACTIVE)dnl
+#    | m4_append([sentence], [This is an])dnl
+#    | m4_append([sentence], [ active ])dnl
+#    | m4_append([sentence], [symbol.])dnl
+#    | sentence
+#    | m4_undefine([active])dnl
+#    | sentence
+#    => This is an ACTIVE symbol.
+#    => This is an active symbol.
+#
+# It can be used to define hooks.
+#
+#    | m4_define(active, ACTIVE)dnl
+#    | m4_append([hooks], [m4_define([act1], [act2])])dnl
+#    | m4_append([hooks], [m4_define([act2], [active])])dnl
+#    | m4_undefine([active])dnl
+#    | act1
+#    | hooks
+#    | act1
+#    => act1
+#    =>
+#    => active
+#
+# It can also be used to create lists, although this particular usage was
+# broken prior to autoconf 2.62.
+#    | m4_append([list], [one], [, ])dnl
+#    | m4_append([list], [two], [, ])dnl
+#    | m4_append([list], [three], [, ])dnl
+#    | list
+#    | m4_dquote(list)
+#    => one, two, three
+#    => [one],[two],[three]
+#
+# Note that m4_append can benefit from amortized O(n) m4 behavior, if
+# the underlying m4 implementation is smart enough to avoid copying existing
+# contents when enlarging a macro's definition into any pre-allocated storage
+# (m4 1.4.x unfortunately does not implement this optimization).  We do
+# not implement m4_prepend, since it is inherently O(n^2) (pre-allocated
+# storage only occurs at the end of a macro, so the existing contents must
+# always be moved).
+#
+# Use _m4_defn for speed.
+m4_define([m4_append],
+[m4_define([$1], m4_ifdef([$1], [_m4_defn([$1])[$3]])[$2])])
+
+
+# m4_append_uniq(MACRO-NAME, STRING, [SEPARATOR], [IF-UNIQ], [IF-DUP])
+# --------------------------------------------------------------------
+# Like `m4_append', but append only if not yet present.  Additionally,
+# expand IF-UNIQ if STRING was appended, or IF-DUP if STRING was already
+# present.  Also, warn if SEPARATOR is not empty and occurs within STRING,
+# as the algorithm no longer guarantees uniqueness.
+#
+# Note that while m4_append can be O(n) (depending on the quality of the
+# underlying M4 implementation), m4_append_uniq is inherently O(n^2)
+# because each append operation searches the entire string.
+m4_define([m4_append_uniq],
+[m4_ifval([$3], [m4_if(m4_index([$2], [$3]), [-1], [],
+		       [m4_warn([syntax],
+				[$0: `$2' contains `$3'])])])_$0($@)])
+m4_define([_m4_append_uniq],
+[m4_ifdef([$1],
+	  [m4_if(m4_index([$3]_m4_defn([$1])[$3], [$3$2$3]), [-1],
+		 [m4_append([$1], [$2], [$3])$4], [$5])],
+	  [m4_define([$1], [$2])$4])])
+
+# m4_append_uniq_w(MACRO-NAME, STRINGS)
+# -------------------------------------
+# For each of the words in the whitespace separated list STRINGS, append
+# only the unique strings to the definition of MACRO-NAME.
+#
+# Use _m4_defn for speed.
+m4_define([m4_append_uniq_w],
+[m4_map_args_w([$2], [_m4_append_uniq([$1],], [, [ ])])])
+
+
+# m4_escape(STRING)
+# -----------------
+# Output quoted STRING, but with embedded #, $, [ and ] turned into
+# quadrigraphs.
+#
+# It is faster to check if STRING is already good using m4_translit
+# than to blindly perform four m4_bpatsubst.
+#
+# Because the translit is stripping quotes, it must also neutralize
+# anything that might be in a macro name, as well as comments, commas,
+# and parentheses.  All the problem characters are unified so that a
+# single m4_index can scan the result.
+#
+# Rather than expand m4_defn every time m4_escape is expanded, we
+# inline its expansion up front.
+m4_define([m4_escape],
+[m4_if(m4_index(m4_translit([$1],
+   [[]#,()]]m4_dquote(m4_defn([m4_cr_symbols2]))[, [$$$]), [$]),
+  [-1], [m4_echo], [_$0])([$1])])
+
+m4_define([_m4_escape],
+[m4_changequote([-=<{(],[)}>=-])]dnl
+[m4_bpatsubst(m4_bpatsubst(m4_bpatsubst(m4_bpatsubst(
+	  -=<{(-=<{(-=<{(-=<{(-=<{($1)}>=-)}>=-)}>=-)}>=-)}>=-,
+	-=<{(#)}>=-, -=<{(@%:@)}>=-),
+      -=<{(\[)}>=-, -=<{(@<:@)}>=-),
+    -=<{(\])}>=-, -=<{(@:>@)}>=-),
+  -=<{(\$)}>=-, -=<{(@S|@)}>=-)m4_changequote([,])])
+
+
+# m4_text_wrap(STRING, [PREFIX], [FIRST-PREFIX], [WIDTH])
+# -------------------------------------------------------
+# Expands into STRING wrapped to hold in WIDTH columns (default = 79).
+# If PREFIX is given, each line is prefixed with it.  If FIRST-PREFIX is
+# specified, then the first line is prefixed with it.  As a special case,
+# if the length of FIRST-PREFIX is greater than that of PREFIX, then
+# FIRST-PREFIX will be left alone on the first line.
+#
+# No expansion occurs on the contents STRING, PREFIX, or FIRST-PREFIX,
+# although quadrigraphs are correctly recognized.  More precisely,
+# you may redefine m4_qlen to recognize whatever escape sequences that
+# you will post-process.
+#
+# Typical outputs are:
+#
+# m4_text_wrap([Short string */], [   ], [/* ], 20)
+#  => /* Short string */
+#
+# m4_text_wrap([Much longer string */], [   ], [/* ], 20)
+#  => /* Much longer
+#  =>    string */
+#
+# m4_text_wrap([Short doc.], [          ], [  --short ], 30)
+#  =>   --short Short doc.
+#
+# m4_text_wrap([Short doc.], [          ], [  --too-wide ], 30)
+#  =>   --too-wide
+#  =>           Short doc.
+#
+# m4_text_wrap([Super long documentation.], [          ], [  --too-wide ], 30)
+#  =>   --too-wide
+#  =>      Super long
+#  =>      documentation.
+#
+# FIXME: there is no checking of a longer PREFIX than WIDTH, but do
+# we really want to bother with people trying each single corner
+# of a software?
+#
+# This macro does not leave a trailing space behind the last word of a line,
+# which complicates it a bit.  The algorithm is otherwise stupid and simple:
+# all the words are preceded by m4_Separator which is defined to empty for
+# the first word, and then ` ' (single space) for all the others.
+#
+# The algorithm uses a helper that uses $2 through $4 directly, rather than
+# using local variables, to avoid m4_defn overhead, or expansion swallowing
+# any $.  It also bypasses m4_popdef overhead with _m4_popdef since no user
+# macro expansion occurs in the meantime.  Also, the definition is written
+# with m4_do, to avoid time wasted on dnl during expansion (since this is
+# already a time-consuming macro).
+m4_define([m4_text_wrap],
+[_$0(m4_escape([$1]), [$2], m4_default_quoted([$3], [$2]),
+     m4_default_quoted([$4], [79]))])
+
+m4_define([_m4_text_wrap],
+m4_do(dnl set up local variables, to avoid repeated calculations
+[[m4_pushdef([m4_Indent], m4_qlen([$2]))]],
+[[m4_pushdef([m4_Cursor], m4_qlen([$3]))]],
+[[m4_pushdef([m4_Separator], [m4_define([m4_Separator], [ ])])]],
+dnl expand the first prefix, then check its length vs. regular prefix
+dnl same length: nothing special
+dnl prefix1 longer: output on line by itself, and reset cursor
+dnl prefix1 shorter: pad to length of prefix, and reset cursor
+[[[$3]m4_cond([m4_Cursor], m4_Indent, [],
+	      [m4_eval(m4_Cursor > m4_Indent)], [1], [
+[$2]m4_define([m4_Cursor], m4_Indent)],
+	      [m4_format([%*s], m4_max([0],
+  m4_eval(m4_Indent - m4_Cursor)), [])m4_define([m4_Cursor], m4_Indent)])]],
+dnl now, for each word, compute the cursor after the word is output, then
+dnl check if the cursor would exceed the wrap column
+dnl if so, reset cursor, and insert newline and prefix
+dnl if not, insert the separator (usually a space)
+dnl either way, insert the word
+[[m4_map_args_w([$1], [$0_word(], [, [$2], [$4])])]],
+dnl finally, clean up the local variables
+[[_m4_popdef([m4_Separator], [m4_Cursor], [m4_Indent])]]))
+
+m4_define([_m4_text_wrap_word],
+[m4_define([m4_Cursor], m4_eval(m4_Cursor + m4_qlen([$1]) + 1))]dnl
+[m4_if(m4_eval(m4_Cursor > ([$3])),
+      [1], [m4_define([m4_Cursor], m4_eval(m4_Indent + m4_qlen([$1]) + 1))
+[$2]],
+      [m4_Separator[]])[$1]])
+
+# m4_text_box(MESSAGE, [FRAME-CHARACTER = `-'])
+# ---------------------------------------------
+# Turn MESSAGE into:
+#  ## ------- ##
+#  ## MESSAGE ##
+#  ## ------- ##
+# using FRAME-CHARACTER in the border.
+#
+# Quadrigraphs are correctly recognized.  More precisely, you may
+# redefine m4_qlen to recognize whatever escape sequences that you
+# will post-process.
+m4_define([m4_text_box],
+[m4_pushdef([m4_Border],
+	    m4_translit(m4_format([[[%*s]]], m4_decr(m4_qlen(_m4_expand([$1
+]))), []), [ ], m4_default_quoted([$2], [-])))]dnl
+[[##] _m4_defn([m4_Border]) [##]
+[##] $1 [##]
+[##] _m4_defn([m4_Border]) [##]_m4_popdef([m4_Border])])
+
+
+# m4_qlen(STRING)
+# ---------------
+# Expands to the length of STRING after autom4te converts all quadrigraphs.
+#
+# If you use some other means of post-processing m4 output rather than
+# autom4te, then you may redefine this macro to recognize whatever
+# escape sequences your post-processor will handle.  For that matter,
+# m4_define([m4_qlen], m4_defn([m4_len])) is sufficient if you don't
+# do any post-processing.
+#
+# Avoid bpatsubsts for the common case of no quadrigraphs.  Cache
+# results, as configure scripts tend to ask about lengths of common
+# strings like `/*' and `*/' rather frequently.  Minimize the number
+# of times that $1 occurs in m4_qlen, so there is less text to parse
+# on a cache hit.
+m4_define([m4_qlen],
+[m4_ifdef([$0-$1], [_m4_defn([$0-]], [_$0(])[$1])])
+m4_define([_m4_qlen],
+[m4_define([m4_qlen-$1],
+m4_if(m4_index([$1], [@]), [-1], [m4_len([$1])],
+      [m4_len(m4_bpatsubst([[$1]],
+			   [@\(\(<:\|:>\|S|\|%:\|\{:\|:\}\)\(@\)\|&t@\)],
+			   [\3]))]))_m4_defn([m4_qlen-$1])])
+
+# m4_copyright_condense(TEXT)
+# ---------------------------
+# Condense the copyright notice in TEXT to only display the final
+# year, wrapping the results to fit in 80 columns.
+m4_define([m4_copyright_condense],
+[m4_text_wrap(m4_bpatsubst(m4_flatten([[$1]]),
+[(C)[-	 ,0-9]*\([1-9][0-9][0-9][0-9]\)], [(C) \1]))])
+
+## ----------------------- ##
+## 13. Number processing.  ##
+## ----------------------- ##
+
+# m4_cmp(A, B)
+# ------------
+# Compare two integer expressions.
+# A < B -> -1
+# A = B ->  0
+# A > B ->  1
+m4_define([m4_cmp],
+[m4_eval((([$1]) > ([$2])) - (([$1]) < ([$2])))])
+
+
+# m4_list_cmp(A, B)
+# -----------------
+#
+# Compare the two lists of integer expressions A and B.  For instance:
+#   m4_list_cmp([1, 0],     [1])    ->  0
+#   m4_list_cmp([1, 0],     [1, 0]) ->  0
+#   m4_list_cmp([1, 2],     [1, 0]) ->  1
+#   m4_list_cmp([1, 2, 3],  [1, 2]) ->  1
+#   m4_list_cmp([1, 2, -3], [1, 2]) -> -1
+#   m4_list_cmp([1, 0],     [1, 2]) -> -1
+#   m4_list_cmp([1],        [1, 2]) -> -1
+#   m4_define([xa], [oops])dnl
+#   m4_list_cmp([[0xa]],    [5+5])  -> 0
+#
+# Rather than face the overhead of m4_case, we use a helper function whose
+# expansion includes the name of the macro to invoke on the tail, either
+# m4_ignore or m4_unquote.  This is particularly useful when comparing
+# long lists, since less text is being expanded for deciding when to end
+# recursion.  The recursion is between a pair of macros that alternate
+# which list is trimmed by one element; this is more efficient than
+# calling m4_cdr on both lists from a single macro.  Guarantee exactly
+# one expansion of both lists' side effects.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_list_cmp],
+[_$0_raw(m4_dquote($1), m4_dquote($2))])
+
+m4_define([_m4_list_cmp_raw],
+[m4_if([$1], [$2], [0], [_m4_list_cmp_1([$1], $2)])])
+
+m4_define([_m4_list_cmp],
+[m4_if([$1], [], [0m4_ignore], [$2], [0], [m4_unquote], [$2m4_ignore])])
+
+m4_define([_m4_list_cmp_1],
+[_m4_list_cmp_2([$2], [m4_shift2($@)], $1)])
+
+m4_define([_m4_list_cmp_2],
+[_m4_list_cmp([$1$3], m4_cmp([$3+0], [$1+0]))(
+  [_m4_list_cmp_1(m4_dquote(m4_shift3($@)), $2)])])
+
+# m4_max(EXPR, ...)
+# m4_min(EXPR, ...)
+# -----------------
+# Return the decimal value of the maximum (or minimum) in a series of
+# integer expressions.
+#
+# M4 1.4.x doesn't provide ?:.  Hence this huge m4_eval.  Avoid m4_eval
+# if both arguments are identical, but be aware of m4_max(0xa, 10) (hence
+# the use of <=, not just <, in the second multiply).
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_max],
+[m4_if([$#], [0], [m4_fatal([too few arguments to $0])],
+       [$#], [1], [m4_eval([$1])],
+       [$#$1], [2$2], [m4_eval([$1])],
+       [$#], [2], [_$0($@)],
+       [_m4_minmax([_$0], $@)])])
+
+m4_define([_m4_max],
+[m4_eval((([$1]) > ([$2])) * ([$1]) + (([$1]) <= ([$2])) * ([$2]))])
+
+m4_define([m4_min],
+[m4_if([$#], [0], [m4_fatal([too few arguments to $0])],
+       [$#], [1], [m4_eval([$1])],
+       [$#$1], [2$2], [m4_eval([$1])],
+       [$#], [2], [_$0($@)],
+       [_m4_minmax([_$0], $@)])])
+
+m4_define([_m4_min],
+[m4_eval((([$1]) < ([$2])) * ([$1]) + (([$1]) >= ([$2])) * ([$2]))])
+
+# _m4_minmax(METHOD, ARG1, ARG2...)
+# ---------------------------------
+# Common recursion code for m4_max and m4_min.  METHOD must be _m4_max
+# or _m4_min, and there must be at least two arguments to combine.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([_m4_minmax],
+[m4_if([$#], [3], [$1([$2], [$3])],
+       [$0([$1], $1([$2], [$3]), m4_shift3($@))])])
+
+
+# m4_sign(A)
+# ----------
+# The sign of the integer expression A.
+m4_define([m4_sign],
+[m4_eval((([$1]) > 0) - (([$1]) < 0))])
+
+
+
+## ------------------------ ##
+## 14. Version processing.  ##
+## ------------------------ ##
+
+
+# m4_version_unletter(VERSION)
+# ----------------------------
+# Normalize beta version numbers with letters to numeric expressions, which
+# can then be handed to m4_eval for the purpose of comparison.
+#
+#   Nl -> (N+1).-1.(l#)
+#
+# for example:
+#   [2.14a] -> [0,2,14+1,-1,[0r36:a]] -> 2.15.-1.10
+#   [2.14b] -> [0,2,15+1,-1,[0r36:b]] -> 2.15.-1.11
+#   [2.61aa.b] -> [0,2.61,1,-1,[0r36:aa],+1,-1,[0r36:b]] -> 2.62.-1.370.1.-1.11
+#   [08] -> [0,[0r10:0]8] -> 8
+#
+# This macro expects reasonable version numbers, but can handle double
+# letters and does not expand any macros.  Original version strings can
+# use both `.' and `-' separators.
+#
+# Inline constant expansions, to avoid m4_defn overhead.
+# _m4_version_unletter is the real workhorse used by m4_version_compare,
+# but since [0r36:a] and commas are less readable than 10 and dots, we
+# provide a wrapper for human use.
+m4_define([m4_version_unletter],
+[m4_substr(m4_map_args([.m4_eval], m4_unquote(_$0([$1]))), [3])])
+m4_define([_m4_version_unletter],
+[m4_bpatsubst(m4_bpatsubst(m4_translit([[[[0,$1]]]], [.-], [,,]),]dnl
+m4_dquote(m4_dquote(m4_defn([m4_cr_Letters])))[[+],
+	      [+1,-1,[0r36:\&]]), [,0], [,[0r10:0]])])
+
+
+# m4_version_compare(VERSION-1, VERSION-2)
+# ----------------------------------------
+# Compare the two version numbers and expand into
+#  -1 if VERSION-1 < VERSION-2
+#   0 if           =
+#   1 if           >
+#
+# Since _m4_version_unletter does not output side effects, we can
+# safely bypass the overhead of m4_version_cmp.
+m4_define([m4_version_compare],
+[_m4_list_cmp_raw(_m4_version_unletter([$1]), _m4_version_unletter([$2]))])
+
+
+# m4_PACKAGE_NAME
+# m4_PACKAGE_TARNAME
+# m4_PACKAGE_VERSION
+# m4_PACKAGE_STRING
+# m4_PACKAGE_BUGREPORT
+# --------------------
+# If m4sugar/version.m4 is present, then define version strings.  This
+# file is optional, provided by Autoconf but absent in Bison.
+m4_sinclude([m4sugar/version.m4])
+
+
+# m4_version_prereq(VERSION, [IF-OK], [IF-NOT = FAIL])
+# ----------------------------------------------------
+# Check this Autoconf version against VERSION.
+m4_define([m4_version_prereq],
+m4_ifdef([m4_PACKAGE_VERSION],
+[[m4_if(m4_version_compare(]m4_dquote(m4_defn([m4_PACKAGE_VERSION]))[, [$1]),
+	[-1],
+	[m4_default([$3],
+		    [m4_fatal([Autoconf version $1 or higher is required],
+			      [63])])],
+	[$2])]],
+[[m4_fatal([m4sugar/version.m4 not found])]]))
+
+
+## ------------------ ##
+## 15. Set handling.  ##
+## ------------------ ##
+
+# Autoconf likes to create arbitrarily large sets; for example, as of
+# this writing, the configure.ac for coreutils tracks a set of more
+# than 400 AC_SUBST.  How do we track all of these set members,
+# without introducing duplicates?  We could use m4_append_uniq, with
+# the set NAME residing in the contents of the macro NAME.
+# Unfortunately, m4_append_uniq is quadratic for set creation, because
+# it costs O(n) to search the string for each of O(n) insertions; not
+# to mention that with m4 1.4.x, even using m4_append is slow, costing
+# O(n) rather than O(1) per insertion.  Other set operations, not used
+# by Autoconf but still possible by manipulation of the definition
+# tracked in macro NAME, include O(n) deletion of one element and O(n)
+# computation of set size.  Because the set is exposed to the user via
+# the definition of a single macro, we cannot cache any data about the
+# set without risking the cache being invalidated by the user
+# redefining NAME.
+#
+# Can we do better?  Yes, because m4 gives us an O(1) search function
+# for free: ifdef.  Additionally, even m4 1.4.x gives us an O(1)
+# insert operation for free: pushdef.  But to use these, we must
+# represent the set via a group of macros; to keep the set consistent,
+# we must hide the set so that the user can only manipulate it through
+# accessor macros.  The contents of the set are maintained through two
+# access points; _m4_set([name]) is a pushdef stack of values in the
+# set, useful for O(n) traversal of the set contents; while the
+# existence of _m4_set([name],value) with no particular value is
+# useful for O(1) querying of set membership.  And since the user
+# cannot externally manipulate the set, we are free to add additional
+# caching macros for other performance improvements.  Deletion can be
+# O(1) per element rather than O(n), by reworking the definition of
+# _m4_set([name],value) to be 0 or 1 based on current membership, and
+# adding _m4_set_cleanup(name) to defer the O(n) cleanup of
+# _m4_set([name]) until we have another reason to do an O(n)
+# traversal.  The existence of _m4_set_cleanup(name) can then be used
+# elsewhere to determine if we must dereference _m4_set([name],value),
+# or assume that definition implies set membership.  Finally, size can
+# be tracked in an O(1) fashion with _m4_set_size(name).
+#
+# The quoting in _m4_set([name],value) is chosen so that there is no
+# ambiguity with a set whose name contains a comma, and so that we can
+# supply the value via _m4_defn([_m4_set([name])]) without needing any
+# quote manipulation.
+
+# m4_set_add(SET, VALUE, [IF-UNIQ], [IF-DUP])
+# -------------------------------------------
+# Add VALUE as an element of SET.  Expand IF-UNIQ on the first
+# addition, and IF-DUP if it is already in the set.  Addition of one
+# element is O(1), such that overall set creation is O(n).
+#
+# We do not want to add a duplicate for a previously deleted but
+# unpruned element, but it is just as easy to check existence directly
+# as it is to query _m4_set_cleanup($1).
+m4_define([m4_set_add],
+[m4_ifdef([_m4_set([$1],$2)],
+	  [m4_if(m4_indir([_m4_set([$1],$2)]), [0],
+		 [m4_define([_m4_set([$1],$2)],
+			    [1])_m4_set_size([$1], [m4_incr])$3], [$4])],
+	  [m4_define([_m4_set([$1],$2)],
+		     [1])m4_pushdef([_m4_set([$1])],
+				    [$2])_m4_set_size([$1], [m4_incr])$3])])
+
+# m4_set_add_all(SET, VALUE...)
+# -----------------------------
+# Add each VALUE into SET.  This is O(n) in the number of VALUEs, and
+# can be faster than calling m4_set_add for each VALUE.
+#
+# Implement two recursion helpers; the check variant is slower but
+# handles the case where an element has previously been removed but
+# not pruned.  The recursion helpers ignore their second argument, so
+# that we can use the faster m4_shift2 and 2 arguments, rather than
+# _m4_shift2 and one argument, as the signal to end recursion.
+#
+# Please keep foreach.m4 in sync with any adjustments made here.
+m4_define([m4_set_add_all],
+[m4_define([_m4_set_size($1)], m4_eval(m4_set_size([$1])
+  + m4_len(m4_ifdef([_m4_set_cleanup($1)], [_$0_check], [_$0])([$1], $@))))])
+
+m4_define([_m4_set_add_all],
+[m4_if([$#], [2], [],
+       [m4_ifdef([_m4_set([$1],$3)], [],
+		 [m4_define([_m4_set([$1],$3)], [1])m4_pushdef([_m4_set([$1])],
+	   [$3])-])$0([$1], m4_shift2($@))])])
+
+m4_define([_m4_set_add_all_check],
+[m4_if([$#], [2], [],
+       [m4_set_add([$1], [$3])$0([$1], m4_shift2($@))])])
+
+# m4_set_contains(SET, VALUE, [IF-PRESENT], [IF-ABSENT])
+# ------------------------------------------------------
+# Expand IF-PRESENT if SET contains VALUE, otherwise expand IF-ABSENT.
+# This is always O(1).
+m4_define([m4_set_contains],
+[m4_ifdef([_m4_set_cleanup($1)],
+	  [m4_if(m4_ifdef([_m4_set([$1],$2)],
+		    [m4_indir([_m4_set([$1],$2)])], [0]), [1], [$3], [$4])],
+	  [m4_ifdef([_m4_set([$1],$2)], [$3], [$4])])])
+
+# m4_set_contents(SET, [SEP])
+# ---------------------------
+# Expand to a single string containing all the elements in SET,
+# separated by SEP, without modifying SET.  No provision is made for
+# disambiguating set elements that contain non-empty SEP as a
+# sub-string, or for recognizing a set that contains only the empty
+# string.  Order of the output is not guaranteed.  If any elements
+# have been previously removed from the set, this action will prune
+# the unused memory.  This is O(n) in the size of the set before
+# pruning.
+#
+# Use _m4_popdef for speed.  The existence of _m4_set_cleanup($1)
+# determines which version of _1 helper we use.
+m4_define([m4_set_contents],
+[m4_set_map_sep([$1], [], [], [[$2]])])
+
+# _m4_set_contents_1(SET)
+# _m4_set_contents_1c(SET)
+# _m4_set_contents_2(SET, [PRE], [POST], [SEP])
+# ---------------------------------------------
+# Expand to a list of quoted elements currently in the set, each
+# surrounded by PRE and POST, and moving SEP in front of PRE on
+# recursion.  To avoid nesting limit restrictions, the algorithm must
+# be broken into two parts; _1 destructively copies the stack in
+# reverse into _m4_set_($1), producing no output; then _2
+# destructively copies _m4_set_($1) back into the stack in reverse.
+# If no elements were deleted, then this visits the set in the order
+# that elements were inserted.  Behavior is undefined if PRE/POST/SEP
+# tries to recursively list or modify SET in any way other than
+# calling m4_set_remove on the current element.  Use _1 if all entries
+# in the stack are guaranteed to be in the set, and _1c to prune
+# removed entries.  Uses _m4_defn and _m4_popdef for speed.
+m4_define([_m4_set_contents_1],
+[_m4_stack_reverse([_m4_set([$1])], [_m4_set_($1)])])
+
+m4_define([_m4_set_contents_1c],
+[m4_ifdef([_m4_set([$1])],
+	  [m4_set_contains([$1], _m4_defn([_m4_set([$1])]),
+		   [m4_pushdef([_m4_set_($1)], _m4_defn([_m4_set([$1])]))],
+		   [_m4_popdef([_m4_set([$1],]_m4_defn(
+      [_m4_set([$1])])[)])])_m4_popdef([_m4_set([$1])])$0([$1])],
+	  [_m4_popdef([_m4_set_cleanup($1)])])])
+
+m4_define([_m4_set_contents_2],
+[_m4_stack_reverse([_m4_set_($1)], [_m4_set([$1])],
+  [$2[]_m4_defn([_m4_set_($1)])$3], [$4[]])])
+
+# m4_set_delete(SET)
+# ------------------
+# Delete all elements in SET, and reclaim any memory occupied by the
+# set.  This is O(n) in the set size.
+#
+# Use _m4_defn and _m4_popdef for speed.
+m4_define([m4_set_delete],
+[m4_ifdef([_m4_set([$1])],
+	  [_m4_popdef([_m4_set([$1],]_m4_defn([_m4_set([$1])])[)],
+		      [_m4_set([$1])])$0([$1])],
+	  [m4_ifdef([_m4_set_cleanup($1)],
+		    [_m4_popdef([_m4_set_cleanup($1)])])m4_ifdef(
+		    [_m4_set_size($1)],
+		    [_m4_popdef([_m4_set_size($1)])])])])
+
+# m4_set_difference(SET1, SET2)
+# -----------------------------
+# Produce a LIST of quoted elements that occur in SET1 but not SET2.
+# Output a comma prior to any elements, to distinguish the empty
+# string from no elements.  This can be directly used as a series of
+# arguments, such as for m4_join, or wrapped inside quotes for use in
+# m4_foreach.  Order of the output is not guaranteed.
+#
+# Short-circuit the idempotence relation.
+m4_define([m4_set_difference],
+[m4_if([$1], [$2], [], [m4_set_map_sep([$1], [_$0([$2],], [)])])])
+
+m4_define([_m4_set_difference],
+[m4_set_contains([$1], [$2], [], [,[$2]])])
+
+# m4_set_dump(SET, [SEP])
+# -----------------------
+# Expand to a single string containing all the elements in SET,
+# separated by SEP, then delete SET.  In general, if you only need to
+# list the contents once, this is faster than m4_set_contents.  No
+# provision is made for disambiguating set elements that contain
+# non-empty SEP as a sub-string.  Order of the output is not
+# guaranteed.  This is O(n) in the size of the set before pruning.
+#
+# Use _m4_popdef for speed.  Use existence of _m4_set_cleanup($1) to
+# decide if more expensive recursion is needed.
+m4_define([m4_set_dump],
+[m4_ifdef([_m4_set_size($1)],
+	  [_m4_popdef([_m4_set_size($1)])])m4_ifdef([_m4_set_cleanup($1)],
+    [_$0_check], [_$0])([$1], [], [$2])])
+
+# _m4_set_dump(SET, [SEP], [PREP])
+# _m4_set_dump_check(SET, [SEP], [PREP])
+# --------------------------------------
+# Print SEP and the current element, then delete the element and
+# recurse with empty SEP changed to PREP.  The check variant checks
+# whether the element has been previously removed.  Use _m4_defn and
+# _m4_popdef for speed.
+m4_define([_m4_set_dump],
+[m4_ifdef([_m4_set([$1])],
+	  [[$2]_m4_defn([_m4_set([$1])])_m4_popdef([_m4_set([$1],]_m4_defn(
+		[_m4_set([$1])])[)], [_m4_set([$1])])$0([$1], [$2$3])])])
+
+m4_define([_m4_set_dump_check],
+[m4_ifdef([_m4_set([$1])],
+	  [m4_set_contains([$1], _m4_defn([_m4_set([$1])]),
+			   [[$2]_m4_defn([_m4_set([$1])])])_m4_popdef(
+    [_m4_set([$1],]_m4_defn([_m4_set([$1])])[)],
+    [_m4_set([$1])])$0([$1], [$2$3])],
+	  [_m4_popdef([_m4_set_cleanup($1)])])])
+
+# m4_set_empty(SET, [IF-EMPTY], [IF-ELEMENTS])
+# --------------------------------------------
+# Expand IF-EMPTY if SET has no elements, otherwise IF-ELEMENTS.
+m4_define([m4_set_empty],
+[m4_ifdef([_m4_set_size($1)],
+	  [m4_if(m4_indir([_m4_set_size($1)]), [0], [$2], [$3])], [$2])])
+
+# m4_set_foreach(SET, VAR, ACTION)
+# --------------------------------
+# For each element of SET, define VAR to the element and expand
+# ACTION.  ACTION should not recursively list SET's contents, add
+# elements to SET, nor delete any element from SET except the one
+# currently in VAR.  The order that the elements are visited in is not
+# guaranteed.  This is faster than the corresponding m4_foreach([VAR],
+#   m4_indir([m4_dquote]m4_set_listc([SET])), [ACTION])
+m4_define([m4_set_foreach],
+[m4_pushdef([$2])m4_set_map_sep([$1],
+[m4_define([$2],], [)$3])m4_popdef([$2])])
+
+# m4_set_intersection(SET1, SET2)
+# -------------------------------
+# Produce a LIST of quoted elements that occur in both SET1 or SET2.
+# Output a comma prior to any elements, to distinguish the empty
+# string from no elements.  This can be directly used as a series of
+# arguments, such as for m4_join, or wrapped inside quotes for use in
+# m4_foreach.  Order of the output is not guaranteed.
+#
+# Iterate over the smaller set, and short-circuit the idempotence
+# relation.
+m4_define([m4_set_intersection],
+[m4_if([$1], [$2], [m4_set_listc([$1])],
+       m4_eval(m4_set_size([$2]) < m4_set_size([$1])), [1], [$0([$2], [$1])],
+       [m4_set_map_sep([$1], [_$0([$2],], [)])])])
+
+m4_define([_m4_set_intersection],
+[m4_set_contains([$1], [$2], [,[$2]])])
+
+# m4_set_list(SET)
+# m4_set_listc(SET)
+# -----------------
+# Produce a LIST of quoted elements of SET.  This can be directly used
+# as a series of arguments, such as for m4_join or m4_set_add_all, or
+# wrapped inside quotes for use in m4_foreach or m4_map.  With
+# m4_set_list, there is no way to distinguish an empty set from a set
+# containing only the empty string; with m4_set_listc, a leading comma
+# is output if there are any elements.
+m4_define([m4_set_list],
+[m4_set_map_sep([$1], [], [], [,])])
+
+m4_define([m4_set_listc],
+[m4_set_map_sep([$1], [,])])
+
+# m4_set_map(SET, ACTION)
+# -----------------------
+# For each element of SET, expand ACTION with a single argument of the
+# current element.  ACTION should not recursively list SET's contents,
+# add elements to SET, nor delete any element from SET except the one
+# passed as an argument.  The order that the elements are visited in
+# is not guaranteed.  This is faster than either of the corresponding
+#   m4_map_args([ACTION]m4_set_listc([SET]))
+#   m4_set_foreach([SET], [VAR], [ACTION(m4_defn([VAR]))])
+m4_define([m4_set_map],
+[m4_set_map_sep([$1], [$2(], [)])])
+
+# m4_set_map_sep(SET, [PRE], [POST], [SEP])
+# -----------------------------------------
+# For each element of SET, expand PRE[value]POST[], and expand SEP
+# between elements.
+m4_define([m4_set_map_sep],
+[m4_ifdef([_m4_set_cleanup($1)], [_m4_set_contents_1c],
+	  [_m4_set_contents_1])([$1])_m4_set_contents_2($@)])
+
+# m4_set_remove(SET, VALUE, [IF-PRESENT], [IF-ABSENT])
+# ----------------------------------------------------
+# If VALUE is an element of SET, delete it and expand IF-PRESENT.
+# Otherwise expand IF-ABSENT.  Deleting a single value is O(1),
+# although it leaves memory occupied until the next O(n) traversal of
+# the set which will compact the set.
+#
+# Optimize if the element being removed is the most recently added,
+# since defining _m4_set_cleanup($1) slows down so many other macros.
+# In particular, this plays well with m4_set_foreach and m4_set_map.
+m4_define([m4_set_remove],
+[m4_set_contains([$1], [$2], [_m4_set_size([$1],
+    [m4_decr])m4_if(_m4_defn([_m4_set([$1])]), [$2],
+		    [_m4_popdef([_m4_set([$1],$2)], [_m4_set([$1])])],
+		    [m4_define([_m4_set_cleanup($1)])m4_define(
+		      [_m4_set([$1],$2)], [0])])$3], [$4])])
+
+# m4_set_size(SET)
+# ----------------
+# Expand to the number of elements currently in SET.  This operation
+# is O(1), and thus more efficient than m4_count(m4_set_list([SET])).
+m4_define([m4_set_size],
+[m4_ifdef([_m4_set_size($1)], [m4_indir([_m4_set_size($1)])], [0])])
+
+# _m4_set_size(SET, ACTION)
+# -------------------------
+# ACTION must be either m4_incr or m4_decr, and the size of SET is
+# changed accordingly.  If the set is empty, ACTION must not be
+# m4_decr.
+m4_define([_m4_set_size],
+[m4_define([_m4_set_size($1)],
+	   m4_ifdef([_m4_set_size($1)], [$2(m4_indir([_m4_set_size($1)]))],
+		    [1]))])
+
+# m4_set_union(SET1, SET2)
+# ------------------------
+# Produce a LIST of double quoted elements that occur in either SET1
+# or SET2, without duplicates.  Output a comma prior to any elements,
+# to distinguish the empty string from no elements.  This can be
+# directly used as a series of arguments, such as for m4_join, or
+# wrapped inside quotes for use in m4_foreach.  Order of the output is
+# not guaranteed.
+#
+# We can rely on the fact that m4_set_listc prunes SET1, so we don't
+# need to check _m4_set([$1],element) for 0.  Short-circuit the
+# idempotence relation.
+m4_define([m4_set_union],
+[m4_set_listc([$1])m4_if([$1], [$2], [],
+  [m4_set_map_sep([$2], [_$0([$1],], [)])])])
+
+m4_define([_m4_set_union],
+[m4_ifdef([_m4_set([$1],$2)], [], [,[$2]])])
+
+
+## ------------------- ##
+## 16. File handling.  ##
+## ------------------- ##
+
+
+# It is a real pity that M4 comes with no macros to bind a diversion
+# to a file.  So we have to deal without, which makes us a lot more
+# fragile than we should.
+
+
+# m4_file_append(FILE-NAME, CONTENT)
+# ----------------------------------
+m4_define([m4_file_append],
+[m4_syscmd([cat >>$1 <<_m4eof
+$2
+_m4eof
+])
+m4_if(m4_sysval, [0], [],
+      [m4_fatal([$0: cannot write: $1])])])
+
+
+
+## ------------------------ ##
+## 17. Setting M4sugar up.  ##
+## ------------------------ ##
+
+# _m4_divert_diversion should be defined.
+m4_divert_push([KILL])
+
+# m4_init
+# -------
+# Initialize the m4sugar language.
+m4_define([m4_init],
+[# All the M4sugar macros start with `m4_', except `dnl' kept as is
+# for sake of simplicity.
+m4_pattern_forbid([^_?m4_])
+m4_pattern_forbid([^dnl$])
+
+# If __m4_version__ is defined, we assume that we are being run by M4
+# 1.6 or newer, thus $@ recursion is linear, and debugmode(+do)
+# is available for faster checks of dereferencing undefined macros
+# and forcing dumpdef to print to stderr regardless of debugfile.
+# But if it is missing, we assume we are being run by M4 1.4.x, that
+# $@ recursion is quadratic, and that we need foreach-based
+# replacement macros.  Also, m4 prior to 1.4.8 loses track of location
+# during m4wrap text; __line__ should never be 0.
+#
+# Use the raw builtin to avoid tripping up include tracing.
+# Meanwhile, avoid m4_copy, since it temporarily undefines m4_defn.
+m4_ifdef([__m4_version__],
+[m4_debugmode([+do])
+m4_define([m4_defn], _m4_defn([_m4_defn]))
+m4_define([m4_dumpdef], _m4_defn([_m4_dumpdef]))
+m4_define([m4_popdef], _m4_defn([_m4_popdef]))
+m4_define([m4_undefine], _m4_defn([_m4_undefine]))],
+[m4_builtin([include], [m4sugar/foreach.m4])
+m4_wrap_lifo([m4_if(__line__, [0], [m4_pushdef([m4_location],
+]]m4_dquote(m4_dquote(m4_dquote(__file__:__line__)))[[)])])])
+
+# Rewrite the first entry of the diversion stack.
+m4_divert([KILL])
+
+# Check the divert push/pop perfect balance.
+# Some users are prone to also use m4_wrap to register last-minute
+# m4_divert_text; so after our diversion cleanups, we restore
+# KILL as the bottom of the diversion stack.
+m4_wrap([m4_popdef([_m4_divert_diversion])m4_ifdef(
+  [_m4_divert_diversion], [m4_fatal([$0: unbalanced m4_divert_push:
+]m4_divert_stack)])_m4_popdef([_m4_divert_stack])m4_divert_push([KILL])])
+])
diff --git a/common/bison/skeletons/README-D.txt b/common/bison/skeletons/README-D.txt
new file mode 100644
index 0000000000000000000000000000000000000000..214e309923b632c4d82561231775e1008de7728e
--- /dev/null
+++ b/common/bison/skeletons/README-D.txt
@@ -0,0 +1,60 @@
+Some usage notes for the D Parser:
+
+- it is a port of the Java parser, so interface is very similar.
+
+- the lexer class needs to implement the interface 'Lexer' (similar to
+  java). It typically (depending on options) looks like this:
+
+public interface Lexer
+{
+  /**
+   * Method to retrieve the beginning position of the last scanned token.
+   * @return the position at which the last scanned token starts.  */
+  @property YYPosition startPos ();
+
+  /**
+   * Method to retrieve the ending position of the last scanned token.
+   * @return the first position beyond the last scanned token.  */
+  @property YYPosition endPos ();
+
+  /**
+   * Method to retrieve the semantic value of the last scanned token.
+   * @return the semantic value of the last scanned token.  */
+  @property YYSemanticType semanticVal ();
+
+  /**
+   * Entry point for the scanner.  Returns the token identifier corresponding
+   * to the next token and prepares to return the semantic value
+   * and beginning/ending positions of the token.
+   * @return the token identifier corresponding to the next token. */
+  YYTokenType yylex ();
+
+  /**
+   * Entry point for error reporting.  Emits an error
+   * referring to the given location in a user-defined way.
+   *
+   * @param loc The location of the element to which the
+   *                error message is related
+   * @param s The string for the error message.  */
+   void yyerror (YYLocation loc, string s);
+}
+
+- semantic types are handled by D usions (same as for C/C++ parsers)
+
+- the following (non-standard) %defines are supported:
+
+  %define package "<package_name>"
+  %define api.parser.class "my_class_name>"
+  %define position_type "my_position_type"
+  %define location_type "my_location_type"
+
+- the following declarations basically work like in C/C++:
+
+  %locations
+  %error-verbose
+  %parse-param
+  %initial-action
+  %code
+  %union
+
+- %destructor is not yet supported
diff --git a/common/bison/skeletons/bison.m4 b/common/bison/skeletons/bison.m4
new file mode 100644
index 0000000000000000000000000000000000000000..7ca8497b357b6460a7cf64181603fd953d812860
--- /dev/null
+++ b/common/bison/skeletons/bison.m4
@@ -0,0 +1,1118 @@
+                                                            -*- Autoconf -*-
+
+# Language-independent M4 Macros for Bison.
+
+# Copyright (C) 2002, 2004-2015, 2018-2019 Free Software Foundation,
+# Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+## ---------------- ##
+## Identification.  ##
+## ---------------- ##
+
+# b4_generated_by
+# ---------------
+m4_define([b4_generated_by],
+[b4_comment([A Bison parser, made by GNU Bison b4_version.])
+])
+
+# b4_copyright(TITLE, [YEARS])
+# ----------------------------
+# If YEARS are not defined, use b4_copyright_years.
+m4_define([b4_copyright],
+[b4_generated_by
+b4_comment([$1
+
+]m4_dquote(m4_text_wrap([Copyright (C)
+]m4_ifval([$2], [[$2]], [m4_defn([b4_copyright_years])])[
+Free Software Foundation, Inc.]))[
+
+This program is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.])
+
+b4_comment([As a special exception, you may create a larger work that contains
+part or all of the Bison parser skeleton and distribute that work
+under terms of your choice, so long as that work isn't itself a
+parser generator using the skeleton or a modified version thereof
+as a parser skeleton.  Alternatively, if you modify or redistribute
+the parser skeleton itself, you may (at your option) remove this
+special exception, which will cause the skeleton and the resulting
+Bison output files to be licensed under the GNU General Public
+License without this special exception.
+
+This special exception was added by the Free Software Foundation in
+version 2.2 of Bison.])
+])
+
+
+# b4_disclaimer
+# -------------
+# Issue a warning about private implementation details.
+m4_define([b4_disclaimer],
+[b4_comment([Undocumented macros, especially those whose name start with YY_,
+are private implementation details.  Do not rely on them.])
+])
+
+
+
+# b4_required_version_if(VERSION, IF_NEWER, IF_OLDER)
+# ---------------------------------------------------
+# If the version %require'd by the user is VERSION (or newer) expand
+# IF_NEWER, otherwise IF_OLDER.  VERSION should be an integer, e.g.,
+# 302 for 3.2.
+m4_define([b4_required_version_if],
+[m4_if(m4_eval($1 <= b4_required_version),
+              [1], [$2], [$3])])
+
+
+## -------- ##
+## Output.  ##
+## -------- ##
+
+# b4_output_begin(FILE1, FILE2)
+# -----------------------------
+# Enable output, i.e., send to diversion 0, expand after "#", and
+# generate the tag to output into FILE.  Must be followed by EOL.
+# FILE is FILE1 concatenated to FILE2.  FILE2 can be empty, or be
+# absolute: do the right thing.
+m4_define([b4_output_begin],
+[m4_changecom()
+m4_divert_push(0)dnl
+@output(m4_unquote([$1])@,m4_unquote([$2])@)@dnl
+])
+
+
+# b4_output_end
+# -------------
+# Output nothing, restore # as comment character (no expansions after #).
+m4_define([b4_output_end],
+[m4_divert_pop(0)
+m4_changecom([#])
+])
+
+
+# b4_divert_kill(CODE)
+# --------------------
+# Expand CODE for its side effects, discard its output.
+m4_define([b4_divert_kill],
+[m4_divert_text([KILL], [$1])])
+
+
+# b4_define_silent(MACRO, CODE)
+# -----------------------------
+# Same as m4_define, but throw away the expansion of CODE.
+m4_define([b4_define_silent],
+[m4_define([$1], [b4_divert_kill([$2])])])
+
+
+## ---------------- ##
+## Error handling.  ##
+## ---------------- ##
+
+# The following error handling macros print error directives that should not
+# become arguments of other macro invocations since they would likely then be
+# mangled.  Thus, they print to stdout directly.
+
+# b4_cat(TEXT)
+# ------------
+# Write TEXT to stdout.  Precede the final newline with an @ so that it's
+# escaped.  For example:
+#
+#   b4_cat([[@complain(invalid input@)]])
+m4_define([b4_cat],
+[m4_syscmd([cat <<'_m4eof'
+]m4_bpatsubst(m4_dquote($1), [_m4eof], [_m4@`eof])[@
+_m4eof
+])dnl
+m4_if(m4_sysval, [0], [], [m4_fatal([$0: cannot write to stdout])])])
+
+# b4_error(KIND, START, END, FORMAT, [ARG1], [ARG2], ...)
+# -------------------------------------------------------
+# Write @KIND(START@,END@,FORMAT@,ARG1@,ARG2@,...@) to stdout.
+#
+# For example:
+#
+#   b4_error([[complain]], [[input.y:2.3]], [[input.y:5.4]],
+#            [[invalid %s]], [[foo]])
+m4_define([b4_error],
+[b4_cat([[@complain][(]$1[@,]$2[@,]$3[@,]$4[]]dnl
+[m4_if([$#], [4], [],
+       [m4_foreach([b4_arg],
+                   m4_dquote(m4_shift(m4_shift(m4_shift(m4_shift($@))))),
+                   [[@,]b4_arg])])[@)]])])
+
+# b4_warn(FORMAT, [ARG1], [ARG2], ...)
+# ------------------------------------
+# Write @warn(FORMAT@,ARG1@,ARG2@,...@) to stdout.
+#
+# For example:
+#
+#   b4_warn([[invalid value for '%s': %s]], [[foo]], [[3]])
+#
+# As a simple test suite, this:
+#
+#   m4_divert(-1)
+#   m4_define([asdf], [ASDF])
+#   m4_define([fsa], [FSA])
+#   m4_define([fdsa], [FDSA])
+#   b4_warn_at([[[asdf), asdf]]], [[[fsa), fsa]]], [[[fdsa), fdsa]]])
+#   b4_warn_at([[asdf), asdf]], [[fsa), fsa]], [[fdsa), fdsa]])
+#   b4_warn_at()
+#   b4_warn_at(1)
+#   b4_warn_at(1, 2)
+#
+# Should produce this without newlines:
+#
+#   @warn_at([asdf), asdf]@,@,@,[fsa), fsa]@,[fdsa), fdsa]@)
+#   @warn(asdf), asdf@,@,@,fsa), fsa@,fdsa), fdsa@)
+#   @warn(@)
+#   @warn(1@)
+#   @warn(1@,2@)
+m4_define([b4_warn],
+[b4_warn_at([], [], $@)])
+
+# b4_warn_at(START, END, FORMAT, [ARG1], [ARG2], ...)
+# ---------------------------------------------------
+# Write @warn(START@,END@,FORMAT@,ARG1@,ARG2@,...@) to stdout.
+#
+# For example:
+#
+#   b4_warn_at([[input.y:2.3]], [[input.y:5.4]], [[invalid %s]], [[foo]])
+m4_define([b4_warn_at],
+[b4_error([[warn]], $@)])
+
+# b4_complain(FORMAT, [ARG1], [ARG2], ...)
+# ----------------------------------------
+# Bounce to b4_complain_at.
+#
+# See b4_warn example.
+m4_define([b4_complain],
+[b4_complain_at([], [], $@)])
+
+# b4_complain_at(START, END, FORMAT, [ARG1], [ARG2], ...)
+# -------------------------------------------------------
+# Write @complain(START@,END@,FORMAT@,ARG1@,ARG2@,...@) to stdout.
+#
+# See b4_warn_at example.
+m4_define([b4_complain_at],
+[b4_error([[complain]], $@)])
+
+# b4_fatal(FORMAT, [ARG1], [ARG2], ...)
+# -------------------------------------
+# Bounce to b4_fatal_at.
+#
+# See b4_warn example.
+m4_define([b4_fatal],
+[b4_fatal_at([], [], $@)])
+
+# b4_fatal_at(START, END, FORMAT, [ARG1], [ARG2], ...)
+# ----------------------------------------------------
+# Write @fatal(START@,END@,FORMAT@,ARG1@,ARG2@,...@) to stdout and exit.
+#
+# See b4_warn_at example.
+m4_define([b4_fatal_at],
+[b4_error([[fatal]], $@)dnl
+m4_exit(1)])
+
+
+## ------------ ##
+## Data Types.  ##
+## ------------ ##
+
+# b4_ints_in(INT1, INT2, LOW, HIGH)
+# ---------------------------------
+# Return 1 iff both INT1 and INT2 are in [LOW, HIGH], 0 otherwise.
+m4_define([b4_ints_in],
+[m4_eval([$3 <= $1 && $1 <= $4 && $3 <= $2 && $2 <= $4])])
+
+
+# b4_subtract(LHS, RHS)
+# ---------------------
+# Evaluate LHS - RHS if they are integer literals, otherwise expand
+# to (LHS) - (RHS).
+m4_define([b4_subtract],
+[m4_bmatch([$1$2], [^[0123456789]*$],
+           [m4_eval([$1 - $2])],
+           [($1) - ($2)])])
+
+# b4_join(ARG1, ...)
+# _b4_join(ARG1, ...)
+# -------------------
+# Join with comma, skipping empty arguments.
+# b4_join calls itself recursively until it sees the first non-empty
+# argument, then calls _b4_join (i.e., `_$0`) which prepends each
+# non-empty argument with a comma.
+m4_define([b4_join],
+[m4_if([$#$1],
+       [1], [],
+       [m4_ifval([$1],
+                 [$1[]_$0(m4_shift($@))],
+                 [$0(m4_shift($@))])])])
+
+# _b4_join(ARGS1, ...)
+# --------------------
+m4_define([_b4_join],
+[m4_if([$#$1],
+       [1], [],
+       [m4_ifval([$1], [, $1])[]$0(m4_shift($@))])])
+
+
+
+
+# b4_integral_parser_tables_map(MACRO)
+# -------------------------------------
+# Map MACRO on all the integral tables.  MACRO is expected to have
+# the signature MACRO(TABLE-NAME, CONTENT, COMMENT).
+m4_define([b4_integral_parser_tables_map],
+[$1([pact], [b4_pact],
+    [[YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+STATE-NUM.]])
+
+$1([defact], [b4_defact],
+   [[YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+Performed when YYTABLE does not specify something else to do.  Zero
+means the default is an error.]])
+
+$1([pgoto], [b4_pgoto], [[YYPGOTO[NTERM-NUM].]])
+
+$1([defgoto], [b4_defgoto], [[YYDEFGOTO[NTERM-NUM].]])
+
+$1([table], [b4_table],
+   [[YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+positive, shift that token.  If negative, reduce the rule whose
+number is the opposite.  If YYTABLE_NINF, syntax error.]])
+
+$1([check], [b4_check])
+
+$1([stos], [b4_stos],
+   [[YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+symbol of state STATE-NUM.]])
+
+$1([r1], [b4_r1],
+   [[YYR1[YYN] -- Symbol number of symbol that rule YYN derives.]])
+
+$1([r2], [b4_r2],
+   [[YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.]])
+])
+
+
+# b4_parser_tables_declare
+# b4_parser_tables_define
+# ------------------------
+# Define/declare the (deterministic) parser tables.
+m4_define([b4_parser_tables_declare],
+[b4_integral_parser_tables_map([b4_integral_parser_table_declare])])
+
+m4_define([b4_parser_tables_define],
+[b4_integral_parser_tables_map([b4_integral_parser_table_define])])
+
+
+
+## ------------------ ##
+## Decoding options.  ##
+## ------------------ ##
+
+# b4_flag_if(FLAG, IF-TRUE, IF-FALSE)
+# -----------------------------------
+# Run IF-TRUE if b4_FLAG_flag is 1, IF-FALSE if FLAG is 0, otherwise fail.
+m4_define([b4_flag_if],
+[m4_case(b4_$1_flag,
+         [0], [$3],
+         [1], [$2],
+         [m4_fatal([invalid $1 value: ]b4_$1_flag)])])
+
+
+# b4_define_flag_if(FLAG)
+# -----------------------
+# Define "b4_FLAG_if(IF-TRUE, IF-FALSE)" that depends on the
+# value of the Boolean FLAG.
+m4_define([b4_define_flag_if],
+[_b4_define_flag_if($[1], $[2], [$1])])
+
+# _b4_define_flag_if($1, $2, FLAG)
+# --------------------------------
+# Work around the impossibility to define macros inside macros,
+# because issuing '[$1]' is not possible in M4.  GNU M4 should provide
+# $$1 a la M5/TeX.
+m4_define([_b4_define_flag_if],
+[m4_if([$1$2], $[1]$[2], [],
+       [m4_fatal([$0: Invalid arguments: $@])])dnl
+m4_define([b4_$3_if],
+          [b4_flag_if([$3], [$1], [$2])])])
+
+
+# b4_FLAG_if(IF-TRUE, IF-FALSE)
+# -----------------------------
+# Expand IF-TRUE, if FLAG is true, IF-FALSE otherwise.
+b4_define_flag_if([defines])            # Whether headers are requested.
+b4_define_flag_if([glr])                # Whether a GLR parser is requested.
+b4_define_flag_if([nondeterministic])   # Whether conflicts should be handled.
+b4_define_flag_if([token_table])        # Whether yytoken_table is demanded.
+b4_define_flag_if([yacc])               # Whether POSIX Yacc is emulated.
+
+
+# b4_glr_cc_if([IF-TRUE], [IF-FALSE])
+# -----------------------------------
+m4_define([b4_glr_cc_if],
+          [m4_if(b4_skeleton, ["glr.cc"], $@)])
+
+
+## --------- ##
+## Symbols.  ##
+## --------- ##
+
+# For a description of the Symbol handling, see README.
+#
+# The following macros provide access to symbol related values.
+
+# __b4_symbol(NUM, FIELD)
+# -----------------------
+# Recover a FIELD about symbol #NUM.  Thanks to m4_indir, fails if
+# undefined.
+m4_define([__b4_symbol],
+[m4_indir([b4_symbol($1, $2)])])
+
+
+# _b4_symbol(NUM, FIELD)
+# ----------------------
+# Recover a FIELD about symbol #NUM (or "orig NUM").  Fails if
+# undefined.
+m4_define([_b4_symbol],
+[m4_ifdef([b4_symbol($1, number)],
+          [__b4_symbol(m4_indir([b4_symbol($1, number)]), $2)],
+          [__b4_symbol([$1], [$2])])])
+
+
+
+# b4_symbol(NUM, FIELD)
+# ---------------------
+# Recover a FIELD about symbol #NUM (or "orig NUM").  Fails if
+# undefined.  If FIELD = id, prepend the token prefix.
+m4_define([b4_symbol],
+[m4_case([$2],
+         [id],    [m4_do([b4_percent_define_get([api.token.prefix])],
+                         [_b4_symbol([$1], [id])])],
+         [_b4_symbol($@)])])
+
+
+# b4_symbol_if(NUM, FIELD, IF-TRUE, IF-FALSE)
+# -------------------------------------------
+# If FIELD about symbol #NUM is 1 expand IF-TRUE, if is 0, expand IF-FALSE.
+# Otherwise an error.
+m4_define([b4_symbol_if],
+[m4_case(b4_symbol([$1], [$2]),
+         [1], [$3],
+         [0], [$4],
+         [m4_fatal([$0: field $2 of $1 is not a Boolean:] b4_symbol([$1], [$2]))])])
+
+
+# b4_symbol_tag_comment(SYMBOL-NUM)
+# ---------------------------------
+# Issue a comment giving the tag of symbol NUM.
+m4_define([b4_symbol_tag_comment],
+[b4_comment([b4_symbol([$1], [tag])])
+])
+
+
+# b4_symbol_action(SYMBOL-NUM, KIND)
+# ----------------------------------
+# Run the action KIND (destructor or printer) for SYMBOL-NUM.
+m4_define([b4_symbol_action],
+[b4_symbol_if([$1], [has_$2],
+[b4_dollar_pushdef([(*yyvaluep)],
+                   [$1],
+                   [],
+                   [(*yylocationp)])dnl
+    _b4_symbol_case([$1])[]dnl
+b4_syncline([b4_symbol([$1], [$2_line])], [b4_symbol([$1], [$2_file])])dnl
+b4_symbol([$1], [$2])
+b4_syncline([@oline@], [@ofile@])dnl
+        break;
+
+b4_dollar_popdef[]dnl
+])])
+
+
+# b4_symbol_destructor(SYMBOL-NUM)
+# b4_symbol_printer(SYMBOL-NUM)
+# --------------------------------
+m4_define([b4_symbol_destructor], [b4_symbol_action([$1], [destructor])])
+m4_define([b4_symbol_printer],    [b4_symbol_action([$1], [printer])])
+
+
+# b4_symbol_actions(KIND, [TYPE = yytype])
+# ----------------------------------------
+# Emit the symbol actions for KIND ("printer" or "destructor").
+# Dispatch on TYPE.
+m4_define([b4_symbol_actions],
+[m4_pushdef([b4_actions_], m4_expand([b4_symbol_foreach([b4_symbol_$1])]))dnl
+m4_ifval(m4_defn([b4_actions_]),
+[switch (m4_default([$2], [yytype]))
+    {
+m4_defn([b4_actions_])[]dnl
+      default:
+        break;
+    }dnl
+],
+[YYUSE (m4_default([$2], [yytype]));])dnl
+m4_popdef([b4_actions_])dnl
+])
+
+# _b4_symbol_case(SYMBOL-NUM)
+# ---------------------------
+# Issue a "case NUM" for SYMBOL-NUM.  Ends with its EOL to make it
+# easier to use with m4_map, but then, use []dnl to suppress the last
+# one.
+m4_define([_b4_symbol_case],
+[case b4_symbol([$1], [number]): b4_symbol_tag_comment([$1])])
+])
+
+
+# b4_symbol_foreach(MACRO)
+# ------------------------
+# Invoke MACRO(SYMBOL-NUM) for each SYMBOL-NUM.
+m4_define([b4_symbol_foreach],
+          [m4_map([$1], m4_defn([b4_symbol_numbers]))])
+
+# b4_symbol_map(MACRO)
+# --------------------
+# Return a list (possibly empty elements) of MACRO invoked for each
+# SYMBOL-NUM.
+m4_define([b4_symbol_map],
+[m4_map_args_sep([$1(], [)], [,], b4_symbol_numbers)])
+
+
+# b4_token_visible_if(NUM, IF-TRUE, IF-FALSE)
+# -------------------------------------------
+# Whether NUM denotes a token that has an exported definition (i.e.,
+# shows in enum yytokentype).
+m4_define([b4_token_visible_if],
+[b4_symbol_if([$1], [is_token],
+              [b4_symbol_if([$1], [has_id], [$2], [$3])],
+              [$3])])
+
+# b4_token_has_definition(NUM)
+# ----------------------------
+# 1 if NUM is visible, nothing otherwise.
+m4_define([b4_token_has_definition],
+[b4_token_visible_if([$1], [1])])
+
+# b4_any_token_visible_if([IF-TRUE], [IF-FALSE])
+# ----------------------------------------------
+# Whether there is a token that needs to be defined.
+m4_define([b4_any_token_visible_if],
+[m4_ifval(b4_symbol_foreach([b4_token_has_definition]),
+          [$1], [$2])])
+
+
+# b4_token_format(FORMAT, NUM)
+# ----------------------------
+m4_define([b4_token_format],
+[b4_token_visible_if([$2],
+[m4_quote(m4_format([$1],
+                     [b4_symbol([$2], [id])],
+                     [b4_symbol([$2], b4_api_token_raw_if([[number]], [[user_number]]))]))])])
+
+
+## ------- ##
+## Types.  ##
+## ------- ##
+
+# _b4_type_action(NUMS)
+# ---------------------
+# Run actions for the symbol NUMS that all have the same type-name.
+# Skip NUMS that have no type-name.
+#
+# To specify the action to run, define b4_dollar_dollar(SYMBOL-NUM,
+# TAG, TYPE).
+m4_define([_b4_type_action],
+[b4_symbol_if([$1], [has_type],
+[m4_map([      _b4_symbol_case], [$@])[]dnl
+        b4_dollar_dollar([b4_symbol([$1], [number])],
+                         [b4_symbol([$1], [tag])],
+                         [b4_symbol([$1], [type])]);
+        break;
+
+])])
+
+# b4_type_foreach(MACRO)
+# ----------------------
+# Invoke MACRO(SYMBOL-NUMS) for each set of SYMBOL-NUMS for each type set.
+m4_define([b4_type_foreach],
+          [m4_map([$1], m4_defn([b4_type_names]))])
+
+
+
+## ----------- ##
+## Synclines.  ##
+## ----------- ##
+
+# b4_basename(NAME)
+# -----------------
+# Similar to POSIX basename; the differences don't matter here.
+# Beware that NAME is not evaluated.
+m4_define([b4_basename],
+[m4_bpatsubst([$1], [^.*/\([^/]+\)/*$], [\1])])
+
+
+# b4_syncline(LINE, FILE)dnl
+# --------------------------
+# Should always be following by a dnl.
+#
+# Emit "#line LINE FILE /* __LINE__ __FILE__ */".
+m4_define([b4_syncline],
+[b4_flag_if([synclines],
+[b4_sync_start([$1], [$2])[]dnl
+b4_sync_end([__line__], [b4_basename(m4_quote(__file__))])
+])])
+
+# b4_sync_start(LINE, FILE)
+# -----------------------
+# Syncline for the new place.  Typically a directive for the compiler.
+m4_define([b4_sync_start], [b4_comment([$2:$1])])
+
+# b4_sync_end(LINE, FILE)
+# -----------------------
+# Syncline for the current place, which ends.  Typically a comment
+# left for the reader.
+m4_define([b4_sync_end],   [ b4_comment([$2:$1])]
+)
+# This generates dependencies on the Bison skeletons hence lots of
+# useless 'git diff'.  This location is useless for the regular
+# user (who does not care about the skeletons) and is actually not
+# useful for Bison developpers too (I, Akim, never used this to locate
+# the code in skeletons that generated output).  So disable it
+# completely.  If someone thinks this was actually useful, a %define
+# variable should be provided to control the level of verbosity of
+# '#line', in replacement of --no-lines.
+m4_define([b4_sync_end])
+
+
+# b4_user_code(USER-CODE)
+# -----------------------
+# Emit code from the user, ending it with synclines.
+m4_define([b4_user_code],
+[$1
+b4_syncline([@oline@], [@ofile@])])
+
+
+# b4_define_user_code(MACRO, COMMENT)
+# -----------------------------------
+# From b4_MACRO, if defined, build b4_user_MACRO that includes the synclines.
+m4_define([b4_define_user_code],
+[m4_define([b4_user_$1],
+           [m4_ifdef([b4_$1],
+                     [m4_ifval([$2],
+                               [b4_comment([$2])
+])b4_user_code([b4_$1])])])])
+
+# b4_user_actions
+# b4_user_initial_action
+# b4_user_post_prologue
+# b4_user_pre_prologue
+# b4_user_union_members
+# ----------------------
+# Macros that issue user code, ending with synclines.
+b4_define_user_code([actions])
+b4_define_user_code([initial_action], [User initialization code.])
+b4_define_user_code([post_prologue], [Second part of user prologue.])
+b4_define_user_code([pre_prologue], [First part of user prologue.])
+b4_define_user_code([union_members])
+
+
+# b4_check_user_names(WHAT, USER-LIST, BISON-NAMESPACE)
+# -----------------------------------------------------
+# Complain if any name of type WHAT is used by the user (as recorded in
+# USER-LIST) but is not used by Bison (as recorded by macros in the
+# namespace BISON-NAMESPACE).
+#
+# USER-LIST must expand to a list specifying all user occurrences of all names
+# of type WHAT.   Each item in the list must be a triplet specifying one
+# occurrence: name, start boundary, and end boundary.  Empty string names are
+# fine.  An empty list is fine.
+#
+# For example, to define b4_foo_user_names to be used for USER-LIST with three
+# name occurrences and with correct quoting:
+#
+#   m4_define([b4_foo_user_names],
+#             [[[[[[bar]], [[parser.y:1.7]], [[parser.y:1.16]]]],
+#               [[[[bar]], [[parser.y:5.7]], [[parser.y:5.16]]]],
+#               [[[[baz]], [[parser.y:8.7]], [[parser.y:8.16]]]]]])
+#
+# The macro BISON-NAMESPACE(bar) must be defined iff the name bar of type WHAT
+# is used by Bison (in the front-end or in the skeleton).  Empty string names
+# are fine, but it would be ugly for Bison to actually use one.
+#
+# For example, to use b4_foo_bison_names for BISON-NAMESPACE and define that
+# the names bar and baz are used by Bison:
+#
+#   m4_define([b4_foo_bison_names(bar)])
+#   m4_define([b4_foo_bison_names(baz)])
+#
+# To invoke b4_check_user_names with TYPE foo, with USER-LIST
+# b4_foo_user_names, with BISON-NAMESPACE b4_foo_bison_names, and with correct
+# quoting:
+#
+#   b4_check_user_names([[foo]], [b4_foo_user_names],
+#                       [[b4_foo_bison_names]])
+m4_define([b4_check_user_names],
+[m4_foreach([b4_occurrence], $2,
+[m4_pushdef([b4_occurrence], b4_occurrence)dnl
+m4_pushdef([b4_user_name], m4_car(b4_occurrence))dnl
+m4_pushdef([b4_start], m4_car(m4_shift(b4_occurrence)))dnl
+m4_pushdef([b4_end], m4_shift(m4_shift(b4_occurrence)))dnl
+m4_ifndef($3[(]m4_quote(b4_user_name)[)],
+          [b4_complain_at([b4_start], [b4_end],
+                          [[%s '%s' is not used]],
+                          [$1], [b4_user_name])])[]dnl
+m4_popdef([b4_occurrence])dnl
+m4_popdef([b4_user_name])dnl
+m4_popdef([b4_start])dnl
+m4_popdef([b4_end])dnl
+])])
+
+
+
+## --------------------- ##
+## b4_percent_define_*.  ##
+## --------------------- ##
+
+
+# b4_percent_define_use(VARIABLE)
+# -------------------------------
+# Declare that VARIABLE was used.
+m4_define([b4_percent_define_use],
+[m4_define([b4_percent_define_bison_variables(]$1[)])dnl
+])
+
+# b4_percent_define_get(VARIABLE, [DEFAULT])
+# ------------------------------------------
+# Mimic muscle_percent_define_get in ../src/muscle-tab.h.  That is, if
+# the %define variable VARIABLE is defined, emit its value.  Contrary
+# to its C counterpart, return DEFAULT otherwise.  Also, record
+# Bison's usage of VARIABLE by defining
+# b4_percent_define_bison_variables(VARIABLE).
+#
+# For example:
+#
+#   b4_percent_define_get([[foo]])
+m4_define([b4_percent_define_get],
+[b4_percent_define_use([$1])dnl
+_b4_percent_define_ifdef([$1],
+                         [m4_indir([b4_percent_define(]$1[)])],
+                         [$2])])
+
+# b4_percent_define_get_loc(VARIABLE)
+# -----------------------------------
+# Mimic muscle_percent_define_get_loc in ../src/muscle-tab.h exactly.  That is,
+# if the %define variable VARIABLE is undefined, complain fatally since that's
+# a Bison or skeleton error.  Otherwise, return its definition location in a
+# form appropriate for the first two arguments of b4_warn_at, b4_complain_at, or
+# b4_fatal_at.  Don't record this as a Bison usage of VARIABLE as there's no
+# reason to suspect that the user-supplied value has yet influenced the output.
+#
+# For example:
+#
+#   b4_complain_at(b4_percent_define_get_loc([[foo]]), [[invalid foo]])
+m4_define([b4_percent_define_get_loc],
+[m4_ifdef([b4_percent_define_loc(]$1[)],
+          [m4_pushdef([b4_loc], m4_indir([b4_percent_define_loc(]$1[)]))dnl
+b4_loc[]dnl
+m4_popdef([b4_loc])],
+          [b4_fatal([[$0: undefined %%define variable '%s']], [$1])])])
+
+# b4_percent_define_get_kind(VARIABLE)
+# ------------------------------------
+# Get the kind (code, keyword, string) of VARIABLE, i.e., how its
+# value was defined (braces, not delimiters, quotes).
+#
+# If the %define variable VARIABLE is undefined, complain fatally
+# since that's a Bison or skeleton error.  Don't record this as a
+# Bison usage of VARIABLE as there's no reason to suspect that the
+# user-supplied value has yet influenced the output.
+m4_define([b4_percent_define_get_kind],
+[m4_ifdef([b4_percent_define_kind(]$1[)],
+          [m4_indir([b4_percent_define_kind(]$1[)])],
+          [b4_fatal([[$0: undefined %%define variable '%s']], [$1])])])
+
+# b4_percent_define_get_syncline(VARIABLE)dnl
+# -------------------------------------------
+# Should always be following by a dnl.
+#
+# Mimic muscle_percent_define_get_syncline in ../src/muscle-tab.h exactly.
+# That is, if the %define variable VARIABLE is undefined, complain fatally
+# since that's a Bison or skeleton error.  Otherwise, return its definition
+# location as a b4_syncline invocation.  Don't record this as a Bison usage of
+# VARIABLE as there's no reason to suspect that the user-supplied value has yet
+# influenced the output.
+#
+# For example:
+#
+#   b4_percent_define_get_syncline([[foo]])
+m4_define([b4_percent_define_get_syncline],
+[m4_ifdef([b4_percent_define_syncline(]$1[)],
+          [m4_indir([b4_percent_define_syncline(]$1[)])],
+          [b4_fatal([[$0: undefined %%define variable '%s']], [$1])])])
+
+# _b4_percent_define_ifdef(VARIABLE, IF-TRUE, [IF-FALSE])
+# ------------------------------------------------------
+# If the %define variable VARIABLE is defined, expand IF-TRUE, else expand
+# IF-FALSE.  Don't record usage of VARIABLE.
+#
+# For example:
+#
+#   _b4_percent_define_ifdef([[foo]], [[it's defined]], [[it's undefined]])
+m4_define([_b4_percent_define_ifdef],
+[m4_ifdef([b4_percent_define(]$1[)],
+          [$2],
+          [$3])])
+
+# b4_percent_define_ifdef(VARIABLE, IF-TRUE, [IF-FALSE])
+# ------------------------------------------------------
+# Mimic muscle_percent_define_ifdef in ../src/muscle-tab.h exactly.  That is,
+# if the %define variable VARIABLE is defined, expand IF-TRUE, else expand
+# IF-FALSE.  Also, record Bison's usage of VARIABLE by defining
+# b4_percent_define_bison_variables(VARIABLE).
+#
+# For example:
+#
+#   b4_percent_define_ifdef([[foo]], [[it's defined]], [[it's undefined]])
+m4_define([b4_percent_define_ifdef],
+[_b4_percent_define_ifdef([$1],
+                         [b4_percent_define_use([$1])$2],
+                         [$3])])
+
+
+# b4_percent_define_check_file_complain(VARIABLE)
+# -----------------------------------------------
+# Warn about %define variable VARIABLE having an incorrect
+# value.
+m4_define([b4_percent_define_check_file_complain],
+[b4_complain_at(b4_percent_define_get_loc([$1]),
+                [[%%define variable '%s' requires 'none' or '"..."' values]],
+                [$1])])
+
+
+# b4_percent_define_check_file(MACRO, VARIABLE, DEFAULT)
+# ------------------------------------------------------
+# If the %define variable VARIABLE:
+# - is undefined, then if DEFAULT is non-empty, define MACRO to DEFAULT
+# - is a string, define MACRO to its value
+# - is the keyword 'none', do nothing
+# - otherwise, warn about the incorrect value.
+m4_define([b4_percent_define_check_file],
+[b4_percent_define_ifdef([$2],
+  [m4_case(b4_percent_define_get_kind([$2]),
+    [string],
+         [m4_define([$1], b4_percent_define_get([$2]))],
+    [keyword],
+         [m4_if(b4_percent_define_get([$2]), [none], [],
+                [b4_percent_define_check_file_complain([$2])])],
+    [b4_percent_define_check_file_complain([$2])])
+   ],
+   [m4_ifval([$3],
+             [m4_define([$1], [$3])])])
+])
+
+
+
+## --------- ##
+## Options.  ##
+## --------- ##
+
+
+# b4_percent_define_flag_if(VARIABLE, IF-TRUE, [IF-FALSE])
+# --------------------------------------------------------
+# Mimic muscle_percent_define_flag_if in ../src/muscle-tab.h exactly.  That is,
+# if the %define variable VARIABLE is defined to "" or "true", expand IF-TRUE.
+# If it is defined to "false", expand IF-FALSE.  Complain if it is undefined
+# (a Bison or skeleton error since the default value should have been set
+# already) or defined to any other value (possibly a user error).  Also, record
+# Bison's usage of VARIABLE by defining
+# b4_percent_define_bison_variables(VARIABLE).
+#
+# For example:
+#
+#   b4_percent_define_flag_if([[foo]], [[it's true]], [[it's false]])
+m4_define([b4_percent_define_flag_if],
+[b4_percent_define_ifdef([$1],
+  [m4_case(b4_percent_define_get([$1]),
+           [], [$2], [true], [$2], [false], [$3],
+           [m4_expand_once([b4_complain_at(b4_percent_define_get_loc([$1]),
+                                           [[invalid value for %%define Boolean variable '%s']],
+                                           [$1])],
+                           [[b4_percent_define_flag_if($1)]])])],
+  [b4_fatal([[$0: undefined %%define variable '%s']], [$1])])])
+
+
+# b4_percent_define_default(VARIABLE, DEFAULT, [KIND = keyword])
+# --------------------------------------------------------------
+# Mimic muscle_percent_define_default in ../src/muscle-tab.h exactly.  That is,
+# if the %define variable VARIABLE is undefined, set its value to DEFAULT.
+# Don't record this as a Bison usage of VARIABLE as there's no reason to
+# suspect that the value has yet influenced the output.
+#
+# For example:
+#
+#   b4_percent_define_default([[foo]], [[default value]])
+m4_define([b4_percent_define_default],
+[_b4_percent_define_ifdef([$1], [],
+           [m4_define([b4_percent_define(]$1[)], [$2])dnl
+            m4_define([b4_percent_define_kind(]$1[)],
+                      [m4_default([$3], [keyword])])dnl
+            m4_define([b4_percent_define_loc(]$1[)],
+                      [[[[<skeleton default value>:-1.-1]],
+                        [[<skeleton default value>:-1.-1]]]])dnl
+            m4_define([b4_percent_define_syncline(]$1[)], [[]])])])
+
+
+# b4_percent_define_if_define(NAME, [VARIABLE = NAME])
+# ----------------------------------------------------
+# Define b4_NAME_if that executes its $1 or $2 depending whether
+# VARIABLE was %defined.  The characters '.' and `-' in VARIABLE are mapped
+# to '_'.
+m4_define([_b4_percent_define_if_define],
+[m4_define(m4_bpatsubst([b4_$1_if], [[-.]], [_]),
+           [b4_percent_define_flag_if(m4_default([$2], [$1]),
+                                      [$3], [$4])])])
+m4_define([b4_percent_define_if_define],
+[b4_percent_define_default([m4_default([$2], [$1])], [[false]])
+_b4_percent_define_if_define([$1], [$2], $[1], $[2])])
+
+
+# b4_percent_define_check_kind(VARIABLE, KIND, [DIAGNOSTIC = complain])
+# ---------------------------------------------------------------------
+m4_define([b4_percent_define_check_kind],
+[_b4_percent_define_ifdef([$1],
+  [m4_if(b4_percent_define_get_kind([$1]), [$2], [],
+    [b4_error([m4_default([$3], [complain])],
+              b4_percent_define_get_loc([$1]),
+              [m4_case([$2],
+                 [code],    [[%%define variable '%s' requires '{...}' values]],
+                 [keyword], [[%%define variable '%s' requires keyword values]],
+                 [string],  [[%%define variable '%s' requires '"..."' values]])],
+              [$1])])])dnl
+])
+
+
+# b4_percent_define_check_values(VALUES)
+# --------------------------------------
+# Mimic muscle_percent_define_check_values in ../src/muscle-tab.h exactly
+# except that the VALUES structure is more appropriate for M4.  That is, VALUES
+# is a list of sublists of strings.  For each sublist, the first string is the
+# name of a %define variable, and all remaining strings in that sublist are the
+# valid values for that variable.  Complain if such a variable is undefined (a
+# Bison error since the default value should have been set already) or defined
+# to any other value (possibly a user error).  Don't record this as a Bison
+# usage of the variable as there's no reason to suspect that the value has yet
+# influenced the output.
+#
+# For example:
+#
+#   b4_percent_define_check_values([[[[foo]], [[foo-value1]], [[foo-value2]]]],
+#                                  [[[[bar]], [[bar-value1]]]])
+m4_define([b4_percent_define_check_values],
+[m4_foreach([b4_sublist], m4_quote($@),
+            [_b4_percent_define_check_values(b4_sublist)])])
+
+m4_define([_b4_percent_define_check_values],
+[_b4_percent_define_ifdef([$1],
+  [b4_percent_define_check_kind(]$1[, [keyword], [deprecated])dnl
+   m4_pushdef([b4_good_value], [0])dnl
+   m4_if($#, 1, [],
+         [m4_foreach([b4_value], m4_dquote(m4_shift($@)),
+                     [m4_if(m4_indir([b4_percent_define(]$1[)]), b4_value,
+                            [m4_define([b4_good_value], [1])])])])dnl
+   m4_if(b4_good_value, [0],
+         [b4_complain_at(b4_percent_define_get_loc([$1]),
+                         [[invalid value for %%define variable '%s': '%s']],
+                         [$1],
+                         m4_dquote(m4_indir([b4_percent_define(]$1[)])))
+          m4_foreach([b4_value], m4_dquote(m4_shift($@)),
+                     [b4_error([[note]], b4_percent_define_get_loc([$1]), []
+                                     [[accepted value: '%s']],
+                                     m4_dquote(b4_value))])])dnl
+   m4_popdef([b4_good_value])],
+  [b4_fatal([[$0: undefined %%define variable '%s']], [$1])])])
+
+# b4_percent_code_get([QUALIFIER])
+# --------------------------------
+# If any %code blocks for QUALIFIER are defined, emit them beginning with a
+# comment and ending with synclines and a newline.  If QUALIFIER is not
+# specified or empty, do this for the unqualified %code blocks.  Also, record
+# Bison's usage of QUALIFIER (if specified) by defining
+# b4_percent_code_bison_qualifiers(QUALIFIER).
+#
+# For example, to emit any unqualified %code blocks followed by any %code
+# blocks for the qualifier foo:
+#
+#   b4_percent_code_get
+#   b4_percent_code_get([[foo]])
+m4_define([b4_percent_code_get],
+[m4_pushdef([b4_macro_name], [[b4_percent_code(]$1[)]])dnl
+m4_ifval([$1], [m4_define([b4_percent_code_bison_qualifiers(]$1[)])])dnl
+m4_ifdef(b4_macro_name,
+[b4_comment(m4_if([$#], [0], [[[Unqualified %code blocks.]]],
+                  [[["%code ]$1[" blocks.]]]))
+b4_user_code([m4_indir(b4_macro_name)])])dnl
+m4_popdef([b4_macro_name])])
+
+# b4_percent_code_ifdef(QUALIFIER, IF-TRUE, [IF-FALSE])
+# -----------------------------------------------------
+# If any %code blocks for QUALIFIER (or unqualified %code blocks if
+# QUALIFIER is empty) are defined, expand IF-TRUE, else expand IF-FALSE.
+# Also, record Bison's usage of QUALIFIER (if specified) by defining
+# b4_percent_code_bison_qualifiers(QUALIFIER).
+m4_define([b4_percent_code_ifdef],
+[m4_ifdef([b4_percent_code(]$1[)],
+          [m4_ifval([$1], [m4_define([b4_percent_code_bison_qualifiers(]$1[)])])$2],
+          [$3])])
+
+
+## ------------------ ##
+## Common variables.  ##
+## ------------------ ##
+
+
+# b4_parse_assert_if([IF-ASSERTIONS-ARE-USED], [IF-NOT])
+# b4_parse_trace_if([IF-DEBUG-TRACES-ARE-ENABLED], [IF-NOT])
+# b4_token_ctor_if([IF-YYLEX-RETURNS-A-TOKEN], [IF-NOT])
+# ----------------------------------------------------------
+b4_percent_define_if_define([api.token.raw])
+b4_percent_define_if_define([token_ctor], [api.token.constructor])
+b4_percent_define_if_define([locations])     # Whether locations are tracked.
+b4_percent_define_if_define([parse.assert])
+b4_percent_define_if_define([parse.trace])
+
+
+# b4_bison_locations_if([IF-TRUE])
+# --------------------------------
+# Expand IF-TRUE if using locations, and using the default location
+# type.
+m4_define([b4_bison_locations_if],
+[b4_locations_if([b4_percent_define_ifdef([[api.location.type]], [], [$1])])])
+
+
+# b4_error_verbose_if([IF-ERRORS-ARE-VERBOSE], [IF-NOT])
+# ------------------------------------------------------
+# Map %define parse.error "(simple|verbose)" to b4_error_verbose_if and
+# b4_error_verbose_flag.
+b4_percent_define_default([[parse.error]], [[simple]])
+b4_percent_define_check_values([[[[parse.error]],
+                                 [[simple]], [[verbose]]]])
+m4_define([b4_error_verbose_flag],
+          [m4_case(b4_percent_define_get([[parse.error]]),
+                   [simple],  [[0]],
+                   [verbose], [[1]])])
+b4_define_flag_if([error_verbose])
+
+# yytoken_table is needed to support verbose errors.
+b4_error_verbose_if([m4_define([b4_token_table_flag], [1])])
+
+
+# b4_variant_if([IF-VARIANT-ARE-USED], [IF-NOT])
+# ----------------------------------------------
+b4_percent_define_if_define([variant])
+m4_define([b4_variant_flag], [[0]])
+b4_percent_define_ifdef([[api.value.type]],
+   [m4_case(b4_percent_define_get_kind([[api.value.type]]), [keyword],
+            [m4_case(b4_percent_define_get([[api.value.type]]), [variant],
+                    [m4_define([b4_variant_flag], [[1]])])])])
+b4_define_flag_if([variant])
+
+
+## ----------------------------------------------------------- ##
+## After processing the skeletons, check that all the user's   ##
+## %define variables and %code qualifiers were used by Bison.  ##
+## ----------------------------------------------------------- ##
+
+m4_define([b4_check_user_names_wrap],
+[m4_ifdef([b4_percent_]$1[_user_]$2[s],
+          [b4_check_user_names([[%]$1 $2],
+                               [b4_percent_]$1[_user_]$2[s],
+                               [[b4_percent_]$1[_bison_]$2[s]])])])
+
+m4_wrap_lifo([
+b4_check_user_names_wrap([[define]], [[variable]])
+b4_check_user_names_wrap([[code]], [[qualifier]])
+])
+
+
+## ---------------- ##
+## Default values.  ##
+## ---------------- ##
+
+# m4_define_default([b4_lex_param], [])   dnl breaks other skeletons
+m4_define_default([b4_epilogue], [])
+m4_define_default([b4_parse_param], [])
+
+# The initial column and line.
+m4_define_default([b4_location_initial_column], [1])
+m4_define_default([b4_location_initial_line],   [1])
+
+
+## --------------- ##
+## Sanity checks.  ##
+## --------------- ##
+
+# api.location.type={...} (C, C++ and Java).
+b4_percent_define_check_kind([api.location.type], [code], [deprecated])
+
+# api.position.type={...} (Java).
+b4_percent_define_check_kind([api.position.type], [code], [deprecated])
+
+# api.prefix >< %name-prefix.
+b4_percent_define_check_kind([api.prefix], [code], [deprecated])
+b4_percent_define_ifdef([api.prefix],
+[m4_ifdef([b4_prefix],
+[b4_complain_at(b4_percent_define_get_loc([api.prefix]),
+                [['%s' and '%s' cannot be used together]],
+                [%name-prefix],
+                [%define api.prefix])])])
+
+# api.token.prefix={...}
+# Make it a warning for those who used betas of Bison 3.0.
+b4_percent_define_check_kind([api.token.prefix], [code], [deprecated])
+
+# api.value.type >< %union.
+b4_percent_define_ifdef([api.value.type],
+[m4_ifdef([b4_union_members],
+[b4_complain_at(b4_percent_define_get_loc([api.value.type]),
+                [['%s' and '%s' cannot be used together]],
+                [%union],
+                [%define api.value.type])])])
+
+# api.value.type=union >< %yacc.
+b4_percent_define_ifdef([api.value.type],
+[m4_if(b4_percent_define_get([api.value.type]), [union],
+[b4_yacc_if(dnl
+[b4_complain_at(b4_percent_define_get_loc([api.value.type]),
+                [['%s' and '%s' cannot be used together]],
+                [%yacc],
+                [%define api.value.type "union"])])])])
+
+# api.value.union.name.
+b4_percent_define_check_kind([api.value.union.name], [keyword])
diff --git a/common/bison/skeletons/c++-skel.m4 b/common/bison/skeletons/c++-skel.m4
new file mode 100644
index 0000000000000000000000000000000000000000..1c3721cdbbb9cf8fe6ff9764d6f816b7a7f31d34
--- /dev/null
+++ b/common/bison/skeletons/c++-skel.m4
@@ -0,0 +1,27 @@
+                                                            -*- Autoconf -*-
+
+# C++ skeleton dispatching for Bison.
+
+# Copyright (C) 2006-2007, 2009-2015, 2018-2019 Free Software
+# Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+b4_glr_if(             [m4_define([b4_used_skeleton], [b4_skeletonsdir/[glr.cc]])])
+b4_nondeterministic_if([m4_define([b4_used_skeleton], [b4_skeletonsdir/[glr.cc]])])
+
+m4_define_default([b4_used_skeleton], [b4_skeletonsdir/[lalr1.cc]])
+m4_define_default([b4_skeleton], ["b4_basename(b4_used_skeleton)"])
+
+m4_include(b4_used_skeleton)
diff --git a/common/bison/skeletons/c++.m4 b/common/bison/skeletons/c++.m4
new file mode 100644
index 0000000000000000000000000000000000000000..3e2e4df425c7eaeda186e472dff78621f82b92ba
--- /dev/null
+++ b/common/bison/skeletons/c++.m4
@@ -0,0 +1,645 @@
+                                                            -*- Autoconf -*-
+
+# C++ skeleton for Bison
+
+# Copyright (C) 2002-2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# Sanity checks, before defaults installed by c.m4.
+b4_percent_define_ifdef([[api.value.union.name]],
+  [b4_complain_at(b4_percent_define_get_loc([[api.value.union.name]]),
+                  [named %union is invalid in C++])])
+
+m4_include(b4_skeletonsdir/[c.m4])
+
+b4_percent_define_check_kind([api.namespace], [code], [deprecated])
+b4_percent_define_check_kind([api.parser.class], [code], [deprecated])
+
+
+## ----- ##
+## C++.  ##
+## ----- ##
+
+# b4_comment(TEXT, [PREFIX])
+# --------------------------
+# Put TEXT in comment. Prefix all the output lines with PREFIX.
+m4_define([b4_comment],
+[_b4_comment([$1], [$2// ], [$2// ])])
+
+
+# b4_inline(hh|cc)
+# ----------------
+# Expand to `inline\n  ` if $1 is hh.
+m4_define([b4_inline],
+[m4_case([$1],
+  [cc], [],
+  [hh], [[inline
+  ]],
+  [m4_fatal([$0: invalid argument: $1])])])
+
+
+# b4_cxx_portability
+# ------------------
+m4_define([b4_cxx_portability],
+[#if defined __cplusplus
+# define YY_CPLUSPLUS __cplusplus
+#else
+# define YY_CPLUSPLUS 199711L
+#endif
+
+// Support move semantics when possible.
+#if 201103L <= YY_CPLUSPLUS
+# define YY_MOVE           std::move
+# define YY_MOVE_OR_COPY   move
+# define YY_MOVE_REF(Type) Type&&
+# define YY_RVREF(Type)    Type&&
+# define YY_COPY(Type)     Type
+#else
+# define YY_MOVE
+# define YY_MOVE_OR_COPY   copy
+# define YY_MOVE_REF(Type) Type&
+# define YY_RVREF(Type)    const Type&
+# define YY_COPY(Type)     const Type&
+#endif
+
+// Support noexcept when possible.
+#if 201103L <= YY_CPLUSPLUS
+# define YY_NOEXCEPT noexcept
+# define YY_NOTHROW
+#else
+# define YY_NOEXCEPT
+# define YY_NOTHROW throw ()
+#endif
+
+// Support constexpr when possible.
+#if 201703 <= YY_CPLUSPLUS
+# define YY_CONSTEXPR constexpr
+#else
+# define YY_CONSTEXPR
+#endif[]dnl
+])
+
+
+## ---------------- ##
+## Default values.  ##
+## ---------------- ##
+
+b4_percent_define_default([[api.parser.class]], [[parser]])
+
+# Don't do that so that we remember whether we're using a user
+# request, or the default value.
+#
+# b4_percent_define_default([[api.location.type]], [[location]])
+
+b4_percent_define_default([[filename_type]], [[std::string]])
+# Make it a warning for those who used betas of Bison 3.0.
+b4_percent_define_default([[api.namespace]], m4_defn([b4_prefix]))
+
+b4_percent_define_default([[global_tokens_and_yystype]], [[false]])
+b4_percent_define_default([[define_location_comparison]],
+                          [m4_if(b4_percent_define_get([[filename_type]]),
+                                 [std::string], [[true]], [[false]])])
+
+
+
+## ----------- ##
+## Namespace.  ##
+## ----------- ##
+
+m4_define([b4_namespace_ref], [b4_percent_define_get([[api.namespace]])])
+
+
+# Don't permit an empty b4_namespace_ref.  Any '::parser::foo' appended to it
+# would compile as an absolute reference with 'parser' in the global namespace.
+# b4_namespace_open would open an anonymous namespace and thus establish
+# internal linkage.  This would compile.  However, it's cryptic, and internal
+# linkage for the parser would be specified in all translation units that
+# include the header, which is always generated.  If we ever need to permit
+# internal linkage somehow, surely we can find a cleaner approach.
+m4_if(m4_bregexp(b4_namespace_ref, [^[	 ]*$]), [-1], [],
+[b4_complain_at(b4_percent_define_get_loc([[api.namespace]]),
+                [[namespace reference is empty]])])
+
+# Instead of assuming the C++ compiler will do it, Bison should reject any
+# invalid b4_namespace_ref that would be converted to a valid
+# b4_namespace_open.  The problem is that Bison doesn't always output
+# b4_namespace_ref to uncommented code but should reserve the ability to do so
+# in future releases without risking breaking any existing user grammars.
+# Specifically, don't allow empty names as b4_namespace_open would just convert
+# those into anonymous namespaces, and that might tempt some users.
+m4_if(m4_bregexp(b4_namespace_ref, [::[	 ]*::]), [-1], [],
+[b4_complain_at(b4_percent_define_get_loc([[api.namespace]]),
+                [[namespace reference has consecutive "::"]])])
+m4_if(m4_bregexp(b4_namespace_ref, [::[	 ]*$]), [-1], [],
+[b4_complain_at(b4_percent_define_get_loc([[api.namespace]]),
+                [[namespace reference has a trailing "::"]])])
+
+m4_define([b4_namespace_open],
+[b4_user_code([b4_percent_define_get_syncline([[api.namespace]])dnl
+[namespace ]m4_bpatsubst(m4_dquote(m4_bpatsubst(m4_dquote(b4_namespace_ref),
+                                                [^\(.\)[	 ]*::], [\1])),
+                         [::], [ { namespace ])[ {]])])
+
+m4_define([b4_namespace_close],
+[b4_user_code([b4_percent_define_get_syncline([[api.namespace]])dnl
+m4_bpatsubst(m4_dquote(m4_bpatsubst(m4_dquote(b4_namespace_ref[ ]),
+                                    [^\(.\)[	 ]*\(::\)?\([^][:]\|:[^:]\)*],
+                                    [\1])),
+             [::\([^][:]\|:[^:]\)*], [} ])[} // ]b4_namespace_ref])])
+
+
+# b4_token_enums
+# --------------
+# Output the definition of the tokens as enums.
+m4_define([b4_token_enums],
+[[enum yytokentype
+      {
+        ]m4_join([,
+        ],
+                 b4_symbol_map([b4_token_enum]))[
+      };]dnl
+])
+
+
+
+
+## ----------------- ##
+## Semantic Values.  ##
+## ----------------- ##
+
+
+
+# b4_value_type_declare
+# ---------------------
+# Declare semantic_type.
+m4_define([b4_value_type_declare],
+[b4_value_type_setup[]dnl
+[    /// Symbol semantic values.
+]m4_bmatch(b4_percent_define_get_kind([[api.value.type]]),
+[code],
+[[    typedef ]b4_percent_define_get([[api.value.type]])[ semantic_type;]],
+[m4_bmatch(b4_percent_define_get([[api.value.type]]),
+[union\|union-directive],
+[[    union semantic_type
+    {
+]b4_user_union_members[
+    };]])])dnl
+])
+
+
+# b4_public_types_declare
+# -----------------------
+# Define the public types: token, semantic value, location, and so forth.
+# Depending on %define token_lex, may be output in the header or source file.
+m4_define([b4_public_types_declare],
+[[#ifndef ]b4_api_PREFIX[STYPE
+]b4_value_type_declare[
+#else
+    typedef ]b4_api_PREFIX[STYPE semantic_type;
+#endif]b4_locations_if([
+    /// Symbol locations.
+    typedef b4_percent_define_get([[api.location.type]],
+                                  [[location]]) location_type;])[
+
+    /// Syntax errors thrown from user actions.
+    struct syntax_error : std::runtime_error
+    {
+      syntax_error (]b4_locations_if([const location_type& l, ])[const std::string& m)
+        : std::runtime_error (m)]b4_locations_if([
+        , location (l)])[
+      {}
+
+      syntax_error (const syntax_error& s)
+        : std::runtime_error (s.what ())]b4_locations_if([
+        , location (s.location)])[
+      {}
+
+      ~syntax_error () YY_NOEXCEPT YY_NOTHROW;]b4_locations_if([
+
+      location_type location;])[
+    };
+
+    /// Tokens.
+    struct token
+    {
+      ]b4_token_enums[
+    };
+
+    /// (External) token type, as returned by yylex.
+    typedef token::yytokentype token_type;
+
+    /// Symbol type: an internal symbol number.
+    typedef int symbol_number_type;
+
+    /// The symbol type number to denote an empty symbol.
+    enum { empty_symbol = -2 };
+
+    /// Internal symbol number for tokens (subsumed by symbol_number_type).
+    typedef ]b4_int_type_for([b4_translate])[ token_number_type;
+]])
+
+
+# b4_symbol_type_define
+# ---------------------
+# Define symbol_type, the external type for symbols used for symbol
+# constructors.
+m4_define([b4_symbol_type_define],
+[[    /// A complete symbol.
+    ///
+    /// Expects its Base type to provide access to the symbol type
+    /// via type_get ().
+    ///
+    /// Provide access to semantic value]b4_locations_if([ and location])[.
+    template <typename Base>
+    struct basic_symbol : Base
+    {
+      /// Alias to Base.
+      typedef Base super_type;
+
+      /// Default constructor.
+      basic_symbol ()
+        : value ()]b4_locations_if([
+        , location ()])[
+      {}
+
+#if 201103L <= YY_CPLUSPLUS
+      /// Move constructor.
+      basic_symbol (basic_symbol&& that);
+#endif
+
+      /// Copy constructor.
+      basic_symbol (const basic_symbol& that);]b4_variant_if([[
+
+      /// Constructor for valueless symbols, and symbols from each type.
+]b4_type_foreach([b4_basic_symbol_constructor_define])], [[
+      /// Constructor for valueless symbols.
+      basic_symbol (typename Base::kind_type t]b4_locations_if([,
+                    YY_MOVE_REF (location_type) l])[);
+
+      /// Constructor for symbols with semantic value.
+      basic_symbol (typename Base::kind_type t,
+                    YY_RVREF (semantic_type) v]b4_locations_if([,
+                    YY_RVREF (location_type) l])[);
+]])[
+      /// Destroy the symbol.
+      ~basic_symbol ()
+      {
+        clear ();
+      }
+
+      /// Destroy contents, and record that is empty.
+      void clear ()
+      {]b4_variant_if([[
+        // User destructor.
+        symbol_number_type yytype = this->type_get ();
+        basic_symbol<Base>& yysym = *this;
+        (void) yysym;
+        switch (yytype)
+        {
+]b4_symbol_foreach([b4_symbol_destructor])dnl
+[       default:
+          break;
+        }
+
+        // Type destructor.
+]b4_symbol_variant([[yytype]], [[value]], [[template destroy]])])[
+        Base::clear ();
+      }
+
+      /// Whether empty.
+      bool empty () const YY_NOEXCEPT;
+
+      /// Destructive move, \a s is emptied into this.
+      void move (basic_symbol& s);
+
+      /// The semantic value.
+      semantic_type value;]b4_locations_if([
+
+      /// The location.
+      location_type location;])[
+
+    private:
+#if YY_CPLUSPLUS < 201103L
+      /// Assignment operator.
+      basic_symbol& operator= (const basic_symbol& that);
+#endif
+    };
+
+    /// Type access provider for token (enum) based symbols.
+    struct by_type
+    {
+      /// Default constructor.
+      by_type ();
+
+#if 201103L <= YY_CPLUSPLUS
+      /// Move constructor.
+      by_type (by_type&& that);
+#endif
+
+      /// Copy constructor.
+      by_type (const by_type& that);
+
+      /// The symbol type as needed by the constructor.
+      typedef token_type kind_type;
+
+      /// Constructor from (external) token numbers.
+      by_type (kind_type t);
+
+      /// Record that this symbol is empty.
+      void clear ();
+
+      /// Steal the symbol type from \a that.
+      void move (by_type& that);
+
+      /// The (internal) type number (corresponding to \a type).
+      /// \a empty when empty.
+      symbol_number_type type_get () const YY_NOEXCEPT;
+
+      /// The symbol type.
+      /// \a empty_symbol when empty.
+      /// An int, not token_number_type, to be able to store empty_symbol.
+      int type;
+    };
+
+    /// "External" symbols: returned by the scanner.
+    struct symbol_type : basic_symbol<by_type>
+    {]b4_variant_if([[
+      /// Superclass.
+      typedef basic_symbol<by_type> super_type;
+
+      /// Empty symbol.
+      symbol_type () {}
+
+      /// Constructor for valueless symbols, and symbols from each type.
+]b4_type_foreach([_b4_token_constructor_define])dnl
+    ])[};
+]])
+
+
+# b4_public_types_define(hh|cc)
+# -----------------------------
+# Provide the implementation needed by the public types.
+m4_define([b4_public_types_define],
+[[  // basic_symbol.
+#if 201103L <= YY_CPLUSPLUS
+  template <typename Base>
+  ]b4_parser_class[::basic_symbol<Base>::basic_symbol (basic_symbol&& that)
+    : Base (std::move (that))
+    , value (]b4_variant_if([], [std::move (that.value)]))b4_locations_if([
+    , location (std::move (that.location))])[
+  {]b4_variant_if([
+    b4_symbol_variant([this->type_get ()], [value], [move],
+                      [std::move (that.value)])
+  ])[}
+#endif
+
+  template <typename Base>
+  ]b4_parser_class[::basic_symbol<Base>::basic_symbol (const basic_symbol& that)
+    : Base (that)
+    , value (]b4_variant_if([], [that.value]))b4_locations_if([
+    , location (that.location)])[
+  {]b4_variant_if([
+    b4_symbol_variant([this->type_get ()], [value], [copy],
+                      [YY_MOVE (that.value)])
+  ])[}
+
+]b4_variant_if([], [[
+  /// Constructor for valueless symbols.
+  template <typename Base>
+  ]b4_parser_class[::basic_symbol<Base>::basic_symbol (]b4_join(
+          [typename Base::kind_type t],
+          b4_locations_if([YY_MOVE_REF (location_type) l]))[)
+    : Base (t)
+    , value ()]b4_locations_if([
+    , location (l)])[
+  {}
+
+  template <typename Base>
+  ]b4_parser_class[::basic_symbol<Base>::basic_symbol (]b4_join(
+          [typename Base::kind_type t],
+          [YY_RVREF (semantic_type) v],
+          b4_locations_if([YY_RVREF (location_type) l]))[)
+    : Base (t)
+    , value (]b4_variant_if([], [YY_MOVE (v)])[)]b4_locations_if([
+    , location (YY_MOVE (l))])[
+  {]b4_variant_if([[
+    (void) v;
+    ]b4_symbol_variant([this->type_get ()], [value], [YY_MOVE_OR_COPY], [YY_MOVE (v)])])[}]])[
+
+  template <typename Base>
+  bool
+  ]b4_parser_class[::basic_symbol<Base>::empty () const YY_NOEXCEPT
+  {
+    return Base::type_get () == empty_symbol;
+  }
+
+  template <typename Base>
+  void
+  ]b4_parser_class[::basic_symbol<Base>::move (basic_symbol& s)
+  {
+    super_type::move (s);
+    ]b4_variant_if([b4_symbol_variant([this->type_get ()], [value], [move],
+                                      [YY_MOVE (s.value)])],
+                   [value = YY_MOVE (s.value);])[]b4_locations_if([
+    location = YY_MOVE (s.location);])[
+  }
+
+  // by_type.
+  ]b4_inline([$1])b4_parser_class[::by_type::by_type ()
+    : type (empty_symbol)
+  {}
+
+#if 201103L <= YY_CPLUSPLUS
+  ]b4_inline([$1])b4_parser_class[::by_type::by_type (by_type&& that)
+    : type (that.type)
+  {
+    that.clear ();
+  }
+#endif
+
+  ]b4_inline([$1])b4_parser_class[::by_type::by_type (const by_type& that)
+    : type (that.type)
+  {}
+
+  ]b4_inline([$1])b4_parser_class[::by_type::by_type (token_type t)
+    : type (yytranslate_ (t))
+  {}
+
+  ]b4_inline([$1])[void
+  ]b4_parser_class[::by_type::clear ()
+  {
+    type = empty_symbol;
+  }
+
+  ]b4_inline([$1])[void
+  ]b4_parser_class[::by_type::move (by_type& that)
+  {
+    type = that.type;
+    that.clear ();
+  }
+
+  ]b4_inline([$1])[int
+  ]b4_parser_class[::by_type::type_get () const YY_NOEXCEPT
+  {
+    return type;
+  }
+]])
+
+
+# b4_token_constructor_define
+# ----------------------------
+# Define symbol constructors for all the value types.
+# Use at class-level.  Redefined in variant.hh.
+m4_define([b4_token_constructor_define], [])
+
+
+# b4_yytranslate_define(cc|hh)
+# ----------------------------
+# Define yytranslate_.  Sometimes used in the header file ($1=hh),
+# sometimes in the cc file.
+m4_define([b4_yytranslate_define],
+[  b4_inline([$1])b4_parser_class[::token_number_type
+  ]b4_parser_class[::yytranslate_ (int t)
+  {
+]b4_api_token_raw_if(
+[[    return static_cast<token_number_type> (t);]],
+[[    // YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to
+    // TOKEN-NUM as returned by yylex.
+    static
+    const token_number_type
+    translate_table[] =
+    {
+  ]b4_translate[
+    };
+    const int user_token_number_max_ = ]b4_user_token_number_max[;
+
+    if (t <= 0)
+      return yyeof_;
+    else if (t <= user_token_number_max_)
+      return translate_table[t];
+    else
+      return yy_undef_token_;]])[
+  }
+]])
+
+
+# b4_lhs_value([TYPE])
+# --------------------
+m4_define([b4_lhs_value],
+[b4_symbol_value([yyval], [$1])])
+
+
+# b4_rhs_value(RULE-LENGTH, POS, [TYPE])
+# --------------------------------------
+# FIXME: Dead code.
+m4_define([b4_rhs_value],
+[b4_symbol_value([yysemantic_stack_@{($1) - ($2)@}], [$3])])
+
+
+# b4_lhs_location()
+# -----------------
+# Expansion of @$.
+m4_define([b4_lhs_location],
+[(yyloc)])
+
+
+# b4_rhs_location(RULE-LENGTH, POS)
+# ---------------------------------
+# Expansion of @POS, where the current rule has RULE-LENGTH symbols
+# on RHS.
+m4_define([b4_rhs_location],
+[(yylocation_stack_@{($1) - ($2)@})])
+
+
+# b4_parse_param_decl
+# -------------------
+# Extra formal arguments of the constructor.
+# Change the parameter names from "foo" into "foo_yyarg", so that
+# there is no collision bw the user chosen attribute name, and the
+# argument name in the constructor.
+m4_define([b4_parse_param_decl],
+[m4_ifset([b4_parse_param],
+          [m4_map_sep([b4_parse_param_decl_1], [, ], [b4_parse_param])])])
+
+m4_define([b4_parse_param_decl_1],
+[$1_yyarg])
+
+
+
+# b4_parse_param_cons
+# -------------------
+# Extra initialisations of the constructor.
+m4_define([b4_parse_param_cons],
+          [m4_ifset([b4_parse_param],
+                    [
+      b4_cc_constructor_calls(b4_parse_param)])])
+m4_define([b4_cc_constructor_calls],
+          [m4_map_sep([b4_cc_constructor_call], [,
+      ], [$@])])
+m4_define([b4_cc_constructor_call],
+          [$2 ($2_yyarg)])
+
+# b4_parse_param_vars
+# -------------------
+# Extra instance variables.
+m4_define([b4_parse_param_vars],
+          [m4_ifset([b4_parse_param],
+                    [
+    // User arguments.
+b4_cc_var_decls(b4_parse_param)])])
+m4_define([b4_cc_var_decls],
+          [m4_map_sep([b4_cc_var_decl], [
+], [$@])])
+m4_define([b4_cc_var_decl],
+          [    $1;])
+
+
+## ---------##
+## Values.  ##
+## ---------##
+
+# b4_yylloc_default_define
+# ------------------------
+# Define YYLLOC_DEFAULT.
+m4_define([b4_yylloc_default_define],
+[[/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+# ifndef YYLLOC_DEFAULT
+#  define YYLLOC_DEFAULT(Current, Rhs, N)                               \
+    do                                                                  \
+      if (N)                                                            \
+        {                                                               \
+          (Current).begin  = YYRHSLOC (Rhs, 1).begin;                   \
+          (Current).end    = YYRHSLOC (Rhs, N).end;                     \
+        }                                                               \
+      else                                                              \
+        {                                                               \
+          (Current).begin = (Current).end = YYRHSLOC (Rhs, 0).end;      \
+        }                                                               \
+    while (false)
+# endif
+]])
+
+## -------- ##
+## Checks.  ##
+## -------- ##
+
+b4_token_ctor_if([b4_variant_if([],
+  [b4_fatal_at(b4_percent_define_get_loc(api.token.constructor),
+               [cannot use '%s' without '%s'],
+               [%define api.token.constructor],
+               [%define api.value.type variant]))])])
diff --git a/common/bison/skeletons/c-like.m4 b/common/bison/skeletons/c-like.m4
new file mode 100644
index 0000000000000000000000000000000000000000..8d891b67ef97b09a121f0487f00c7a25c3578317
--- /dev/null
+++ b/common/bison/skeletons/c-like.m4
@@ -0,0 +1,66 @@
+                                                            -*- Autoconf -*-
+
+# Common code for C-like languages (C, C++, Java, etc.)
+
+# Copyright (C) 2012-2015, 2018-2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# _b4_comment(TEXT, OPEN, CONTINUE, END)
+# --------------------------------------
+# Put TEXT in comment.  Avoid trailing spaces: don't indent empty lines.
+# Avoid adding indentation to the first line, as the indentation comes
+# from OPEN.  That's why we don't patsubst([$1], [^\(.\)], [   \1]).
+#
+# Prefix all the output lines with PREFIX.
+m4_define([_b4_comment],
+[$2[]m4_bpatsubst(m4_expand([[$1]]), [
+\(.\)], [
+$3\1])$4])
+
+
+# b4_comment(TEXT, [PREFIX])
+# --------------------------
+# Put TEXT in comment.  Prefix all the output lines with PREFIX.
+m4_define([b4_comment],
+[_b4_comment([$1], [$2/* ], [$2   ], [  */])])
+
+
+
+
+# _b4_dollar_dollar(VALUE, SYMBOL-NUM, FIELD, DEFAULT-FIELD)
+# ----------------------------------------------------------
+# If FIELD (or DEFAULT-FIELD) is non-null, return "VALUE.FIELD",
+# otherwise just VALUE.  Be sure to pass "(VALUE)" if VALUE is a
+# pointer.
+m4_define([_b4_dollar_dollar],
+[b4_symbol_value([$1],
+                 [$2],
+                 m4_if([$3], [[]],
+                       [[$4]], [[$3]]))])
+
+# b4_dollar_pushdef(VALUE-POINTER, SYMBOL-NUM, [TYPE_TAG], LOCATION)
+# b4_dollar_popdef
+# ------------------------------------------------------------------
+# Define b4_dollar_dollar for VALUE-POINTER and DEFAULT-FIELD,
+# and b4_at_dollar for LOCATION.
+m4_define([b4_dollar_pushdef],
+[m4_pushdef([b4_dollar_dollar],
+            [_b4_dollar_dollar([$1], [$2], m4_dquote($][1), [$3])])dnl
+m4_pushdef([b4_at_dollar], [$4])dnl
+])
+m4_define([b4_dollar_popdef],
+[m4_popdef([b4_at_dollar])dnl
+m4_popdef([b4_dollar_dollar])dnl
+])
diff --git a/common/bison/skeletons/c-skel.m4 b/common/bison/skeletons/c-skel.m4
new file mode 100644
index 0000000000000000000000000000000000000000..2a21cfc7d0d596387c5821c450dd6abdf661ae09
--- /dev/null
+++ b/common/bison/skeletons/c-skel.m4
@@ -0,0 +1,27 @@
+                                                            -*- Autoconf -*-
+
+# C skeleton dispatching for Bison.
+
+# Copyright (C) 2006-2007, 2009-2015, 2018-2019 Free Software
+# Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+b4_glr_if(             [m4_define([b4_used_skeleton], [b4_skeletonsdir/[glr.c]])])
+b4_nondeterministic_if([m4_define([b4_used_skeleton], [b4_skeletonsdir/[glr.c]])])
+
+m4_define_default([b4_used_skeleton], [b4_skeletonsdir/[yacc.c]])
+m4_define_default([b4_skeleton], ["b4_basename(b4_used_skeleton)"])
+
+m4_include(b4_used_skeleton)
diff --git a/common/bison/skeletons/c.m4 b/common/bison/skeletons/c.m4
new file mode 100644
index 0000000000000000000000000000000000000000..4b2c094620044964c997b41631a098f5ba8fbe26
--- /dev/null
+++ b/common/bison/skeletons/c.m4
@@ -0,0 +1,991 @@
+                                                            -*- Autoconf -*-
+
+# C M4 Macros for Bison.
+
+# Copyright (C) 2002, 2004-2015, 2018-2019 Free Software Foundation,
+# Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+m4_include(b4_skeletonsdir/[c-like.m4])
+
+# b4_tocpp(STRING)
+# ----------------
+# Convert STRING into a valid C macro name.
+m4_define([b4_tocpp],
+[m4_toupper(m4_bpatsubst(m4_quote($1), [[^a-zA-Z0-9]+], [_]))])
+
+
+# b4_cpp_guard(FILE)
+# ------------------
+# A valid C macro name to use as a CPP header guard for FILE.
+m4_define([b4_cpp_guard],
+[[YY_]b4_tocpp(m4_defn([b4_prefix])/[$1])[_INCLUDED]])
+
+
+# b4_cpp_guard_open(FILE)
+# b4_cpp_guard_close(FILE)
+# ------------------------
+# If FILE does not expand to nothing, open/close CPP inclusion guards for FILE.
+m4_define([b4_cpp_guard_open],
+[m4_ifval(m4_quote($1),
+[#ifndef b4_cpp_guard([$1])
+# define b4_cpp_guard([$1])])])
+
+m4_define([b4_cpp_guard_close],
+[m4_ifval(m4_quote($1),
+[#endif b4_comment([!b4_cpp_guard([$1])])])])
+
+
+## ---------------- ##
+## Identification.  ##
+## ---------------- ##
+
+# b4_identification
+# -----------------
+# Depends on individual skeletons to define b4_pure_flag, b4_push_flag, or
+# b4_pull_flag if they use the values of the %define variables api.pure or
+# api.push-pull.
+m4_define([b4_identification],
+[[/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "]b4_version["
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME ]b4_skeleton[]m4_ifdef([b4_pure_flag], [[
+
+/* Pure parsers.  */
+#define YYPURE ]b4_pure_flag])[]m4_ifdef([b4_push_flag], [[
+
+/* Push parsers.  */
+#define YYPUSH ]b4_push_flag])[]m4_ifdef([b4_pull_flag], [[
+
+/* Pull parsers.  */
+#define YYPULL ]b4_pull_flag])[
+]])
+
+
+## ---------------- ##
+## Default values.  ##
+## ---------------- ##
+
+# b4_api_prefix, b4_api_PREFIX
+# ----------------------------
+# Corresponds to %define api.prefix
+b4_percent_define_default([[api.prefix]], [[yy]])
+m4_define([b4_api_prefix],
+[b4_percent_define_get([[api.prefix]])])
+m4_define([b4_api_PREFIX],
+[m4_toupper(b4_api_prefix)])
+
+
+# b4_prefix
+# ---------
+# If the %name-prefix is not given, it is api.prefix.
+m4_define_default([b4_prefix], [b4_api_prefix])
+
+# If the %union is not named, its name is YYSTYPE.
+b4_percent_define_default([[api.value.union.name]],
+                          [b4_api_PREFIX[][STYPE]])
+
+
+## ------------------------ ##
+## Pure/impure interfaces.  ##
+## ------------------------ ##
+
+# b4_lex_formals
+# --------------
+# All the yylex formal arguments.
+# b4_lex_param arrives quoted twice, but we want to keep only one level.
+m4_define([b4_lex_formals],
+[b4_pure_if([[[[YYSTYPE *yylvalp]], [[&yylval]]][]dnl
+b4_locations_if([, [[YYLTYPE *yyllocp], [&yylloc]]])])dnl
+m4_ifdef([b4_lex_param], [, ]b4_lex_param)])
+
+
+# b4_lex
+# ------
+# Call yylex.
+m4_define([b4_lex],
+[b4_function_call([yylex], [int], b4_lex_formals)])
+
+
+# b4_user_args
+# ------------
+m4_define([b4_user_args],
+[m4_ifset([b4_parse_param], [, b4_args(b4_parse_param)])])
+
+
+# b4_parse_param
+# --------------
+# If defined, b4_parse_param arrives double quoted, but below we prefer
+# it to be single quoted.
+m4_define([b4_parse_param],
+b4_parse_param)
+
+
+# b4_parse_param_for(DECL, FORMAL, BODY)
+# ---------------------------------------
+# Iterate over the user parameters, binding the declaration to DECL,
+# the formal name to FORMAL, and evaluating the BODY.
+m4_define([b4_parse_param_for],
+[m4_foreach([$1_$2], m4_defn([b4_parse_param]),
+[m4_pushdef([$1], m4_unquote(m4_car($1_$2)))dnl
+m4_pushdef([$2], m4_shift($1_$2))dnl
+$3[]dnl
+m4_popdef([$2])dnl
+m4_popdef([$1])dnl
+])])
+
+# b4_parse_param_use([VAL], [LOC])
+# --------------------------------
+# 'YYUSE' VAL, LOC if locations are enabled, and all the parse-params.
+m4_define([b4_parse_param_use],
+[m4_ifvaln([$1], [  YYUSE ([$1]);])dnl
+b4_locations_if([m4_ifvaln([$2], [  YYUSE ([$2]);])])dnl
+b4_parse_param_for([Decl], [Formal], [  YYUSE (Formal);
+])dnl
+])
+
+
+## ------------ ##
+## Data Types.  ##
+## ------------ ##
+
+# b4_int_type(MIN, MAX)
+# ---------------------
+# Return a narrow int type able to handle integers ranging from MIN
+# to MAX (included) in portable C code.  Assume MIN and MAX fall in
+# 'int' range.
+m4_define([b4_int_type],
+[m4_if(b4_ints_in($@,   [-127],   [127]), [1], [signed char],
+       b4_ints_in($@,      [0],   [255]), [1], [unsigned char],
+
+       b4_ints_in($@, [-32767], [32767]), [1], [short],
+       b4_ints_in($@,      [0], [65535]), [1], [unsigned short],
+
+                                               [int])])
+
+# b4_c99_int_type(MIN, MAX)
+# -------------------------
+# Like b4_int_type, but for C99.
+# b4_c99_int_type_define replaces b4_int_type with this.
+m4_define([b4_c99_int_type],
+[m4_if(b4_ints_in($@,   [-127],   [127]), [1], [yytype_int8],
+       b4_ints_in($@,      [0],   [255]), [1], [yytype_uint8],
+
+       b4_ints_in($@, [-32767], [32767]), [1], [yytype_int16],
+       b4_ints_in($@,      [0], [65535]), [1], [yytype_uint16],
+
+                                               [int])])
+
+# b4_c99_int_type_define
+# ----------------------
+# Define private types suitable for holding small integers in C99 or later.
+m4_define([b4_c99_int_type_define],
+[m4_copy_force([b4_c99_int_type], [b4_int_type])dnl
+[/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
+   <limits.h> and (if available) <stdint.h> are included
+   so that the code can choose integer types of a good width.  */
+
+#ifndef __PTRDIFF_MAX__
+# include <limits.h> /* INFRINGES ON USER NAME SPACE */
+# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
+#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
+#  define YY_STDINT_H
+# endif
+#endif
+
+/* Narrow types that promote to a signed type and that can represent a
+   signed or unsigned integer of at least N bits.  In tables they can
+   save space and decrease cache pressure.  Promoting to a signed type
+   helps avoid bugs in integer arithmetic.  */
+
+#ifdef __INT_LEAST8_MAX__
+typedef __INT_LEAST8_TYPE__ yytype_int8;
+#elif defined YY_STDINT_H
+typedef int_least8_t yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef __INT_LEAST16_MAX__
+typedef __INT_LEAST16_TYPE__ yytype_int16;
+#elif defined YY_STDINT_H
+typedef int_least16_t yytype_int16;
+#else
+typedef short yytype_int16;
+#endif
+
+#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST8_TYPE__ yytype_uint8;
+#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST8_MAX <= INT_MAX)
+typedef uint_least8_t yytype_uint8;
+#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
+typedef unsigned char yytype_uint8;
+#else
+typedef short yytype_uint8;
+#endif
+
+#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST16_TYPE__ yytype_uint16;
+#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST16_MAX <= INT_MAX)
+typedef uint_least16_t yytype_uint16;
+#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
+typedef unsigned short yytype_uint16;
+#else
+typedef int yytype_uint16;
+#endif]])
+
+
+# b4_int_type_for(NAME)
+# ---------------------
+# Return a narrow int type able to handle numbers ranging from
+# 'NAME_min' to 'NAME_max' (included).
+m4_define([b4_int_type_for],
+[b4_int_type($1_min, $1_max)])
+
+
+# b4_table_value_equals(TABLE, VALUE, LITERAL, SYMBOL)
+# ----------------------------------------------------
+# Without inducing a comparison warning from the compiler, check if the
+# literal value LITERAL equals VALUE from table TABLE, which must have
+# TABLE_min and TABLE_max defined.  SYMBOL denotes
+m4_define([b4_table_value_equals],
+[m4_if(m4_eval($3 < m4_indir([b4_]$1[_min])
+               || m4_indir([b4_]$1[_max]) < $3), [1],
+       [[0]],
+       [(($2) == $4)])])
+
+
+## ----------------- ##
+## Compiler issues.  ##
+## ----------------- ##
+
+# b4_attribute_define([noreturn])
+# -------------------------------
+# Provide portable compiler "attributes".  If "noreturn" is passed, define
+# _Noreturn.
+m4_define([b4_attribute_define],
+[[#ifndef YY_ATTRIBUTE_PURE
+# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
+# else
+#  define YY_ATTRIBUTE_PURE
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+# else
+#  define YY_ATTRIBUTE_UNUSED
+# endif
+#endif
+
+]m4_bmatch([$1], [\bnoreturn\b], [[/* The _Noreturn keyword of C11.  */
+]dnl This is an exact copy of lib/_Noreturn.h.
+[#ifndef _Noreturn
+# if (defined __cplusplus \
+      && ((201103 <= __cplusplus && !(__GNUC__ == 4 && __GNUC_MINOR__ == 7)) \
+          || (defined _MSC_VER && 1900 <= _MSC_VER)))
+#  define _Noreturn [[noreturn]]
+# elif ((!defined __cplusplus || defined __clang__) \
+        && (201112 <= (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0)  \
+            || 4 < __GNUC__ + (7 <= __GNUC_MINOR__)))
+   /* _Noreturn works as-is.  */
+# elif 2 < __GNUC__ + (8 <= __GNUC_MINOR__) || 0x5110 <= __SUNPRO_C
+#  define _Noreturn __attribute__ ((__noreturn__))
+# elif 1200 <= (defined _MSC_VER ? _MSC_VER : 0)
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn
+# endif
+#endif
+
+]])[/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                            \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
+# define YY_IGNORE_USELESS_CAST_BEGIN                          \
+    _Pragma ("GCC diagnostic push")                            \
+    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
+# define YY_IGNORE_USELESS_CAST_END            \
+    _Pragma ("GCC diagnostic pop")
+#endif
+#ifndef YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_END
+#endif
+]])
+
+
+# b4_cast_define
+# --------------
+m4_define([b4_cast_define],
+[# ifndef YY_CAST
+#  ifdef __cplusplus
+#   define YY_CAST(Type, Val) static_cast<Type> (Val)
+#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
+#  else
+#   define YY_CAST(Type, Val) ((Type) (Val))
+#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
+#  endif
+# endif[]dnl
+])
+
+
+# b4_null_define
+# --------------
+# Portability issues: define a YY_NULLPTR appropriate for the current
+# language (C, C++98, or C++11).
+#
+# In C++ pre C++11 it is standard practice to use 0 (not NULL) for the
+# null pointer.  In C, prefer ((void*)0) to avoid having to include stdlib.h.
+m4_define([b4_null_define],
+[# ifndef YY_NULLPTR
+#  if defined __cplusplus
+#   if 201103L <= __cplusplus
+#    define YY_NULLPTR nullptr
+#   else
+#    define YY_NULLPTR 0
+#   endif
+#  else
+#   define YY_NULLPTR ((void*)0)
+#  endif
+# endif[]dnl
+])
+
+
+# b4_null
+# -------
+# Return a null pointer constant.
+m4_define([b4_null], [YY_NULLPTR])
+
+
+
+## ---------##
+## Values.  ##
+## ---------##
+
+# b4_integral_parser_table_define(TABLE-NAME, CONTENT, COMMENT)
+# -------------------------------------------------------------
+# Define "yy<TABLE-NAME>" whose contents is CONTENT.
+m4_define([b4_integral_parser_table_define],
+[m4_ifvaln([$3], [b4_comment([$3], [  ])])dnl
+static const b4_int_type_for([$2]) yy$1[[]] =
+{
+  $2
+};dnl
+])
+
+
+## ------------------------- ##
+## Assigning token numbers.  ##
+## ------------------------- ##
+
+# b4_token_define(TOKEN-NUM)
+# --------------------------
+# Output the definition of this token as #define.
+m4_define([b4_token_define],
+[b4_token_format([#define %s %s], [$1])])
+
+# b4_token_defines
+# ----------------
+# Output the definition of the tokens.
+m4_define([b4_token_defines],
+[b4_any_token_visible_if([/* Tokens.  */
+m4_join([
+], b4_symbol_map([b4_token_define]))
+])])
+
+
+# b4_token_enum(TOKEN-NUM)
+# ------------------------
+# Output the definition of this token as an enum.
+m4_define([b4_token_enum],
+[b4_token_format([%s = %s], [$1])])
+
+
+# b4_token_enums
+# --------------
+# Output the definition of the tokens (if there are) as enums.
+m4_define([b4_token_enums],
+[b4_any_token_visible_if([[/* Token type.  */
+#ifndef ]b4_api_PREFIX[TOKENTYPE
+# define ]b4_api_PREFIX[TOKENTYPE
+  enum ]b4_api_prefix[tokentype
+  {
+    ]m4_join([,
+    ],
+             b4_symbol_map([b4_token_enum]))[
+  };
+#endif
+]])])
+
+
+# b4_token_enums_defines
+# ----------------------
+# Output the definition of the tokens (if there are any) as enums and,
+# if POSIX Yacc is enabled, as #defines.
+m4_define([b4_token_enums_defines],
+[b4_token_enums[]b4_yacc_if([b4_token_defines])])
+
+
+## ----------------- ##
+## Semantic Values.  ##
+## ----------------- ##
+
+
+# b4_symbol_value(VAL, [SYMBOL-NUM], [TYPE-TAG])
+# ----------------------------------------------
+# See README.
+m4_define([b4_symbol_value],
+[m4_ifval([$3],
+          [($1.$3)],
+          [m4_ifval([$2],
+                    [b4_symbol_if([$2], [has_type],
+                                  [($1.b4_symbol([$2], [type]))],
+                                  [$1])],
+                    [$1])])])
+
+
+## ---------------------- ##
+## Defining C functions.  ##
+## ---------------------- ##
+
+
+# b4_function_define(NAME, RETURN-VALUE, [DECL1, NAME1], ...)
+# -----------------------------------------------------------
+# Declare the function NAME in C.
+m4_define([b4_function_define],
+[$2
+$1 (b4_formals(m4_shift2($@)))[]dnl
+])
+
+
+# b4_formals([DECL1, NAME1], ...)
+# -------------------------------
+# The formal arguments of a C function definition.
+m4_define([b4_formals],
+[m4_if([$#], [0], [void],
+       [$#$1], [1], [void],
+               [m4_map_sep([b4_formal], [, ], [$@])])])
+
+m4_define([b4_formal],
+[$1])
+
+
+
+## ----------------------- ##
+## Declaring C functions.  ##
+## ----------------------- ##
+
+
+# b4_function_declare(NAME, RETURN-VALUE, [DECL1, NAME1], ...)
+# ------------------------------------------------------------
+# Declare the function NAME.
+m4_define([b4_function_declare],
+[$2 $1 (b4_formals(m4_shift2($@)));[]dnl
+])
+
+
+
+
+## --------------------- ##
+## Calling C functions.  ##
+## --------------------- ##
+
+
+# b4_function_call(NAME, RETURN-VALUE, [DECL1, NAME1], ...)
+# -----------------------------------------------------------
+# Call the function NAME with arguments NAME1, NAME2 etc.
+m4_define([b4_function_call],
+[$1 (b4_args(m4_shift2($@)))[]dnl
+])
+
+
+# b4_args([DECL1, NAME1], ...)
+# ----------------------------
+# Output the arguments NAME1, NAME2...
+m4_define([b4_args],
+[m4_map_sep([b4_arg], [, ], [$@])])
+
+m4_define([b4_arg],
+[$2])
+
+
+## ----------- ##
+## Synclines.  ##
+## ----------- ##
+
+# b4_sync_start(LINE, FILE)
+# -------------------------
+m4_define([b4_sync_start], [[#]line $1 $2])
+
+
+## -------------- ##
+## User actions.  ##
+## -------------- ##
+
+# b4_case(LABEL, STATEMENTS)
+# --------------------------
+m4_define([b4_case],
+[  case $1:
+$2
+b4_syncline([@oline@], [@ofile@])dnl
+    break;])
+
+
+# b4_predicate_case(LABEL, CONDITIONS)
+# ------------------------------------
+m4_define([b4_predicate_case],
+[  case $1:
+    if (! (
+$2)) YYERROR;
+b4_syncline([@oline@], [@ofile@])dnl
+    break;])
+
+
+# b4_yydestruct_define
+# --------------------
+# Define the "yydestruct" function.
+m4_define_default([b4_yydestruct_define],
+[[/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+]b4_function_define([yydestruct],
+    [static void],
+    [[const char *yymsg],    [yymsg]],
+    [[int yytype],           [yytype]],
+    [[YYSTYPE *yyvaluep],    [yyvaluep]][]dnl
+b4_locations_if(            [, [[YYLTYPE *yylocationp], [yylocationp]]])[]dnl
+m4_ifset([b4_parse_param], [, b4_parse_param]))[
+{
+]b4_parse_param_use([yyvaluep], [yylocationp])dnl
+[  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  ]b4_symbol_actions([destructor])[
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}]dnl
+])
+
+
+# b4_yy_symbol_print_define
+# -------------------------
+# Define the "yy_symbol_print" function.
+m4_define_default([b4_yy_symbol_print_define],
+[[
+/*-----------------------------------.
+| Print this symbol's value on YYO.  |
+`-----------------------------------*/
+
+]b4_function_define([yy_symbol_value_print],
+    [static void],
+               [[FILE *yyo],                            [yyo]],
+               [[int yytype],                           [yytype]],
+               [[YYSTYPE const * const yyvaluep],       [yyvaluep]][]dnl
+b4_locations_if([, [[YYLTYPE const * const yylocationp], [yylocationp]]])[]dnl
+m4_ifset([b4_parse_param], [, b4_parse_param]))[
+{
+  FILE *yyoutput = yyo;
+]b4_parse_param_use([yyoutput], [yylocationp])dnl
+[  if (!yyvaluep)
+    return;]
+dnl glr.c does not feature yytoknum.
+m4_if(b4_skeleton, ["yacc.c"],
+[[# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);
+# endif
+]])dnl
+b4_percent_code_get([[pre-printer]])dnl
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  b4_symbol_actions([printer])
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+b4_percent_code_get([[post-printer]])dnl
+[}
+
+
+/*---------------------------.
+| Print this symbol on YYO.  |
+`---------------------------*/
+
+]b4_function_define([yy_symbol_print],
+    [static void],
+               [[FILE *yyo],                            [yyo]],
+               [[int yytype],                           [yytype]],
+               [[YYSTYPE const * const yyvaluep],       [yyvaluep]][]dnl
+b4_locations_if([, [[YYLTYPE const * const yylocationp], [yylocationp]]])[]dnl
+m4_ifset([b4_parse_param], [, b4_parse_param]))[
+{
+  YYFPRINTF (yyo, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+
+]b4_locations_if([  YY_LOCATION_PRINT (yyo, *yylocationp);
+  YYFPRINTF (yyo, ": ");
+])dnl
+[  yy_symbol_value_print (yyo, yytype, yyvaluep]dnl
+b4_locations_if([, yylocationp])[]b4_user_args[);
+  YYFPRINTF (yyo, ")");
+}]dnl
+])
+
+
+## ---------------- ##
+## api.value.type.  ##
+## ---------------- ##
+
+
+# ---------------------- #
+# api.value.type=union.  #
+# ---------------------- #
+
+# b4_symbol_type_register(SYMBOL-NUM)
+# -----------------------------------
+# Symbol SYMBOL-NUM has a type (for variant) instead of a type-tag.
+# Extend the definition of %union's body (b4_union_members) with a
+# field of that type, and extend the symbol's "type" field to point to
+# the field name, instead of the type name.
+m4_define([b4_symbol_type_register],
+[m4_define([b4_symbol($1, type_tag)],
+           [b4_symbol_if([$1], [has_id],
+                         [b4_symbol([$1], [id])],
+                         [yytype_[]b4_symbol([$1], [number])])])dnl
+m4_append([b4_union_members],
+m4_expand([
+  b4_symbol_tag_comment([$1])dnl
+  b4_symbol([$1], [type]) b4_symbol([$1], [type_tag]);]))
+])
+
+
+# b4_type_define_tag(SYMBOL1-NUM, ...)
+# ------------------------------------
+# For the batch of symbols SYMBOL1-NUM... (which all have the same
+# type), enhance the %union definition for each of them, and set
+# there "type" field to the field tag name, instead of the type name.
+m4_define([b4_type_define_tag],
+[b4_symbol_if([$1], [has_type],
+              [m4_map([b4_symbol_type_register], [$@])])
+])
+
+
+# b4_symbol_value_union(VAL, SYMBOL-NUM, [TYPE])
+# ----------------------------------------------
+# Same of b4_symbol_value, but when api.value.type=union.
+m4_define([b4_symbol_value_union],
+[m4_ifval([$3],
+          [(*($3*)(&$1))],
+          [m4_ifval([$2],
+                    [b4_symbol_if([$2], [has_type],
+                                  [($1.b4_symbol([$2], [type_tag]))],
+                                  [$1])],
+                    [$1])])])
+
+
+# b4_value_type_setup_union
+# -------------------------
+# Setup support for api.value.type=union.  Symbols are defined with a
+# type instead of a union member name: build the corresponding union,
+# and give the symbols their tag.
+m4_define([b4_value_type_setup_union],
+[m4_define([b4_union_members])
+b4_type_foreach([b4_type_define_tag])
+m4_copy_force([b4_symbol_value_union], [b4_symbol_value])
+])
+
+
+# -------------------------- #
+# api.value.type = variant.  #
+# -------------------------- #
+
+# b4_value_type_setup_variant
+# ---------------------------
+# Setup support for api.value.type=variant.  By default, fail, specialized
+# by other skeletons.
+m4_define([b4_value_type_setup_variant],
+[b4_complain_at(b4_percent_define_get_loc([[api.value.type]]),
+                [['%s' does not support '%s']],
+                [b4_skeleton],
+                [%define api.value.type variant])])
+
+
+# _b4_value_type_setup_keyword
+# ----------------------------
+# api.value.type is defined with a keyword/string syntax.  Check if
+# that is properly defined, and prepare its use.
+m4_define([_b4_value_type_setup_keyword],
+[b4_percent_define_check_values([[[[api.value.type]],
+                                  [[none]],
+                                  [[union]],
+                                  [[union-directive]],
+                                  [[variant]],
+                                  [[yystype]]]])dnl
+m4_case(b4_percent_define_get([[api.value.type]]),
+        [union],   [b4_value_type_setup_union],
+        [variant], [b4_value_type_setup_variant])])
+
+
+# b4_value_type_setup
+# -------------------
+# Check if api.value.type is properly defined, and possibly prepare
+# its use.
+b4_define_silent([b4_value_type_setup],
+[# Define default value.
+b4_percent_define_ifdef([[api.value.type]], [],
+[# %union => api.value.type=union-directive
+m4_ifdef([b4_union_members],
+[m4_define([b4_percent_define_kind(api.value.type)], [keyword])
+m4_define([b4_percent_define(api.value.type)], [union-directive])],
+[# no tag seen => api.value.type={int}
+m4_if(b4_tag_seen_flag, 0,
+[m4_define([b4_percent_define_kind(api.value.type)], [code])
+m4_define([b4_percent_define(api.value.type)], [int])],
+[# otherwise api.value.type=yystype
+m4_define([b4_percent_define_kind(api.value.type)], [keyword])
+m4_define([b4_percent_define(api.value.type)], [yystype])])])])
+
+# Set up.
+m4_bmatch(b4_percent_define_get_kind([[api.value.type]]),
+   [keyword\|string], [_b4_value_type_setup_keyword])
+])
+
+
+## -------------- ##
+## Declarations.  ##
+## -------------- ##
+
+
+# b4_value_type_define
+# --------------------
+m4_define([b4_value_type_define],
+[b4_value_type_setup[]dnl
+/* Value type.  */
+m4_bmatch(b4_percent_define_get_kind([[api.value.type]]),
+[code],
+[[#if ! defined ]b4_api_PREFIX[STYPE && ! defined ]b4_api_PREFIX[STYPE_IS_DECLARED
+typedef ]b4_percent_define_get([[api.value.type]])[ ]b4_api_PREFIX[STYPE;
+# define ]b4_api_PREFIX[STYPE_IS_TRIVIAL 1
+# define ]b4_api_PREFIX[STYPE_IS_DECLARED 1
+#endif
+]],
+[m4_bmatch(b4_percent_define_get([[api.value.type]]),
+[union\|union-directive],
+[[#if ! defined ]b4_api_PREFIX[STYPE && ! defined ]b4_api_PREFIX[STYPE_IS_DECLARED
+]b4_percent_define_get_syncline([[api.value.union.name]])dnl
+[union ]b4_percent_define_get([[api.value.union.name]])[
+{
+]b4_user_union_members[
+};
+]b4_percent_define_get_syncline([[api.value.union.name]])dnl
+[typedef union ]b4_percent_define_get([[api.value.union.name]])[ ]b4_api_PREFIX[STYPE;
+# define ]b4_api_PREFIX[STYPE_IS_TRIVIAL 1
+# define ]b4_api_PREFIX[STYPE_IS_DECLARED 1
+#endif
+]])])])
+
+
+# b4_location_type_define
+# -----------------------
+m4_define([b4_location_type_define],
+[[/* Location type.  */
+]b4_percent_define_ifdef([[api.location.type]],
+[[typedef ]b4_percent_define_get([[api.location.type]])[ ]b4_api_PREFIX[LTYPE;
+]],
+[[#if ! defined ]b4_api_PREFIX[LTYPE && ! defined ]b4_api_PREFIX[LTYPE_IS_DECLARED
+typedef struct ]b4_api_PREFIX[LTYPE ]b4_api_PREFIX[LTYPE;
+struct ]b4_api_PREFIX[LTYPE
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+};
+# define ]b4_api_PREFIX[LTYPE_IS_DECLARED 1
+# define ]b4_api_PREFIX[LTYPE_IS_TRIVIAL 1
+#endif
+]])])
+
+
+# b4_declare_yylstype
+# -------------------
+# Declarations that might either go into the header (if --defines) or
+# in the parser body.  Declare YYSTYPE/YYLTYPE, and yylval/yylloc.
+m4_define([b4_declare_yylstype],
+[b4_value_type_define[]b4_locations_if([
+b4_location_type_define])
+
+b4_pure_if([], [[extern ]b4_api_PREFIX[STYPE ]b4_prefix[lval;
+]b4_locations_if([[extern ]b4_api_PREFIX[LTYPE ]b4_prefix[lloc;]])])[]dnl
+])
+
+
+# b4_YYDEBUG_define
+# -----------------
+m4_define([b4_YYDEBUG_define],
+[[/* Debug traces.  */
+]m4_if(b4_api_prefix, [yy],
+[[#ifndef YYDEBUG
+# define YYDEBUG ]b4_parse_trace_if([1], [0])[
+#endif]],
+[[#ifndef ]b4_api_PREFIX[DEBUG
+# if defined YYDEBUG
+#if YYDEBUG
+#   define ]b4_api_PREFIX[DEBUG 1
+#  else
+#   define ]b4_api_PREFIX[DEBUG 0
+#  endif
+# else /* ! defined YYDEBUG */
+#  define ]b4_api_PREFIX[DEBUG ]b4_parse_trace_if([1], [0])[
+# endif /* ! defined YYDEBUG */
+#endif  /* ! defined ]b4_api_PREFIX[DEBUG */]])[]dnl
+])
+
+# b4_declare_yydebug
+# ------------------
+m4_define([b4_declare_yydebug],
+[b4_YYDEBUG_define[
+#if ]b4_api_PREFIX[DEBUG
+extern int ]b4_prefix[debug;
+#endif][]dnl
+])
+
+# b4_yylloc_default_define
+# ------------------------
+# Define YYLLOC_DEFAULT.
+m4_define([b4_yylloc_default_define],
+[[/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)                                \
+    do                                                                  \
+      if (N)                                                            \
+        {                                                               \
+          (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;        \
+          (Current).first_column = YYRHSLOC (Rhs, 1).first_column;      \
+          (Current).last_line    = YYRHSLOC (Rhs, N).last_line;         \
+          (Current).last_column  = YYRHSLOC (Rhs, N).last_column;       \
+        }                                                               \
+      else                                                              \
+        {                                                               \
+          (Current).first_line   = (Current).last_line   =              \
+            YYRHSLOC (Rhs, 0).last_line;                                \
+          (Current).first_column = (Current).last_column =              \
+            YYRHSLOC (Rhs, 0).last_column;                              \
+        }                                                               \
+    while (0)
+#endif
+]])
+
+# b4_yy_location_print_define
+# ---------------------------
+# Define YY_LOCATION_PRINT.
+m4_define([b4_yy_location_print_define],
+[b4_locations_if([[
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if defined ]b4_api_PREFIX[LTYPE_IS_TRIVIAL && ]b4_api_PREFIX[LTYPE_IS_TRIVIAL
+
+/* Print *YYLOCP on YYO.  Private, do not rely on its existence. */
+
+YY_ATTRIBUTE_UNUSED
+]b4_function_define([yy_location_print_],
+    [static int],
+               [[FILE *yyo],                    [yyo]],
+               [[YYLTYPE const * const yylocp], [yylocp]])[
+{
+  int res = 0;
+  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;
+  if (0 <= yylocp->first_line)
+    {
+      res += YYFPRINTF (yyo, "%d", yylocp->first_line);
+      if (0 <= yylocp->first_column)
+        res += YYFPRINTF (yyo, ".%d", yylocp->first_column);
+    }
+  if (0 <= yylocp->last_line)
+    {
+      if (yylocp->first_line < yylocp->last_line)
+        {
+          res += YYFPRINTF (yyo, "-%d", yylocp->last_line);
+          if (0 <= end_col)
+            res += YYFPRINTF (yyo, ".%d", end_col);
+        }
+      else if (0 <= end_col && yylocp->first_column < end_col)
+        res += YYFPRINTF (yyo, "-%d", end_col);
+    }
+  return res;
+ }
+
+#  define YY_LOCATION_PRINT(File, Loc)          \
+  yy_location_print_ (File, &(Loc))
+
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif]],
+[[/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif]])
+])
+
+# b4_yyloc_default
+# ----------------
+# Expand to a possible default value for yylloc.
+m4_define([b4_yyloc_default],
+[[
+# if defined ]b4_api_PREFIX[LTYPE_IS_TRIVIAL && ]b4_api_PREFIX[LTYPE_IS_TRIVIAL
+  = { ]m4_join([, ],
+               m4_defn([b4_location_initial_line]),
+               m4_defn([b4_location_initial_column]),
+               m4_defn([b4_location_initial_line]),
+               m4_defn([b4_location_initial_column]))[ }
+# endif
+]])
diff --git a/common/bison/skeletons/d-skel.m4 b/common/bison/skeletons/d-skel.m4
new file mode 100644
index 0000000000000000000000000000000000000000..1705d84dac9c72abd9d3d16221f40e5bf8c69aa5
--- /dev/null
+++ b/common/bison/skeletons/d-skel.m4
@@ -0,0 +1,26 @@
+                                                            -*- Autoconf -*-
+
+# D skeleton dispatching for Bison.
+
+# Copyright (C) 2018-2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+b4_glr_if(             [b4_complain([%%glr-parser not supported for D])])
+b4_nondeterministic_if([b4_complain([%%nondeterministic-parser not supported for D])])
+
+m4_define_default([b4_used_skeleton], [b4_skeletonsdir/[lalr1.d]])
+m4_define_default([b4_skeleton], ["b4_basename(b4_used_skeleton)"])
+
+m4_include(b4_used_skeleton)
diff --git a/common/bison/skeletons/d.m4 b/common/bison/skeletons/d.m4
new file mode 100644
index 0000000000000000000000000000000000000000..2d29127c2d5f79fdf53319a17e42b1e5e8df40b7
--- /dev/null
+++ b/common/bison/skeletons/d.m4
@@ -0,0 +1,332 @@
+                                                            -*- Autoconf -*-
+
+# D language support for Bison
+
+# Copyright (C) 2018-2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+# _b4_comment(TEXT, OPEN, CONTINUE, END)
+# --------------------------------------
+# Put TEXT in comment.  Avoid trailing spaces: don't indent empty lines.
+# Avoid adding indentation to the first line, as the indentation comes
+# from OPEN.  That's why we don't patsubst([$1], [^\(.\)], [   \1]).
+#
+# Prefix all the output lines with PREFIX.
+m4_define([_b4_comment],
+[$2[]m4_bpatsubst(m4_expand([[$1]]), [
+\(.\)], [
+$3\1])$4])
+
+
+# b4_comment(TEXT, [PREFIX])
+# --------------------------
+# Put TEXT in comment.  Prefix all the output lines with PREFIX.
+m4_define([b4_comment],
+[_b4_comment([$1], [$2/* ], [$2   ], [  */])])
+
+
+# b4_sync_start(LINE, FILE)
+# -------------------------
+m4_define([b4_sync_start], [[#]line $1 $2])
+
+
+# b4_list2(LIST1, LIST2)
+# ----------------------
+# Join two lists with a comma if necessary.
+m4_define([b4_list2],
+          [$1[]m4_ifval(m4_quote($1), [m4_ifval(m4_quote($2), [[, ]])])[]$2])
+
+
+# b4_percent_define_get3(DEF, PRE, POST, NOT)
+# -------------------------------------------
+# Expand to the value of DEF surrounded by PRE and POST if it's %define'ed,
+# otherwise NOT.
+m4_define([b4_percent_define_get3],
+          [m4_ifval(m4_quote(b4_percent_define_get([$1])),
+                [$2[]b4_percent_define_get([$1])[]$3], [$4])])
+
+
+# b4_flag_value(BOOLEAN-FLAG)
+# ---------------------------
+m4_define([b4_flag_value], [b4_flag_if([$1], [true], [false])])
+
+
+# b4_parser_class_declaration
+# ---------------------------
+# The declaration of the parser class ("class YYParser"), with all its
+# qualifiers/annotations.
+b4_percent_define_default([[api.parser.abstract]], [[false]])
+b4_percent_define_default([[api.parser.final]],    [[false]])
+b4_percent_define_default([[api.parser.public]],   [[false]])
+
+m4_define([b4_parser_class_declaration],
+[b4_percent_define_get3([api.parser.annotations], [], [ ])dnl
+b4_percent_define_flag_if([api.parser.public],   [public ])dnl
+b4_percent_define_flag_if([api.parser.abstract], [abstract ])dnl
+b4_percent_define_flag_if([api.parser.final],    [final ])dnl
+[class ]b4_parser_class[]dnl
+b4_percent_define_get3([api.parser.extends], [ extends ])dnl
+b4_percent_define_get3([api.parser.implements], [ implements ])])
+
+
+# b4_lexer_if(TRUE, FALSE)
+# ------------------------
+m4_define([b4_lexer_if],
+[b4_percent_code_ifdef([[lexer]], [$1], [$2])])
+
+
+# b4_position_type_if(TRUE, FALSE)
+# --------------------------------
+m4_define([b4_position_type_if],
+[b4_percent_define_ifdef([[position_type]], [$1], [$2])])
+
+
+# b4_location_type_if(TRUE, FALSE)
+# --------------------------------
+m4_define([b4_location_type_if],
+[b4_percent_define_ifdef([[location_type]], [$1], [$2])])
+
+
+# b4_identification
+# -----------------
+m4_define([b4_identification],
+[/** Version number for the Bison executable that generated this parser.  */
+  public static immutable string yy_bison_version = "b4_version";
+
+  /** Name of the skeleton that generated this parser.  */
+  public static immutable string yy_bison_skeleton = b4_skeleton;
+])
+
+
+## ------------ ##
+## Data types.  ##
+## ------------ ##
+
+# b4_int_type(MIN, MAX)
+# ---------------------
+# Return the smallest int type able to handle numbers ranging from
+# MIN to MAX (included).
+m4_define([b4_int_type],
+[m4_if(b4_ints_in($@,   [-128],   [127]), [1], [byte],
+       b4_ints_in($@, [-32768], [32767]), [1], [short],
+                                               [int])])
+
+# b4_int_type_for(NAME)
+# ---------------------
+# Return the smallest int type able to handle numbers ranging from
+# `NAME_min' to `NAME_max' (included).
+m4_define([b4_int_type_for],
+[b4_int_type($1_min, $1_max)])
+
+# b4_null
+# -------
+m4_define([b4_null], [null])
+
+
+# b4_integral_parser_table_define(NAME, DATA, COMMENT)
+#-----------------------------------------------------
+# Define "yy<TABLE-NAME>" whose contents is CONTENT.
+m4_define([b4_integral_parser_table_define],
+[m4_ifvaln([$3], [b4_comment([$3], [  ])])dnl
+private static immutable b4_int_type_for([$2])[[]] yy$1_ =
+@{
+  $2
+@};dnl
+])
+
+
+## ------------------------- ##
+## Assigning token numbers.  ##
+## ------------------------- ##
+
+# b4_token_enum(TOKEN-NAME, TOKEN-NUMBER)
+# ---------------------------------------
+# Output the definition of this token as an enum.
+m4_define([b4_token_enum],
+[b4_token_format([  %s = %s,
+], [$1])])
+
+# b4_token_enums(LIST-OF-PAIRS-TOKEN-NAME-TOKEN-NUMBER)
+# -----------------------------------------------------
+# Output the definition of the tokens as enums.
+m4_define([b4_token_enums],
+[/* Tokens.  */
+public enum YYTokenType {
+
+  /** Token returned by the scanner to signal the end of its input.  */
+  EOF = 0,
+b4_symbol_foreach([b4_token_enum])
+}
+])
+
+# b4-case(ID, CODE)
+# -----------------
+m4_define([b4_case], [    case $1:
+$2
+      break;])
+
+
+## ---------------- ##
+## Default values.  ##
+## ---------------- ##
+
+m4_define([b4_yystype], [b4_percent_define_get([[stype]])])
+b4_percent_define_default([[stype]], [[YYSemanticType]])])
+
+# %name-prefix
+m4_define_default([b4_prefix], [[YY]])
+
+b4_percent_define_default([[api.parser.class]], [b4_prefix[]Parser])])
+m4_define([b4_parser_class], [b4_percent_define_get([[api.parser.class]])])
+
+#b4_percent_define_default([[location_type]], [Location])])
+m4_define([b4_location_type], b4_percent_define_ifdef([[location_type]],[b4_percent_define_get([[location_type]])],[YYLocation]))
+
+#b4_percent_define_default([[position_type]], [Position])])
+m4_define([b4_position_type], b4_percent_define_ifdef([[position_type]],[b4_percent_define_get([[position_type]])],[YYPosition]))
+
+
+## ----------------- ##
+## Semantic Values.  ##
+## ----------------- ##
+
+
+# b4_symbol_value(VAL, [SYMBOL-NUM], [TYPE-TAG])
+# ----------------------------------------------
+# See README.  FIXME: factor in c-like?
+m4_define([b4_symbol_value],
+[m4_ifval([$3],
+          [($1.$3)],
+          [m4_ifval([$2],
+                    [b4_symbol_if([$2], [has_type],
+                                  [($1.b4_symbol([$2], [type]))],
+                                  [$1])],
+                    [$1])])])
+
+# b4_lhs_value(SYMBOL-NUM, [TYPE])
+# --------------------------------
+# See README.
+m4_define([b4_lhs_value],
+[b4_symbol_value([yyval], [$1], [$2])])
+
+
+# b4_rhs_value(RULE-LENGTH, POS, SYMBOL-NUM, [TYPE])
+# --------------------------------------------------
+# See README.
+#
+# In this simple implementation, %token and %type have class names
+# between the angle brackets.
+m4_define([b4_rhs_value],
+[b4_symbol_value([(yystack.valueAt (b4_subtract([$1], [$2])))], [$3], [$4])])
+
+
+# b4_lhs_location()
+# -----------------
+# Expansion of @$.
+m4_define([b4_lhs_location],
+[(yyloc)])
+
+
+# b4_rhs_location(RULE-LENGTH, POS)
+# ---------------------------------
+# Expansion of @POS, where the current rule has RULE-LENGTH symbols
+# on RHS.
+m4_define([b4_rhs_location],
+[yystack.locationAt ([$1], [$2])])
+
+
+# b4_lex_param
+# b4_parse_param
+# --------------
+# If defined, b4_lex_param arrives double quoted, but below we prefer
+# it to be single quoted.  Same for b4_parse_param.
+
+# TODO: should be in bison.m4
+m4_define_default([b4_lex_param], [[]]))
+m4_define([b4_lex_param], b4_lex_param))
+m4_define([b4_parse_param], b4_parse_param))
+
+# b4_lex_param_decl
+# -------------------
+# Extra formal arguments of the constructor.
+m4_define([b4_lex_param_decl],
+[m4_ifset([b4_lex_param],
+          [b4_remove_comma([$1],
+                           b4_param_decls(b4_lex_param))],
+          [$1])])
+
+m4_define([b4_param_decls],
+          [m4_map([b4_param_decl], [$@])])
+m4_define([b4_param_decl], [, $1])
+
+m4_define([b4_remove_comma], [m4_ifval(m4_quote($1), [$1, ], [])m4_shift2($@)])
+
+
+
+# b4_parse_param_decl
+# -------------------
+# Extra formal arguments of the constructor.
+m4_define([b4_parse_param_decl],
+[m4_ifset([b4_parse_param],
+          [b4_remove_comma([$1],
+                           b4_param_decls(b4_parse_param))],
+          [$1])])
+
+
+
+# b4_lex_param_call
+# -------------------
+# Delegating the lexer parameters to the lexer constructor.
+m4_define([b4_lex_param_call],
+          [m4_ifset([b4_lex_param],
+                    [b4_remove_comma([$1],
+                                     b4_param_calls(b4_lex_param))],
+                    [$1])])
+m4_define([b4_param_calls],
+          [m4_map([b4_param_call], [$@])])
+m4_define([b4_param_call], [, $2])
+
+
+
+# b4_parse_param_cons
+# -------------------
+# Extra initialisations of the constructor.
+m4_define([b4_parse_param_cons],
+          [m4_ifset([b4_parse_param],
+                    [b4_constructor_calls(b4_parse_param)])])
+
+m4_define([b4_constructor_calls],
+          [m4_map([b4_constructor_call], [$@])])
+m4_define([b4_constructor_call],
+          [this.$2 = $2;
+          ])
+
+
+
+# b4_parse_param_vars
+# -------------------
+# Extra instance variables.
+m4_define([b4_parse_param_vars],
+          [m4_ifset([b4_parse_param],
+                    [
+    /* User arguments.  */
+b4_var_decls(b4_parse_param)])])
+
+m4_define([b4_var_decls],
+          [m4_map_sep([b4_var_decl], [
+], [$@])])
+m4_define([b4_var_decl],
+          [    protected $1;])
diff --git a/common/bison/skeletons/glr.c b/common/bison/skeletons/glr.c
new file mode 100644
index 0000000000000000000000000000000000000000..945ff0ac8330394f3219691d4d5416cfffa149d7
--- /dev/null
+++ b/common/bison/skeletons/glr.c
@@ -0,0 +1,2642 @@
+                                                                    -*- C -*-
+
+# GLR skeleton for Bison
+
+# Copyright (C) 2002-2015, 2018-2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+# If we are loaded by glr.cc, do not override c++.m4 definitions by
+# those of c.m4.
+m4_if(b4_skeleton, ["glr.c"],
+      [m4_include(b4_skeletonsdir/[c.m4])])
+
+
+## ---------------- ##
+## Default values.  ##
+## ---------------- ##
+
+# Stack parameters.
+m4_define_default([b4_stack_depth_max], [10000])
+m4_define_default([b4_stack_depth_init],  [200])
+
+
+
+## ------------------------ ##
+## Pure/impure interfaces.  ##
+## ------------------------ ##
+
+b4_define_flag_if([pure])
+# If glr.cc is including this file and thus has already set b4_pure_flag,
+# do not change the value of b4_pure_flag, and do not record a use of api.pure.
+m4_ifndef([b4_pure_flag],
+[b4_percent_define_default([[api.pure]], [[false]])
+ m4_define([b4_pure_flag],
+           [b4_percent_define_flag_if([[api.pure]], [[1]], [[0]])])])
+
+# b4_user_formals
+# ---------------
+# The possible parse-params formal arguments preceded by a comma.
+#
+# This is not shared with yacc.c in c.m4 because  GLR relies on ISO C
+# formal argument declarations.
+m4_define([b4_user_formals],
+[m4_ifset([b4_parse_param], [, b4_formals(b4_parse_param)])])
+
+
+# b4_yyerror_args
+# ---------------
+# Optional effective arguments passed to yyerror: user args plus yylloc, and
+# a trailing comma.
+m4_define([b4_yyerror_args],
+[b4_pure_if([b4_locations_if([yylocp, ])])dnl
+m4_ifset([b4_parse_param], [b4_args(b4_parse_param), ])])
+
+
+# b4_lyyerror_args
+# ----------------
+# Same as above, but on the lookahead, hence &yylloc instead of yylocp.
+m4_define([b4_lyyerror_args],
+[b4_pure_if([b4_locations_if([&yylloc, ])])dnl
+m4_ifset([b4_parse_param], [b4_args(b4_parse_param), ])])
+
+
+# b4_pure_args
+# ------------
+# Same as b4_yyerror_args, but with a leading comma.
+m4_define([b4_pure_args],
+[b4_pure_if([b4_locations_if([, yylocp])])[]b4_user_args])
+
+
+# b4_lpure_args
+# -------------
+# Same as above, but on the lookahead, hence &yylloc instead of yylocp.
+m4_define([b4_lpure_args],
+[b4_pure_if([b4_locations_if([, &yylloc])])[]b4_user_args])
+
+
+
+# b4_pure_formals
+# ---------------
+# Arguments passed to yyerror: user formals plus yylocp with leading comma.
+m4_define([b4_pure_formals],
+[b4_pure_if([b4_locations_if([, YYLTYPE *yylocp])])[]b4_user_formals])
+
+
+# b4_locuser_formals(LOC = yylocp)
+# --------------------------------
+# User formal arguments, possibly preceded by location argument.
+m4_define([b4_locuser_formals],
+[b4_locations_if([, YYLTYPE *m4_default([$1], [yylocp])])[]b4_user_formals])
+
+
+# b4_locuser_args(LOC = yylocp)
+# -----------------------------
+m4_define([b4_locuser_args],
+[b4_locations_if([, m4_default([$1], [yylocp])])[]b4_user_args])
+
+
+
+## ----------------- ##
+## Semantic Values.  ##
+## ----------------- ##
+
+
+# b4_lhs_value(SYMBOL-NUM, [TYPE])
+# --------------------------------
+# See README.
+m4_define([b4_lhs_value],
+[b4_symbol_value([(*yyvalp)], [$1], [$2])])
+
+
+# b4_rhs_data(RULE-LENGTH, POS)
+# -----------------------------
+# See README.
+m4_define([b4_rhs_data],
+[YY_CAST (yyGLRStackItem const *, yyvsp)@{YYFILL (b4_subtract([$2], [$1]))@}.yystate])
+
+
+# b4_rhs_value(RULE-LENGTH, POS, SYMBOL-NUM, [TYPE])
+# --------------------------------------------------
+# Expansion of $$ or $<TYPE>$, for symbol SYMBOL-NUM.
+m4_define([b4_rhs_value],
+[b4_symbol_value([b4_rhs_data([$1], [$2]).yysemantics.yysval], [$3], [$4])])
+
+
+
+## ----------- ##
+## Locations.  ##
+## ----------- ##
+
+# b4_lhs_location()
+# -----------------
+# Expansion of @$.
+m4_define([b4_lhs_location],
+[(*yylocp)])
+
+
+# b4_rhs_location(RULE-LENGTH, NUM)
+# ---------------------------------
+# Expansion of @NUM, where the current rule has RULE-LENGTH symbols
+# on RHS.
+m4_define([b4_rhs_location],
+[(b4_rhs_data([$1], [$2]).yyloc)])
+
+
+## -------------- ##
+## Declarations.  ##
+## -------------- ##
+
+# b4_shared_declarations
+# ----------------------
+# Declaration that might either go into the header (if --defines)
+# or open coded in the parser body.  glr.cc has its own definition.
+m4_if(b4_skeleton, ["glr.c"],
+[m4_define([b4_shared_declarations],
+[b4_declare_yydebug[
+]b4_percent_code_get([[requires]])[
+]b4_token_enums[
+]b4_declare_yylstype[
+]b4_function_declare(b4_prefix[parse], [int], b4_parse_param)[
+]b4_percent_code_get([[provides]])[]dnl
+])
+])
+
+## -------------- ##
+## Output files.  ##
+## -------------- ##
+
+# Unfortunately the order of generation between the header and the
+# implementation file matters (for glr.c) because of the current
+# implementation of api.value.type=union.  In that case we still use a
+# union for YYSTYPE, but we generate the contents of this union when
+# setting up YYSTYPE.  This is needed for other aspects, such as
+# defining yy_symbol_value_print, since we need to now the name of the
+# members of this union.
+#
+# To avoid this issue, just generate the header before the
+# implementation file.  But we should also make them more independant.
+
+# ----------------- #
+# The header file.  #
+# ----------------- #
+
+# glr.cc produces its own header.
+b4_glr_cc_if([],
+[b4_defines_if(
+[b4_output_begin([b4_spec_header_file])
+b4_copyright([Skeleton interface for Bison GLR parsers in C],
+             [2002-2015, 2018-2019])[
+]b4_cpp_guard_open([b4_spec_header_file])[
+]b4_shared_declarations[
+]b4_cpp_guard_close([b4_spec_header_file])[
+]b4_output_end[
+]])])
+
+
+# ------------------------- #
+# The implementation file.  #
+# ------------------------- #
+
+b4_output_begin([b4_parser_file_name])
+b4_copyright([Skeleton implementation for Bison GLR parsers in C],
+             [2002-2015, 2018-2019])[
+/* C GLR parser skeleton written by Paul Hilfinger.  */
+
+]b4_disclaimer[
+]b4_identification[
+
+]b4_percent_code_get([[top]])[
+]m4_if(b4_api_prefix, [yy], [],
+[[/* Substitute the type names.  */
+#define YYSTYPE ]b4_api_PREFIX[STYPE]b4_locations_if([[
+#define YYLTYPE ]b4_api_PREFIX[LTYPE]])])[
+]m4_if(b4_prefix, [yy], [],
+[[/* Substitute the variable and function names.  */
+#define yyparse ]b4_prefix[parse
+#define yylex   ]b4_prefix[lex
+#define yyerror ]b4_prefix[error
+#define yydebug ]b4_prefix[debug]]b4_pure_if([], [[
+#define yylval  ]b4_prefix[lval
+#define yychar  ]b4_prefix[char
+#define yynerrs ]b4_prefix[nerrs]b4_locations_if([[
+#define yylloc  ]b4_prefix[lloc]])]))[
+
+]b4_user_pre_prologue[
+]b4_cast_define[
+]b4_null_define[
+
+]b4_defines_if([[#include "@basename(]b4_spec_header_file[@)"]],
+               [b4_shared_declarations])[
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE ]b4_error_verbose_if([1], [0])[
+#endif
+
+/* Default (constant) value used for initialization for null
+   right-hand sides.  Unlike the standard yacc.c template, here we set
+   the default value of $$ to a zeroed-out value.  Since the default
+   value is undefined, this behavior is technically correct.  */
+static YYSTYPE yyval_default;]b4_locations_if([[
+static YYLTYPE yyloc_default][]b4_yyloc_default;])[
+
+]b4_user_post_prologue[
+]b4_percent_code_get[]dnl
+
+[#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+]b4_c99_int_type_define[
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+#ifndef YYFREE
+# define YYFREE free
+#endif
+#ifndef YYMALLOC
+# define YYMALLOC malloc
+#endif
+#ifndef YYREALLOC
+# define YYREALLOC realloc
+#endif
+
+#define YYSIZEMAX \
+  (PTRDIFF_MAX < SIZE_MAX ? PTRDIFF_MAX : YY_CAST (ptrdiff_t, SIZE_MAX))
+
+#ifdef __cplusplus
+  typedef bool yybool;
+# define yytrue true
+# define yyfalse false
+#else
+  /* When we move to stdbool, get rid of the various casts to yybool.  */
+  typedef signed char yybool;
+# define yytrue 1
+# define yyfalse 0
+#endif
+
+#ifndef YYSETJMP
+# include <setjmp.h>
+# define YYJMP_BUF jmp_buf
+# define YYSETJMP(Env) setjmp (Env)
+/* Pacify Clang and ICC.  */
+# define YYLONGJMP(Env, Val)                    \
+ do {                                           \
+   longjmp (Env, Val);                          \
+   YY_ASSERT (0);                               \
+ } while (yyfalse)
+#endif
+
+]b4_attribute_define([noreturn])[
+
+]b4_parse_assert_if([[#ifdef NDEBUG
+# define YY_ASSERT(E) ((void) (0 && (E)))
+#else
+# include <assert.h> /* INFRINGES ON USER NAME SPACE */
+# define YY_ASSERT(E) assert (E)
+#endif
+]],
+[[#define YY_ASSERT(E) ((void) (0 && (E)))]])[
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  ]b4_final_state_number[
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   ]b4_last[
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  ]b4_tokens_number[
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  ]b4_nterms_number[
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  ]b4_rules_number[
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  ]b4_states_number[
+/* YYMAXRHS -- Maximum number of symbols on right-hand side of rule.  */
+#define YYMAXRHS ]b4_r2_max[
+/* YYMAXLEFT -- Maximum number of symbols to the left of a handle
+   accessed by $0, $-1, etc., in any rule.  */
+#define YYMAXLEFT ]b4_max_left_semantic_context[
+
+/* YYMAXUTOK -- Last valid token number (for yychar).  */
+#define YYMAXUTOK   ]b4_user_token_number_max[]b4_glr_cc_if([[
+/* YYFAULTYTOK -- Token number (for yychar) that denotes a
+   syntax_error thrown from the scanner.  */
+#define YYFAULTYTOK (YYMAXUTOK + 1)]])[
+/* YYUNDEFTOK -- Symbol number (for yytoken) that denotes an unknown
+   token.  */
+#define YYUNDEFTOK  ]b4_undef_token_number[
+
+/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, with out-of-bounds checking.  */
+]b4_api_token_raw_if(dnl
+[[#define YYTRANSLATE(YYX) (YYX)]],
+[[#define YYTRANSLATE(YYX)                         \
+  (0 <= (YYX) && (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex.  */
+static const ]b4_int_type_for([b4_translate])[ yytranslate[] =
+{
+  ]b4_translate[
+};]])[
+
+#if ]b4_api_PREFIX[DEBUG
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const ]b4_int_type_for([b4_rline])[ yyrline[] =
+{
+  ]b4_rline[
+};
+#endif
+
+#if ]b4_api_PREFIX[DEBUG || YYERROR_VERBOSE || ]b4_token_table_flag[
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  ]b4_tname[
+};
+#endif
+
+#define YYPACT_NINF (]b4_pact_ninf[)
+#define YYTABLE_NINF (]b4_table_ninf[)
+
+]b4_parser_tables_define[
+
+/* YYDPREC[RULE-NUM] -- Dynamic precedence of rule #RULE-NUM (0 if none).  */
+static const ]b4_int_type_for([b4_dprec])[ yydprec[] =
+{
+  ]b4_dprec[
+};
+
+/* YYMERGER[RULE-NUM] -- Index of merging function for rule #RULE-NUM.  */
+static const ]b4_int_type_for([b4_merger])[ yymerger[] =
+{
+  ]b4_merger[
+};
+
+/* YYIMMEDIATE[RULE-NUM] -- True iff rule #RULE-NUM is not to be deferred, as
+   in the case of predicates.  */
+static const yybool yyimmediate[] =
+{
+  ]b4_immediate[
+};
+
+/* YYCONFLP[YYPACT[STATE-NUM]] -- Pointer into YYCONFL of start of
+   list of conflicting reductions corresponding to action entry for
+   state STATE-NUM in yytable.  0 means no conflicts.  The list in
+   yyconfl is terminated by a rule number of 0.  */
+static const ]b4_int_type_for([b4_conflict_list_heads])[ yyconflp[] =
+{
+  ]b4_conflict_list_heads[
+};
+
+/* YYCONFL[I] -- lists of conflicting rule numbers, each terminated by
+   0, pointed into by YYCONFLP.  */
+]dnl Do not use b4_int_type_for here, since there are places where
+dnl pointers onto yyconfl are taken, whose type is "short*".
+dnl We probably ought to introduce a type for confl.
+[static const short yyconfl[] =
+{
+  ]b4_conflicting_rules[
+};
+
+/* Error token number */
+#define YYTERROR 1
+
+]b4_locations_if([[
+]b4_yylloc_default_define[
+# define YYRHSLOC(Rhs, K) ((Rhs)[K].yystate.yyloc)
+]])[
+
+]b4_pure_if(
+[
+#undef yynerrs
+#define yynerrs (yystackp->yyerrcnt)
+#undef yychar
+#define yychar (yystackp->yyrawchar)
+#undef yylval
+#define yylval (yystackp->yyval)
+#undef yylloc
+#define yylloc (yystackp->yyloc)
+m4_if(b4_prefix[], [yy], [],
+[#define b4_prefix[]nerrs yynerrs
+#define b4_prefix[]char yychar
+#define b4_prefix[]lval yylval
+#define b4_prefix[]lloc yylloc])],
+[YYSTYPE yylval;]b4_locations_if([[
+YYLTYPE yylloc;]])[
+
+int yynerrs;
+int yychar;])[
+
+static const int YYEOF = 0;
+static const int YYEMPTY = -2;
+
+typedef enum { yyok, yyaccept, yyabort, yyerr } YYRESULTTAG;
+
+#define YYCHK(YYE)                              \
+  do {                                          \
+    YYRESULTTAG yychk_flag = YYE;               \
+    if (yychk_flag != yyok)                     \
+      return yychk_flag;                        \
+  } while (0)
+
+#if ]b4_api_PREFIX[DEBUG
+
+# ifndef YYFPRINTF
+#  define YYFPRINTF fprintf
+# endif
+
+# define YY_FPRINTF                             \
+  YY_IGNORE_USELESS_CAST_BEGIN YY_FPRINTF_
+
+# define YY_FPRINTF_(Args)                      \
+  do {                                          \
+    YYFPRINTF Args;                             \
+    YY_IGNORE_USELESS_CAST_END                  \
+  } while (0)
+
+# define YY_DPRINTF                             \
+  YY_IGNORE_USELESS_CAST_BEGIN YY_DPRINTF_
+
+# define YY_DPRINTF_(Args)                      \
+  do {                                          \
+    if (yydebug)                                \
+      YYFPRINTF Args;                           \
+    YY_IGNORE_USELESS_CAST_END                  \
+  } while (0)
+
+]b4_yy_location_print_define[
+
+]b4_yy_symbol_print_define[
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                  \
+  do {                                                                  \
+    if (yydebug)                                                        \
+      {                                                                 \
+        YY_FPRINTF ((stderr, "%s ", Title));                            \
+        yy_symbol_print (stderr, Type, Value]b4_locuser_args([Location])[);        \
+        YY_FPRINTF ((stderr, "\n"));                                    \
+      }                                                                 \
+  } while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+
+struct yyGLRStack;
+static void yypstack (struct yyGLRStack* yystackp, ptrdiff_t yyk)
+  YY_ATTRIBUTE_UNUSED;
+static void yypdumpstack (struct yyGLRStack* yystackp)
+  YY_ATTRIBUTE_UNUSED;
+
+#else /* !]b4_api_PREFIX[DEBUG */
+
+# define YY_DPRINTF(Args) do {} while (yyfalse)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+
+#endif /* !]b4_api_PREFIX[DEBUG */
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH ]b4_stack_depth_init[
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYMAXDEPTH * sizeof (GLRStackItem)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH ]b4_stack_depth_max[
+#endif
+
+/* Minimum number of free items on the stack allowed after an
+   allocation.  This is to allow allocation and initialization
+   to be completed by functions that call yyexpandGLRStack before the
+   stack is expanded, thus insuring that all necessary pointers get
+   properly redirected to new data.  */
+#define YYHEADROOM 2
+
+#ifndef YYSTACKEXPANDABLE
+#  define YYSTACKEXPANDABLE 1
+#endif
+
+#if YYSTACKEXPANDABLE
+# define YY_RESERVE_GLRSTACK(Yystack)                   \
+  do {                                                  \
+    if (Yystack->yyspaceLeft < YYHEADROOM)              \
+      yyexpandGLRStack (Yystack);                       \
+  } while (0)
+#else
+# define YY_RESERVE_GLRSTACK(Yystack)                   \
+  do {                                                  \
+    if (Yystack->yyspaceLeft < YYHEADROOM)              \
+      yyMemoryExhausted (Yystack);                      \
+  } while (0)
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static ptrdiff_t
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      ptrdiff_t yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            else
+              goto append;
+
+          append:
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (yyres)
+    return yystpcpy (yyres, yystr) - yyres;
+  else
+    return YY_CAST (ptrdiff_t, strlen (yystr));
+}
+# endif
+
+#endif /* !YYERROR_VERBOSE */
+
+/** State numbers. */
+typedef int yyStateNum;
+
+/** Rule numbers. */
+typedef int yyRuleNum;
+
+/** Grammar symbol. */
+typedef int yySymbol;
+
+/** Item references. */
+typedef short yyItemNum;
+
+typedef struct yyGLRState yyGLRState;
+typedef struct yyGLRStateSet yyGLRStateSet;
+typedef struct yySemanticOption yySemanticOption;
+typedef union yyGLRStackItem yyGLRStackItem;
+typedef struct yyGLRStack yyGLRStack;
+
+struct yyGLRState {
+  /** Type tag: always true.  */
+  yybool yyisState;
+  /** Type tag for yysemantics.  If true, yysval applies, otherwise
+   *  yyfirstVal applies.  */
+  yybool yyresolved;
+  /** Number of corresponding LALR(1) machine state.  */
+  yyStateNum yylrState;
+  /** Preceding state in this stack */
+  yyGLRState* yypred;
+  /** Source position of the last token produced by my symbol */
+  ptrdiff_t yyposn;
+  union {
+    /** First in a chain of alternative reductions producing the
+     *  nonterminal corresponding to this state, threaded through
+     *  yynext.  */
+    yySemanticOption* yyfirstVal;
+    /** Semantic value for this state.  */
+    YYSTYPE yysval;
+  } yysemantics;]b4_locations_if([[
+  /** Source location for this state.  */
+  YYLTYPE yyloc;]])[
+};
+
+struct yyGLRStateSet {
+  yyGLRState** yystates;
+  /** During nondeterministic operation, yylookaheadNeeds tracks which
+   *  stacks have actually needed the current lookahead.  During deterministic
+   *  operation, yylookaheadNeeds[0] is not maintained since it would merely
+   *  duplicate yychar != YYEMPTY.  */
+  yybool* yylookaheadNeeds;
+  ptrdiff_t yysize;
+  ptrdiff_t yycapacity;
+};
+
+struct yySemanticOption {
+  /** Type tag: always false.  */
+  yybool yyisState;
+  /** Rule number for this reduction */
+  yyRuleNum yyrule;
+  /** The last RHS state in the list of states to be reduced.  */
+  yyGLRState* yystate;
+  /** The lookahead for this reduction.  */
+  int yyrawchar;
+  YYSTYPE yyval;]b4_locations_if([[
+  YYLTYPE yyloc;]])[
+  /** Next sibling in chain of options.  To facilitate merging,
+   *  options are chained in decreasing order by address.  */
+  yySemanticOption* yynext;
+};
+
+/** Type of the items in the GLR stack.  The yyisState field
+ *  indicates which item of the union is valid.  */
+union yyGLRStackItem {
+  yyGLRState yystate;
+  yySemanticOption yyoption;
+};
+
+struct yyGLRStack {
+  int yyerrState;
+]b4_locations_if([[  /* To compute the location of the error token.  */
+  yyGLRStackItem yyerror_range[3];]])[
+]b4_pure_if(
+[
+  int yyerrcnt;
+  int yyrawchar;
+  YYSTYPE yyval;]b4_locations_if([[
+  YYLTYPE yyloc;]])[
+])[
+  YYJMP_BUF yyexception_buffer;
+  yyGLRStackItem* yyitems;
+  yyGLRStackItem* yynextFree;
+  ptrdiff_t yyspaceLeft;
+  yyGLRState* yysplitPoint;
+  yyGLRState* yylastDeleted;
+  yyGLRStateSet yytops;
+};
+
+#if YYSTACKEXPANDABLE
+static void yyexpandGLRStack (yyGLRStack* yystackp);
+#endif
+
+_Noreturn static void
+yyFail (yyGLRStack* yystackp]b4_pure_formals[, const char* yymsg)
+{
+  if (yymsg != YY_NULLPTR)
+    yyerror (]b4_yyerror_args[yymsg);
+  YYLONGJMP (yystackp->yyexception_buffer, 1);
+}
+
+_Noreturn static void
+yyMemoryExhausted (yyGLRStack* yystackp)
+{
+  YYLONGJMP (yystackp->yyexception_buffer, 2);
+}
+
+#if ]b4_api_PREFIX[DEBUG || YYERROR_VERBOSE
+/** A printable representation of TOKEN.  */
+static inline const char*
+yytokenName (yySymbol yytoken)
+{
+  return yytoken == YYEMPTY ? "" : yytname[yytoken];
+}
+#endif
+
+/** Fill in YYVSP[YYLOW1 .. YYLOW0-1] from the chain of states starting
+ *  at YYVSP[YYLOW0].yystate.yypred.  Leaves YYVSP[YYLOW1].yystate.yypred
+ *  containing the pointer to the next state in the chain.  */
+static void yyfillin (yyGLRStackItem *, int, int) YY_ATTRIBUTE_UNUSED;
+static void
+yyfillin (yyGLRStackItem *yyvsp, int yylow0, int yylow1)
+{
+  int i;
+  yyGLRState *s = yyvsp[yylow0].yystate.yypred;
+  for (i = yylow0-1; i >= yylow1; i -= 1)
+    {
+#if ]b4_api_PREFIX[DEBUG
+      yyvsp[i].yystate.yylrState = s->yylrState;
+#endif
+      yyvsp[i].yystate.yyresolved = s->yyresolved;
+      if (s->yyresolved)
+        yyvsp[i].yystate.yysemantics.yysval = s->yysemantics.yysval;
+      else
+        /* The effect of using yysval or yyloc (in an immediate rule) is
+         * undefined.  */
+        yyvsp[i].yystate.yysemantics.yyfirstVal = YY_NULLPTR;]b4_locations_if([[
+      yyvsp[i].yystate.yyloc = s->yyloc;]])[
+      s = yyvsp[i].yystate.yypred = s->yypred;
+    }
+}
+
+]m4_define([b4_yygetToken_call],
+           [[yygetToken (&yychar][]b4_pure_if([, yystackp])[]b4_user_args[)]])[
+/** If yychar is empty, fetch the next token.  */
+static inline yySymbol
+yygetToken (int *yycharp][]b4_pure_if([, yyGLRStack* yystackp])[]b4_user_formals[)
+{
+  yySymbol yytoken;
+]b4_parse_param_use()dnl
+[  if (*yycharp == YYEMPTY)
+    {
+      YY_DPRINTF ((stderr, "Reading a token: "));]b4_glr_cc_if([[
+#if YY_EXCEPTIONS
+      try
+        {
+#endif // YY_EXCEPTIONS
+          *yycharp = ]b4_lex[;
+#if YY_EXCEPTIONS
+        }
+      catch (const ]b4_namespace_ref[::]b4_parser_class[::syntax_error& yyexc)
+        {
+          YY_DPRINTF ((stderr, "Caught exception: %s\n", yyexc.what()));]b4_locations_if([
+          yylloc = yyexc.location;])[
+          yyerror (]b4_lyyerror_args[yyexc.what ());
+          // Map errors caught in the scanner to the undefined token
+          // (YYUNDEFTOK), so that error handling is started.
+          // However, record this with this special value of yychar.
+          *yycharp = YYFAULTYTOK;
+        }
+#endif // YY_EXCEPTIONS]], [[
+      *yycharp = ]b4_lex[;]])[
+    }
+  if (*yycharp <= YYEOF)
+    {
+      *yycharp = yytoken = YYEOF;
+      YY_DPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (*yycharp);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+  return yytoken;
+}
+
+/* Do nothing if YYNORMAL or if *YYLOW <= YYLOW1.  Otherwise, fill in
+ * YYVSP[YYLOW1 .. *YYLOW-1] as in yyfillin and set *YYLOW = YYLOW1.
+ * For convenience, always return YYLOW1.  */
+static inline int yyfill (yyGLRStackItem *, int *, int, yybool)
+     YY_ATTRIBUTE_UNUSED;
+static inline int
+yyfill (yyGLRStackItem *yyvsp, int *yylow, int yylow1, yybool yynormal)
+{
+  if (!yynormal && yylow1 < *yylow)
+    {
+      yyfillin (yyvsp, *yylow, yylow1);
+      *yylow = yylow1;
+    }
+  return yylow1;
+}
+
+/** Perform user action for rule number YYN, with RHS length YYRHSLEN,
+ *  and top stack item YYVSP.  YYLVALP points to place to put semantic
+ *  value ($$), and yylocp points to place for location information
+ *  (@@$).  Returns yyok for normal return, yyaccept for YYACCEPT,
+ *  yyerr for YYERROR, yyabort for YYABORT.  */
+static YYRESULTTAG
+yyuserAction (yyRuleNum yyn, int yyrhslen, yyGLRStackItem* yyvsp,
+              yyGLRStack* yystackp,
+              YYSTYPE* yyvalp]b4_locuser_formals[)
+{
+  yybool yynormal YY_ATTRIBUTE_UNUSED = yystackp->yysplitPoint == YY_NULLPTR;
+  int yylow;
+]b4_parse_param_use([yyvalp], [yylocp])dnl
+[  YYUSE (yyrhslen);
+# undef yyerrok
+# define yyerrok (yystackp->yyerrState = 0)
+# undef YYACCEPT
+# define YYACCEPT return yyaccept
+# undef YYABORT
+# define YYABORT return yyabort
+# undef YYERROR
+# define YYERROR return yyerrok, yyerr
+# undef YYRECOVERING
+# define YYRECOVERING() (yystackp->yyerrState != 0)
+# undef yyclearin
+# define yyclearin (yychar = YYEMPTY)
+# undef YYFILL
+# define YYFILL(N) yyfill (yyvsp, &yylow, (N), yynormal)
+# undef YYBACKUP
+# define YYBACKUP(Token, Value)                                              \
+  return yyerror (]b4_yyerror_args[YY_("syntax error: cannot back up")),     \
+         yyerrok, yyerr
+
+  yylow = 1;
+  if (yyrhslen == 0)
+    *yyvalp = yyval_default;
+  else
+    *yyvalp = yyvsp[YYFILL (1-yyrhslen)].yystate.yysemantics.yysval;]b4_locations_if([[
+  /* Default location. */
+  YYLLOC_DEFAULT ((*yylocp), (yyvsp - yyrhslen), yyrhslen);
+  yystackp->yyerror_range[1].yystate.yyloc = *yylocp;
+]])[]b4_glr_cc_if([[
+#if YY_EXCEPTIONS
+  typedef ]b4_namespace_ref[::]b4_parser_class[::syntax_error syntax_error;
+  try
+  {
+#endif // YY_EXCEPTIONS]])[
+  switch (yyn)
+    {
+]b4_user_actions[
+      default: break;
+    }]b4_glr_cc_if([[
+#if YY_EXCEPTIONS
+  }
+  catch (const syntax_error& yyexc)
+    {
+      YY_DPRINTF ((stderr, "Caught exception: %s\n", yyexc.what()));]b4_locations_if([
+      *yylocp = yyexc.location;])[
+      yyerror (]b4_yyerror_args[yyexc.what ());
+      YYERROR;
+    }
+#endif // YY_EXCEPTIONS]])[
+
+  return yyok;
+# undef yyerrok
+# undef YYABORT
+# undef YYACCEPT
+# undef YYERROR
+# undef YYBACKUP
+# undef yyclearin
+# undef YYRECOVERING
+}
+
+
+static void
+yyuserMerge (int yyn, YYSTYPE* yy0, YYSTYPE* yy1)
+{
+  YYUSE (yy0);
+  YYUSE (yy1);
+
+  switch (yyn)
+    {
+]b4_mergers[
+      default: break;
+    }
+}
+
+                              /* Bison grammar-table manipulation.  */
+
+]b4_yydestruct_define[
+
+/** Number of symbols composing the right hand side of rule #RULE.  */
+static inline int
+yyrhsLength (yyRuleNum yyrule)
+{
+  return yyr2[yyrule];
+}
+
+static void
+yydestroyGLRState (char const *yymsg, yyGLRState *yys]b4_user_formals[)
+{
+  if (yys->yyresolved)
+    yydestruct (yymsg, yystos[yys->yylrState],
+                &yys->yysemantics.yysval]b4_locuser_args([&yys->yyloc])[);
+  else
+    {
+#if ]b4_api_PREFIX[DEBUG
+      if (yydebug)
+        {
+          if (yys->yysemantics.yyfirstVal)
+            YY_FPRINTF ((stderr, "%s unresolved", yymsg));
+          else
+            YY_FPRINTF ((stderr, "%s incomplete", yymsg));
+          YY_SYMBOL_PRINT ("", yystos[yys->yylrState], YY_NULLPTR, &yys->yyloc);
+        }
+#endif
+
+      if (yys->yysemantics.yyfirstVal)
+        {
+          yySemanticOption *yyoption = yys->yysemantics.yyfirstVal;
+          yyGLRState *yyrh;
+          int yyn;
+          for (yyrh = yyoption->yystate, yyn = yyrhsLength (yyoption->yyrule);
+               yyn > 0;
+               yyrh = yyrh->yypred, yyn -= 1)
+            yydestroyGLRState (yymsg, yyrh]b4_user_args[);
+        }
+    }
+}
+
+/** Left-hand-side symbol for rule #YYRULE.  */
+static inline yySymbol
+yylhsNonterm (yyRuleNum yyrule)
+{
+  return yyr1[yyrule];
+}
+
+#define yypact_value_is_default(Yyn) \
+  ]b4_table_value_equals([[pact]], [[Yyn]], [b4_pact_ninf], [YYPACT_NINF])[
+
+/** True iff LR state YYSTATE has only a default reduction (regardless
+ *  of token).  */
+static inline yybool
+yyisDefaultedState (yyStateNum yystate)
+{
+  return yypact_value_is_default (yypact[yystate]);
+}
+
+/** The default reduction for YYSTATE, assuming it has one.  */
+static inline yyRuleNum
+yydefaultAction (yyStateNum yystate)
+{
+  return yydefact[yystate];
+}
+
+#define yytable_value_is_error(Yyn) \
+  ]b4_table_value_equals([[table]], [[Yyn]], [b4_table_ninf], [YYTABLE_NINF])[
+
+/** The action to take in YYSTATE on seeing YYTOKEN.
+ *  Result R means
+ *    R < 0:  Reduce on rule -R.
+ *    R = 0:  Error.
+ *    R > 0:  Shift to state R.
+ *  Set *YYCONFLICTS to a pointer into yyconfl to a 0-terminated list
+ *  of conflicting reductions.
+ */
+static inline int
+yygetLRActions (yyStateNum yystate, yySymbol yytoken, const short** yyconflicts)
+{
+  int yyindex = yypact[yystate] + yytoken;
+  if (yyisDefaultedState (yystate)
+      || yyindex < 0 || YYLAST < yyindex || yycheck[yyindex] != yytoken)
+    {
+      *yyconflicts = yyconfl;
+      return -yydefact[yystate];
+    }
+  else if (! yytable_value_is_error (yytable[yyindex]))
+    {
+      *yyconflicts = yyconfl + yyconflp[yyindex];
+      return yytable[yyindex];
+    }
+  else
+    {
+      *yyconflicts = yyconfl + yyconflp[yyindex];
+      return 0;
+    }
+}
+
+/** Compute post-reduction state.
+ * \param yystate   the current state
+ * \param yysym     the nonterminal to push on the stack
+ */
+static inline yyStateNum
+yyLRgotoState (yyStateNum yystate, yySymbol yysym)
+{
+  int yyr = yypgoto[yysym - YYNTOKENS] + yystate;
+  if (0 <= yyr && yyr <= YYLAST && yycheck[yyr] == yystate)
+    return yytable[yyr];
+  else
+    return yydefgoto[yysym - YYNTOKENS];
+}
+
+static inline yybool
+yyisShiftAction (int yyaction)
+{
+  return 0 < yyaction;
+}
+
+static inline yybool
+yyisErrorAction (int yyaction)
+{
+  return yyaction == 0;
+}
+
+                                /* GLRStates */
+
+/** Return a fresh GLRStackItem in YYSTACKP.  The item is an LR state
+ *  if YYISSTATE, and otherwise a semantic option.  Callers should call
+ *  YY_RESERVE_GLRSTACK afterwards to make sure there is sufficient
+ *  headroom.  */
+
+static inline yyGLRStackItem*
+yynewGLRStackItem (yyGLRStack* yystackp, yybool yyisState)
+{
+  yyGLRStackItem* yynewItem = yystackp->yynextFree;
+  yystackp->yyspaceLeft -= 1;
+  yystackp->yynextFree += 1;
+  yynewItem->yystate.yyisState = yyisState;
+  return yynewItem;
+}
+
+/** Add a new semantic action that will execute the action for rule
+ *  YYRULE on the semantic values in YYRHS to the list of
+ *  alternative actions for YYSTATE.  Assumes that YYRHS comes from
+ *  stack #YYK of *YYSTACKP. */
+static void
+yyaddDeferredAction (yyGLRStack* yystackp, ptrdiff_t yyk, yyGLRState* yystate,
+                     yyGLRState* yyrhs, yyRuleNum yyrule)
+{
+  yySemanticOption* yynewOption =
+    &yynewGLRStackItem (yystackp, yyfalse)->yyoption;
+  YY_ASSERT (!yynewOption->yyisState);
+  yynewOption->yystate = yyrhs;
+  yynewOption->yyrule = yyrule;
+  if (yystackp->yytops.yylookaheadNeeds[yyk])
+    {
+      yynewOption->yyrawchar = yychar;
+      yynewOption->yyval = yylval;]b4_locations_if([
+      yynewOption->yyloc = yylloc;])[
+    }
+  else
+    yynewOption->yyrawchar = YYEMPTY;
+  yynewOption->yynext = yystate->yysemantics.yyfirstVal;
+  yystate->yysemantics.yyfirstVal = yynewOption;
+
+  YY_RESERVE_GLRSTACK (yystackp);
+}
+
+                                /* GLRStacks */
+
+/** Initialize YYSET to a singleton set containing an empty stack.  */
+static yybool
+yyinitStateSet (yyGLRStateSet* yyset)
+{
+  yyset->yysize = 1;
+  yyset->yycapacity = 16;
+  yyset->yystates
+    = YY_CAST (yyGLRState**,
+               YYMALLOC (YY_CAST (size_t, yyset->yycapacity)
+                         * sizeof yyset->yystates[0]));
+  if (! yyset->yystates)
+    return yyfalse;
+  yyset->yystates[0] = YY_NULLPTR;
+  yyset->yylookaheadNeeds
+    = YY_CAST (yybool*,
+               YYMALLOC (YY_CAST (size_t, yyset->yycapacity)
+                         * sizeof yyset->yylookaheadNeeds[0]));
+  if (! yyset->yylookaheadNeeds)
+    {
+      YYFREE (yyset->yystates);
+      return yyfalse;
+    }
+  memset (yyset->yylookaheadNeeds,
+          0,
+          YY_CAST (size_t, yyset->yycapacity) * sizeof yyset->yylookaheadNeeds[0]);
+  return yytrue;
+}
+
+static void yyfreeStateSet (yyGLRStateSet* yyset)
+{
+  YYFREE (yyset->yystates);
+  YYFREE (yyset->yylookaheadNeeds);
+}
+
+/** Initialize *YYSTACKP to a single empty stack, with total maximum
+ *  capacity for all stacks of YYSIZE.  */
+static yybool
+yyinitGLRStack (yyGLRStack* yystackp, ptrdiff_t yysize)
+{
+  yystackp->yyerrState = 0;
+  yynerrs = 0;
+  yystackp->yyspaceLeft = yysize;
+  yystackp->yyitems
+    = YY_CAST (yyGLRStackItem*,
+               YYMALLOC (YY_CAST (size_t, yysize)
+                         * sizeof yystackp->yynextFree[0]));
+  if (!yystackp->yyitems)
+    return yyfalse;
+  yystackp->yynextFree = yystackp->yyitems;
+  yystackp->yysplitPoint = YY_NULLPTR;
+  yystackp->yylastDeleted = YY_NULLPTR;
+  return yyinitStateSet (&yystackp->yytops);
+}
+
+
+#if YYSTACKEXPANDABLE
+# define YYRELOC(YYFROMITEMS, YYTOITEMS, YYX, YYTYPE)                   \
+  &((YYTOITEMS)                                                         \
+    - ((YYFROMITEMS) - YY_REINTERPRET_CAST (yyGLRStackItem*, (YYX))))->YYTYPE
+
+/** If *YYSTACKP is expandable, extend it.  WARNING: Pointers into the
+    stack from outside should be considered invalid after this call.
+    We always expand when there are 1 or fewer items left AFTER an
+    allocation, so that we can avoid having external pointers exist
+    across an allocation.  */
+static void
+yyexpandGLRStack (yyGLRStack* yystackp)
+{
+  yyGLRStackItem* yynewItems;
+  yyGLRStackItem* yyp0, *yyp1;
+  ptrdiff_t yynewSize;
+  ptrdiff_t yyn;
+  ptrdiff_t yysize = yystackp->yynextFree - yystackp->yyitems;
+  if (YYMAXDEPTH - YYHEADROOM < yysize)
+    yyMemoryExhausted (yystackp);
+  yynewSize = 2*yysize;
+  if (YYMAXDEPTH < yynewSize)
+    yynewSize = YYMAXDEPTH;
+  yynewItems
+    = YY_CAST (yyGLRStackItem*,
+               YYMALLOC (YY_CAST (size_t, yynewSize)
+                         * sizeof yynewItems[0]));
+  if (! yynewItems)
+    yyMemoryExhausted (yystackp);
+  for (yyp0 = yystackp->yyitems, yyp1 = yynewItems, yyn = yysize;
+       0 < yyn;
+       yyn -= 1, yyp0 += 1, yyp1 += 1)
+    {
+      *yyp1 = *yyp0;
+      if (*YY_REINTERPRET_CAST (yybool *, yyp0))
+        {
+          yyGLRState* yys0 = &yyp0->yystate;
+          yyGLRState* yys1 = &yyp1->yystate;
+          if (yys0->yypred != YY_NULLPTR)
+            yys1->yypred =
+              YYRELOC (yyp0, yyp1, yys0->yypred, yystate);
+          if (! yys0->yyresolved && yys0->yysemantics.yyfirstVal != YY_NULLPTR)
+            yys1->yysemantics.yyfirstVal =
+              YYRELOC (yyp0, yyp1, yys0->yysemantics.yyfirstVal, yyoption);
+        }
+      else
+        {
+          yySemanticOption* yyv0 = &yyp0->yyoption;
+          yySemanticOption* yyv1 = &yyp1->yyoption;
+          if (yyv0->yystate != YY_NULLPTR)
+            yyv1->yystate = YYRELOC (yyp0, yyp1, yyv0->yystate, yystate);
+          if (yyv0->yynext != YY_NULLPTR)
+            yyv1->yynext = YYRELOC (yyp0, yyp1, yyv0->yynext, yyoption);
+        }
+    }
+  if (yystackp->yysplitPoint != YY_NULLPTR)
+    yystackp->yysplitPoint = YYRELOC (yystackp->yyitems, yynewItems,
+                                      yystackp->yysplitPoint, yystate);
+
+  for (yyn = 0; yyn < yystackp->yytops.yysize; yyn += 1)
+    if (yystackp->yytops.yystates[yyn] != YY_NULLPTR)
+      yystackp->yytops.yystates[yyn] =
+        YYRELOC (yystackp->yyitems, yynewItems,
+                 yystackp->yytops.yystates[yyn], yystate);
+  YYFREE (yystackp->yyitems);
+  yystackp->yyitems = yynewItems;
+  yystackp->yynextFree = yynewItems + yysize;
+  yystackp->yyspaceLeft = yynewSize - yysize;
+}
+#endif
+
+static void
+yyfreeGLRStack (yyGLRStack* yystackp)
+{
+  YYFREE (yystackp->yyitems);
+  yyfreeStateSet (&yystackp->yytops);
+}
+
+/** Assuming that YYS is a GLRState somewhere on *YYSTACKP, update the
+ *  splitpoint of *YYSTACKP, if needed, so that it is at least as deep as
+ *  YYS.  */
+static inline void
+yyupdateSplit (yyGLRStack* yystackp, yyGLRState* yys)
+{
+  if (yystackp->yysplitPoint != YY_NULLPTR && yystackp->yysplitPoint > yys)
+    yystackp->yysplitPoint = yys;
+}
+
+/** Invalidate stack #YYK in *YYSTACKP.  */
+static inline void
+yymarkStackDeleted (yyGLRStack* yystackp, ptrdiff_t yyk)
+{
+  if (yystackp->yytops.yystates[yyk] != YY_NULLPTR)
+    yystackp->yylastDeleted = yystackp->yytops.yystates[yyk];
+  yystackp->yytops.yystates[yyk] = YY_NULLPTR;
+}
+
+/** Undelete the last stack in *YYSTACKP that was marked as deleted.  Can
+    only be done once after a deletion, and only when all other stacks have
+    been deleted.  */
+static void
+yyundeleteLastStack (yyGLRStack* yystackp)
+{
+  if (yystackp->yylastDeleted == YY_NULLPTR || yystackp->yytops.yysize != 0)
+    return;
+  yystackp->yytops.yystates[0] = yystackp->yylastDeleted;
+  yystackp->yytops.yysize = 1;
+  YY_DPRINTF ((stderr, "Restoring last deleted stack as stack #0.\n"));
+  yystackp->yylastDeleted = YY_NULLPTR;
+}
+
+static inline void
+yyremoveDeletes (yyGLRStack* yystackp)
+{
+  ptrdiff_t yyi, yyj;
+  yyi = yyj = 0;
+  while (yyj < yystackp->yytops.yysize)
+    {
+      if (yystackp->yytops.yystates[yyi] == YY_NULLPTR)
+        {
+          if (yyi == yyj)
+            YY_DPRINTF ((stderr, "Removing dead stacks.\n"));
+          yystackp->yytops.yysize -= 1;
+        }
+      else
+        {
+          yystackp->yytops.yystates[yyj] = yystackp->yytops.yystates[yyi];
+          /* In the current implementation, it's unnecessary to copy
+             yystackp->yytops.yylookaheadNeeds[yyi] since, after
+             yyremoveDeletes returns, the parser immediately either enters
+             deterministic operation or shifts a token.  However, it doesn't
+             hurt, and the code might evolve to need it.  */
+          yystackp->yytops.yylookaheadNeeds[yyj] =
+            yystackp->yytops.yylookaheadNeeds[yyi];
+          if (yyj != yyi)
+            YY_DPRINTF ((stderr, "Rename stack %ld -> %ld.\n",
+                        YY_CAST (long, yyi), YY_CAST (long, yyj)));
+          yyj += 1;
+        }
+      yyi += 1;
+    }
+}
+
+/** Shift to a new state on stack #YYK of *YYSTACKP, corresponding to LR
+ * state YYLRSTATE, at input position YYPOSN, with (resolved) semantic
+ * value *YYVALP and source location *YYLOCP.  */
+static inline void
+yyglrShift (yyGLRStack* yystackp, ptrdiff_t yyk, yyStateNum yylrState,
+            ptrdiff_t yyposn,
+            YYSTYPE* yyvalp]b4_locations_if([, YYLTYPE* yylocp])[)
+{
+  yyGLRState* yynewState = &yynewGLRStackItem (yystackp, yytrue)->yystate;
+
+  yynewState->yylrState = yylrState;
+  yynewState->yyposn = yyposn;
+  yynewState->yyresolved = yytrue;
+  yynewState->yypred = yystackp->yytops.yystates[yyk];
+  yynewState->yysemantics.yysval = *yyvalp;]b4_locations_if([
+  yynewState->yyloc = *yylocp;])[
+  yystackp->yytops.yystates[yyk] = yynewState;
+
+  YY_RESERVE_GLRSTACK (yystackp);
+}
+
+/** Shift stack #YYK of *YYSTACKP, to a new state corresponding to LR
+ *  state YYLRSTATE, at input position YYPOSN, with the (unresolved)
+ *  semantic value of YYRHS under the action for YYRULE.  */
+static inline void
+yyglrShiftDefer (yyGLRStack* yystackp, ptrdiff_t yyk, yyStateNum yylrState,
+                 ptrdiff_t yyposn, yyGLRState* yyrhs, yyRuleNum yyrule)
+{
+  yyGLRState* yynewState = &yynewGLRStackItem (yystackp, yytrue)->yystate;
+  YY_ASSERT (yynewState->yyisState);
+
+  yynewState->yylrState = yylrState;
+  yynewState->yyposn = yyposn;
+  yynewState->yyresolved = yyfalse;
+  yynewState->yypred = yystackp->yytops.yystates[yyk];
+  yynewState->yysemantics.yyfirstVal = YY_NULLPTR;
+  yystackp->yytops.yystates[yyk] = yynewState;
+
+  /* Invokes YY_RESERVE_GLRSTACK.  */
+  yyaddDeferredAction (yystackp, yyk, yynewState, yyrhs, yyrule);
+}
+
+#if !]b4_api_PREFIX[DEBUG
+# define YY_REDUCE_PRINT(Args)
+#else
+# define YY_REDUCE_PRINT(Args)          \
+  do {                                  \
+    if (yydebug)                        \
+      yy_reduce_print Args;             \
+  } while (0)
+
+/*----------------------------------------------------------------------.
+| Report that stack #YYK of *YYSTACKP is going to be reduced by YYRULE. |
+`----------------------------------------------------------------------*/
+
+static inline void
+yy_reduce_print (yybool yynormal, yyGLRStackItem* yyvsp, ptrdiff_t yyk,
+                 yyRuleNum yyrule]b4_user_formals[)
+{
+  int yynrhs = yyrhsLength (yyrule);]b4_locations_if([
+  int yylow = 1;])[
+  int yyi;
+  YY_FPRINTF ((stderr, "Reducing stack %ld by rule %d (line %d):\n",
+               YY_CAST (long, yyk), yyrule - 1, yyrline[yyrule]));
+  if (! yynormal)
+    yyfillin (yyvsp, 1, -yynrhs);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YY_FPRINTF ((stderr, "   $%d = ", yyi + 1));
+      yy_symbol_print (stderr,
+                       yystos[yyvsp[yyi - yynrhs + 1].yystate.yylrState],
+                       &yyvsp[yyi - yynrhs + 1].yystate.yysemantics.yysval]b4_locations_if([,
+                       &]b4_rhs_location(yynrhs, yyi + 1))[]dnl
+                       b4_user_args[);
+      if (!yyvsp[yyi - yynrhs + 1].yystate.yyresolved)
+        YY_FPRINTF ((stderr, " (unresolved)"));
+      YY_FPRINTF ((stderr, "\n"));
+    }
+}
+#endif
+
+/** Pop the symbols consumed by reduction #YYRULE from the top of stack
+ *  #YYK of *YYSTACKP, and perform the appropriate semantic action on their
+ *  semantic values.  Assumes that all ambiguities in semantic values
+ *  have been previously resolved.  Set *YYVALP to the resulting value,
+ *  and *YYLOCP to the computed location (if any).  Return value is as
+ *  for userAction.  */
+static inline YYRESULTTAG
+yydoAction (yyGLRStack* yystackp, ptrdiff_t yyk, yyRuleNum yyrule,
+            YYSTYPE* yyvalp]b4_locuser_formals[)
+{
+  int yynrhs = yyrhsLength (yyrule);
+
+  if (yystackp->yysplitPoint == YY_NULLPTR)
+    {
+      /* Standard special case: single stack.  */
+      yyGLRStackItem* yyrhs
+        = YY_REINTERPRET_CAST (yyGLRStackItem*, yystackp->yytops.yystates[yyk]);
+      YY_ASSERT (yyk == 0);
+      yystackp->yynextFree -= yynrhs;
+      yystackp->yyspaceLeft += yynrhs;
+      yystackp->yytops.yystates[0] = & yystackp->yynextFree[-1].yystate;
+      YY_REDUCE_PRINT ((yytrue, yyrhs, yyk, yyrule]b4_user_args[));
+      return yyuserAction (yyrule, yynrhs, yyrhs, yystackp,
+                           yyvalp]b4_locuser_args[);
+    }
+  else
+    {
+      yyGLRStackItem yyrhsVals[YYMAXRHS + YYMAXLEFT + 1];
+      yyGLRState* yys = yyrhsVals[YYMAXRHS + YYMAXLEFT].yystate.yypred
+        = yystackp->yytops.yystates[yyk];
+      int yyi;]b4_locations_if([[
+      if (yynrhs == 0)
+        /* Set default location.  */
+        yyrhsVals[YYMAXRHS + YYMAXLEFT - 1].yystate.yyloc = yys->yyloc;]])[
+      for (yyi = 0; yyi < yynrhs; yyi += 1)
+        {
+          yys = yys->yypred;
+          YY_ASSERT (yys);
+        }
+      yyupdateSplit (yystackp, yys);
+      yystackp->yytops.yystates[yyk] = yys;
+      YY_REDUCE_PRINT ((yyfalse, yyrhsVals + YYMAXRHS + YYMAXLEFT - 1, yyk, yyrule]b4_user_args[));
+      return yyuserAction (yyrule, yynrhs, yyrhsVals + YYMAXRHS + YYMAXLEFT - 1,
+                           yystackp, yyvalp]b4_locuser_args[);
+    }
+}
+
+/** Pop items off stack #YYK of *YYSTACKP according to grammar rule YYRULE,
+ *  and push back on the resulting nonterminal symbol.  Perform the
+ *  semantic action associated with YYRULE and store its value with the
+ *  newly pushed state, if YYFORCEEVAL or if *YYSTACKP is currently
+ *  unambiguous.  Otherwise, store the deferred semantic action with
+ *  the new state.  If the new state would have an identical input
+ *  position, LR state, and predecessor to an existing state on the stack,
+ *  it is identified with that existing state, eliminating stack #YYK from
+ *  *YYSTACKP.  In this case, the semantic value is
+ *  added to the options for the existing state's semantic value.
+ */
+static inline YYRESULTTAG
+yyglrReduce (yyGLRStack* yystackp, ptrdiff_t yyk, yyRuleNum yyrule,
+             yybool yyforceEval]b4_user_formals[)
+{
+  ptrdiff_t yyposn = yystackp->yytops.yystates[yyk]->yyposn;
+
+  if (yyforceEval || yystackp->yysplitPoint == YY_NULLPTR)
+    {
+      YYSTYPE yysval;]b4_locations_if([[
+      YYLTYPE yyloc;]])[
+
+      YYRESULTTAG yyflag = yydoAction (yystackp, yyk, yyrule, &yysval]b4_locuser_args([&yyloc])[);
+      if (yyflag == yyerr && yystackp->yysplitPoint != YY_NULLPTR)
+        YY_DPRINTF ((stderr,
+                     "Parse on stack %ld rejected by rule %d (line %d).\n",
+                     YY_CAST (long, yyk), yyrule - 1, yyrline[yyrule - 1]));
+      if (yyflag != yyok)
+        return yyflag;
+      YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyrule], &yysval, &yyloc);
+      yyglrShift (yystackp, yyk,
+                  yyLRgotoState (yystackp->yytops.yystates[yyk]->yylrState,
+                                 yylhsNonterm (yyrule)),
+                  yyposn, &yysval]b4_locations_if([, &yyloc])[);
+    }
+  else
+    {
+      ptrdiff_t yyi;
+      int yyn;
+      yyGLRState* yys, *yys0 = yystackp->yytops.yystates[yyk];
+      yyStateNum yynewLRState;
+
+      for (yys = yystackp->yytops.yystates[yyk], yyn = yyrhsLength (yyrule);
+           0 < yyn; yyn -= 1)
+        {
+          yys = yys->yypred;
+          YY_ASSERT (yys);
+        }
+      yyupdateSplit (yystackp, yys);
+      yynewLRState = yyLRgotoState (yys->yylrState, yylhsNonterm (yyrule));
+      YY_DPRINTF ((stderr,
+                   "Reduced stack %ld by rule %d (line %d); action deferred.  "
+                   "Now in state %d.\n",
+                   YY_CAST (long, yyk), yyrule - 1, yyrline[yyrule - 1],
+                   yynewLRState));
+      for (yyi = 0; yyi < yystackp->yytops.yysize; yyi += 1)
+        if (yyi != yyk && yystackp->yytops.yystates[yyi] != YY_NULLPTR)
+          {
+            yyGLRState *yysplit = yystackp->yysplitPoint;
+            yyGLRState *yyp = yystackp->yytops.yystates[yyi];
+            while (yyp != yys && yyp != yysplit && yyp->yyposn >= yyposn)
+              {
+                if (yyp->yylrState == yynewLRState && yyp->yypred == yys)
+                  {
+                    yyaddDeferredAction (yystackp, yyk, yyp, yys0, yyrule);
+                    yymarkStackDeleted (yystackp, yyk);
+                    YY_DPRINTF ((stderr, "Merging stack %ld into stack %ld.\n",
+                                 YY_CAST (long, yyk), YY_CAST (long, yyi)));
+                    return yyok;
+                  }
+                yyp = yyp->yypred;
+              }
+          }
+      yystackp->yytops.yystates[yyk] = yys;
+      yyglrShiftDefer (yystackp, yyk, yynewLRState, yyposn, yys0, yyrule);
+    }
+  return yyok;
+}
+
+static ptrdiff_t
+yysplitStack (yyGLRStack* yystackp, ptrdiff_t yyk)
+{
+  if (yystackp->yysplitPoint == YY_NULLPTR)
+    {
+      YY_ASSERT (yyk == 0);
+      yystackp->yysplitPoint = yystackp->yytops.yystates[yyk];
+    }
+  if (yystackp->yytops.yycapacity <= yystackp->yytops.yysize)
+    {
+      ptrdiff_t state_size = sizeof yystackp->yytops.yystates[0];
+      ptrdiff_t half_max_capacity = YYSIZEMAX / 2 / state_size;
+      if (half_max_capacity < yystackp->yytops.yycapacity)
+        yyMemoryExhausted (yystackp);
+      yystackp->yytops.yycapacity *= 2;
+
+      {
+        yyGLRState** yynewStates
+          = YY_CAST (yyGLRState**,
+                     YYREALLOC (yystackp->yytops.yystates,
+                                (YY_CAST (size_t, yystackp->yytops.yycapacity)
+                                 * sizeof yynewStates[0])));
+        if (yynewStates == YY_NULLPTR)
+          yyMemoryExhausted (yystackp);
+        yystackp->yytops.yystates = yynewStates;
+      }
+
+      {
+        yybool* yynewLookaheadNeeds
+          = YY_CAST (yybool*,
+                     YYREALLOC (yystackp->yytops.yylookaheadNeeds,
+                                (YY_CAST (size_t, yystackp->yytops.yycapacity)
+                                 * sizeof yynewLookaheadNeeds[0])));
+        if (yynewLookaheadNeeds == YY_NULLPTR)
+          yyMemoryExhausted (yystackp);
+        yystackp->yytops.yylookaheadNeeds = yynewLookaheadNeeds;
+      }
+    }
+  yystackp->yytops.yystates[yystackp->yytops.yysize]
+    = yystackp->yytops.yystates[yyk];
+  yystackp->yytops.yylookaheadNeeds[yystackp->yytops.yysize]
+    = yystackp->yytops.yylookaheadNeeds[yyk];
+  yystackp->yytops.yysize += 1;
+  return yystackp->yytops.yysize - 1;
+}
+
+/** True iff YYY0 and YYY1 represent identical options at the top level.
+ *  That is, they represent the same rule applied to RHS symbols
+ *  that produce the same terminal symbols.  */
+static yybool
+yyidenticalOptions (yySemanticOption* yyy0, yySemanticOption* yyy1)
+{
+  if (yyy0->yyrule == yyy1->yyrule)
+    {
+      yyGLRState *yys0, *yys1;
+      int yyn;
+      for (yys0 = yyy0->yystate, yys1 = yyy1->yystate,
+           yyn = yyrhsLength (yyy0->yyrule);
+           yyn > 0;
+           yys0 = yys0->yypred, yys1 = yys1->yypred, yyn -= 1)
+        if (yys0->yyposn != yys1->yyposn)
+          return yyfalse;
+      return yytrue;
+    }
+  else
+    return yyfalse;
+}
+
+/** Assuming identicalOptions (YYY0,YYY1), destructively merge the
+ *  alternative semantic values for the RHS-symbols of YYY1 and YYY0.  */
+static void
+yymergeOptionSets (yySemanticOption* yyy0, yySemanticOption* yyy1)
+{
+  yyGLRState *yys0, *yys1;
+  int yyn;
+  for (yys0 = yyy0->yystate, yys1 = yyy1->yystate,
+       yyn = yyrhsLength (yyy0->yyrule);
+       0 < yyn;
+       yys0 = yys0->yypred, yys1 = yys1->yypred, yyn -= 1)
+    {
+      if (yys0 == yys1)
+        break;
+      else if (yys0->yyresolved)
+        {
+          yys1->yyresolved = yytrue;
+          yys1->yysemantics.yysval = yys0->yysemantics.yysval;
+        }
+      else if (yys1->yyresolved)
+        {
+          yys0->yyresolved = yytrue;
+          yys0->yysemantics.yysval = yys1->yysemantics.yysval;
+        }
+      else
+        {
+          yySemanticOption** yyz0p = &yys0->yysemantics.yyfirstVal;
+          yySemanticOption* yyz1 = yys1->yysemantics.yyfirstVal;
+          while (yytrue)
+            {
+              if (yyz1 == *yyz0p || yyz1 == YY_NULLPTR)
+                break;
+              else if (*yyz0p == YY_NULLPTR)
+                {
+                  *yyz0p = yyz1;
+                  break;
+                }
+              else if (*yyz0p < yyz1)
+                {
+                  yySemanticOption* yyz = *yyz0p;
+                  *yyz0p = yyz1;
+                  yyz1 = yyz1->yynext;
+                  (*yyz0p)->yynext = yyz;
+                }
+              yyz0p = &(*yyz0p)->yynext;
+            }
+          yys1->yysemantics.yyfirstVal = yys0->yysemantics.yyfirstVal;
+        }
+    }
+}
+
+/** Y0 and Y1 represent two possible actions to take in a given
+ *  parsing state; return 0 if no combination is possible,
+ *  1 if user-mergeable, 2 if Y0 is preferred, 3 if Y1 is preferred.  */
+static int
+yypreference (yySemanticOption* y0, yySemanticOption* y1)
+{
+  yyRuleNum r0 = y0->yyrule, r1 = y1->yyrule;
+  int p0 = yydprec[r0], p1 = yydprec[r1];
+
+  if (p0 == p1)
+    {
+      if (yymerger[r0] == 0 || yymerger[r0] != yymerger[r1])
+        return 0;
+      else
+        return 1;
+    }
+  if (p0 == 0 || p1 == 0)
+    return 0;
+  if (p0 < p1)
+    return 3;
+  if (p1 < p0)
+    return 2;
+  return 0;
+}
+
+static YYRESULTTAG yyresolveValue (yyGLRState* yys,
+                                   yyGLRStack* yystackp]b4_user_formals[);
+
+
+/** Resolve the previous YYN states starting at and including state YYS
+ *  on *YYSTACKP. If result != yyok, some states may have been left
+ *  unresolved possibly with empty semantic option chains.  Regardless
+ *  of whether result = yyok, each state has been left with consistent
+ *  data so that yydestroyGLRState can be invoked if necessary.  */
+static YYRESULTTAG
+yyresolveStates (yyGLRState* yys, int yyn,
+                 yyGLRStack* yystackp]b4_user_formals[)
+{
+  if (0 < yyn)
+    {
+      YY_ASSERT (yys->yypred);
+      YYCHK (yyresolveStates (yys->yypred, yyn-1, yystackp]b4_user_args[));
+      if (! yys->yyresolved)
+        YYCHK (yyresolveValue (yys, yystackp]b4_user_args[));
+    }
+  return yyok;
+}
+
+/** Resolve the states for the RHS of YYOPT on *YYSTACKP, perform its
+ *  user action, and return the semantic value and location in *YYVALP
+ *  and *YYLOCP.  Regardless of whether result = yyok, all RHS states
+ *  have been destroyed (assuming the user action destroys all RHS
+ *  semantic values if invoked).  */
+static YYRESULTTAG
+yyresolveAction (yySemanticOption* yyopt, yyGLRStack* yystackp,
+                 YYSTYPE* yyvalp]b4_locuser_formals[)
+{
+  yyGLRStackItem yyrhsVals[YYMAXRHS + YYMAXLEFT + 1];
+  int yynrhs = yyrhsLength (yyopt->yyrule);
+  YYRESULTTAG yyflag =
+    yyresolveStates (yyopt->yystate, yynrhs, yystackp]b4_user_args[);
+  if (yyflag != yyok)
+    {
+      yyGLRState *yys;
+      for (yys = yyopt->yystate; yynrhs > 0; yys = yys->yypred, yynrhs -= 1)
+        yydestroyGLRState ("Cleanup: popping", yys]b4_user_args[);
+      return yyflag;
+    }
+
+  yyrhsVals[YYMAXRHS + YYMAXLEFT].yystate.yypred = yyopt->yystate;]b4_locations_if([[
+  if (yynrhs == 0)
+    /* Set default location.  */
+    yyrhsVals[YYMAXRHS + YYMAXLEFT - 1].yystate.yyloc = yyopt->yystate->yyloc;]])[
+  {
+    int yychar_current = yychar;
+    YYSTYPE yylval_current = yylval;]b4_locations_if([
+    YYLTYPE yylloc_current = yylloc;])[
+    yychar = yyopt->yyrawchar;
+    yylval = yyopt->yyval;]b4_locations_if([
+    yylloc = yyopt->yyloc;])[
+    yyflag = yyuserAction (yyopt->yyrule, yynrhs,
+                           yyrhsVals + YYMAXRHS + YYMAXLEFT - 1,
+                           yystackp, yyvalp]b4_locuser_args[);
+    yychar = yychar_current;
+    yylval = yylval_current;]b4_locations_if([
+    yylloc = yylloc_current;])[
+  }
+  return yyflag;
+}
+
+#if ]b4_api_PREFIX[DEBUG
+static void
+yyreportTree (yySemanticOption* yyx, int yyindent)
+{
+  int yynrhs = yyrhsLength (yyx->yyrule);
+  int yyi;
+  yyGLRState* yys;
+  yyGLRState* yystates[1 + YYMAXRHS];
+  yyGLRState yyleftmost_state;
+
+  for (yyi = yynrhs, yys = yyx->yystate; 0 < yyi; yyi -= 1, yys = yys->yypred)
+    yystates[yyi] = yys;
+  if (yys == YY_NULLPTR)
+    {
+      yyleftmost_state.yyposn = 0;
+      yystates[0] = &yyleftmost_state;
+    }
+  else
+    yystates[0] = yys;
+
+  if (yyx->yystate->yyposn < yys->yyposn + 1)
+    YY_FPRINTF ((stderr, "%*s%s -> <Rule %d, empty>\n",
+                 yyindent, "", yytokenName (yylhsNonterm (yyx->yyrule)),
+                 yyx->yyrule - 1));
+  else
+    YY_FPRINTF ((stderr, "%*s%s -> <Rule %d, tokens %ld .. %ld>\n",
+                 yyindent, "", yytokenName (yylhsNonterm (yyx->yyrule)),
+                 yyx->yyrule - 1, YY_CAST (long, yys->yyposn + 1),
+                 YY_CAST (long, yyx->yystate->yyposn)));
+  for (yyi = 1; yyi <= yynrhs; yyi += 1)
+    {
+      if (yystates[yyi]->yyresolved)
+        {
+          if (yystates[yyi-1]->yyposn+1 > yystates[yyi]->yyposn)
+            YY_FPRINTF ((stderr, "%*s%s <empty>\n", yyindent+2, "",
+                         yytokenName (yystos[yystates[yyi]->yylrState])));
+          else
+            YY_FPRINTF ((stderr, "%*s%s <tokens %ld .. %ld>\n", yyindent+2, "",
+                         yytokenName (yystos[yystates[yyi]->yylrState]),
+                         YY_CAST (long, yystates[yyi-1]->yyposn + 1),
+                         YY_CAST (long, yystates[yyi]->yyposn)));
+        }
+      else
+        yyreportTree (yystates[yyi]->yysemantics.yyfirstVal, yyindent+2);
+    }
+}
+#endif
+
+static YYRESULTTAG
+yyreportAmbiguity (yySemanticOption* yyx0,
+                   yySemanticOption* yyx1]b4_pure_formals[)
+{
+  YYUSE (yyx0);
+  YYUSE (yyx1);
+
+#if ]b4_api_PREFIX[DEBUG
+  YY_FPRINTF ((stderr, "Ambiguity detected.\n"));
+  YY_FPRINTF ((stderr, "Option 1,\n"));
+  yyreportTree (yyx0, 2);
+  YY_FPRINTF ((stderr, "\nOption 2,\n"));
+  yyreportTree (yyx1, 2);
+  YY_FPRINTF ((stderr, "\n"));
+#endif
+
+  yyerror (]b4_yyerror_args[YY_("syntax is ambiguous"));
+  return yyabort;
+}]b4_locations_if([[
+
+/** Resolve the locations for each of the YYN1 states in *YYSTACKP,
+ *  ending at YYS1.  Has no effect on previously resolved states.
+ *  The first semantic option of a state is always chosen.  */
+static void
+yyresolveLocations (yyGLRState *yys1, int yyn1,
+                    yyGLRStack *yystackp]b4_user_formals[)
+{
+  if (0 < yyn1)
+    {
+      yyresolveLocations (yys1->yypred, yyn1 - 1, yystackp]b4_user_args[);
+      if (!yys1->yyresolved)
+        {
+          yyGLRStackItem yyrhsloc[1 + YYMAXRHS];
+          int yynrhs;
+          yySemanticOption *yyoption = yys1->yysemantics.yyfirstVal;
+          YY_ASSERT (yyoption);
+          yynrhs = yyrhsLength (yyoption->yyrule);
+          if (0 < yynrhs)
+            {
+              yyGLRState *yys;
+              int yyn;
+              yyresolveLocations (yyoption->yystate, yynrhs,
+                                  yystackp]b4_user_args[);
+              for (yys = yyoption->yystate, yyn = yynrhs;
+                   yyn > 0;
+                   yys = yys->yypred, yyn -= 1)
+                yyrhsloc[yyn].yystate.yyloc = yys->yyloc;
+            }
+          else
+            {
+              /* Both yyresolveAction and yyresolveLocations traverse the GSS
+                 in reverse rightmost order.  It is only necessary to invoke
+                 yyresolveLocations on a subforest for which yyresolveAction
+                 would have been invoked next had an ambiguity not been
+                 detected.  Thus the location of the previous state (but not
+                 necessarily the previous state itself) is guaranteed to be
+                 resolved already.  */
+              yyGLRState *yyprevious = yyoption->yystate;
+              yyrhsloc[0].yystate.yyloc = yyprevious->yyloc;
+            }
+          YYLLOC_DEFAULT ((yys1->yyloc), yyrhsloc, yynrhs);
+        }
+    }
+}]])[
+
+/** Resolve the ambiguity represented in state YYS in *YYSTACKP,
+ *  perform the indicated actions, and set the semantic value of YYS.
+ *  If result != yyok, the chain of semantic options in YYS has been
+ *  cleared instead or it has been left unmodified except that
+ *  redundant options may have been removed.  Regardless of whether
+ *  result = yyok, YYS has been left with consistent data so that
+ *  yydestroyGLRState can be invoked if necessary.  */
+static YYRESULTTAG
+yyresolveValue (yyGLRState* yys, yyGLRStack* yystackp]b4_user_formals[)
+{
+  yySemanticOption* yyoptionList = yys->yysemantics.yyfirstVal;
+  yySemanticOption* yybest = yyoptionList;
+  yySemanticOption** yypp;
+  yybool yymerge = yyfalse;
+  YYSTYPE yysval;
+  YYRESULTTAG yyflag;]b4_locations_if([
+  YYLTYPE *yylocp = &yys->yyloc;])[
+
+  for (yypp = &yyoptionList->yynext; *yypp != YY_NULLPTR; )
+    {
+      yySemanticOption* yyp = *yypp;
+
+      if (yyidenticalOptions (yybest, yyp))
+        {
+          yymergeOptionSets (yybest, yyp);
+          *yypp = yyp->yynext;
+        }
+      else
+        {
+          switch (yypreference (yybest, yyp))
+            {
+            case 0:]b4_locations_if([[
+              yyresolveLocations (yys, 1, yystackp]b4_user_args[);]])[
+              return yyreportAmbiguity (yybest, yyp]b4_pure_args[);
+              break;
+            case 1:
+              yymerge = yytrue;
+              break;
+            case 2:
+              break;
+            case 3:
+              yybest = yyp;
+              yymerge = yyfalse;
+              break;
+            default:
+              /* This cannot happen so it is not worth a YY_ASSERT (yyfalse),
+                 but some compilers complain if the default case is
+                 omitted.  */
+              break;
+            }
+          yypp = &yyp->yynext;
+        }
+    }
+
+  if (yymerge)
+    {
+      yySemanticOption* yyp;
+      int yyprec = yydprec[yybest->yyrule];
+      yyflag = yyresolveAction (yybest, yystackp, &yysval]b4_locuser_args[);
+      if (yyflag == yyok)
+        for (yyp = yybest->yynext; yyp != YY_NULLPTR; yyp = yyp->yynext)
+          {
+            if (yyprec == yydprec[yyp->yyrule])
+              {
+                YYSTYPE yysval_other;]b4_locations_if([
+                YYLTYPE yydummy;])[
+                yyflag = yyresolveAction (yyp, yystackp, &yysval_other]b4_locuser_args([&yydummy])[);
+                if (yyflag != yyok)
+                  {
+                    yydestruct ("Cleanup: discarding incompletely merged value for",
+                                yystos[yys->yylrState],
+                                &yysval]b4_locuser_args[);
+                    break;
+                  }
+                yyuserMerge (yymerger[yyp->yyrule], &yysval, &yysval_other);
+              }
+          }
+    }
+  else
+    yyflag = yyresolveAction (yybest, yystackp, &yysval]b4_locuser_args([yylocp])[);
+
+  if (yyflag == yyok)
+    {
+      yys->yyresolved = yytrue;
+      yys->yysemantics.yysval = yysval;
+    }
+  else
+    yys->yysemantics.yyfirstVal = YY_NULLPTR;
+  return yyflag;
+}
+
+static YYRESULTTAG
+yyresolveStack (yyGLRStack* yystackp]b4_user_formals[)
+{
+  if (yystackp->yysplitPoint != YY_NULLPTR)
+    {
+      yyGLRState* yys;
+      int yyn;
+
+      for (yyn = 0, yys = yystackp->yytops.yystates[0];
+           yys != yystackp->yysplitPoint;
+           yys = yys->yypred, yyn += 1)
+        continue;
+      YYCHK (yyresolveStates (yystackp->yytops.yystates[0], yyn, yystackp
+                             ]b4_user_args[));
+    }
+  return yyok;
+}
+
+static void
+yycompressStack (yyGLRStack* yystackp)
+{
+  yyGLRState* yyp, *yyq, *yyr;
+
+  if (yystackp->yytops.yysize != 1 || yystackp->yysplitPoint == YY_NULLPTR)
+    return;
+
+  for (yyp = yystackp->yytops.yystates[0], yyq = yyp->yypred, yyr = YY_NULLPTR;
+       yyp != yystackp->yysplitPoint;
+       yyr = yyp, yyp = yyq, yyq = yyp->yypred)
+    yyp->yypred = yyr;
+
+  yystackp->yyspaceLeft += yystackp->yynextFree - yystackp->yyitems;
+  yystackp->yynextFree = YY_REINTERPRET_CAST (yyGLRStackItem*, yystackp->yysplitPoint) + 1;
+  yystackp->yyspaceLeft -= yystackp->yynextFree - yystackp->yyitems;
+  yystackp->yysplitPoint = YY_NULLPTR;
+  yystackp->yylastDeleted = YY_NULLPTR;
+
+  while (yyr != YY_NULLPTR)
+    {
+      yystackp->yynextFree->yystate = *yyr;
+      yyr = yyr->yypred;
+      yystackp->yynextFree->yystate.yypred = &yystackp->yynextFree[-1].yystate;
+      yystackp->yytops.yystates[0] = &yystackp->yynextFree->yystate;
+      yystackp->yynextFree += 1;
+      yystackp->yyspaceLeft -= 1;
+    }
+}
+
+static YYRESULTTAG
+yyprocessOneStack (yyGLRStack* yystackp, ptrdiff_t yyk,
+                   ptrdiff_t yyposn]b4_pure_formals[)
+{
+  while (yystackp->yytops.yystates[yyk] != YY_NULLPTR)
+    {
+      yyStateNum yystate = yystackp->yytops.yystates[yyk]->yylrState;
+      YY_DPRINTF ((stderr, "Stack %ld Entering state %d\n", YY_CAST (long, yyk), yystate));
+
+      YY_ASSERT (yystate != YYFINAL);
+
+      if (yyisDefaultedState (yystate))
+        {
+          YYRESULTTAG yyflag;
+          yyRuleNum yyrule = yydefaultAction (yystate);
+          if (yyrule == 0)
+            {
+              YY_DPRINTF ((stderr, "Stack %ld dies.\n", YY_CAST (long, yyk)));
+              yymarkStackDeleted (yystackp, yyk);
+              return yyok;
+            }
+          yyflag = yyglrReduce (yystackp, yyk, yyrule, yyimmediate[yyrule]]b4_user_args[);
+          if (yyflag == yyerr)
+            {
+              YY_DPRINTF ((stderr,
+                           "Stack %ld dies "
+                           "(predicate failure or explicit user error).\n",
+                           YY_CAST (long, yyk)));
+              yymarkStackDeleted (yystackp, yyk);
+              return yyok;
+            }
+          if (yyflag != yyok)
+            return yyflag;
+        }
+      else
+        {
+          yySymbol yytoken = ]b4_yygetToken_call[;
+          const short* yyconflicts;
+          const int yyaction = yygetLRActions (yystate, yytoken, &yyconflicts);
+          yystackp->yytops.yylookaheadNeeds[yyk] = yytrue;
+
+          while (*yyconflicts != 0)
+            {
+              YYRESULTTAG yyflag;
+              ptrdiff_t yynewStack = yysplitStack (yystackp, yyk);
+              YY_DPRINTF ((stderr, "Splitting off stack %ld from %ld.\n",
+                           YY_CAST (long, yynewStack), YY_CAST (long, yyk)));
+              yyflag = yyglrReduce (yystackp, yynewStack,
+                                    *yyconflicts,
+                                    yyimmediate[*yyconflicts]]b4_user_args[);
+              if (yyflag == yyok)
+                YYCHK (yyprocessOneStack (yystackp, yynewStack,
+                                          yyposn]b4_pure_args[));
+              else if (yyflag == yyerr)
+                {
+                  YY_DPRINTF ((stderr, "Stack %ld dies.\n", YY_CAST (long, yynewStack)));
+                  yymarkStackDeleted (yystackp, yynewStack);
+                }
+              else
+                return yyflag;
+              yyconflicts += 1;
+            }
+
+          if (yyisShiftAction (yyaction))
+            break;
+          else if (yyisErrorAction (yyaction))
+            {
+              YY_DPRINTF ((stderr, "Stack %ld dies.\n", YY_CAST (long, yyk)));
+              yymarkStackDeleted (yystackp, yyk);
+              break;
+            }
+          else
+            {
+              YYRESULTTAG yyflag = yyglrReduce (yystackp, yyk, -yyaction,
+                                                yyimmediate[-yyaction]]b4_user_args[);
+              if (yyflag == yyerr)
+                {
+                  YY_DPRINTF ((stderr,
+                               "Stack %ld dies "
+                               "(predicate failure or explicit user error).\n",
+                               YY_CAST (long, yyk)));
+                  yymarkStackDeleted (yystackp, yyk);
+                  break;
+                }
+              else if (yyflag != yyok)
+                return yyflag;
+            }
+        }
+    }
+  return yyok;
+}
+
+static void
+yyreportSyntaxError (yyGLRStack* yystackp]b4_user_formals[)
+{
+  if (yystackp->yyerrState != 0)
+    return;
+#if ! YYERROR_VERBOSE
+  yyerror (]b4_lyyerror_args[YY_("syntax error"));
+#else
+  {
+  yySymbol yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+  yybool yysize_overflow = yyfalse;
+  char* yymsg = YY_NULLPTR;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat: reported tokens (one for the "unexpected",
+     one per "expected"). */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Actual size of YYARG. */
+  int yycount = 0;
+  /* Cumulated lengths of YYARG.  */
+  ptrdiff_t yysize = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[yystackp->yytops.yystates[0]->yylrState];
+      ptrdiff_t yysize0 = yytnamerr (YY_NULLPTR, yytokenName (yytoken));
+      yysize = yysize0;
+      yyarg[yycount++] = yytokenName (yytoken);
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for this
+             state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytokenName (yyx);
+                {
+                  ptrdiff_t yysz = yytnamerr (YY_NULLPTR, yytokenName (yyx));
+                  if (YYSIZEMAX - yysize < yysz)
+                    yysize_overflow = yytrue;
+                  else
+                    yysize += yysz;
+                }
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+#define YYCASE_(N, S)                   \
+      case N:                           \
+        yyformat = S;                   \
+      break
+    default: /* Avoid compiler warnings. */
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+#undef YYCASE_
+    }
+
+  {
+    /* Don't count the "%s"s in the final size, but reserve room for
+       the terminator.  */
+    ptrdiff_t yysz = YY_CAST (ptrdiff_t, strlen (yyformat)) - 2 * yycount + 1;
+    if (YYSIZEMAX - yysize < yysz)
+      yysize_overflow = yytrue;
+    else
+      yysize += yysz;
+  }
+
+  if (!yysize_overflow)
+    yymsg = YY_CAST (char *, YYMALLOC (YY_CAST (size_t, yysize)));
+
+  if (yymsg)
+    {
+      char *yyp = yymsg;
+      int yyi = 0;
+      while ((*yyp = *yyformat))
+        {
+          if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+            {
+              yyp += yytnamerr (yyp, yyarg[yyi++]);
+              yyformat += 2;
+            }
+          else
+            {
+              ++yyp;
+              ++yyformat;
+            }
+        }
+      yyerror (]b4_lyyerror_args[yymsg);
+      YYFREE (yymsg);
+    }
+  else
+    {
+      yyerror (]b4_lyyerror_args[YY_("syntax error"));
+      yyMemoryExhausted (yystackp);
+    }
+  }
+#endif /* YYERROR_VERBOSE */
+  yynerrs += 1;
+}
+
+/* Recover from a syntax error on *YYSTACKP, assuming that *YYSTACKP->YYTOKENP,
+   yylval, and yylloc are the syntactic category, semantic value, and location
+   of the lookahead.  */
+static void
+yyrecoverSyntaxError (yyGLRStack* yystackp]b4_user_formals[)
+{
+  if (yystackp->yyerrState == 3)
+    /* We just shifted the error token and (perhaps) took some
+       reductions.  Skip tokens until we can proceed.  */
+    while (yytrue)
+      {
+        yySymbol yytoken;
+        int yyj;
+        if (yychar == YYEOF)
+          yyFail (yystackp][]b4_lpure_args[, YY_NULLPTR);
+        if (yychar != YYEMPTY)
+          {]b4_locations_if([[
+            /* We throw away the lookahead, but the error range
+               of the shifted error token must take it into account.  */
+            yyGLRState *yys = yystackp->yytops.yystates[0];
+            yyGLRStackItem yyerror_range[3];
+            yyerror_range[1].yystate.yyloc = yys->yyloc;
+            yyerror_range[2].yystate.yyloc = yylloc;
+            YYLLOC_DEFAULT ((yys->yyloc), yyerror_range, 2);]])[
+            yytoken = YYTRANSLATE (yychar);
+            yydestruct ("Error: discarding",
+                        yytoken, &yylval]b4_locuser_args([&yylloc])[);
+            yychar = YYEMPTY;
+          }
+        yytoken = ]b4_yygetToken_call[;
+        yyj = yypact[yystackp->yytops.yystates[0]->yylrState];
+        if (yypact_value_is_default (yyj))
+          return;
+        yyj += yytoken;
+        if (yyj < 0 || YYLAST < yyj || yycheck[yyj] != yytoken)
+          {
+            if (yydefact[yystackp->yytops.yystates[0]->yylrState] != 0)
+              return;
+          }
+        else if (! yytable_value_is_error (yytable[yyj]))
+          return;
+      }
+
+  /* Reduce to one stack.  */
+  {
+    ptrdiff_t yyk;
+    for (yyk = 0; yyk < yystackp->yytops.yysize; yyk += 1)
+      if (yystackp->yytops.yystates[yyk] != YY_NULLPTR)
+        break;
+    if (yyk >= yystackp->yytops.yysize)
+      yyFail (yystackp][]b4_lpure_args[, YY_NULLPTR);
+    for (yyk += 1; yyk < yystackp->yytops.yysize; yyk += 1)
+      yymarkStackDeleted (yystackp, yyk);
+    yyremoveDeletes (yystackp);
+    yycompressStack (yystackp);
+  }
+
+  /* Now pop stack until we find a state that shifts the error token.  */
+  yystackp->yyerrState = 3;
+  while (yystackp->yytops.yystates[0] != YY_NULLPTR)
+    {
+      yyGLRState *yys = yystackp->yytops.yystates[0];
+      int yyj = yypact[yys->yylrState];
+      if (! yypact_value_is_default (yyj))
+        {
+          yyj += YYTERROR;
+          if (0 <= yyj && yyj <= YYLAST && yycheck[yyj] == YYTERROR
+              && yyisShiftAction (yytable[yyj]))
+            {
+              /* Shift the error token.  */
+              int yyaction = yytable[yyj];]b4_locations_if([[
+              /* First adjust its location.*/
+              YYLTYPE yyerrloc;
+              yystackp->yyerror_range[2].yystate.yyloc = yylloc;
+              YYLLOC_DEFAULT (yyerrloc, (yystackp->yyerror_range), 2);]])[
+              YY_SYMBOL_PRINT ("Shifting", yystos[yyaction],
+                               &yylval, &yyerrloc);
+              yyglrShift (yystackp, 0, yyaction,
+                          yys->yyposn, &yylval]b4_locations_if([, &yyerrloc])[);
+              yys = yystackp->yytops.yystates[0];
+              break;
+            }
+        }]b4_locations_if([[
+      yystackp->yyerror_range[1].yystate.yyloc = yys->yyloc;]])[
+      if (yys->yypred != YY_NULLPTR)
+        yydestroyGLRState ("Error: popping", yys]b4_user_args[);
+      yystackp->yytops.yystates[0] = yys->yypred;
+      yystackp->yynextFree -= 1;
+      yystackp->yyspaceLeft += 1;
+    }
+  if (yystackp->yytops.yystates[0] == YY_NULLPTR)
+    yyFail (yystackp][]b4_lpure_args[, YY_NULLPTR);
+}
+
+#define YYCHK1(YYE)                                                          \
+  do {                                                                       \
+    switch (YYE) {                                                           \
+    case yyok:                                                               \
+      break;                                                                 \
+    case yyabort:                                                            \
+      goto yyabortlab;                                                       \
+    case yyaccept:                                                           \
+      goto yyacceptlab;                                                      \
+    case yyerr:                                                              \
+      goto yyuser_error;                                                     \
+    default:                                                                 \
+      goto yybuglab;                                                         \
+    }                                                                        \
+  } while (0)
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+]b4_function_define([yyparse], [int], b4_parse_param)[
+{
+  int yyresult;
+  yyGLRStack yystack;
+  yyGLRStack* const yystackp = &yystack;
+  ptrdiff_t yyposn;
+
+  YY_DPRINTF ((stderr, "Starting parse\n"));
+
+  yychar = YYEMPTY;
+  yylval = yyval_default;]b4_locations_if([
+  yylloc = yyloc_default;])[
+]m4_ifdef([b4_initial_action], [
+b4_dollar_pushdef([yylval], [], [], [yylloc])dnl
+  b4_user_initial_action
+b4_dollar_popdef])[]dnl
+[
+  if (! yyinitGLRStack (yystackp, YYINITDEPTH))
+    goto yyexhaustedlab;
+  switch (YYSETJMP (yystack.yyexception_buffer))
+    {
+    case 0: break;
+    case 1: goto yyabortlab;
+    case 2: goto yyexhaustedlab;
+    default: goto yybuglab;
+    }
+  yyglrShift (&yystack, 0, 0, 0, &yylval]b4_locations_if([, &yylloc])[);
+  yyposn = 0;
+
+  while (yytrue)
+    {
+      /* For efficiency, we have two loops, the first of which is
+         specialized to deterministic operation (single stack, no
+         potential ambiguity).  */
+      /* Standard mode */
+      while (yytrue)
+        {
+          yyStateNum yystate = yystack.yytops.yystates[0]->yylrState;
+          YY_DPRINTF ((stderr, "Entering state %d\n", yystate));
+          if (yystate == YYFINAL)
+            goto yyacceptlab;
+          if (yyisDefaultedState (yystate))
+            {
+              yyRuleNum yyrule = yydefaultAction (yystate);
+              if (yyrule == 0)
+                {]b4_locations_if([[
+                  yystack.yyerror_range[1].yystate.yyloc = yylloc;]])[
+                  yyreportSyntaxError (&yystack]b4_user_args[);
+                  goto yyuser_error;
+                }
+              YYCHK1 (yyglrReduce (&yystack, 0, yyrule, yytrue]b4_user_args[));
+            }
+          else
+            {
+              yySymbol yytoken = ]b4_yygetToken_call;[
+              const short* yyconflicts;
+              int yyaction = yygetLRActions (yystate, yytoken, &yyconflicts);
+              if (*yyconflicts != 0)
+                break;
+              if (yyisShiftAction (yyaction))
+                {
+                  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+                  yychar = YYEMPTY;
+                  yyposn += 1;
+                  yyglrShift (&yystack, 0, yyaction, yyposn, &yylval]b4_locations_if([, &yylloc])[);
+                  if (0 < yystack.yyerrState)
+                    yystack.yyerrState -= 1;
+                }
+              else if (yyisErrorAction (yyaction))
+                {]b4_locations_if([[
+                  yystack.yyerror_range[1].yystate.yyloc = yylloc;]])[]b4_glr_cc_if([[
+                  /* Don't issue an error message again for exceptions
+                     thrown from the scanner.  */
+                  if (yychar != YYFAULTYTOK)
+  ]])[                  yyreportSyntaxError (&yystack]b4_user_args[);
+                  goto yyuser_error;
+                }
+              else
+                YYCHK1 (yyglrReduce (&yystack, 0, -yyaction, yytrue]b4_user_args[));
+            }
+        }
+
+      while (yytrue)
+        {
+          yySymbol yytoken_to_shift;
+          ptrdiff_t yys;
+
+          for (yys = 0; yys < yystack.yytops.yysize; yys += 1)
+            yystackp->yytops.yylookaheadNeeds[yys] = yychar != YYEMPTY;
+
+          /* yyprocessOneStack returns one of three things:
+
+              - An error flag.  If the caller is yyprocessOneStack, it
+                immediately returns as well.  When the caller is finally
+                yyparse, it jumps to an error label via YYCHK1.
+
+              - yyok, but yyprocessOneStack has invoked yymarkStackDeleted
+                (&yystack, yys), which sets the top state of yys to NULL.  Thus,
+                yyparse's following invocation of yyremoveDeletes will remove
+                the stack.
+
+              - yyok, when ready to shift a token.
+
+             Except in the first case, yyparse will invoke yyremoveDeletes and
+             then shift the next token onto all remaining stacks.  This
+             synchronization of the shift (that is, after all preceding
+             reductions on all stacks) helps prevent double destructor calls
+             on yylval in the event of memory exhaustion.  */
+
+          for (yys = 0; yys < yystack.yytops.yysize; yys += 1)
+            YYCHK1 (yyprocessOneStack (&yystack, yys, yyposn]b4_lpure_args[));
+          yyremoveDeletes (&yystack);
+          if (yystack.yytops.yysize == 0)
+            {
+              yyundeleteLastStack (&yystack);
+              if (yystack.yytops.yysize == 0)
+                yyFail (&yystack][]b4_lpure_args[, YY_("syntax error"));
+              YYCHK1 (yyresolveStack (&yystack]b4_user_args[));
+              YY_DPRINTF ((stderr, "Returning to deterministic operation.\n"));]b4_locations_if([[
+              yystack.yyerror_range[1].yystate.yyloc = yylloc;]])[
+              yyreportSyntaxError (&yystack]b4_user_args[);
+              goto yyuser_error;
+            }
+
+          /* If any yyglrShift call fails, it will fail after shifting.  Thus,
+             a copy of yylval will already be on stack 0 in the event of a
+             failure in the following loop.  Thus, yychar is set to YYEMPTY
+             before the loop to make sure the user destructor for yylval isn't
+             called twice.  */
+          yytoken_to_shift = YYTRANSLATE (yychar);
+          yychar = YYEMPTY;
+          yyposn += 1;
+          for (yys = 0; yys < yystack.yytops.yysize; yys += 1)
+            {
+              yyStateNum yystate = yystack.yytops.yystates[yys]->yylrState;
+              const short* yyconflicts;
+              int yyaction = yygetLRActions (yystate, yytoken_to_shift,
+                              &yyconflicts);
+              /* Note that yyconflicts were handled by yyprocessOneStack.  */
+              YY_DPRINTF ((stderr, "On stack %ld, ", YY_CAST (long, yys)));
+              YY_SYMBOL_PRINT ("shifting", yytoken_to_shift, &yylval, &yylloc);
+              yyglrShift (&yystack, yys, yyaction, yyposn,
+                          &yylval]b4_locations_if([, &yylloc])[);
+              YY_DPRINTF ((stderr, "Stack %ld now in state #%d\n",
+                           YY_CAST (long, yys),
+                           yystack.yytops.yystates[yys]->yylrState));
+            }
+
+          if (yystack.yytops.yysize == 1)
+            {
+              YYCHK1 (yyresolveStack (&yystack]b4_user_args[));
+              YY_DPRINTF ((stderr, "Returning to deterministic operation.\n"));
+              yycompressStack (&yystack);
+              break;
+            }
+        }
+      continue;
+    yyuser_error:
+      yyrecoverSyntaxError (&yystack]b4_user_args[);
+      yyposn = yystack.yytops.yystates[0]->yyposn;
+    }
+
+ yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+ yybuglab:
+  YY_ASSERT (yyfalse);
+  goto yyabortlab;
+
+ yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+ yyexhaustedlab:
+  yyerror (]b4_lyyerror_args[YY_("memory exhausted"));
+  yyresult = 2;
+  goto yyreturn;
+
+ yyreturn:
+  if (yychar != YYEMPTY)
+    yydestruct ("Cleanup: discarding lookahead",
+                YYTRANSLATE (yychar), &yylval]b4_locuser_args([&yylloc])[);
+
+  /* If the stack is well-formed, pop the stack until it is empty,
+     destroying its entries as we go.  But free the stack regardless
+     of whether it is well-formed.  */
+  if (yystack.yyitems)
+    {
+      yyGLRState** yystates = yystack.yytops.yystates;
+      if (yystates)
+        {
+          ptrdiff_t yysize = yystack.yytops.yysize;
+          ptrdiff_t yyk;
+          for (yyk = 0; yyk < yysize; yyk += 1)
+            if (yystates[yyk])
+              {
+                while (yystates[yyk])
+                  {
+                    yyGLRState *yys = yystates[yyk];]b4_locations_if([[
+                    yystack.yyerror_range[1].yystate.yyloc = yys->yyloc;]])[
+                    if (yys->yypred != YY_NULLPTR)
+                      yydestroyGLRState ("Cleanup: popping", yys]b4_user_args[);
+                    yystates[yyk] = yys->yypred;
+                    yystack.yynextFree -= 1;
+                    yystack.yyspaceLeft += 1;
+                  }
+                break;
+              }
+        }
+      yyfreeGLRStack (&yystack);
+    }
+
+  return yyresult;
+}
+
+/* DEBUGGING ONLY */
+#if ]b4_api_PREFIX[DEBUG
+static void
+yy_yypstack (yyGLRState* yys)
+{
+  if (yys->yypred)
+    {
+      yy_yypstack (yys->yypred);
+      YY_FPRINTF ((stderr, " -> "));
+    }
+  YY_FPRINTF ((stderr, "%d@@%ld", yys->yylrState, YY_CAST (long, yys->yyposn)));
+}
+
+static void
+yypstates (yyGLRState* yyst)
+{
+  if (yyst == YY_NULLPTR)
+    YY_FPRINTF ((stderr, "<null>"));
+  else
+    yy_yypstack (yyst);
+  YY_FPRINTF ((stderr, "\n"));
+}
+
+static void
+yypstack (yyGLRStack* yystackp, ptrdiff_t yyk)
+{
+  yypstates (yystackp->yytops.yystates[yyk]);
+}
+
+static void
+yypdumpstack (yyGLRStack* yystackp)
+{
+#define YYINDEX(YYX)                                                    \
+  YY_CAST (long,                                                        \
+           ((YYX)                                                       \
+            ? YY_REINTERPRET_CAST (yyGLRStackItem*, (YYX)) - yystackp->yyitems \
+            : -1))
+
+  yyGLRStackItem* yyp;
+  for (yyp = yystackp->yyitems; yyp < yystackp->yynextFree; yyp += 1)
+    {
+      YY_FPRINTF ((stderr, "%3ld. ",
+                   YY_CAST (long, yyp - yystackp->yyitems)));
+      if (*YY_REINTERPRET_CAST (yybool *, yyp))
+        {
+          YY_ASSERT (yyp->yystate.yyisState);
+          YY_ASSERT (yyp->yyoption.yyisState);
+          YY_FPRINTF ((stderr, "Res: %d, LR State: %d, posn: %ld, pred: %ld",
+                       yyp->yystate.yyresolved, yyp->yystate.yylrState,
+                       YY_CAST (long, yyp->yystate.yyposn),
+                       YYINDEX (yyp->yystate.yypred)));
+          if (! yyp->yystate.yyresolved)
+            YY_FPRINTF ((stderr, ", firstVal: %ld",
+                         YYINDEX (yyp->yystate.yysemantics.yyfirstVal)));
+        }
+      else
+        {
+          YY_ASSERT (!yyp->yystate.yyisState);
+          YY_ASSERT (!yyp->yyoption.yyisState);
+          YY_FPRINTF ((stderr, "Option. rule: %d, state: %ld, next: %ld",
+                       yyp->yyoption.yyrule - 1,
+                       YYINDEX (yyp->yyoption.yystate),
+                       YYINDEX (yyp->yyoption.yynext)));
+        }
+      YY_FPRINTF ((stderr, "\n"));
+    }
+
+  YY_FPRINTF ((stderr, "Tops:"));
+  {
+    ptrdiff_t yyi;
+    for (yyi = 0; yyi < yystackp->yytops.yysize; yyi += 1)
+      YY_FPRINTF ((stderr, "%ld: %ld; ", YY_CAST (long, yyi),
+                   YYINDEX (yystackp->yytops.yystates[yyi])));
+    YY_FPRINTF ((stderr, "\n"));
+  }
+#undef YYINDEX
+}
+#endif
+
+#undef yylval
+#undef yychar
+#undef yynerrs]b4_locations_if([
+#undef yylloc])
+
+m4_if(b4_prefix, [yy], [],
+[[/* Substitute the variable and function names.  */
+#define yyparse ]b4_prefix[parse
+#define yylex   ]b4_prefix[lex
+#define yyerror ]b4_prefix[error
+#define yylval  ]b4_prefix[lval
+#define yychar  ]b4_prefix[char
+#define yydebug ]b4_prefix[debug
+#define yynerrs ]b4_prefix[nerrs]b4_locations_if([[
+#define yylloc  ]b4_prefix[lloc]])])[
+
+]b4_epilogue[]dnl
+b4_output_end
diff --git a/common/bison/skeletons/glr.cc b/common/bison/skeletons/glr.cc
new file mode 100644
index 0000000000000000000000000000000000000000..343b52efd02d523444b510ba4c09640dd9a46e92
--- /dev/null
+++ b/common/bison/skeletons/glr.cc
@@ -0,0 +1,383 @@
+# C++ GLR skeleton for Bison
+
+# Copyright (C) 2002-2015, 2018-2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+# This skeleton produces a C++ class that encapsulates a C glr parser.
+# This is in order to reduce the maintenance burden.  The glr.c
+# skeleton is clean and pure enough so that there are no real
+# problems.  The C++ interface is the same as that of lalr1.cc.  In
+# fact, glr.c can replace yacc.c without the user noticing any
+# difference, and similarly for glr.cc replacing lalr1.cc.
+#
+# The passing of parse-params
+#
+#   The additional arguments are stored as members of the parser
+#   object, yyparser.  The C routines need to carry yyparser
+#   throughout the C parser; that's easy: make yyparser an
+#   additional parse-param.  But because the C++ skeleton needs to
+#   know the "real" original parse-param, we save them
+#   (b4_parse_param_orig).  Note that b4_parse_param is overquoted
+#   (and c.m4 strips one level of quotes).  This is a PITA, and
+#   explains why there are so many levels of quotes.
+#
+# The locations
+#
+#   We use location.cc just like lalr1.cc, but because glr.c stores
+#   the locations in a union, the position and location classes
+#   must not have a constructor.  Therefore, contrary to lalr1.cc, we
+#   must not define "b4_location_constructors".  As a consequence the
+#   user must initialize the first positions (in particular the
+#   filename member).
+
+# We require a pure interface.
+m4_define([b4_pure_flag], [1])
+
+m4_include(b4_skeletonsdir/[c++.m4])
+b4_bison_locations_if([m4_include(b4_skeletonsdir/[location.cc])])
+
+m4_define([b4_parser_class],
+          [b4_percent_define_get([[api.parser.class]])])
+
+# Save the parse parameters.
+m4_define([b4_parse_param_orig], m4_defn([b4_parse_param]))
+
+# b4_parse_param_wrap
+# -------------------
+# New ones.
+m4_ifset([b4_parse_param],
+[m4_define([b4_parse_param_wrap],
+           [[b4_namespace_ref::b4_parser_class[& yyparser], [[yyparser]]],]
+m4_defn([b4_parse_param]))],
+[m4_define([b4_parse_param_wrap],
+           [[b4_namespace_ref::b4_parser_class[& yyparser], [[yyparser]]]])
+])
+
+
+# b4_yy_symbol_print_define
+# -------------------------
+# Bypass the default implementation to generate the "yy_symbol_print"
+# and "yy_symbol_value_print" functions.
+m4_define([b4_yy_symbol_print_define],
+[[
+/*--------------------.
+| Print this symbol.  |
+`--------------------*/
+
+]b4_function_define([yy_symbol_print],
+    [static void],
+    [[FILE *],      []],
+    [[int yytype],  [yytype]],
+    [[const ]b4_namespace_ref::b4_parser_class[::semantic_type *yyvaluep],
+                    [yyvaluep]][]dnl
+b4_locations_if([,
+    [[const ]b4_namespace_ref::b4_parser_class[::location_type *yylocationp],
+                    [yylocationp]]]),
+    b4_parse_param)[
+{
+]b4_parse_param_use[]dnl
+[  yyparser.yy_symbol_print_ (yytype, yyvaluep]b4_locations_if([, yylocationp])[);
+}
+]])[
+
+# Hijack the initial action to initialize the locations.
+]b4_bison_locations_if([m4_define([b4_initial_action],
+[yylloc.initialize ();]m4_ifdef([b4_initial_action], [
+m4_defn([b4_initial_action])]))])[
+
+# Hijack the post prologue to declare yyerror.
+]m4_append([b4_post_prologue],
+[b4_syncline([@oline@], [@ofile@])dnl
+b4_function_declare([yyerror],
+    [static void],b4_locations_if([
+    [[const ]b4_namespace_ref::b4_parser_class[::location_type *yylocationp],
+                        [yylocationp]],])
+    b4_parse_param,
+    [[const char* msg], [msg]])])[
+
+
+#undef yynerrs
+#undef yychar
+#undef yylval]b4_locations_if([
+#undef yylloc])
+
+m4_if(b4_prefix, [yy], [],
+[[/* Substitute the variable and function names.  */
+#define yyparse ]b4_prefix[parse
+#define yylex   ]b4_prefix[lex
+#define yyerror ]b4_prefix[error
+#define yydebug ]b4_prefix[debug]]b4_pure_if([], [[
+#define yylval  ]b4_prefix[lval
+#define yychar  ]b4_prefix[char
+#define yynerrs ]b4_prefix[nerrs]b4_locations_if([[
+#define yylloc  ]b4_prefix[lloc]])]))
+
+# Hijack the epilogue to define implementations (yyerror, parser member
+# functions etc.).
+m4_append([b4_epilogue],
+[b4_syncline([@oline@], [@ofile@])dnl
+[
+/*------------------.
+| Report an error.  |
+`------------------*/
+
+]b4_function_define([yyerror],
+    [static void],b4_locations_if([
+    [[const ]b4_namespace_ref::b4_parser_class[::location_type *yylocationp],
+                        [yylocationp]],])
+    b4_parse_param,
+    [[const char* msg], [msg]])[
+{
+]b4_parse_param_use[]dnl
+[  yyparser.error (]b4_locations_if([[*yylocationp, ]])[msg);
+}
+
+
+]b4_namespace_open[
+]dnl In this section, the parse params are the original parse_params.
+m4_pushdef([b4_parse_param], m4_defn([b4_parse_param_orig]))dnl
+[  /// Build a parser object.
+  ]b4_parser_class::b4_parser_class[ (]b4_parse_param_decl[)]m4_ifset([b4_parse_param], [
+    :])[
+#if ]b4_api_PREFIX[DEBUG
+    ]m4_ifset([b4_parse_param], [  ], [ :])[yycdebug_ (&std::cerr)]m4_ifset([b4_parse_param], [,])[
+#endif]b4_parse_param_cons[
+  {}
+
+  ]b4_parser_class::~b4_parser_class[ ()
+  {}
+
+  ]b4_parser_class[::syntax_error::~syntax_error () YY_NOEXCEPT YY_NOTHROW
+  {}
+
+  int
+  ]b4_parser_class[::operator() ()
+  {
+    return parse ();
+  }
+
+  int
+  ]b4_parser_class[::parse ()
+  {
+    return ::yyparse (*this]b4_user_args[);
+  }
+
+#if ]b4_api_PREFIX[DEBUG
+  /*--------------------.
+  | Print this symbol.  |
+  `--------------------*/
+
+  void
+  ]b4_parser_class[::yy_symbol_value_print_ (int yytype,
+                           const semantic_type* yyvaluep]b4_locations_if([[,
+                           const location_type* yylocationp]])[)
+  {]b4_locations_if([[
+    YYUSE (yylocationp);]])[
+    YYUSE (yyvaluep);
+    std::ostream& yyo = debug_stream ();
+    std::ostream& yyoutput = yyo;
+    YYUSE (yyoutput);
+    ]b4_symbol_actions([printer])[
+  }
+
+
+  void
+  ]b4_parser_class[::yy_symbol_print_ (int yytype,
+                           const semantic_type* yyvaluep]b4_locations_if([[,
+                           const location_type* yylocationp]])[)
+  {
+    *yycdebug_ << (yytype < YYNTOKENS ? "token" : "nterm")
+               << ' ' << yytname[yytype] << " ("]b4_locations_if([[
+               << *yylocationp << ": "]])[;
+    yy_symbol_value_print_ (yytype, yyvaluep]b4_locations_if([[, yylocationp]])[);
+    *yycdebug_ << ')';
+  }
+
+  std::ostream&
+  ]b4_parser_class[::debug_stream () const
+  {
+    return *yycdebug_;
+  }
+
+  void
+  ]b4_parser_class[::set_debug_stream (std::ostream& o)
+  {
+    yycdebug_ = &o;
+  }
+
+
+  ]b4_parser_class[::debug_level_type
+  ]b4_parser_class[::debug_level () const
+  {
+    return yydebug;
+  }
+
+  void
+  ]b4_parser_class[::set_debug_level (debug_level_type l)
+  {
+    // Actually, it is yydebug which is really used.
+    yydebug = l;
+  }
+
+#endif
+]m4_popdef([b4_parse_param])dnl
+b4_namespace_close[]dnl
+])
+
+
+# b4_shared_declarations(hh|cc)
+# -----------------------------
+# Declaration that might either go into the header (if --defines, $1 = hh)
+# or in the implementation file.
+m4_define([b4_shared_declarations],
+[m4_pushdef([b4_parse_param], m4_defn([b4_parse_param_orig]))dnl
+b4_percent_code_get([[requires]])[
+#include <iostream>
+#include <stdexcept>
+#include <string>
+
+]b4_cxx_portability[
+]m4_ifdef([b4_location_include],
+          [[# include ]b4_location_include])[
+]b4_variant_if([b4_variant_includes])[
+
+]b4_attribute_define[
+]b4_null_define[
+
+// This skeleton is based on C, yet compiles it as C++.
+// So expect warnings about C style casts.
+#if defined __clang__ && 306 <= __clang_major__ * 100 + __clang_minor__
+# pragma clang diagnostic ignored "-Wold-style-cast"
+#elif defined __GNUC__ && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
+# pragma GCC diagnostic ignored "-Wold-style-cast"
+#endif
+
+// On MacOS, PTRDIFF_MAX is defined as long long, which Clang's
+// -pedantic reports as being a C++11 extension.
+#if defined __APPLE__ && YY_CPLUSPLUS < 201103L && 4 <= __clang_major__
+# pragma clang diagnostic ignored "-Wc++11-long-long"
+#endif
+
+// Whether we are compiled with exception support.
+#ifndef YY_EXCEPTIONS
+# if defined __GNUC__ && !defined __EXCEPTIONS
+#  define YY_EXCEPTIONS 0
+# else
+#  define YY_EXCEPTIONS 1
+# endif
+#endif
+
+]b4_YYDEBUG_define[
+
+]b4_namespace_open[
+
+]b4_bison_locations_if([m4_ifndef([b4_location_file],
+                                  [b4_location_define])])[
+
+  /// A Bison parser.
+  class ]b4_parser_class[
+  {
+  public:
+]b4_public_types_declare[
+
+    /// Build a parser object.
+    ]b4_parser_class[ (]b4_parse_param_decl[);
+    virtual ~]b4_parser_class[ ();
+
+    /// Parse.  An alias for parse ().
+    /// \returns  0 iff parsing succeeded.
+    int operator() ();
+
+    /// Parse.
+    /// \returns  0 iff parsing succeeded.
+    virtual int parse ();
+
+#if ]b4_api_PREFIX[DEBUG
+    /// The current debugging stream.
+    std::ostream& debug_stream () const;
+    /// Set the current debugging stream.
+    void set_debug_stream (std::ostream &);
+
+    /// Type for debugging levels.
+    typedef int debug_level_type;
+    /// The current debugging level.
+    debug_level_type debug_level () const;
+    /// Set the current debugging level.
+    void set_debug_level (debug_level_type l);
+#endif
+
+    /// Report a syntax error.]b4_locations_if([[
+    /// \param loc    where the syntax error is found.]])[
+    /// \param msg    a description of the syntax error.
+    virtual void error (]b4_locations_if([[const location_type& loc, ]])[const std::string& msg);
+
+# if ]b4_api_PREFIX[DEBUG
+  public:
+    /// \brief Report a symbol value on the debug stream.
+    /// \param yytype       The token type.
+    /// \param yyvaluep     Its semantic value.]b4_locations_if([[
+    /// \param yylocationp  Its location.]])[
+    virtual void yy_symbol_value_print_ (int yytype,
+                                         const semantic_type* yyvaluep]b4_locations_if([[,
+                                         const location_type* yylocationp]])[);
+    /// \brief Report a symbol on the debug stream.
+    /// \param yytype       The token type.
+    /// \param yyvaluep     Its semantic value.]b4_locations_if([[
+    /// \param yylocationp  Its location.]])[
+    virtual void yy_symbol_print_ (int yytype,
+                                   const semantic_type* yyvaluep]b4_locations_if([[,
+                                   const location_type* yylocationp]])[);
+  private:
+    // Debugging.
+    std::ostream* yycdebug_;
+#endif
+
+]b4_parse_param_vars[
+  };
+
+]dnl Redirections for glr.c.
+b4_percent_define_flag_if([[global_tokens_and_yystype]],
+[b4_token_defines])
+[
+#ifndef ]b4_api_PREFIX[STYPE
+# define ]b4_api_PREFIX[STYPE ]b4_namespace_ref[::]b4_parser_class[::semantic_type
+#endif
+#ifndef ]b4_api_PREFIX[LTYPE
+# define ]b4_api_PREFIX[LTYPE ]b4_namespace_ref[::]b4_parser_class[::location_type
+#endif
+
+]b4_namespace_close[
+]b4_percent_code_get([[provides]])[
+]m4_popdef([b4_parse_param])dnl
+])
+
+b4_defines_if(
+[b4_output_begin([b4_spec_header_file])
+b4_copyright([Skeleton interface for Bison GLR parsers in C++],
+             [2002-2015, 2018-2019])[
+// C++ GLR parser skeleton written by Akim Demaille.
+
+]b4_disclaimer[
+]b4_cpp_guard_open([b4_spec_header_file])[
+]b4_shared_declarations[
+]b4_cpp_guard_close([b4_spec_header_file])[
+]b4_output_end])
+
+# Let glr.c (and b4_shared_declarations) believe that the user
+# arguments include the parser itself.
+m4_pushdef([b4_parse_param], m4_defn([b4_parse_param_wrap]))
+m4_include(b4_skeletonsdir/[glr.c])
+m4_popdef([b4_parse_param])
diff --git a/common/bison/skeletons/java-skel.m4 b/common/bison/skeletons/java-skel.m4
new file mode 100644
index 0000000000000000000000000000000000000000..922f1a81217fb05b940535ff85d0ac3a778fe650
--- /dev/null
+++ b/common/bison/skeletons/java-skel.m4
@@ -0,0 +1,27 @@
+                                                            -*- Autoconf -*-
+
+# Java skeleton dispatching for Bison.
+
+# Copyright (C) 2007, 2009-2015, 2018-2019 Free Software Foundation,
+# Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+b4_glr_if(             [b4_complain([%%glr-parser not supported for Java])])
+b4_nondeterministic_if([b4_complain([%%nondeterministic-parser not supported for Java])])
+
+m4_define_default([b4_used_skeleton], [b4_skeletonsdir/[lalr1.java]])
+m4_define_default([b4_skeleton], ["b4_basename(b4_used_skeleton)"])
+
+m4_include(b4_used_skeleton)
diff --git a/common/bison/skeletons/java.m4 b/common/bison/skeletons/java.m4
new file mode 100644
index 0000000000000000000000000000000000000000..edf23a92d3bde7734b41b8d2ae2832bb887bdca6
--- /dev/null
+++ b/common/bison/skeletons/java.m4
@@ -0,0 +1,364 @@
+                                                            -*- Autoconf -*-
+
+# Java language support for Bison
+
+# Copyright (C) 2007-2015, 2018-2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+m4_include(b4_skeletonsdir/[c-like.m4])
+
+
+# b4_list2(LIST1, LIST2)
+# ----------------------
+# Join two lists with a comma if necessary.
+m4_define([b4_list2],
+          [$1[]m4_ifval(m4_quote($1), [m4_ifval(m4_quote($2), [[, ]])])[]$2])
+
+
+# b4_percent_define_get3(DEF, PRE, POST, NOT)
+# -------------------------------------------
+# Expand to the value of DEF surrounded by PRE and POST if it's %define'ed,
+# otherwise NOT.
+m4_define([b4_percent_define_get3],
+          [m4_ifval(m4_quote(b4_percent_define_get([$1])),
+                [$2[]b4_percent_define_get([$1])[]$3], [$4])])
+
+
+
+# b4_flag_value(BOOLEAN-FLAG)
+# ---------------------------
+m4_define([b4_flag_value], [b4_flag_if([$1], [true], [false])])
+
+
+# b4_parser_class_declaration
+# ---------------------------
+# The declaration of the parser class ("class YYParser"), with all its
+# qualifiers/annotations.
+b4_percent_define_default([[api.parser.abstract]], [[false]])
+b4_percent_define_default([[api.parser.final]],    [[false]])
+b4_percent_define_default([[api.parser.public]],   [[false]])
+b4_percent_define_default([[api.parser.strictfp]], [[false]])
+
+m4_define([b4_parser_class_declaration],
+[b4_percent_define_get3([api.parser.annotations], [], [ ])dnl
+b4_percent_define_flag_if([api.parser.public],   [public ])dnl
+b4_percent_define_flag_if([api.parser.abstract], [abstract ])dnl
+b4_percent_define_flag_if([api.parser.final],    [final ])dnl
+b4_percent_define_flag_if([api.parser.strictfp], [strictfp ])dnl
+[class ]b4_parser_class[]dnl
+b4_percent_define_get3([api.parser.extends], [ extends ])dnl
+b4_percent_define_get3([api.parser.implements], [ implements ])])
+
+
+# b4_lexer_if(TRUE, FALSE)
+# ------------------------
+m4_define([b4_lexer_if],
+[b4_percent_code_ifdef([[lexer]], [$1], [$2])])
+
+
+# b4_identification
+# -----------------
+m4_define([b4_identification],
+[  /** Version number for the Bison executable that generated this parser.  */
+  public static final String bisonVersion = "b4_version";
+
+  /** Name of the skeleton that generated this parser.  */
+  public static final String bisonSkeleton = b4_skeleton;
+])
+
+
+## ------------ ##
+## Data types.  ##
+## ------------ ##
+
+# b4_int_type(MIN, MAX)
+# ---------------------
+# Return the smallest int type able to handle numbers ranging from
+# MIN to MAX (included).
+m4_define([b4_int_type],
+[m4_if(b4_ints_in($@,   [-128],   [127]), [1], [byte],
+       b4_ints_in($@, [-32768], [32767]), [1], [short],
+                                               [int])])
+
+# b4_int_type_for(NAME)
+# ---------------------
+# Return the smallest int type able to handle numbers ranging from
+# 'NAME_min' to 'NAME_max' (included).
+m4_define([b4_int_type_for],
+[b4_int_type($1_min, $1_max)])
+
+# b4_null
+# -------
+m4_define([b4_null], [null])
+
+
+# b4_typed_parser_table_define(TYPE, NAME, DATA, COMMENT)
+# -------------------------------------------------------
+m4_define([b4_typed_parser_table_define],
+[m4_ifval([$4], [b4_comment([$4])
+  ])dnl
+[private static final ]$1[ yy$2_[] = yy$2_init();
+  private static final ]$1[[] yy$2_init()
+  {
+    return new ]$1[[]
+    {
+  ]$3[
+    };
+  }]])
+
+
+# b4_integral_parser_table_define(NAME, DATA, COMMENT)
+#-----------------------------------------------------
+m4_define([b4_integral_parser_table_define],
+[b4_typed_parser_table_define([b4_int_type_for([$2])], [$1], [$2], [$3])])
+
+
+## ------------------------- ##
+## Assigning token numbers.  ##
+## ------------------------- ##
+
+# b4_token_enum(TOKEN-NUM)
+# ------------------------
+# Output the definition of this token as an enum.
+m4_define([b4_token_enum],
+[b4_token_format([    /** Token number, to be returned by the scanner.  */
+    static final int %s = %s;
+], [$1])])
+
+# b4_token_enums
+# --------------
+# Output the definition of the tokens (if there are) as enums.
+m4_define([b4_token_enums],
+[b4_any_token_visible_if([/* Tokens.  */
+b4_symbol_foreach([b4_token_enum])])])
+
+# b4-case(ID, CODE)
+# -----------------
+# We need to fool Java's stupid unreachable code detection.
+m4_define([b4_case], [  case $1:
+  if (yyn == $1)
+    $2;
+  break;
+    ])
+
+# b4_predicate_case(LABEL, CONDITIONS)
+# ------------------------------------
+m4_define([b4_predicate_case], [  case $1:
+     if (! ($2)) YYERROR;
+    break;
+    ])
+
+
+## -------- ##
+## Checks.  ##
+## -------- ##
+
+b4_percent_define_check_kind([[api.value.type]],    [code], [deprecated])
+
+b4_percent_define_check_kind([[annotations]],       [code], [deprecated])
+b4_percent_define_check_kind([[extends]],           [code], [deprecated])
+b4_percent_define_check_kind([[implements]],        [code], [deprecated])
+b4_percent_define_check_kind([[init_throws]],       [code], [deprecated])
+b4_percent_define_check_kind([[lex_throws]],        [code], [deprecated])
+b4_percent_define_check_kind([[api.parser.class]],  [code], [deprecated])
+b4_percent_define_check_kind([[throws]],            [code], [deprecated])
+
+
+
+## ---------------- ##
+## Default values.  ##
+## ---------------- ##
+
+m4_define([b4_yystype], [b4_percent_define_get([[api.value.type]])])
+b4_percent_define_default([[api.value.type]], [[Object]])
+
+# b4_api_prefix, b4_api_PREFIX
+# ----------------------------
+# Corresponds to %define api.prefix
+b4_percent_define_default([[api.prefix]], [[YY]])
+m4_define([b4_api_prefix],
+[b4_percent_define_get([[api.prefix]])])
+m4_define([b4_api_PREFIX],
+[m4_toupper(b4_api_prefix)])
+
+# b4_prefix
+# ---------
+# If the %name-prefix is not given, it is api.prefix.
+m4_define_default([b4_prefix], [b4_api_prefix])
+
+b4_percent_define_default([[api.parser.class]], [b4_prefix[]Parser])
+m4_define([b4_parser_class], [b4_percent_define_get([[api.parser.class]])])
+
+b4_percent_define_default([[lex_throws]], [[java.io.IOException]])
+m4_define([b4_lex_throws], [b4_percent_define_get([[lex_throws]])])
+
+b4_percent_define_default([[throws]], [])
+m4_define([b4_throws], [b4_percent_define_get([[throws]])])
+
+b4_percent_define_default([[init_throws]], [])
+m4_define([b4_init_throws], [b4_percent_define_get([[init_throws]])])
+
+b4_percent_define_default([[api.location.type]], [Location])
+m4_define([b4_location_type], [b4_percent_define_get([[api.location.type]])])
+
+b4_percent_define_default([[api.position.type]], [Position])
+m4_define([b4_position_type], [b4_percent_define_get([[api.position.type]])])
+
+
+## ----------------- ##
+## Semantic Values.  ##
+## ----------------- ##
+
+
+# b4_symbol_value(VAL, [SYMBOL-NUM], [TYPE-TAG])
+# ----------------------------------------------
+# See README.
+m4_define([b4_symbol_value],
+[m4_ifval([$3],
+          [(($3)($1))],
+          [m4_ifval([$2],
+                    [b4_symbol_if([$2], [has_type],
+                                  [((b4_symbol([$2], [type]))($1))],
+                                  [$1])],
+                    [$1])])])
+
+
+# b4_lhs_value([SYMBOL-NUM], [TYPE])
+# ----------------------------------
+# See README.
+m4_define([b4_lhs_value], [yyval])
+
+
+# b4_rhs_data(RULE-LENGTH, POS)
+# -----------------------------
+# See README.
+m4_define([b4_rhs_data],
+[yystack.valueAt (b4_subtract($@))])
+
+# b4_rhs_value(RULE-LENGTH, POS, SYMBOL-NUM, [TYPE])
+# --------------------------------------------------
+# See README.
+#
+# In this simple implementation, %token and %type have class names
+# between the angle brackets.
+m4_define([b4_rhs_value],
+[b4_symbol_value([b4_rhs_data([$1], [$2])], [$3], [$4])])
+
+
+# b4_lhs_location()
+# -----------------
+# Expansion of @$.
+m4_define([b4_lhs_location],
+[(yyloc)])
+
+
+# b4_rhs_location(RULE-LENGTH, POS)
+# ---------------------------------
+# Expansion of @POS, where the current rule has RULE-LENGTH symbols
+# on RHS.
+m4_define([b4_rhs_location],
+[yystack.locationAt (b4_subtract($@))])
+
+
+# b4_lex_param
+# b4_parse_param
+# --------------
+# If defined, b4_lex_param arrives double quoted, but below we prefer
+# it to be single quoted.  Same for b4_parse_param.
+
+# TODO: should be in bison.m4
+m4_define_default([b4_lex_param], [[]])
+m4_define([b4_lex_param], b4_lex_param)
+m4_define([b4_parse_param], b4_parse_param)
+
+# b4_lex_param_decl
+# -----------------
+# Extra formal arguments of the constructor.
+m4_define([b4_lex_param_decl],
+[m4_ifset([b4_lex_param],
+          [b4_remove_comma([$1],
+                           b4_param_decls(b4_lex_param))],
+          [$1])])
+
+m4_define([b4_param_decls],
+          [m4_map([b4_param_decl], [$@])])
+m4_define([b4_param_decl], [, $1])
+
+m4_define([b4_remove_comma], [m4_ifval(m4_quote($1), [$1, ], [])m4_shift2($@)])
+
+
+
+# b4_parse_param_decl
+# -------------------
+# Extra formal arguments of the constructor.
+m4_define([b4_parse_param_decl],
+[m4_ifset([b4_parse_param],
+          [b4_remove_comma([$1],
+                           b4_param_decls(b4_parse_param))],
+          [$1])])
+
+
+
+# b4_lex_param_call
+# -----------------
+# Delegating the lexer parameters to the lexer constructor.
+m4_define([b4_lex_param_call],
+          [m4_ifset([b4_lex_param],
+                    [b4_remove_comma([$1],
+                                     b4_param_calls(b4_lex_param))],
+                    [$1])])
+m4_define([b4_param_calls],
+          [m4_map([b4_param_call], [$@])])
+m4_define([b4_param_call], [, $2])
+
+
+
+# b4_parse_param_cons
+# -------------------
+# Extra initialisations of the constructor.
+m4_define([b4_parse_param_cons],
+          [m4_ifset([b4_parse_param],
+                    [b4_constructor_calls(b4_parse_param)])])
+
+m4_define([b4_constructor_calls],
+          [m4_map([b4_constructor_call], [$@])])
+m4_define([b4_constructor_call],
+          [this.$2 = $2;
+          ])
+
+
+
+# b4_parse_param_vars
+# -------------------
+# Extra instance variables.
+m4_define([b4_parse_param_vars],
+          [m4_ifset([b4_parse_param],
+                    [
+    /* User arguments.  */
+b4_var_decls(b4_parse_param)])])
+
+m4_define([b4_var_decls],
+          [m4_map_sep([b4_var_decl], [
+], [$@])])
+m4_define([b4_var_decl],
+          [    protected final $1;])
+
+
+
+# b4_maybe_throws(THROWS)
+# -----------------------
+# Expand to either an empty string or "throws THROWS".
+m4_define([b4_maybe_throws],
+          [m4_ifval($1, [throws $1])])
diff --git a/common/bison/skeletons/lalr1.cc b/common/bison/skeletons/lalr1.cc
new file mode 100644
index 0000000000000000000000000000000000000000..d245796b3afdeae1e38f681cb6806efdd501a85d
--- /dev/null
+++ b/common/bison/skeletons/lalr1.cc
@@ -0,0 +1,1463 @@
+# C++ skeleton for Bison
+
+# Copyright (C) 2002-2015, 2018-2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+m4_include(b4_skeletonsdir/[c++.m4])
+
+# api.value.type=variant is valid.
+m4_define([b4_value_type_setup_variant])
+
+# Check the value of %define parse.lac, where LAC stands for lookahead
+# correction.
+b4_percent_define_default([[parse.lac]], [[none]])
+b4_define_flag_if([lac])
+m4_define([b4_lac_flag],
+          [m4_if(b4_percent_define_get([[parse.lac]]),
+                 [none], [[0]], [[1]])])
+
+
+# b4_integral_parser_table_declare(TABLE-NAME, CONTENT, COMMENT)
+# --------------------------------------------------------------
+# Declare "parser::yy<TABLE-NAME>_" whose contents is CONTENT.
+m4_define([b4_integral_parser_table_declare],
+[m4_ifval([$3], [b4_comment([$3], [    ])
+])dnl
+    static const b4_int_type_for([$2]) yy$1_[[]];dnl
+])
+
+# b4_integral_parser_table_define(TABLE-NAME, CONTENT, COMMENT)
+# -------------------------------------------------------------
+# Define "parser::yy<TABLE-NAME>_" whose contents is CONTENT.
+m4_define([b4_integral_parser_table_define],
+[  const b4_int_type_for([$2])
+  b4_parser_class::yy$1_[[]] =
+  {
+  $2
+  };dnl
+])
+
+# b4_symbol_value_template(VAL, SYMBOL-NUM, [TYPE])
+# -------------------------------------------------
+# Same as b4_symbol_value, but used in a template method.  It makes
+# a difference when using variants.  Note that b4_value_type_setup_union
+# overrides b4_symbol_value, so we must override it again.
+m4_copy([b4_symbol_value], [b4_symbol_value_template])
+m4_append([b4_value_type_setup_union],
+[m4_copy_force([b4_symbol_value_union], [b4_symbol_value_template])])
+
+# b4_lhs_value(SYMBOL-NUM, [TYPE])
+# --------------------------------
+# See README.
+m4_define([b4_lhs_value],
+[b4_symbol_value([yylhs.value], [$1], [$2])])
+
+
+# b4_lhs_location()
+# -----------------
+# Expansion of @$.
+m4_define([b4_lhs_location],
+[yylhs.location])
+
+
+# b4_rhs_data(RULE-LENGTH, POS)
+# -----------------------------
+# See README.
+m4_define([b4_rhs_data],
+[yystack_@{b4_subtract($@)@}])
+
+
+# b4_rhs_state(RULE-LENGTH, POS)
+# ------------------------------
+# The state corresponding to the symbol #POS, where the current
+# rule has RULE-LENGTH symbols on RHS.
+m4_define([b4_rhs_state],
+[b4_rhs_data([$1], [$2]).state])
+
+
+# b4_rhs_value(RULE-LENGTH, POS, SYMBOL-NUM, [TYPE])
+# --------------------------------------------------
+# See README.
+m4_define([_b4_rhs_value],
+[b4_symbol_value([b4_rhs_data([$1], [$2]).value], [$3], [$4])])
+
+m4_define([b4_rhs_value],
+[b4_percent_define_ifdef([api.value.automove],
+                         [YY_MOVE (_b4_rhs_value($@))],
+                         [_b4_rhs_value($@)])])
+
+
+# b4_rhs_location(RULE-LENGTH, POS)
+# ---------------------------------
+# Expansion of @POS, where the current rule has RULE-LENGTH symbols
+# on RHS.
+m4_define([b4_rhs_location],
+[b4_rhs_data([$1], [$2]).location])
+
+
+# b4_symbol_action(SYMBOL-NUM, KIND)
+# ----------------------------------
+# Run the action KIND (destructor or printer) for SYMBOL-NUM.
+# Same as in C, but using references instead of pointers.
+m4_define([b4_symbol_action],
+[b4_symbol_if([$1], [has_$2],
+[m4_pushdef([b4_symbol_value], m4_defn([b4_symbol_value_template]))[]dnl
+b4_dollar_pushdef([yysym.value],
+                  [$1],
+                  [],
+                  [yysym.location])dnl
+      _b4_symbol_case([$1])[]dnl
+b4_syncline([b4_symbol([$1], [$2_line])], [b4_symbol([$1], [$2_file])])dnl
+        b4_symbol([$1], [$2])
+b4_syncline([@oline@], [@ofile@])dnl
+        break;
+
+m4_popdef([b4_symbol_value])[]dnl
+b4_dollar_popdef[]dnl
+])])
+
+
+# b4_lex
+# ------
+# Call yylex.
+m4_define([b4_lex],
+[b4_token_ctor_if(
+[b4_function_call([yylex],
+                  [symbol_type], m4_ifdef([b4_lex_param], b4_lex_param))],
+[b4_function_call([yylex], [int],
+                  [b4_api_PREFIX[STYPE*], [&yyla.value]][]dnl
+b4_locations_if([, [[location*], [&yyla.location]]])dnl
+m4_ifdef([b4_lex_param], [, ]b4_lex_param))])])
+
+
+m4_pushdef([b4_copyright_years],
+           [2002-2015, 2018-2019])
+
+m4_define([b4_parser_class],
+          [b4_percent_define_get([[api.parser.class]])])
+
+b4_bison_locations_if([# Backward compatibility.
+   m4_define([b4_location_constructors])
+   m4_include(b4_skeletonsdir/[location.cc])])
+m4_include(b4_skeletonsdir/[stack.hh])
+b4_variant_if([m4_include(b4_skeletonsdir/[variant.hh])])
+
+
+# b4_shared_declarations(hh|cc)
+# -----------------------------
+# Declaration that might either go into the header (if --defines, $1 = hh)
+# or in the implementation file.
+m4_define([b4_shared_declarations],
+[b4_percent_code_get([[requires]])[
+]b4_parse_assert_if([# include <cassert>])[
+# include <cstdlib> // std::abort
+# include <iostream>
+# include <stdexcept>
+# include <string>
+# include <vector>
+
+]b4_cxx_portability[
+]m4_ifdef([b4_location_include],
+          [[# include ]b4_location_include])[
+]b4_variant_if([b4_variant_includes])[
+
+]b4_attribute_define[
+]b4_cast_define[
+]b4_null_define[
+
+]b4_YYDEBUG_define[
+
+]b4_namespace_open[
+
+]b4_bison_locations_if([m4_ifndef([b4_location_file],
+                                  [b4_location_define])])[
+
+  /// A Bison parser.
+  class ]b4_parser_class[
+  {
+  public:
+]b4_public_types_declare[
+]b4_symbol_type_define[
+    /// Build a parser object.
+    ]b4_parser_class[ (]b4_parse_param_decl[);
+    virtual ~]b4_parser_class[ ();
+
+    /// Parse.  An alias for parse ().
+    /// \returns  0 iff parsing succeeded.
+    int operator() ();
+
+    /// Parse.
+    /// \returns  0 iff parsing succeeded.
+    virtual int parse ();
+
+#if ]b4_api_PREFIX[DEBUG
+    /// The current debugging stream.
+    std::ostream& debug_stream () const YY_ATTRIBUTE_PURE;
+    /// Set the current debugging stream.
+    void set_debug_stream (std::ostream &);
+
+    /// Type for debugging levels.
+    typedef int debug_level_type;
+    /// The current debugging level.
+    debug_level_type debug_level () const YY_ATTRIBUTE_PURE;
+    /// Set the current debugging level.
+    void set_debug_level (debug_level_type l);
+#endif
+
+    /// Report a syntax error.]b4_locations_if([[
+    /// \param loc    where the syntax error is found.]])[
+    /// \param msg    a description of the syntax error.
+    virtual void error (]b4_locations_if([[const location_type& loc, ]])[const std::string& msg);
+
+    /// Report a syntax error.
+    void error (const syntax_error& err);
+
+]b4_token_constructor_define[
+
+  private:
+    /// This class is not copyable.
+    ]b4_parser_class[ (const ]b4_parser_class[&);
+    ]b4_parser_class[& operator= (const ]b4_parser_class[&);]b4_lac_if([[
+
+    /// Check the lookahead yytoken.
+    /// \returns  true iff the token will be eventually shifted.
+    bool yy_lac_check_ (int yytoken) const;
+    /// Establish the initial context if no initial context currently exists.
+    /// \returns  true iff the token will be eventually shifted.
+    bool yy_lac_establish_ (int yytoken);
+    /// Discard any previous initial lookahead context because of event.
+    /// \param event  the event which caused the lookahead to be discarded.
+    ///               Only used for debbuging output.
+    void yy_lac_discard_ (const char* event);]])[
+
+    /// Stored state numbers (used for stacks).
+    typedef ]b4_int_type(0, m4_eval(b4_states_number - 1))[ state_type;
+
+    /// Generate an error message.
+    /// \param yystate   the state where the error occurred.
+    /// \param yyla      the lookahead token.
+    virtual std::string yysyntax_error_ (state_type yystate,
+                                         const symbol_type& yyla) const;
+
+    /// Compute post-reduction state.
+    /// \param yystate   the current state
+    /// \param yysym     the nonterminal to push on the stack
+    static state_type yy_lr_goto_state_ (state_type yystate, int yysym);
+
+    /// Whether the given \c yypact_ value indicates a defaulted state.
+    /// \param yyvalue   the value to check
+    static bool yy_pact_value_is_default_ (int yyvalue);
+
+    /// Whether the given \c yytable_ value indicates a syntax error.
+    /// \param yyvalue   the value to check
+    static bool yy_table_value_is_error_ (int yyvalue);
+
+    static const ]b4_int_type(b4_pact_ninf, b4_pact_ninf)[ yypact_ninf_;
+    static const ]b4_int_type(b4_table_ninf, b4_table_ninf)[ yytable_ninf_;
+
+    /// Convert a scanner token number \a t to a symbol number.
+    /// In theory \a t should be a token_type, but character literals
+    /// are valid, yet not members of the token_type enum.
+    static token_number_type yytranslate_ (int t);
+
+    // Tables.
+]b4_parser_tables_declare[]b4_error_verbose_if([
+
+    /// Convert the symbol name \a n to a form suitable for a diagnostic.
+    static std::string yytnamerr_ (const char *n);])[
+
+]b4_token_table_if([], [[#if ]b4_api_PREFIX[DEBUG]])[
+    /// For a symbol, its name in clear.
+    static const char* const yytname_[];
+]b4_token_table_if([[#if ]b4_api_PREFIX[DEBUG]])[
+]b4_integral_parser_table_declare([rline], [b4_rline],
+     [[YYRLINE[YYN] -- Source line where rule number YYN was defined.]])[
+    /// Report on the debug stream that the rule \a r is going to be reduced.
+    virtual void yy_reduce_print_ (int r);
+    /// Print the state stack on the debug stream.
+    virtual void yystack_print_ ();
+
+    /// Debugging level.
+    int yydebug_;
+    /// Debug stream.
+    std::ostream* yycdebug_;
+
+    /// \brief Display a symbol type, value and location.
+    /// \param yyo    The output stream.
+    /// \param yysym  The symbol.
+    template <typename Base>
+    void yy_print_ (std::ostream& yyo, const basic_symbol<Base>& yysym) const;
+#endif
+
+    /// \brief Reclaim the memory associated to a symbol.
+    /// \param yymsg     Why this token is reclaimed.
+    ///                  If null, print nothing.
+    /// \param yysym     The symbol.
+    template <typename Base>
+    void yy_destroy_ (const char* yymsg, basic_symbol<Base>& yysym) const;
+
+  private:
+    /// Type access provider for state based symbols.
+    struct by_state
+    {
+      /// Default constructor.
+      by_state () YY_NOEXCEPT;
+
+      /// The symbol type as needed by the constructor.
+      typedef state_type kind_type;
+
+      /// Constructor.
+      by_state (kind_type s) YY_NOEXCEPT;
+
+      /// Copy constructor.
+      by_state (const by_state& that) YY_NOEXCEPT;
+
+      /// Record that this symbol is empty.
+      void clear () YY_NOEXCEPT;
+
+      /// Steal the symbol type from \a that.
+      void move (by_state& that);
+
+      /// The (internal) type number (corresponding to \a state).
+      /// \a empty_symbol when empty.
+      symbol_number_type type_get () const YY_NOEXCEPT;
+
+      /// The state number used to denote an empty symbol.
+      /// We use the initial state, as it does not have a value.
+      enum { empty_state = 0 };
+
+      /// The state.
+      /// \a empty when empty.
+      state_type state;
+    };
+
+    /// "Internal" symbol: element of the stack.
+    struct stack_symbol_type : basic_symbol<by_state>
+    {
+      /// Superclass.
+      typedef basic_symbol<by_state> super_type;
+      /// Construct an empty symbol.
+      stack_symbol_type ();
+      /// Move or copy construction.
+      stack_symbol_type (YY_RVREF (stack_symbol_type) that);
+      /// Steal the contents from \a sym to build this.
+      stack_symbol_type (state_type s, YY_MOVE_REF (symbol_type) sym);
+#if YY_CPLUSPLUS < 201103L
+      /// Assignment, needed by push_back by some old implementations.
+      /// Moves the contents of that.
+      stack_symbol_type& operator= (stack_symbol_type& that);
+
+      /// Assignment, needed by push_back by other implementations.
+      /// Needed by some other old implementations.
+      stack_symbol_type& operator= (const stack_symbol_type& that);
+#endif
+    };
+
+]b4_stack_define[
+
+    /// Stack type.
+    typedef stack<stack_symbol_type> stack_type;
+
+    /// The stack.
+    stack_type yystack_;]b4_lac_if([[
+    /// The stack for LAC.
+    /// Logically, the yy_lac_stack's lifetime is confined to the function
+    /// yy_lac_check_. We just store it as a member of this class to hold
+    /// on to the memory and to avoid frequent reallocations.
+    /// Since yy_lac_check_ is const, this member must be mutable.
+    mutable std::vector<state_type> yylac_stack_;
+    /// Whether an initial LAC context was established.
+    bool yy_lac_established_;
+]])[
+
+    /// Push a new state on the stack.
+    /// \param m    a debug message to display
+    ///             if null, no trace is output.
+    /// \param sym  the symbol
+    /// \warning the contents of \a s.value is stolen.
+    void yypush_ (const char* m, YY_MOVE_REF (stack_symbol_type) sym);
+
+    /// Push a new look ahead token on the state on the stack.
+    /// \param m    a debug message to display
+    ///             if null, no trace is output.
+    /// \param s    the state
+    /// \param sym  the symbol (for its value and location).
+    /// \warning the contents of \a sym.value is stolen.
+    void yypush_ (const char* m, state_type s, YY_MOVE_REF (symbol_type) sym);
+
+    /// Pop \a n symbols from the stack.
+    void yypop_ (int n = 1);
+
+    /// Some specific tokens.
+    static const token_number_type yy_error_token_ = 1;
+    static const token_number_type yy_undef_token_ = ]b4_undef_token_number[;
+
+    /// Constants.
+    enum
+    {
+      yyeof_ = 0,
+      yylast_ = ]b4_last[,     ///< Last index in yytable_.
+      yynnts_ = ]b4_nterms_number[,  ///< Number of nonterminal symbols.
+      yyfinal_ = ]b4_final_state_number[, ///< Termination state number.
+      yyntokens_ = ]b4_tokens_number[  ///< Number of tokens.
+    };
+
+]b4_parse_param_vars[
+  };
+
+]b4_token_ctor_if([b4_yytranslate_define([$1])[
+]b4_public_types_define([$1])])[
+]b4_namespace_close[
+
+]b4_percent_define_flag_if([[global_tokens_and_yystype]],
+[b4_token_defines
+
+#ifndef ]b4_api_PREFIX[STYPE
+ // Redirection for backward compatibility.
+# define ]b4_api_PREFIX[STYPE b4_namespace_ref::b4_parser_class::semantic_type
+#endif
+])[
+]b4_percent_code_get([[provides]])[
+]])
+
+## -------------- ##
+## Output files.  ##
+## -------------- ##
+
+b4_defines_if(
+[b4_output_begin([b4_spec_header_file])
+b4_copyright([Skeleton interface for Bison LALR(1) parsers in C++])
+[
+/**
+ ** \file ]b4_spec_header_file[
+ ** Define the ]b4_namespace_ref[::parser class.
+ */
+
+// C++ LALR(1) parser skeleton written by Akim Demaille.
+
+]b4_disclaimer[
+]b4_cpp_guard_open([b4_spec_header_file])[
+]b4_shared_declarations(hh)[
+]b4_cpp_guard_close([b4_spec_header_file])[
+]b4_output_end[
+]])
+
+
+b4_output_begin([b4_parser_file_name])[
+]b4_copyright([Skeleton implementation for Bison LALR(1) parsers in C++])[
+]b4_disclaimer[
+]b4_percent_code_get([[top]])[]dnl
+m4_if(b4_prefix, [yy], [],
+[
+// Take the name prefix into account.
+[#]define yylex   b4_prefix[]lex])[
+
+]b4_user_pre_prologue[
+
+]b4_defines_if([[#include "@basename(]b4_spec_header_file[@)"]],
+               [b4_shared_declarations([cc])])[
+
+]b4_user_post_prologue[
+]b4_percent_code_get[
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> // FIXME: INFRINGES ON USER NAME SPACE.
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+// Whether we are compiled with exception support.
+#ifndef YY_EXCEPTIONS
+# if defined __GNUC__ && !defined __EXCEPTIONS
+#  define YY_EXCEPTIONS 0
+# else
+#  define YY_EXCEPTIONS 1
+# endif
+#endif
+
+]b4_locations_if([dnl
+[#define YYRHSLOC(Rhs, K) ((Rhs)[K].location)
+]b4_yylloc_default_define])[
+
+// Enable debugging if requested.
+#if ]b4_api_PREFIX[DEBUG
+
+// A pseudo ostream that takes yydebug_ into account.
+# define YYCDEBUG if (yydebug_) (*yycdebug_)
+
+# define YY_SYMBOL_PRINT(Title, Symbol)         \
+  do {                                          \
+    if (yydebug_)                               \
+    {                                           \
+      *yycdebug_ << Title << ' ';               \
+      yy_print_ (*yycdebug_, Symbol);           \
+      *yycdebug_ << '\n';                       \
+    }                                           \
+  } while (false)
+
+# define YY_REDUCE_PRINT(Rule)          \
+  do {                                  \
+    if (yydebug_)                       \
+      yy_reduce_print_ (Rule);          \
+  } while (false)
+
+# define YY_STACK_PRINT()               \
+  do {                                  \
+    if (yydebug_)                       \
+      yystack_print_ ();                \
+  } while (false)
+
+#else // !]b4_api_PREFIX[DEBUG
+
+# define YYCDEBUG if (false) std::cerr
+# define YY_SYMBOL_PRINT(Title, Symbol)  YYUSE (Symbol)
+# define YY_REDUCE_PRINT(Rule)           static_cast<void> (0)
+# define YY_STACK_PRINT()                static_cast<void> (0)
+
+#endif // !]b4_api_PREFIX[DEBUG
+
+#define yyerrok         (yyerrstatus_ = 0)
+#define yyclearin       (yyla.clear ())
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+#define YYRECOVERING()  (!!yyerrstatus_)
+
+]b4_namespace_open[]b4_error_verbose_if([[
+
+  /* Return YYSTR after stripping away unnecessary quotes and
+     backslashes, so that it's suitable for yyerror.  The heuristic is
+     that double-quoting is unnecessary unless the string contains an
+     apostrophe, a comma, or backslash (other than backslash-backslash).
+     YYSTR is taken from yytname.  */
+  std::string
+  ]b4_parser_class[::yytnamerr_ (const char *yystr)
+  {
+    if (*yystr == '"')
+      {
+        std::string yyr;
+        char const *yyp = yystr;
+
+        for (;;)
+          switch (*++yyp)
+            {
+            case '\'':
+            case ',':
+              goto do_not_strip_quotes;
+
+            case '\\':
+              if (*++yyp != '\\')
+                goto do_not_strip_quotes;
+              else
+                goto append;
+
+            append:
+            default:
+              yyr += *yyp;
+              break;
+
+            case '"':
+              return yyr;
+            }
+      do_not_strip_quotes: ;
+      }
+
+    return yystr;
+  }
+]])[
+
+  /// Build a parser object.
+  ]b4_parser_class::b4_parser_class[ (]b4_parse_param_decl[)
+#if ]b4_api_PREFIX[DEBUG
+    : yydebug_ (false),
+      yycdebug_ (&std::cerr)]b4_lac_if([,], [m4_ifset([b4_parse_param], [,])])[
+#else
+]b4_lac_if([    :], [m4_ifset([b4_parse_param], [    :])])[
+#endif]b4_lac_if([[
+      yy_lac_established_ (false)]m4_ifset([b4_parse_param], [,])])[]b4_parse_param_cons[
+  {}
+
+  ]b4_parser_class::~b4_parser_class[ ()
+  {}
+
+  ]b4_parser_class[::syntax_error::~syntax_error () YY_NOEXCEPT YY_NOTHROW
+  {}
+
+  /*---------------.
+  | Symbol types.  |
+  `---------------*/
+
+]b4_token_ctor_if([], [b4_public_types_define([cc])])[
+
+  // by_state.
+  ]b4_parser_class[::by_state::by_state () YY_NOEXCEPT
+    : state (empty_state)
+  {}
+
+  ]b4_parser_class[::by_state::by_state (const by_state& that) YY_NOEXCEPT
+    : state (that.state)
+  {}
+
+  void
+  ]b4_parser_class[::by_state::clear () YY_NOEXCEPT
+  {
+    state = empty_state;
+  }
+
+  void
+  ]b4_parser_class[::by_state::move (by_state& that)
+  {
+    state = that.state;
+    that.clear ();
+  }
+
+  ]b4_parser_class[::by_state::by_state (state_type s) YY_NOEXCEPT
+    : state (s)
+  {}
+
+  ]b4_parser_class[::symbol_number_type
+  ]b4_parser_class[::by_state::type_get () const YY_NOEXCEPT
+  {
+    if (state == empty_state)
+      return empty_symbol;
+    else
+      return yystos_[state];
+  }
+
+  ]b4_parser_class[::stack_symbol_type::stack_symbol_type ()
+  {}
+
+  ]b4_parser_class[::stack_symbol_type::stack_symbol_type (YY_RVREF (stack_symbol_type) that)
+    : super_type (YY_MOVE (that.state)]b4_variant_if([], [, YY_MOVE (that.value)])b4_locations_if([, YY_MOVE (that.location)])[)
+  {]b4_variant_if([
+    b4_symbol_variant([that.type_get ()],
+                      [value], [YY_MOVE_OR_COPY], [YY_MOVE (that.value)])])[
+#if 201103L <= YY_CPLUSPLUS
+    // that is emptied.
+    that.state = empty_state;
+#endif
+  }
+
+  ]b4_parser_class[::stack_symbol_type::stack_symbol_type (state_type s, YY_MOVE_REF (symbol_type) that)
+    : super_type (s]b4_variant_if([], [, YY_MOVE (that.value)])[]b4_locations_if([, YY_MOVE (that.location)])[)
+  {]b4_variant_if([
+    b4_symbol_variant([that.type_get ()],
+                      [value], [move], [YY_MOVE (that.value)])])[
+    // that is emptied.
+    that.type = empty_symbol;
+  }
+
+#if YY_CPLUSPLUS < 201103L
+  ]b4_parser_class[::stack_symbol_type&
+  ]b4_parser_class[::stack_symbol_type::operator= (const stack_symbol_type& that)
+  {
+    state = that.state;
+    ]b4_variant_if([b4_symbol_variant([that.type_get ()],
+                                      [value], [copy], [that.value])],
+                   [[value = that.value;]])[]b4_locations_if([
+    location = that.location;])[
+    return *this;
+  }
+
+  ]b4_parser_class[::stack_symbol_type&
+  ]b4_parser_class[::stack_symbol_type::operator= (stack_symbol_type& that)
+  {
+    state = that.state;
+    ]b4_variant_if([b4_symbol_variant([that.type_get ()],
+                                      [value], [move], [that.value])],
+                   [[value = that.value;]])[]b4_locations_if([
+    location = that.location;])[
+    // that is emptied.
+    that.state = empty_state;
+    return *this;
+  }
+#endif
+
+  template <typename Base>
+  void
+  ]b4_parser_class[::yy_destroy_ (const char* yymsg, basic_symbol<Base>& yysym) const
+  {
+    if (yymsg)
+      YY_SYMBOL_PRINT (yymsg, yysym);]b4_variant_if([], [
+
+    // User destructor.
+    b4_symbol_actions([destructor], [yysym.type_get ()])])[
+  }
+
+#if ]b4_api_PREFIX[DEBUG
+  template <typename Base>
+  void
+  ]b4_parser_class[::yy_print_ (std::ostream& yyo,
+                                     const basic_symbol<Base>& yysym) const
+  {
+    std::ostream& yyoutput = yyo;
+    YYUSE (yyoutput);
+    symbol_number_type yytype = yysym.type_get ();
+#if defined __GNUC__ && ! defined __clang__ && ! defined __ICC && __GNUC__ * 100 + __GNUC_MINOR__ <= 408
+    // Avoid a (spurious) G++ 4.8 warning about "array subscript is
+    // below array bounds".
+    if (yysym.empty ())
+      std::abort ();
+#endif
+    yyo << (yytype < yyntokens_ ? "token" : "nterm")
+        << ' ' << yytname_[yytype] << " ("]b4_locations_if([
+        << yysym.location << ": "])[;
+    ]b4_symbol_actions([printer])[
+    yyo << ')';
+  }
+#endif
+
+  void
+  ]b4_parser_class[::yypush_ (const char* m, YY_MOVE_REF (stack_symbol_type) sym)
+  {
+    if (m)
+      YY_SYMBOL_PRINT (m, sym);
+    yystack_.push (YY_MOVE (sym));
+  }
+
+  void
+  ]b4_parser_class[::yypush_ (const char* m, state_type s, YY_MOVE_REF (symbol_type) sym)
+  {
+#if 201103L <= YY_CPLUSPLUS
+    yypush_ (m, stack_symbol_type (s, std::move (sym)));
+#else
+    stack_symbol_type ss (s, sym);
+    yypush_ (m, ss);
+#endif
+  }
+
+  void
+  ]b4_parser_class[::yypop_ (int n)
+  {
+    yystack_.pop (n);
+  }
+
+#if ]b4_api_PREFIX[DEBUG
+  std::ostream&
+  ]b4_parser_class[::debug_stream () const
+  {
+    return *yycdebug_;
+  }
+
+  void
+  ]b4_parser_class[::set_debug_stream (std::ostream& o)
+  {
+    yycdebug_ = &o;
+  }
+
+
+  ]b4_parser_class[::debug_level_type
+  ]b4_parser_class[::debug_level () const
+  {
+    return yydebug_;
+  }
+
+  void
+  ]b4_parser_class[::set_debug_level (debug_level_type l)
+  {
+    yydebug_ = l;
+  }
+#endif // ]b4_api_PREFIX[DEBUG
+
+  ]b4_parser_class[::state_type
+  ]b4_parser_class[::yy_lr_goto_state_ (state_type yystate, int yysym)
+  {
+    int yyr = yypgoto_[yysym - yyntokens_] + yystate;
+    if (0 <= yyr && yyr <= yylast_ && yycheck_[yyr] == yystate)
+      return yytable_[yyr];
+    else
+      return yydefgoto_[yysym - yyntokens_];
+  }
+
+  bool
+  ]b4_parser_class[::yy_pact_value_is_default_ (int yyvalue)
+  {
+    return yyvalue == yypact_ninf_;
+  }
+
+  bool
+  ]b4_parser_class[::yy_table_value_is_error_ (int yyvalue)
+  {
+    return yyvalue == yytable_ninf_;
+  }
+
+  int
+  ]b4_parser_class[::operator() ()
+  {
+    return parse ();
+  }
+
+  int
+  ]b4_parser_class[::parse ()
+  {
+    int yyn;
+    /// Length of the RHS of the rule being reduced.
+    int yylen = 0;
+
+    // Error handling.
+    int yynerrs_ = 0;
+    int yyerrstatus_ = 0;
+
+    /// The lookahead symbol.
+    symbol_type yyla;]b4_locations_if([[
+
+    /// The locations where the error started and ended.
+    stack_symbol_type yyerror_range[3];]])[
+
+    /// The return value of parse ().
+    int yyresult;]b4_lac_if([[
+
+    /// Discard the LAC context in case there still is one left from a
+    /// previous invocation.
+    yy_lac_discard_ ("init");]])[
+
+#if YY_EXCEPTIONS
+    try
+#endif // YY_EXCEPTIONS
+      {
+    YYCDEBUG << "Starting parse\n";
+
+]m4_ifdef([b4_initial_action], [
+b4_dollar_pushdef([yyla.value], [], [], [yyla.location])dnl
+    b4_user_initial_action
+b4_dollar_popdef])[]dnl
+
+  [  /* Initialize the stack.  The initial state will be set in
+       yynewstate, since the latter expects the semantical and the
+       location values to have been already stored, initialize these
+       stacks with a primary value.  */
+    yystack_.clear ();
+    yypush_ (YY_NULLPTR, 0, YY_MOVE (yyla));
+
+  /*-----------------------------------------------.
+  | yynewstate -- push a new symbol on the stack.  |
+  `-----------------------------------------------*/
+  yynewstate:
+    YYCDEBUG << "Entering state " << int (yystack_[0].state) << '\n';
+
+    // Accept?
+    if (yystack_[0].state == yyfinal_)
+      YYACCEPT;
+
+    goto yybackup;
+
+
+  /*-----------.
+  | yybackup.  |
+  `-----------*/
+  yybackup:
+    // Try to take a decision without lookahead.
+    yyn = yypact_[yystack_[0].state];
+    if (yy_pact_value_is_default_ (yyn))
+      goto yydefault;
+
+    // Read a lookahead token.
+    if (yyla.empty ())
+      {
+        YYCDEBUG << "Reading a token: ";
+#if YY_EXCEPTIONS
+        try
+#endif // YY_EXCEPTIONS
+          {]b4_token_ctor_if([[
+            symbol_type yylookahead (]b4_lex[);
+            yyla.move (yylookahead);]], [[
+            yyla.type = yytranslate_ (]b4_lex[);]])[
+          }
+#if YY_EXCEPTIONS
+        catch (const syntax_error& yyexc)
+          {
+            YYCDEBUG << "Caught exception: " << yyexc.what() << '\n';
+            error (yyexc);
+            goto yyerrlab1;
+          }
+#endif // YY_EXCEPTIONS
+      }
+    YY_SYMBOL_PRINT ("Next token is", yyla);
+
+    /* If the proper action on seeing token YYLA.TYPE is to reduce or
+       to detect an error, take that action.  */
+    yyn += yyla.type_get ();
+    if (yyn < 0 || yylast_ < yyn || yycheck_[yyn] != yyla.type_get ())
+      {]b4_lac_if([[
+        if (!yy_lac_establish_ (yyla.type_get ()))
+           goto yyerrlab;]])[
+        goto yydefault;
+      }
+
+    // Reduce or error.
+    yyn = yytable_[yyn];
+    if (yyn <= 0)
+      {
+        if (yy_table_value_is_error_ (yyn))
+          goto yyerrlab;]b4_lac_if([[
+        if (!yy_lac_establish_ (yyla.type_get ()))
+           goto yyerrlab;
+]])[
+        yyn = -yyn;
+        goto yyreduce;
+      }
+
+    // Count tokens shifted since error; after three, turn off error status.
+    if (yyerrstatus_)
+      --yyerrstatus_;
+
+    // Shift the lookahead token.
+    yypush_ ("Shifting", static_cast<state_type> (yyn), YY_MOVE (yyla));]b4_lac_if([[
+    yy_lac_discard_ ("shift");]])[
+    goto yynewstate;
+
+
+  /*-----------------------------------------------------------.
+  | yydefault -- do the default action for the current state.  |
+  `-----------------------------------------------------------*/
+  yydefault:
+    yyn = yydefact_[yystack_[0].state];
+    if (yyn == 0)
+      goto yyerrlab;
+    goto yyreduce;
+
+
+  /*-----------------------------.
+  | yyreduce -- do a reduction.  |
+  `-----------------------------*/
+  yyreduce:
+    yylen = yyr2_[yyn];
+    {
+      stack_symbol_type yylhs;
+      yylhs.state = yy_lr_goto_state_ (yystack_[yylen].state, yyr1_[yyn]);]b4_variant_if([
+      /* Variants are always initialized to an empty instance of the
+         correct type. The default '$$ = $1' action is NOT applied
+         when using variants.  */
+      b4_symbol_variant([[yyr1_@{yyn@}]], [yylhs.value], [emplace])], [
+      /* If YYLEN is nonzero, implement the default value of the
+         action: '$$ = $1'.  Otherwise, use the top of the stack.
+
+         Otherwise, the following line sets YYLHS.VALUE to garbage.
+         This behavior is undocumented and Bison users should not rely
+         upon it.  */
+      if (yylen)
+        yylhs.value = yystack_@{yylen - 1@}.value;
+      else
+        yylhs.value = yystack_@{0@}.value;])[
+]b4_locations_if([dnl
+[
+      // Default location.
+      {
+        stack_type::slice range (yystack_, yylen);
+        YYLLOC_DEFAULT (yylhs.location, range, yylen);
+        yyerror_range[1].location = yylhs.location;
+      }]])[
+
+      // Perform the reduction.
+      YY_REDUCE_PRINT (yyn);
+#if YY_EXCEPTIONS
+      try
+#endif // YY_EXCEPTIONS
+        {
+          switch (yyn)
+            {
+]b4_user_actions[
+            default:
+              break;
+            }
+        }
+#if YY_EXCEPTIONS
+      catch (const syntax_error& yyexc)
+        {
+          YYCDEBUG << "Caught exception: " << yyexc.what() << '\n';
+          error (yyexc);
+          YYERROR;
+        }
+#endif // YY_EXCEPTIONS
+      YY_SYMBOL_PRINT ("-> $$ =", yylhs);
+      yypop_ (yylen);
+      yylen = 0;
+      YY_STACK_PRINT ();
+
+      // Shift the result of the reduction.
+      yypush_ (YY_NULLPTR, YY_MOVE (yylhs));
+    }
+    goto yynewstate;
+
+
+  /*--------------------------------------.
+  | yyerrlab -- here on detecting error.  |
+  `--------------------------------------*/
+  yyerrlab:
+    // If not already recovering from an error, report this error.
+    if (!yyerrstatus_)
+      {
+        ++yynerrs_;
+        error (]b4_join(b4_locations_if([yyla.location]),
+                        [[yysyntax_error_ (yystack_[0].state, yyla)]])[);
+      }
+
+]b4_locations_if([[
+    yyerror_range[1].location = yyla.location;]])[
+    if (yyerrstatus_ == 3)
+      {
+        /* If just tried and failed to reuse lookahead token after an
+           error, discard it.  */
+
+        // Return failure if at end of input.
+        if (yyla.type_get () == yyeof_)
+          YYABORT;
+        else if (!yyla.empty ())
+          {
+            yy_destroy_ ("Error: discarding", yyla);
+            yyla.clear ();
+          }
+      }
+
+    // Else will try to reuse lookahead token after shifting the error token.
+    goto yyerrlab1;
+
+
+  /*---------------------------------------------------.
+  | yyerrorlab -- error raised explicitly by YYERROR.  |
+  `---------------------------------------------------*/
+  yyerrorlab:
+    /* Pacify compilers when the user code never invokes YYERROR and
+       the label yyerrorlab therefore never appears in user code.  */
+    if (false)
+      YYERROR;
+
+    /* Do not reclaim the symbols of the rule whose action triggered
+       this YYERROR.  */
+    yypop_ (yylen);
+    yylen = 0;
+    goto yyerrlab1;
+
+
+  /*-------------------------------------------------------------.
+  | yyerrlab1 -- common code for both syntax error and YYERROR.  |
+  `-------------------------------------------------------------*/
+  yyerrlab1:
+    yyerrstatus_ = 3;   // Each real token shifted decrements this.
+    {
+      stack_symbol_type error_token;
+      for (;;)
+        {
+          yyn = yypact_[yystack_[0].state];
+          if (!yy_pact_value_is_default_ (yyn))
+            {
+              yyn += yy_error_token_;
+              if (0 <= yyn && yyn <= yylast_ && yycheck_[yyn] == yy_error_token_)
+                {
+                  yyn = yytable_[yyn];
+                  if (0 < yyn)
+                    break;
+                }
+            }
+
+          // Pop the current state because it cannot handle the error token.
+          if (yystack_.size () == 1)
+            YYABORT;
+]b4_locations_if([[
+          yyerror_range[1].location = yystack_[0].location;]])[
+          yy_destroy_ ("Error: popping", yystack_[0]);
+          yypop_ ();
+          YY_STACK_PRINT ();
+        }
+]b4_locations_if([[
+      yyerror_range[2].location = yyla.location;
+      YYLLOC_DEFAULT (error_token.location, yyerror_range, 2);]])[
+
+      // Shift the error token.]b4_lac_if([[
+      yy_lac_discard_ ("error recovery");]])[
+      error_token.state = static_cast<state_type> (yyn);
+      yypush_ ("Shifting", YY_MOVE (error_token));
+    }
+    goto yynewstate;
+
+
+  /*-------------------------------------.
+  | yyacceptlab -- YYACCEPT comes here.  |
+  `-------------------------------------*/
+  yyacceptlab:
+    yyresult = 0;
+    goto yyreturn;
+
+
+  /*-----------------------------------.
+  | yyabortlab -- YYABORT comes here.  |
+  `-----------------------------------*/
+  yyabortlab:
+    yyresult = 1;
+    goto yyreturn;
+
+
+  /*-----------------------------------------------------.
+  | yyreturn -- parsing is finished, return the result.  |
+  `-----------------------------------------------------*/
+  yyreturn:
+    if (!yyla.empty ())
+      yy_destroy_ ("Cleanup: discarding lookahead", yyla);
+
+    /* Do not reclaim the symbols of the rule whose action triggered
+       this YYABORT or YYACCEPT.  */
+    yypop_ (yylen);
+    while (1 < yystack_.size ())
+      {
+        yy_destroy_ ("Cleanup: popping", yystack_[0]);
+        yypop_ ();
+      }
+
+    return yyresult;
+  }
+#if YY_EXCEPTIONS
+    catch (...)
+      {
+        YYCDEBUG << "Exception caught: cleaning lookahead and stack\n";
+        // Do not try to display the values of the reclaimed symbols,
+        // as their printers might throw an exception.
+        if (!yyla.empty ())
+          yy_destroy_ (YY_NULLPTR, yyla);
+
+        while (1 < yystack_.size ())
+          {
+            yy_destroy_ (YY_NULLPTR, yystack_[0]);
+            yypop_ ();
+          }
+        throw;
+      }
+#endif // YY_EXCEPTIONS
+  }
+
+  void
+  ]b4_parser_class[::error (const syntax_error& yyexc)
+  {
+    error (]b4_join(b4_locations_if([yyexc.location]),
+                    [[yyexc.what ()]])[);
+  }]b4_lac_if([[
+
+  bool
+  ]b4_parser_class[::yy_lac_check_ (int yytoken) const
+  {
+    // Logically, the yylac_stack's lifetime is confined to this function.
+    // Clear it, to get rid of potential left-overs from previous call.
+    yylac_stack_.clear ();
+    // Reduce until we encounter a shift and thereby accept the token.
+#if ]b4_api_PREFIX[DEBUG
+    YYCDEBUG << "LAC: checking lookahead " << yytname_[yytoken] << ':';
+#endif
+    std::ptrdiff_t lac_top = 0;
+    while (true)
+      {
+        state_type top_state = (yylac_stack_.empty ()
+                                ? yystack_[lac_top].state
+                                : yylac_stack_.back ());
+        int yyrule = yypact_[top_state];
+        if (yy_pact_value_is_default_ (yyrule)
+            || (yyrule += yytoken) < 0 || yylast_ < yyrule
+            || yycheck_[yyrule] != yytoken)
+          {
+            // Use the default action.
+            yyrule = yydefact_[top_state];
+            if (yyrule == 0)
+              {
+                YYCDEBUG << " Err\n";
+                return false;
+              }
+          }
+        else
+          {
+            // Use the action from yytable.
+            yyrule = yytable_[yyrule];
+            if (yy_table_value_is_error_ (yyrule))
+              {
+                YYCDEBUG << " Err\n";
+                return false;
+              }
+            if (0 < yyrule)
+              {
+                YYCDEBUG << " S" << yyrule << '\n';
+                return true;
+              }
+            yyrule = -yyrule;
+          }
+        // By now we know we have to simulate a reduce.
+        YYCDEBUG << " R" << yyrule - 1;
+        // Pop the corresponding number of values from the stack.
+        {
+          std::ptrdiff_t yylen = yyr2_[yyrule];
+          // First pop from the LAC stack as many tokens as possible.
+          std::ptrdiff_t lac_size = std::ptrdiff_t (yylac_stack_.size ());
+          if (yylen < lac_size)
+            {
+              yylac_stack_.resize (std::size_t (lac_size - yylen));
+              yylen = 0;
+            }
+          else if (lac_size)
+            {
+              yylac_stack_.clear ();
+              yylen -= lac_size;
+            }
+          // Only afterwards look at the main stack.
+          // We simulate popping elements by incrementing lac_top.
+          lac_top += yylen;
+        }
+        // Keep top_state in sync with the updated stack.
+        top_state = (yylac_stack_.empty ()
+                     ? yystack_[lac_top].state
+                     : yylac_stack_.back ());
+        // Push the resulting state of the reduction.
+        state_type state = yy_lr_goto_state_ (top_state, yyr1_[yyrule]);
+        YYCDEBUG << " G" << state;
+        yylac_stack_.push_back (state);
+      }
+  }
+
+  // Establish the initial context if no initial context currently exists.
+  bool
+  ]b4_parser_class[::yy_lac_establish_ (int yytoken)
+  {
+    /* Establish the initial context for the current lookahead if no initial
+       context is currently established.
+
+       We define a context as a snapshot of the parser stacks.  We define
+       the initial context for a lookahead as the context in which the
+       parser initially examines that lookahead in order to select a
+       syntactic action.  Thus, if the lookahead eventually proves
+       syntactically unacceptable (possibly in a later context reached via a
+       series of reductions), the initial context can be used to determine
+       the exact set of tokens that would be syntactically acceptable in the
+       lookahead's place.  Moreover, it is the context after which any
+       further semantic actions would be erroneous because they would be
+       determined by a syntactically unacceptable token.
+
+       yy_lac_establish_ should be invoked when a reduction is about to be
+       performed in an inconsistent state (which, for the purposes of LAC,
+       includes consistent states that don't know they're consistent because
+       their default reductions have been disabled).
+
+       For parse.lac=full, the implementation of yy_lac_establish_ is as
+       follows.  If no initial context is currently established for the
+       current lookahead, then check if that lookahead can eventually be
+       shifted if syntactic actions continue from the current context.  */
+    if (!yy_lac_established_)
+      {
+#if ]b4_api_PREFIX[DEBUG
+        YYCDEBUG << "LAC: initial context established for "
+                 << yytname_[yytoken] << '\n';
+#endif
+        yy_lac_established_ = true;
+        return yy_lac_check_ (yytoken);
+      }
+    return true;
+  }
+
+  // Discard any previous initial lookahead context.
+  void
+  ]b4_parser_class[::yy_lac_discard_ (const char* evt)
+  {
+   /* Discard any previous initial lookahead context because of Event,
+      which may be a lookahead change or an invalidation of the currently
+      established initial context for the current lookahead.
+
+      The most common example of a lookahead change is a shift.  An example
+      of both cases is syntax error recovery.  That is, a syntax error
+      occurs when the lookahead is syntactically erroneous for the
+      currently established initial context, so error recovery manipulates
+      the parser stacks to try to find a new initial context in which the
+      current lookahead is syntactically acceptable.  If it fails to find
+      such a context, it discards the lookahead.  */
+    if (yy_lac_established_)
+      {
+        YYCDEBUG << "LAC: initial context discarded due to "
+                 << evt << '\n';
+        yy_lac_established_ = false;
+      }
+  }]])[
+
+  // Generate an error message.
+  std::string
+  ]b4_parser_class[::yysyntax_error_ (]dnl
+b4_error_verbose_if([state_type yystate, const symbol_type& yyla],
+                    [state_type, const symbol_type&])[) const
+  {]b4_error_verbose_if([[
+    // Number of reported tokens (one for the "unexpected", one per
+    // "expected").
+    std::ptrdiff_t yycount = 0;
+    // Its maximum.
+    enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+    // Arguments of yyformat.
+    char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+
+    /* There are many possibilities here to consider:
+       - If this state is a consistent state with a default action, then
+         the only way this function was invoked is if the default action
+         is an error action.  In that case, don't check for expected
+         tokens because there are none.
+       - The only way there can be no lookahead present (in yyla) is
+         if this state is a consistent state with a default action.
+         Thus, detecting the absence of a lookahead is sufficient to
+         determine that there is no unexpected or expected token to
+         report.  In that case, just report a simple "syntax error".
+       - Don't assume there isn't a lookahead just because this state is
+         a consistent state with a default action.  There might have
+         been a previous inconsistent state, consistent state with a
+         non-default action, or user semantic action that manipulated
+         yyla.  (However, yyla is currently not documented for users.)]b4_lac_if([[
+         In the first two cases, it might appear that the current syntax
+         error should have been detected in the previous state when
+         yy_lac_check was invoked.  However, at that time, there might
+         have been a different syntax error that discarded a different
+         initial context during error recovery, leaving behind the
+         current lookahead.]], [[
+       - Of course, the expected token list depends on states to have
+         correct lookahead information, and it depends on the parser not
+         to perform extra reductions after fetching a lookahead from the
+         scanner and before detecting a syntax error.  Thus, state merging
+         (from LALR or IELR) and default reductions corrupt the expected
+         token list.  However, the list is correct for canonical LR with
+         one exception: it will still contain any token that will not be
+         accepted due to an error action in a later state.]])[
+    */
+    if (!yyla.empty ())
+      {
+        symbol_number_type yytoken = yyla.type_get ();
+        yyarg[yycount++] = yytname_[yytoken];]b4_lac_if([[
+
+#if ]b4_api_PREFIX[DEBUG
+        // Execute LAC once. We don't care if it is succesful, we
+        // only do it for the sake of debugging output.
+        if (!yy_lac_established_)
+          yy_lac_check_ (yytoken);
+#endif]])[
+
+        int yyn = yypact_[yystate];
+        if (!yy_pact_value_is_default_ (yyn))
+          {]b4_lac_if([[
+            for (int yyx = 0; yyx < yyntokens_; ++yyx)
+              if (yyx != yy_error_token_ && yyx != yy_undef_token_
+                  && yy_lac_check_ (yyx))
+                {]], [[
+            /* Start YYX at -YYN if negative to avoid negative indexes in
+               YYCHECK.  In other words, skip the first -YYN actions for
+               this state because they are default actions.  */
+            int yyxbegin = yyn < 0 ? -yyn : 0;
+            // Stay within bounds of both yycheck and yytname.
+            int yychecklim = yylast_ - yyn + 1;
+            int yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_;
+            for (int yyx = yyxbegin; yyx < yyxend; ++yyx)
+              if (yycheck_[yyx + yyn] == yyx && yyx != yy_error_token_
+                  && !yy_table_value_is_error_ (yytable_[yyx + yyn]))
+                {]])[
+                  if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                    {
+                      yycount = 1;
+                      break;
+                    }
+                  else
+                    yyarg[yycount++] = yytname_[yyx];
+                }
+          }
+      }
+
+    char const* yyformat = YY_NULLPTR;
+    switch (yycount)
+      {
+#define YYCASE_(N, S)                         \
+        case N:                               \
+          yyformat = S;                       \
+        break
+      default: // Avoid compiler warnings.
+        YYCASE_ (0, YY_("syntax error"));
+        YYCASE_ (1, YY_("syntax error, unexpected %s"));
+        YYCASE_ (2, YY_("syntax error, unexpected %s, expecting %s"));
+        YYCASE_ (3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+        YYCASE_ (4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+        YYCASE_ (5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+#undef YYCASE_
+      }
+
+    std::string yyres;
+    // Argument number.
+    std::ptrdiff_t yyi = 0;
+    for (char const* yyp = yyformat; *yyp; ++yyp)
+      if (yyp[0] == '%' && yyp[1] == 's' && yyi < yycount)
+        {
+          yyres += yytnamerr_ (yyarg[yyi++]);
+          ++yyp;
+        }
+      else
+        yyres += *yyp;
+    return yyres;]], [[
+    return YY_("syntax error");]])[
+  }
+
+
+  const ]b4_int_type(b4_pact_ninf, b4_pact_ninf) b4_parser_class::yypact_ninf_ = b4_pact_ninf[;
+
+  const ]b4_int_type(b4_table_ninf, b4_table_ninf) b4_parser_class::yytable_ninf_ = b4_table_ninf[;
+
+]b4_parser_tables_define[
+
+]b4_token_table_if([], [[#if ]b4_api_PREFIX[DEBUG]])[
+  // YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+  // First, the terminals, then, starting at \a yyntokens_, nonterminals.
+  const char*
+  const ]b4_parser_class[::yytname_[] =
+  {
+  ]b4_tname[
+  };
+
+]b4_token_table_if([[#if ]b4_api_PREFIX[DEBUG]])[
+]b4_integral_parser_table_define([rline], [b4_rline])[
+
+  // Print the state stack on the debug stream.
+  void
+  ]b4_parser_class[::yystack_print_ ()
+  {
+    *yycdebug_ << "Stack now";
+    for (stack_type::const_iterator
+           i = yystack_.begin (),
+           i_end = yystack_.end ();
+         i != i_end; ++i)
+      *yycdebug_ << ' ' << int (i->state);
+    *yycdebug_ << '\n';
+  }
+
+  // Report on the debug stream that the rule \a yyrule is going to be reduced.
+  void
+  ]b4_parser_class[::yy_reduce_print_ (int yyrule)
+  {
+    int yylno = yyrline_[yyrule];
+    int yynrhs = yyr2_[yyrule];
+    // Print the symbols being reduced, and their result.
+    *yycdebug_ << "Reducing stack by rule " << yyrule - 1
+               << " (line " << yylno << "):\n";
+    // The symbols being reduced.
+    for (int yyi = 0; yyi < yynrhs; yyi++)
+      YY_SYMBOL_PRINT ("   $" << yyi + 1 << " =",
+                       ]b4_rhs_data(yynrhs, yyi + 1)[);
+  }
+#endif // ]b4_api_PREFIX[DEBUG
+
+]b4_token_ctor_if([], [b4_yytranslate_define([cc])])[
+]b4_namespace_close[
+]b4_epilogue[]dnl
+b4_output_end
+
+
+m4_popdef([b4_copyright_years])dnl
diff --git a/common/bison/skeletons/lalr1.d b/common/bison/skeletons/lalr1.d
new file mode 100644
index 0000000000000000000000000000000000000000..5aa2fb6e7d3d09c3c672440f0ccb74bd644cd3cb
--- /dev/null
+++ b/common/bison/skeletons/lalr1.d
@@ -0,0 +1,895 @@
+# D skeleton for Bison -*- autoconf -*-
+
+# Copyright (C) 2007-2012, 2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+m4_include(b4_skeletonsdir/[d.m4])
+
+
+b4_output_begin([b4_parser_file_name])
+b4_copyright([Skeleton implementation for Bison LALR(1) parsers in D],
+             [2007-2012, 2019])[
+
+]b4_percent_define_ifdef([package], [module b4_percent_define_get([package]);
+])[
+version(D_Version2) {
+} else {
+  static assert(false, "need compiler for D Version 2");
+}
+
+]b4_user_pre_prologue[
+]b4_user_post_prologue[
+]b4_percent_code_get([[imports]])[
+import std.format;
+
+/**
+ * A Bison parser, automatically generated from <tt>]m4_bpatsubst(b4_file_name, [^"\(.*\)"$], [\1])[</tt>.
+ *
+ * @@author LALR (1) parser skeleton written by Paolo Bonzini.
+ * Port to D language was done by Oliver Mangold.
+ */
+
+/**
+ * Communication interface between the scanner and the Bison-generated
+ * parser <tt>]b4_parser_class[</tt>.
+ */
+public interface Lexer
+{]b4_locations_if([[
+  /**
+   * Method to retrieve the beginning position of the last scanned token.
+   * @@return the position at which the last scanned token starts.  */
+  @@property ]b4_position_type[ startPos ();
+
+  /**
+   * Method to retrieve the ending position of the last scanned token.
+   * @@return the first position beyond the last scanned token.  */
+  @@property ]b4_position_type[ endPos ();
+
+]])[
+  /**
+   * Method to retrieve the semantic value of the last scanned token.
+   * @@return the semantic value of the last scanned token.  */
+  @@property ]b4_yystype[ semanticVal ();
+
+  /**
+   * Entry point for the scanner.  Returns the token identifier corresponding
+   * to the next token and prepares to return the semantic value
+   * ]b4_locations_if([and beginning/ending positions ])[of the token.
+   * @@return the token identifier corresponding to the next token. */
+  int yylex ();
+
+  /**
+   * Entry point for error reporting.  Emits an error
+   * ]b4_locations_if([referring to the given location ])[in a user-defined way.
+   *]b4_locations_if([[
+   * @@param loc The location of the element to which the
+   *                error message is related]])[
+   * @@param s The string for the error message.  */
+   void yyerror (]b4_locations_if([b4_location_type[ loc, ]])[string s);
+}
+
+]b4_locations_if([b4_position_type_if([[
+static assert(__traits(compiles,
+              (new ]b4_position_type[[1])[0]=(new ]b4_position_type[[1])[0]),
+              "struct/class ]b4_position_type[ must be default-constructible "
+              "and assignable");
+static assert(__traits(compiles, (new string[1])[0]=(new ]b4_position_type[).toString()),
+              "error: struct/class ]b4_position_type[ must have toString method");
+]], [[
+  /**
+   * A struct denoting a point in the input.*/
+public struct ]b4_position_type[ {
+
+  /** The column index within the line of input.  */
+  public int column = 1;
+  /** The line number within an input file.  */
+  public int line = 1;
+  /** The name of the input file.  */
+  public string filename = null;
+
+  /**
+   * A string representation of the position. */
+  public string toString() const {
+    if (filename)
+      return format("%s:%d.%d", filename, line, column);
+    else
+      return format("%d.%d", line, column);
+  }
+}
+]])b4_location_type_if([[
+static assert(__traits(compiles, (new ]b4_location_type[((new ]b4_position_type[[1])[0]))) &&
+              __traits(compiles, (new ]b4_location_type[((new ]b4_position_type[[1])[0], (new ]b4_position_type[[1])[0]))),
+              "error: struct/class ]b4_location_type[ must have "
+              "default constructor and constructors this(]b4_position_type[) and this(]b4_position_type[, ]b4_position_type[).");
+static assert(__traits(compiles, (new ]b4_location_type[[1])[0].begin=(new ]b4_location_type[[1])[0].begin) &&
+              __traits(compiles, (new ]b4_location_type[[1])[0].begin=(new ]b4_location_type[[1])[0].end) &&
+              __traits(compiles, (new ]b4_location_type[[1])[0].end=(new ]b4_location_type[[1])[0].begin) &&
+              __traits(compiles, (new ]b4_location_type[[1])[0].end=(new ]b4_location_type[[1])[0].end),
+              "error: struct/class ]b4_location_type[ must have assignment-compatible "
+              "members/properties 'begin' and 'end'.");
+static assert(__traits(compiles, (new string[1])[0]=(new ]b4_location_type[[1])[0].toString()),
+              "error: struct/class ]b4_location_type[ must have toString method.");
+
+private immutable bool yy_location_is_class = !__traits(compiles, *(new ]b4_location_type[((new ]b4_position_type[[1])[0])));]], [[
+/**
+ * A class defining a pair of positions.  Positions, defined by the
+ * <code>]b4_position_type[</code> class, denote a point in the input.
+ * Locations represent a part of the input through the beginning
+ * and ending positions.  */
+public class ]b4_location_type[
+{
+  /** The first, inclusive, position in the range.  */
+  public ]b4_position_type[ begin;
+
+  /** The first position beyond the range.  */
+  public ]b4_position_type[ end;
+
+  /**
+   * Create a <code>]b4_location_type[</code> denoting an empty range located at
+   * a given point.
+   * @@param loc The position at which the range is anchored.  */
+  public this (]b4_position_type[ loc) {
+    this.begin = this.end = loc;
+  }
+
+  public this () {
+  }
+
+  /**
+   * Create a <code>]b4_location_type[</code> from the endpoints of the range.
+   * @@param begin The first position included in the range.
+   * @@param end   The first position beyond the range.  */
+  public this (]b4_position_type[ begin, ]b4_position_type[ end)
+  {
+    this.begin = begin;
+    this.end = end;
+  }
+
+  /**
+   * A representation of the location. For this to be correct,
+   * <code>]b4_position_type[</code> should override the <code>toString</code>
+   * method.  */
+  public override string toString () const {
+    auto end_col = 0 < end.column ? end.column - 1 : 0;
+    auto res = begin.toString ();
+    if (end.filename && begin.filename != end.filename)
+      res ~= "-" ~ format("%s:%d.%d", end.filename, end.line, end_col);
+    else if (begin.line < end.line)
+      res ~= "-" ~ format("%d.%d", end.line, end_col);
+    else if (begin.column < end_col)
+      res ~= "-" ~ format("%d", end_col);
+    return res;
+  }
+}
+
+private immutable bool yy_location_is_class = true;
+
+]])])m4_ifdef([b4_user_union_members], [private union YYSemanticType
+{
+b4_user_union_members
+};],
+[m4_if(b4_tag_seen_flag, 0,
+[[private alias int YYSemanticType;]])])[
+]b4_token_enums(b4_tokens)[
+]b4_parser_class_declaration[
+{
+  ]b4_identification[
+
+]b4_locations_if([[
+  private final ]b4_location_type[ yylloc_from_stack (ref YYStack rhs, int n)
+  {
+    static if (yy_location_is_class) {
+      if (n > 0)
+        return new ]b4_location_type[ (rhs.locationAt (n-1).begin, rhs.locationAt (0).end);
+      else
+        return new ]b4_location_type[ (rhs.locationAt (0).end);
+    } else {
+      if (n > 0)
+        return ]b4_location_type[ (rhs.locationAt (n-1).begin, rhs.locationAt (0).end);
+      else
+        return ]b4_location_type[ (rhs.locationAt (0).end);
+    }
+  }]])[
+
+]b4_lexer_if([[  private class YYLexer implements Lexer {
+]b4_percent_code_get([[lexer]])[
+  }
+]])[
+  /** The object doing lexical analysis for us.  */
+  private Lexer yylexer;
+
+]b4_parse_param_vars[
+
+]b4_lexer_if([[
+  /**
+   * Instantiate the Bison-generated parser.
+   */
+  public this] (b4_parse_param_decl([b4_lex_param_decl])[) {
+    this (new YYLexer(]b4_lex_param_call[));
+  }
+]])[
+
+  /**
+   * Instantiate the Bison-generated parser.
+   * @@param yylexer The scanner that will supply tokens to the parser.
+   */
+  ]b4_lexer_if([[protected]], [[public]]) [this (]b4_parse_param_decl([[Lexer yylexer]])[) {
+    this.yylexer = yylexer;]b4_parse_trace_if([[
+    this.yyDebugStream = stderr;]])[
+]b4_parse_param_cons[
+  }
+]b4_parse_trace_if([[
+  private File yyDebugStream;
+
+  /**
+   * The <tt>File</tt> on which the debugging output is
+   * printed.
+   */
+  public File getDebugStream () { return yyDebugStream; }
+
+  /**
+   * Set the <tt>std.File</tt> on which the debug output is printed.
+   * @@param s The stream that is used for debugging output.
+   */
+  public final void setDebugStream(File s) { yyDebugStream = s; }
+
+  private int yydebug = 0;
+
+  /**
+   * Answer the verbosity of the debugging output; 0 means that all kinds of
+   * output from the parser are suppressed.
+   */
+  public final int getDebugLevel() { return yydebug; }
+
+  /**
+   * Set the verbosity of the debugging output; 0 means that all kinds of
+   * output from the parser are suppressed.
+   * @@param level The verbosity level for debugging output.
+   */
+  public final void setDebugLevel(int level) { yydebug = level; }
+
+  protected final void yycdebug (string s) {
+    if (0 < yydebug)
+      yyDebugStream.writeln (s);
+  }
+]])[
+  private final int yylex () {
+    return yylexer.yylex ();
+  }
+
+  protected final void yyerror (]b4_locations_if(ref [b4_location_type[ loc, ]])[string s) {
+    yylexer.yyerror (]b4_locations_if([loc, ])[s);
+  }
+
+  /**
+   * Returned by a Bison action in order to stop the parsing process and
+   * return success (<tt>true</tt>).  */
+  public static immutable int YYACCEPT = 0;
+
+  /**
+   * Returned by a Bison action in order to stop the parsing process and
+   * return failure (<tt>false</tt>).  */
+  public static immutable int YYABORT = 1;
+
+  /**
+   * Returned by a Bison action in order to start error recovery without
+   * printing an error message.  */
+  public static immutable int YYERROR = 2;
+
+  // Internal return codes that are not supported for user semantic
+  // actions.
+  private static immutable int YYERRLAB = 3;
+  private static immutable int YYNEWSTATE = 4;
+  private static immutable int YYDEFAULT = 5;
+  private static immutable int YYREDUCE = 6;
+  private static immutable int YYERRLAB1 = 7;
+  private static immutable int YYRETURN = 8;
+]b4_locations_if([
+  private static immutable YYSemanticType yy_semantic_null;])[
+  private int yyerrstatus_ = 0;
+
+  /**
+   * Whether error recovery is being done.  In this state, the parser
+   * reads token until it reaches a known state, and then restarts normal
+   * operation.  */
+  public final bool recovering ()
+  {
+    return yyerrstatus_ == 0;
+  }
+
+  private int yyaction (int yyn, ref YYStack yystack, int yylen)
+  {
+    ]b4_yystype[ yyval;]b4_locations_if([[
+    ]b4_location_type[ yyloc = yylloc_from_stack (yystack, yylen);]])[
+
+    /* If YYLEN is nonzero, implement the default value of the action:
+       `$$ = $1'.  Otherwise, use the top of the stack.
+
+       Otherwise, the following line sets YYVAL to garbage.
+       This behavior is undocumented and Bison
+       users should not rely upon it.  */
+    if (yylen > 0)
+      yyval = yystack.valueAt (yylen - 1);
+    else
+      yyval = yystack.valueAt (0);
+
+]b4_parse_trace_if([[
+    yy_reduce_print (yyn, yystack);]])[
+
+    switch (yyn)
+    {
+]b4_user_actions[
+      default: break;
+    }
+
+]b4_parse_trace_if([[
+    yy_symbol_print ("-> $$ =", yyr1_[yyn], yyval]b4_locations_if([, yyloc])[);]])[
+
+    yystack.pop (yylen);
+    yylen = 0;
+
+    /* Shift the result of the reduction.  */
+    yyn = yyr1_[yyn];
+    int yystate = yypgoto_[yyn - yyntokens_] + yystack.stateAt (0);
+    if (0 <= yystate && yystate <= yylast_
+        && yycheck_[yystate] == yystack.stateAt (0))
+      yystate = yytable_[yystate];
+    else
+      yystate = yydefgoto_[yyn - yyntokens_];
+
+    yystack.push (yystate, yyval]b4_locations_if([, yyloc])[);
+    return YYNEWSTATE;
+  }
+
+  /* Return YYSTR after stripping away unnecessary quotes and
+     backslashes, so that it's suitable for yyerror.  The heuristic is
+     that double-quoting is unnecessary unless the string contains an
+     apostrophe, a comma, or backslash (other than backslash-backslash).
+     YYSTR is taken from yytname.  */
+  private final string yytnamerr_ (string yystr)
+  {
+    if (yystr[0] == '"')
+      {
+        string yyr;
+      strip_quotes:
+        for (int i = 1; i < yystr.length; i++)
+          switch (yystr[i])
+            {
+            case '\'':
+            case ',':
+              break strip_quotes;
+
+            case '\\':
+              if (yystr[++i] != '\\')
+                break strip_quotes;
+              goto default;
+            default:
+              yyr ~= yystr[i];
+              break;
+
+            case '"':
+              return yyr;
+            }
+      }
+    else if (yystr == "$end")
+      return "end of input";
+
+    return yystr;
+  }
+]b4_parse_trace_if([[
+  /*--------------------------------.
+  | Print this symbol on YYOUTPUT.  |
+  `--------------------------------*/
+
+  private final void yy_symbol_print (string s, int yytype,
+    ref ]b4_yystype[ yyvaluep]dnl
+b4_locations_if([, ref ]b4_location_type[ yylocationp])[)
+  {
+    if (0 < yydebug)
+    {
+      string message = s ~ (yytype < yyntokens_ ? " token " : " nterm ")
+              ~ yytname_[yytype] ~ " ("]b4_locations_if([
+              ~ yylocationp.toString() ~ ": "])[;
+      static if (__traits(compiles, message ~= yyvaluep.toString ()))
+              message ~= yyvaluep.toString ();
+      else
+              message ~= format ("%s", &yyvaluep);
+      message ~= ")";
+      yycdebug (message);
+    }
+  }
+]])[
+  /**
+   * Parse input from the scanner that was specified at object construction
+   * time.  Return whether the end of the input was reached successfully.
+   *
+   * @@return <tt>true</tt> if the parsing succeeds.  Note that this does not
+   *          imply that there were no syntax errors.
+   */
+  public bool parse ()
+  {
+    /// Lookahead and lookahead in internal form.
+    int yychar = yyempty_;
+    int yytoken = 0;
+
+    /* State.  */
+    int yyn = 0;
+    int yylen = 0;
+    int yystate = 0;
+
+    YYStack yystack;
+
+    /* Error handling.  */
+    int yynerrs_ = 0;]b4_locations_if([[
+    /// The location where the error started.
+    ]b4_location_type[ yyerrloc = null;
+
+    /// ]b4_location_type[ of the lookahead.
+    ]b4_location_type[ yylloc;
+
+    /// @@$.
+    ]b4_location_type[ yyloc;]])[
+
+    /// Semantic value of the lookahead.
+    ]b4_yystype[ yylval;
+
+    int yyresult;]b4_parse_trace_if([[
+
+    yycdebug ("Starting parse\n");]])[
+    yyerrstatus_ = 0;
+
+]m4_ifdef([b4_initial_action], [
+m4_pushdef([b4_at_dollar],     [yylloc])dnl
+m4_pushdef([b4_dollar_dollar], [yylval])dnl
+    /* User initialization code.  */
+    b4_user_initial_action
+m4_popdef([b4_dollar_dollar])dnl
+m4_popdef([b4_at_dollar])])dnl
+
+  [  /* Initialize the stack.  */
+    yystack.push (yystate, yylval]b4_locations_if([, yylloc])[);
+
+    int label = YYNEWSTATE;
+    for (;;)
+      final switch (label)
+      {
+        /* New state.  Unlike in the C/C++ skeletons, the state is already
+           pushed when we come here.  */
+      case YYNEWSTATE:]b4_parse_trace_if([[
+        yycdebug (format("Entering state %d\n", yystate));
+        if (0 < yydebug)
+          yystack.print (yyDebugStream);]])[
+
+        /* Accept?  */
+        if (yystate == yyfinal_)
+          return true;
+
+        /* Take a decision.  First try without lookahead.  */
+        yyn = yypact_[yystate];
+        if (yy_pact_value_is_default_ (yyn))
+        {
+          label = YYDEFAULT;
+          break;
+        }
+
+        /* Read a lookahead token.  */
+        if (yychar == yyempty_)
+        {]b4_parse_trace_if([[
+          yycdebug ("Reading a token: ");]])[
+          yychar = yylex ();]b4_locations_if([[
+          static if (yy_location_is_class) {
+            yylloc = new ]b4_location_type[(yylexer.startPos, yylexer.endPos);
+          } else {
+            yylloc = ]b4_location_type[(yylexer.startPos, yylexer.endPos);
+          }]])
+          yylval = yylexer.semanticVal;[
+        }
+
+        /* Convert token to internal form.  */
+        yytoken = yytranslate_ (yychar);]b4_parse_trace_if([[
+        yy_symbol_print ("Next token is",
+                         yytoken, yylval]b4_locations_if([, yylloc])[);]])[
+
+        /* If the proper action on seeing token YYTOKEN is to reduce or to
+           detect an error, take that action.  */
+        yyn += yytoken;
+        if (yyn < 0 || yylast_ < yyn || yycheck_[yyn] != yytoken)
+          label = YYDEFAULT;
+
+        /* <= 0 means reduce or error.  */
+        else if ((yyn = yytable_[yyn]) <= 0)
+        {
+          if (yy_table_value_is_error_ (yyn))
+            label = YYERRLAB;
+          else
+          {
+            yyn = -yyn;
+            label = YYREDUCE;
+          }
+        }
+        else
+        {
+          /* Shift the lookahead token.  */]b4_parse_trace_if([[
+          yy_symbol_print ("Shifting", yytoken,
+                            yylval]b4_locations_if([, yylloc])[);]])[
+
+          /* Discard the token being shifted.  */
+          yychar = yyempty_;
+
+          /* Count tokens shifted since error; after three, turn off error
+           * status.  */
+          if (yyerrstatus_ > 0)
+            --yyerrstatus_;
+
+          yystate = yyn;
+          yystack.push (yystate, yylval]b4_locations_if([, yylloc])[);
+          label = YYNEWSTATE;
+        }
+        break;
+
+      /*-----------------------------------------------------------.
+      | yydefault -- do the default action for the current state.  |
+      `-----------------------------------------------------------*/
+      case YYDEFAULT:
+        yyn = yydefact_[yystate];
+        if (yyn == 0)
+          label = YYERRLAB;
+        else
+          label = YYREDUCE;
+        break;
+
+      /*-----------------------------.
+      | yyreduce -- Do a reduction.  |
+      `-----------------------------*/
+      case YYREDUCE:
+        yylen = yyr2_[yyn];
+        label = yyaction (yyn, yystack, yylen);
+        yystate = yystack.stateAt (0);
+        break;
+
+      /*------------------------------------.
+      | yyerrlab -- here on detecting error |
+      `------------------------------------*/
+      case YYERRLAB:
+        /* If not already recovering from an error, report this error.  */
+        if (yyerrstatus_ == 0)
+        {
+          ++yynerrs_;
+          if (yychar == yyempty_)
+            yytoken = yyempty_;
+          yyerror (]b4_locations_if([yylloc, ])[yysyntax_error (yystate, yytoken));
+        }
+
+]b4_locations_if([        yyerrloc = yylloc;])[
+        if (yyerrstatus_ == 3)
+        {
+          /* If just tried and failed to reuse lookahead token after an
+           * error, discard it.  */
+
+          if (yychar <= YYTokenType.EOF)
+          {
+            /* Return failure if at end of input.  */
+            if (yychar == YYTokenType.EOF)
+             return false;
+          }
+          else
+            yychar = yyempty_;
+        }
+
+        /* Else will try to reuse lookahead token after shifting the error
+         * token.  */
+        label = YYERRLAB1;
+        break;
+
+      /*-------------------------------------------------.
+      | errorlab -- error raised explicitly by YYERROR.  |
+      `-------------------------------------------------*/
+      case YYERROR:]b4_locations_if([
+        yyerrloc = yystack.locationAt (yylen - 1);])[
+        /* Do not reclaim the symbols of the rule which action triggered
+           this YYERROR.  */
+        yystack.pop (yylen);
+        yylen = 0;
+        yystate = yystack.stateAt (0);
+        label = YYERRLAB1;
+        break;
+
+      /*-------------------------------------------------------------.
+      | yyerrlab1 -- common code for both syntax error and YYERROR.  |
+      `-------------------------------------------------------------*/
+      case YYERRLAB1:
+        yyerrstatus_ = 3;       /* Each real token shifted decrements this.  */
+
+        for (;;)
+        {
+          yyn = yypact_[yystate];
+          if (!yy_pact_value_is_default_ (yyn))
+          {
+            yyn += yy_error_token_;
+            if (0 <= yyn && yyn <= yylast_ && yycheck_[yyn] == yy_error_token_)
+            {
+              yyn = yytable_[yyn];
+              if (0 < yyn)
+                break;
+                  }
+          }
+
+          /* Pop the current state because it cannot handle the error token.  */
+          if (yystack.height == 1)
+            return false;
+
+]b4_locations_if([          yyerrloc = yystack.locationAt (0);])[
+          yystack.pop ();
+          yystate = yystack.stateAt (0);]b4_parse_trace_if([[
+          if (0 < yydebug)
+            yystack.print (yyDebugStream);]])[
+        }
+
+]b4_locations_if([
+        /* Muck with the stack to setup for yylloc.  */
+        yystack.push (0, yy_semantic_null, yylloc);
+        yystack.push (0, yy_semantic_null, yyerrloc);
+        yyloc = yylloc_from_stack (yystack, 2);
+        yystack.pop (2);])[
+
+        /* Shift the error token.  */]b4_parse_trace_if([[
+        yy_symbol_print ("Shifting", yystos_[yyn],
+        yylval]b4_locations_if([, yyloc])[);]])[
+
+        yystate = yyn;
+        yystack.push (yyn, yylval]b4_locations_if([, yyloc])[);
+        label = YYNEWSTATE;
+        break;
+
+      /* Accept.  */
+      case YYACCEPT:
+        return true;
+
+      /* Abort.  */
+      case YYABORT:
+        return false;
+    }
+  }
+
+  // Generate an error message.
+  private final string yysyntax_error (int yystate, int tok)
+  {]b4_error_verbose_if([[
+    /* There are many possibilities here to consider:
+       - Assume YYFAIL is not used.  It's too flawed to consider.
+         See
+         <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
+         for details.  YYERROR is fine as it does not invoke this
+         function.
+       - If this state is a consistent state with a default action,
+         then the only way this function was invoked is if the
+         default action is an error action.  In that case, don't
+         check for expected tokens because there are none.
+       - The only way there can be no lookahead present (in tok) is
+         if this state is a consistent state with a default action.
+         Thus, detecting the absence of a lookahead is sufficient to
+         determine that there is no unexpected or expected token to
+         report.  In that case, just report a simple "syntax error".
+       - Don't assume there isn't a lookahead just because this
+         state is a consistent state with a default action.  There
+         might have been a previous inconsistent state, consistent
+         state with a non-default action, or user semantic action
+         that manipulated yychar.  (However, yychar is currently out
+         of scope during semantic actions.)
+       - Of course, the expected token list depends on states to
+         have correct lookahead information, and it depends on the
+         parser not to perform extra reductions after fetching a
+         lookahead from the scanner and before detecting a syntax
+         error.  Thus, state merging (from LALR or IELR) and default
+         reductions corrupt the expected token list.  However, the
+         list is correct for canonical LR with one exception: it
+         will still contain any token that will not be accepted due
+         to an error action in a later state.
+      */
+    if (tok != yyempty_)
+    {
+      // FIXME: This method of building the message is not compatible
+      // with internationalization.
+      string res = "syntax error, unexpected ";
+      res ~= yytnamerr_ (yytname_[tok]);
+      int yyn = yypact_[yystate];
+      if (!yy_pact_value_is_default_ (yyn))
+      {
+        /* Start YYX at -YYN if negative to avoid negative
+           indexes in YYCHECK.  In other words, skip the first
+           -YYN actions for this state because they are default
+           actions.  */
+        int yyxbegin = yyn < 0 ? -yyn : 0;
+        /* Stay within bounds of both yycheck and yytname.  */
+        int yychecklim = yylast_ - yyn + 1;
+        int yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_;
+        int count = 0;
+        for (int x = yyxbegin; x < yyxend; ++x)
+          if (yycheck_[x + yyn] == x && x != yy_error_token_
+              && !yy_table_value_is_error_ (yytable_[x + yyn]))
+             ++count;
+          if (count < 5)
+          {
+             count = 0;
+             for (int x = yyxbegin; x < yyxend; ++x)
+               if (yycheck_[x + yyn] == x && x != yy_error_token_
+                   && !yy_table_value_is_error_ (yytable_[x + yyn]))
+               {
+                  res ~= count++ == 0 ? ", expecting " : " or ";
+                  res ~= yytnamerr_ (yytname_[x]);
+               }
+          }
+      }
+      return res;
+    }]])[
+    return "syntax error";
+  }
+
+  /**
+   * Whether the given <code>yypact_</code> value indicates a defaulted state.
+   * @@param yyvalue   the value to check
+   */
+  private static bool yy_pact_value_is_default_ (int yyvalue)
+  {
+    return yyvalue == yypact_ninf_;
+  }
+
+  /**
+   * Whether the given <code>yytable_</code> value indicates a syntax error.
+   * @@param yyvalue   the value to check
+   */
+  private static bool yy_table_value_is_error_ (int yyvalue)
+  {
+    return yyvalue == yytable_ninf_;
+  }
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+  private static immutable ]b4_int_type_for([b4_pact])[ yypact_ninf_ = ]b4_pact_ninf[;
+
+  /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule which
+     number is the opposite.  If YYTABLE_NINF_, syntax error.  */
+  private static immutable ]b4_int_type_for([b4_table])[ yytable_ninf_ = ]b4_table_ninf[;
+
+  ]b4_parser_tables_define[
+
+  /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+     First, the terminals, then, starting at \a yyntokens_, nonterminals.  */
+  private static immutable string[] yytname_ =
+  @{
+  ]b4_tname[
+  @};
+
+]b4_parse_trace_if([[
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+  private static immutable ]b4_int_type_for([b4_rline])[[] yyrline_ =
+  @{
+  ]b4_rline[
+  @};
+
+  // Report on the debug stream that the rule yyrule is going to be reduced.
+  private final void yy_reduce_print (int yyrule, ref YYStack yystack)
+  {
+    if (yydebug == 0)
+      return;
+
+    int yylno = yyrline_[yyrule];
+    int yynrhs = yyr2_[yyrule];
+    /* Print the symbols being reduced, and their result.  */
+    yycdebug (format("Reducing stack by rule %d (line %d), ",
+              yyrule - 1, yylno));
+
+    /* The symbols being reduced.  */
+    for (int yyi = 0; yyi < yynrhs; yyi++)
+      yy_symbol_print (format("   $%d =", yyi + 1),
+                       yystos_[yystack.stateAt(yynrhs - (yyi + 1))],
+                       ]b4_rhs_value(yynrhs, yyi + 1)b4_locations_if([,
+                       b4_rhs_location(yynrhs, yyi + 1)])[);
+  }
+]])[
+
+  private static token_number_type yytranslate_ (int t)
+  {
+]b4_api_token_raw_if(
+[[    import std.conv : to;
+    return to!byte (t);]],
+[[    /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+    immutable token_number_type[] translate_table =
+    @{
+  ]b4_translate[
+    @};
+
+    immutable int user_token_number_max_ = ]b4_user_token_number_max[;
+    immutable token_number_type undef_token_ = ]b4_undef_token_number[;
+
+    if (t <= 0)
+      return YYTokenType.EOF;
+    else if (t <= user_token_number_max_)
+      return translate_table[t];
+    else
+      return undef_token_;]])[
+  }
+
+  alias ]b4_int_type_for([b4_translate])[ token_number_type;
+
+  private static immutable token_number_type yy_error_token_ = 1;
+
+  private static immutable int yylast_ = ]b4_last[;
+  private static immutable int yynnts_ = ]b4_nterms_number[;
+  private static immutable int yyempty_ = -2;
+  private static immutable int yyfinal_ = ]b4_final_state_number[;
+  private static immutable int yyntokens_ = ]b4_tokens_number[;
+
+  private final struct YYStackElement {
+    int state;
+    ]b4_yystype[ value;]b4_locations_if(
+    b4_location_type[[] location;])[
+  }
+
+  private final struct YYStack {
+    private YYStackElement[] stack = [];
+
+    public final @@property ulong height()
+    {
+      return stack.length;
+    }
+
+    public final void push (int state, ]b4_yystype[ value]dnl
+  b4_locations_if([, ref ]b4_location_type[ loc])[)
+    {
+      stack ~= YYStackElement(state, value]b4_locations_if([, loc])[);
+    }
+
+    public final void pop ()
+    {
+      pop (1);
+    }
+
+    public final void pop (int num)
+    {
+      stack.length -= num;
+    }
+
+    public final int stateAt (int i)
+    {
+      return stack[$-i-1].state;
+    }
+
+]b4_locations_if([[
+    public final ref ]b4_location_type[ locationAt (int i)
+    {
+      return stack[$-i-1].location;
+    }]])[
+
+    public final ref ]b4_yystype[ valueAt (int i)
+    {
+      return stack[$-i-1].value;
+    }
+]b4_parse_trace_if([[
+    // Print the state stack on the debug stream.
+    public final void print (File stream)
+    {
+      stream.write ("Stack now");
+      for (int i = 0; i < stack.length; i++)
+        stream.write (" ", stack[i].state);
+      stream.writeln ();
+    }]])[
+  }
+
+  /* User implementation code.  */
+]b4_percent_code_get[
+}
+]b4_epilogue[]dnl
+b4_output_end
diff --git a/common/bison/skeletons/lalr1.java b/common/bison/skeletons/lalr1.java
new file mode 100644
index 0000000000000000000000000000000000000000..9ec0806b875a5b792c8d8a33ab1c9d5a3573bace
--- /dev/null
+++ b/common/bison/skeletons/lalr1.java
@@ -0,0 +1,1045 @@
+# Java skeleton for Bison                           -*- autoconf -*-
+
+# Copyright (C) 2007-2015, 2018-2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+m4_include(b4_skeletonsdir/[java.m4])
+
+b4_defines_if([b4_complain([%defines does not make sense in Java])])
+
+m4_define([b4_symbol_no_destructor_assert],
+[b4_symbol_if([$1], [has_destructor],
+              [b4_complain_at(m4_unquote(b4_symbol([$1], [destructor_loc])),
+                              [%destructor does not make sense in Java])])])
+b4_symbol_foreach([b4_symbol_no_destructor_assert])
+
+# Setup some macros for api.push-pull.
+b4_percent_define_default([[api.push-pull]], [[pull]])
+b4_percent_define_check_values([[[[api.push-pull]],
+                                 [[pull]], [[push]], [[both]]]])
+
+# Define m4 conditional macros that encode the value
+# of the api.push-pull flag.
+b4_define_flag_if([pull]) m4_define([b4_pull_flag], [[1]])
+b4_define_flag_if([push]) m4_define([b4_push_flag], [[1]])
+m4_case(b4_percent_define_get([[api.push-pull]]),
+        [pull], [m4_define([b4_push_flag], [[0]])],
+        [push], [m4_define([b4_pull_flag], [[0]])])
+
+# Define a macro to be true when api.push-pull has the value "both".
+m4_define([b4_both_if],[b4_push_if([b4_pull_if([$1],[$2])],[$2])])
+
+# Handle BISON_USE_PUSH_FOR_PULL for the test suite.  So that push parsing
+# tests function as written, do not let BISON_USE_PUSH_FOR_PULL modify the
+# behavior of Bison at all when push parsing is already requested.
+b4_define_flag_if([use_push_for_pull])
+b4_use_push_for_pull_if([
+  b4_push_if([m4_define([b4_use_push_for_pull_flag], [[0]])],
+             [m4_define([b4_push_flag], [[1]])])])
+
+# Define a macro to encapsulate the parse state variables.
+# This allows them to be defined either in parse() when doing
+# pull parsing, or as class instance variable when doing push parsing.
+m4_define([b4_define_state],[[
+    /* Lookahead and lookahead in internal form.  */
+    int yychar = yyempty_;
+    int yytoken = 0;
+
+    /* State.  */
+    int yyn = 0;
+    int yylen = 0;
+    int yystate = 0;
+    YYStack yystack = new YYStack ();
+    int label = YYNEWSTATE;
+
+    /* Error handling.  */
+    int yynerrs_ = 0;
+    ]b4_locations_if([[/* The location where the error started.  */
+    ]b4_location_type[ yyerrloc = null;
+
+    /* Location. */
+    ]b4_location_type[ yylloc = new ]b4_location_type[ (null, null);]])[
+
+    /* Semantic value of the lookahead.  */
+    ]b4_yystype[ yylval = null;
+]])[
+
+]b4_output_begin([b4_parser_file_name])[
+]b4_copyright([Skeleton implementation for Bison LALR(1) parsers in Java],
+              [2007-2015, 2018-2019])[
+]b4_percent_define_ifdef([package], [package b4_percent_define_get([package]);[
+]])[
+]b4_user_pre_prologue[
+]b4_user_post_prologue[
+]b4_percent_code_get([[imports]])[
+/**
+ * A Bison parser, automatically generated from <tt>]m4_bpatsubst(b4_file_name, [^"\(.*\)"$], [\1])[</tt>.
+ *
+ * @@author LALR (1) parser skeleton written by Paolo Bonzini.
+ */
+]b4_parser_class_declaration[
+{
+  ]b4_identification[
+]b4_error_verbose_if([[
+  /**
+   * True if verbose error messages are enabled.
+   */
+  private boolean yyErrorVerbose = true;
+
+  /**
+   * Whether verbose error messages are enabled.
+   */
+  public final boolean getErrorVerbose() { return yyErrorVerbose; }
+
+  /**
+   * Set the verbosity of error messages.
+   * @@param verbose True to request verbose error messages.
+   */
+  public final void setErrorVerbose(boolean verbose)
+  { yyErrorVerbose = verbose; }
+]])
+
+b4_locations_if([[
+  /**
+   * A class defining a pair of positions.  Positions, defined by the
+   * <code>]b4_position_type[</code> class, denote a point in the input.
+   * Locations represent a part of the input through the beginning
+   * and ending positions.
+   */
+  public class ]b4_location_type[ {
+    /**
+     * The first, inclusive, position in the range.
+     */
+    public ]b4_position_type[ begin;
+
+    /**
+     * The first position beyond the range.
+     */
+    public ]b4_position_type[ end;
+
+    /**
+     * Create a <code>]b4_location_type[</code> denoting an empty range located at
+     * a given point.
+     * @@param loc The position at which the range is anchored.
+     */
+    public ]b4_location_type[ (]b4_position_type[ loc) {
+      this.begin = this.end = loc;
+    }
+
+    /**
+     * Create a <code>]b4_location_type[</code> from the endpoints of the range.
+     * @@param begin The first position included in the range.
+     * @@param end   The first position beyond the range.
+     */
+    public ]b4_location_type[ (]b4_position_type[ begin, ]b4_position_type[ end) {
+      this.begin = begin;
+      this.end = end;
+    }
+
+    /**
+     * Print a representation of the location.  For this to be correct,
+     * <code>]b4_position_type[</code> should override the <code>equals</code>
+     * method.
+     */
+    public String toString () {
+      if (begin.equals (end))
+        return begin.toString ();
+      else
+        return begin.toString () + "-" + end.toString ();
+    }
+  }
+
+]])[
+
+]b4_locations_if([[
+  private ]b4_location_type[ yylloc (YYStack rhs, int n)
+  {
+    if (0 < n)
+      return new ]b4_location_type[ (rhs.locationAt (n-1).begin, rhs.locationAt (0).end);
+    else
+      return new ]b4_location_type[ (rhs.locationAt (0).end);
+  }]])[
+
+  /**
+   * Communication interface between the scanner and the Bison-generated
+   * parser <tt>]b4_parser_class[</tt>.
+   */
+  public interface Lexer {
+    /** Token returned by the scanner to signal the end of its input.  */
+    public static final int EOF = 0;
+
+]b4_token_enums[
+
+    ]b4_locations_if([[/**
+     * Method to retrieve the beginning position of the last scanned token.
+     * @@return the position at which the last scanned token starts.
+     */
+    ]b4_position_type[ getStartPos ();
+
+    /**
+     * Method to retrieve the ending position of the last scanned token.
+     * @@return the first position beyond the last scanned token.
+     */
+    ]b4_position_type[ getEndPos ();]])[
+
+    /**
+     * Method to retrieve the semantic value of the last scanned token.
+     * @@return the semantic value of the last scanned token.
+     */
+    ]b4_yystype[ getLVal ();
+
+    /**
+     * Entry point for the scanner.  Returns the token identifier corresponding
+     * to the next token and prepares to return the semantic value
+     * ]b4_locations_if([and beginning/ending positions ])[of the token.
+     * @@return the token identifier corresponding to the next token.
+     */
+    int yylex () ]b4_maybe_throws([b4_lex_throws])[;
+
+    /**
+     * Entry point for error reporting.  Emits an error
+     * ]b4_locations_if([referring to the given location ])[in a user-defined way.
+     *
+     * ]b4_locations_if([[@@param loc The location of the element to which the
+     *                error message is related]])[
+     * @@param msg The string for the error message.
+     */
+     void yyerror (]b4_locations_if([b4_location_type[ loc, ]])[String msg);
+  }
+
+]b4_lexer_if([[
+  private class YYLexer implements Lexer {
+]b4_percent_code_get([[lexer]])[
+  }
+
+  ]])[/**
+   * The object doing lexical analysis for us.
+   */
+  private Lexer yylexer;
+
+  ]b4_parse_param_vars[
+
+]b4_lexer_if([[
+  /**
+   * Instantiates the Bison-generated parser.
+   */
+  public ]b4_parser_class (b4_parse_param_decl([b4_lex_param_decl])[) ]b4_maybe_throws([b4_init_throws])[
+  {
+    ]b4_percent_code_get([[init]])[
+    this.yylexer = new YYLexer(]b4_lex_param_call[);
+    ]b4_parse_param_cons[
+  }
+]])[
+
+  /**
+   * Instantiates the Bison-generated parser.
+   * @@param yylexer The scanner that will supply tokens to the parser.
+   */
+  ]b4_lexer_if([[protected]], [[public]]) b4_parser_class[ (]b4_parse_param_decl([[Lexer yylexer]])[) ]b4_maybe_throws([b4_init_throws])[
+  {
+    ]b4_percent_code_get([[init]])[
+    this.yylexer = yylexer;
+    ]b4_parse_param_cons[
+  }
+
+]b4_parse_trace_if([[
+  private java.io.PrintStream yyDebugStream = System.err;
+
+  /**
+   * The <tt>PrintStream</tt> on which the debugging output is printed.
+   */
+  public final java.io.PrintStream getDebugStream () { return yyDebugStream; }
+
+  /**
+   * Set the <tt>PrintStream</tt> on which the debug output is printed.
+   * @@param s The stream that is used for debugging output.
+   */
+  public final void setDebugStream(java.io.PrintStream s) { yyDebugStream = s; }
+
+  private int yydebug = 0;
+
+  /**
+   * Answer the verbosity of the debugging output; 0 means that all kinds of
+   * output from the parser are suppressed.
+   */
+  public final int getDebugLevel() { return yydebug; }
+
+  /**
+   * Set the verbosity of the debugging output; 0 means that all kinds of
+   * output from the parser are suppressed.
+   * @@param level The verbosity level for debugging output.
+   */
+  public final void setDebugLevel(int level) { yydebug = level; }
+]])[
+
+  /**
+   * Print an error message via the lexer.
+   *]b4_locations_if([[ Use a <code>null</code> location.]])[
+   * @@param msg The error message.
+   */
+  public final void yyerror (String msg)
+  {
+    yylexer.yyerror (]b4_locations_if([[(]b4_location_type[)null, ]])[msg);
+  }
+]b4_locations_if([[
+  /**
+   * Print an error message via the lexer.
+   * @@param loc The location associated with the message.
+   * @@param msg The error message.
+   */
+  public final void yyerror (]b4_location_type[ loc, String msg)
+  {
+    yylexer.yyerror (loc, msg);
+  }
+
+  /**
+   * Print an error message via the lexer.
+   * @@param pos The position associated with the message.
+   * @@param msg The error message.
+   */
+  public final void yyerror (]b4_position_type[ pos, String msg)
+  {
+    yylexer.yyerror (new ]b4_location_type[ (pos), msg);
+  }]])[
+]b4_parse_trace_if([[
+  protected final void yycdebug (String s) {
+    if (0 < yydebug)
+      yyDebugStream.println (s);
+  }]])[
+
+  private final class YYStack {
+    private int[] stateStack = new int[16];
+    ]b4_locations_if([[private ]b4_location_type[[] locStack = new ]b4_location_type[[16];]])[
+    private ]b4_yystype[[] valueStack = new ]b4_yystype[[16];
+
+    public int size = 16;
+    public int height = -1;
+
+    public final void push (int state, ]b4_yystype[ value]dnl
+                            b4_locations_if([, ]b4_location_type[ loc])[) {
+      height++;
+      if (size == height)
+        {
+          int[] newStateStack = new int[size * 2];
+          System.arraycopy (stateStack, 0, newStateStack, 0, height);
+          stateStack = newStateStack;
+          ]b4_locations_if([[
+          ]b4_location_type[[] newLocStack = new ]b4_location_type[[size * 2];
+          System.arraycopy (locStack, 0, newLocStack, 0, height);
+          locStack = newLocStack;]])
+
+          b4_yystype[[] newValueStack = new ]b4_yystype[[size * 2];
+          System.arraycopy (valueStack, 0, newValueStack, 0, height);
+          valueStack = newValueStack;
+
+          size *= 2;
+        }
+
+      stateStack[height] = state;
+      ]b4_locations_if([[locStack[height] = loc;]])[
+      valueStack[height] = value;
+    }
+
+    public final void pop () {
+      pop (1);
+    }
+
+    public final void pop (int num) {
+      // Avoid memory leaks... garbage collection is a white lie!
+      if (0 < num) {
+        java.util.Arrays.fill (valueStack, height - num + 1, height + 1, null);
+        ]b4_locations_if([[java.util.Arrays.fill (locStack, height - num + 1, height + 1, null);]])[
+      }
+      height -= num;
+    }
+
+    public final int stateAt (int i) {
+      return stateStack[height - i];
+    }
+
+    ]b4_locations_if([[public final ]b4_location_type[ locationAt (int i) {
+      return locStack[height - i];
+    }
+
+    ]])[public final ]b4_yystype[ valueAt (int i) {
+      return valueStack[height - i];
+    }
+
+    // Print the state stack on the debug stream.
+    public void print (java.io.PrintStream out) {
+      out.print ("Stack now");
+
+      for (int i = 0; i <= height; i++)
+        {
+          out.print (' ');
+          out.print (stateStack[i]);
+        }
+      out.println ();
+    }
+  }
+
+  /**
+   * Returned by a Bison action in order to stop the parsing process and
+   * return success (<tt>true</tt>).
+   */
+  public static final int YYACCEPT = 0;
+
+  /**
+   * Returned by a Bison action in order to stop the parsing process and
+   * return failure (<tt>false</tt>).
+   */
+  public static final int YYABORT = 1;
+
+]b4_push_if([
+  /**
+   * Returned by a Bison action in order to request a new token.
+   */
+  public static final int YYPUSH_MORE = 4;])[
+
+  /**
+   * Returned by a Bison action in order to start error recovery without
+   * printing an error message.
+   */
+  public static final int YYERROR = 2;
+
+  /**
+   * Internal return codes that are not supported for user semantic
+   * actions.
+   */
+  private static final int YYERRLAB = 3;
+  private static final int YYNEWSTATE = 4;
+  private static final int YYDEFAULT = 5;
+  private static final int YYREDUCE = 6;
+  private static final int YYERRLAB1 = 7;
+  private static final int YYRETURN = 8;
+]b4_push_if([[  private static final int YYGETTOKEN = 9; /* Signify that a new token is expected when doing push-parsing.  */]])[
+
+  private int yyerrstatus_ = 0;
+
+]b4_push_if([b4_define_state])[
+  /**
+   * Whether error recovery is being done.  In this state, the parser
+   * reads token until it reaches a known state, and then restarts normal
+   * operation.
+   */
+  public final boolean recovering ()
+  {
+    return yyerrstatus_ == 0;
+  }
+
+  /** Compute post-reduction state.
+   * @@param yystate   the current state
+   * @@param yysym     the nonterminal to push on the stack
+   */
+  private int yyLRGotoState (int yystate, int yysym)
+  {
+    int yyr = yypgoto_[yysym - yyntokens_] + yystate;
+    if (0 <= yyr && yyr <= yylast_ && yycheck_[yyr] == yystate)
+      return yytable_[yyr];
+    else
+      return yydefgoto_[yysym - yyntokens_];
+  }
+
+  private int yyaction (int yyn, YYStack yystack, int yylen) ]b4_maybe_throws([b4_throws])[
+  {
+    /* If YYLEN is nonzero, implement the default value of the action:
+       '$$ = $1'.  Otherwise, use the top of the stack.
+
+       Otherwise, the following line sets YYVAL to garbage.
+       This behavior is undocumented and Bison
+       users should not rely upon it.  */
+    ]b4_yystype[ yyval = (0 < yylen) ? yystack.valueAt (yylen - 1) : yystack.valueAt (0);
+    ]b4_locations_if([b4_location_type[ yyloc = yylloc (yystack, yylen);]])[]b4_parse_trace_if([[
+
+    yyReducePrint (yyn, yystack);]])[
+
+    switch (yyn)
+      {
+        ]b4_user_actions[
+        default: break;
+      }]b4_parse_trace_if([[
+
+    yySymbolPrint ("-> $$ =", yyr1_[yyn], yyval]b4_locations_if([, yyloc])[);]])[
+
+    yystack.pop (yylen);
+    yylen = 0;
+
+    /* Shift the result of the reduction.  */
+    int yystate = yyLRGotoState (yystack.stateAt (0), yyr1_[yyn]);
+    yystack.push (yystate, yyval]b4_locations_if([, yyloc])[);
+    return YYNEWSTATE;
+  }
+
+]b4_error_verbose_if([[
+  /* Return YYSTR after stripping away unnecessary quotes and
+     backslashes, so that it's suitable for yyerror.  The heuristic is
+     that double-quoting is unnecessary unless the string contains an
+     apostrophe, a comma, or backslash (other than backslash-backslash).
+     YYSTR is taken from yytname.  */
+  private final String yytnamerr_ (String yystr)
+  {
+    if (yystr.charAt (0) == '"')
+      {
+        StringBuffer yyr = new StringBuffer ();
+        strip_quotes: for (int i = 1; i < yystr.length (); i++)
+          switch (yystr.charAt (i))
+            {
+            case '\'':
+            case ',':
+              break strip_quotes;
+
+            case '\\':
+              if (yystr.charAt(++i) != '\\')
+                break strip_quotes;
+              /* Fall through.  */
+            default:
+              yyr.append (yystr.charAt (i));
+              break;
+
+            case '"':
+              return yyr.toString ();
+            }
+      }
+    else if (yystr.equals ("$end"))
+      return "end of input";
+
+    return yystr;
+  }
+]])[
+]b4_parse_trace_if([[
+  /*--------------------------------.
+  | Print this symbol on YYOUTPUT.  |
+  `--------------------------------*/
+
+  private void yySymbolPrint (String s, int yytype,
+                             ]b4_yystype[ yyvaluep]dnl
+                              b4_locations_if([, Object yylocationp])[)
+  {
+    yycdebug (s + (yytype < yyntokens_ ? " token " : " nterm ")
+              + yytname_[yytype] + " ("]b4_locations_if([
+              + yylocationp + ": "])[
+              + (yyvaluep == null ? "(null)" : yyvaluep.toString ()) + ")");
+  }]])[
+
+]b4_push_if([],[[
+  /**
+   * Parse input from the scanner that was specified at object construction
+   * time.  Return whether the end of the input was reached successfully.
+   *
+   * @@return <tt>true</tt> if the parsing succeeds.  Note that this does not
+   *          imply that there were no syntax errors.
+   */
+  public boolean parse () ]b4_maybe_throws([b4_list2([b4_lex_throws], [b4_throws])])[]])[
+]b4_push_if([
+  /**
+   * Push Parse input from external lexer
+   *
+   * @@param yylextoken current token
+   * @@param yylexval current lval
+]b4_locations_if([   * @@param yylexloc current position])[
+   *
+   * @@return <tt>YYACCEPT, YYABORT, YYPUSH_MORE</tt>
+   */
+  public int push_parse (int yylextoken, b4_yystype yylexval[]b4_locations_if([, b4_location_type yylexloc]))
+      b4_maybe_throws([b4_list2([b4_lex_throws], [b4_throws])])])[
+  {
+    ]b4_locations_if([/* @@$.  */
+    b4_location_type yyloc;])[
+]b4_push_if([],[[
+]b4_define_state[]b4_parse_trace_if([[
+    yycdebug ("Starting parse\n");]])[
+    yyerrstatus_ = 0;
+
+    /* Initialize the stack.  */
+    yystack.push (yystate, yylval ]b4_locations_if([, yylloc])[);
+]m4_ifdef([b4_initial_action], [
+b4_dollar_pushdef([yylval], [], [], [yylloc])dnl
+    b4_user_initial_action
+b4_dollar_popdef[]dnl
+])[
+]])[
+]b4_push_if([[
+    if (!this.push_parse_initialized)
+      {
+        push_parse_initialize ();
+]m4_ifdef([b4_initial_action], [
+b4_dollar_pushdef([yylval], [], [], [yylloc])dnl
+    b4_user_initial_action
+b4_dollar_popdef[]dnl
+])[]b4_parse_trace_if([[
+        yycdebug ("Starting parse\n");]])[
+        yyerrstatus_ = 0;
+      } else
+        label = YYGETTOKEN;
+
+    boolean push_token_consumed = true;
+]])[
+    for (;;)
+      switch (label)
+      {
+        /* New state.  Unlike in the C/C++ skeletons, the state is already
+           pushed when we come here.  */
+      case YYNEWSTATE:]b4_parse_trace_if([[
+        yycdebug ("Entering state " + yystate + "\n");
+        if (0 < yydebug)
+          yystack.print (yyDebugStream);]])[
+
+        /* Accept?  */
+        if (yystate == yyfinal_)
+          ]b4_push_if([{label = YYACCEPT; break;}],
+                      [return true;])[
+
+        /* Take a decision.  First try without lookahead.  */
+        yyn = yypact_[yystate];
+        if (yyPactValueIsDefault (yyn))
+          {
+            label = YYDEFAULT;
+            break;
+          }
+]b4_push_if([        /* Fall Through */
+
+      case YYGETTOKEN:])[
+        /* Read a lookahead token.  */
+        if (yychar == yyempty_)
+          {
+]b4_push_if([[
+            if (!push_token_consumed)
+              return YYPUSH_MORE;]b4_parse_trace_if([[
+            yycdebug ("Reading a token: ");]])[
+            yychar = yylextoken;
+            yylval = yylexval;]b4_locations_if([
+            yylloc = yylexloc;])[
+            push_token_consumed = false;]], [b4_parse_trace_if([[
+            yycdebug ("Reading a token: ");]])[
+            yychar = yylexer.yylex ();
+            yylval = yylexer.getLVal ();]b4_locations_if([
+            yylloc = new b4_location_type (yylexer.getStartPos (),
+                            yylexer.getEndPos ());])[
+]])[
+          }
+
+        /* Convert token to internal form.  */
+        yytoken = yytranslate_ (yychar);]b4_parse_trace_if([[
+        yySymbolPrint ("Next token is", yytoken,
+                       yylval]b4_locations_if([, yylloc])[);]])[
+
+        /* If the proper action on seeing token YYTOKEN is to reduce or to
+           detect an error, take that action.  */
+        yyn += yytoken;
+        if (yyn < 0 || yylast_ < yyn || yycheck_[yyn] != yytoken)
+          label = YYDEFAULT;
+
+        /* <= 0 means reduce or error.  */
+        else if ((yyn = yytable_[yyn]) <= 0)
+          {
+            if (yyTableValueIsError (yyn))
+              label = YYERRLAB;
+            else
+              {
+                yyn = -yyn;
+                label = YYREDUCE;
+              }
+          }
+
+        else
+          {
+            /* Shift the lookahead token.  */]b4_parse_trace_if([[
+            yySymbolPrint ("Shifting", yytoken,
+                           yylval]b4_locations_if([, yylloc])[);
+]])[
+            /* Discard the token being shifted.  */
+            yychar = yyempty_;
+
+            /* Count tokens shifted since error; after three, turn off error
+               status.  */
+            if (yyerrstatus_ > 0)
+              --yyerrstatus_;
+
+            yystate = yyn;
+            yystack.push (yystate, yylval]b4_locations_if([, yylloc])[);
+            label = YYNEWSTATE;
+          }
+        break;
+
+      /*-----------------------------------------------------------.
+      | yydefault -- do the default action for the current state.  |
+      `-----------------------------------------------------------*/
+      case YYDEFAULT:
+        yyn = yydefact_[yystate];
+        if (yyn == 0)
+          label = YYERRLAB;
+        else
+          label = YYREDUCE;
+        break;
+
+      /*-----------------------------.
+      | yyreduce -- Do a reduction.  |
+      `-----------------------------*/
+      case YYREDUCE:
+        yylen = yyr2_[yyn];
+        label = yyaction (yyn, yystack, yylen);
+        yystate = yystack.stateAt (0);
+        break;
+
+      /*------------------------------------.
+      | yyerrlab -- here on detecting error |
+      `------------------------------------*/
+      case YYERRLAB:
+        /* If not already recovering from an error, report this error.  */
+        if (yyerrstatus_ == 0)
+          {
+            ++yynerrs_;
+            if (yychar == yyempty_)
+              yytoken = yyempty_;
+            yyerror (]b4_locations_if([yylloc, ])[yysyntax_error (yystate, yytoken));
+          }
+
+        ]b4_locations_if([yyerrloc = yylloc;])[
+        if (yyerrstatus_ == 3)
+          {
+            /* If just tried and failed to reuse lookahead token after an
+               error, discard it.  */
+
+            if (yychar <= Lexer.EOF)
+              {
+                /* Return failure if at end of input.  */
+                if (yychar == Lexer.EOF)
+                  ]b4_push_if([{label = YYABORT; break;}], [return false;])[
+              }
+            else
+              yychar = yyempty_;
+          }
+
+        /* Else will try to reuse lookahead token after shifting the error
+           token.  */
+        label = YYERRLAB1;
+        break;
+
+      /*-------------------------------------------------.
+      | errorlab -- error raised explicitly by YYERROR.  |
+      `-------------------------------------------------*/
+      case YYERROR:
+        ]b4_locations_if([yyerrloc = yystack.locationAt (yylen - 1);])[
+        /* Do not reclaim the symbols of the rule which action triggered
+           this YYERROR.  */
+        yystack.pop (yylen);
+        yylen = 0;
+        yystate = yystack.stateAt (0);
+        label = YYERRLAB1;
+        break;
+
+      /*-------------------------------------------------------------.
+      | yyerrlab1 -- common code for both syntax error and YYERROR.  |
+      `-------------------------------------------------------------*/
+      case YYERRLAB1:
+        yyerrstatus_ = 3;       /* Each real token shifted decrements this.  */
+
+        for (;;)
+          {
+            yyn = yypact_[yystate];
+            if (!yyPactValueIsDefault (yyn))
+              {
+                yyn += yy_error_token_;
+                if (0 <= yyn && yyn <= yylast_ && yycheck_[yyn] == yy_error_token_)
+                  {
+                    yyn = yytable_[yyn];
+                    if (0 < yyn)
+                      break;
+                  }
+              }
+
+            /* Pop the current state because it cannot handle the
+             * error token.  */
+            if (yystack.height == 0)
+              ]b4_push_if([{label = YYABORT; break;}],[return false;])[
+
+            ]b4_locations_if([yyerrloc = yystack.locationAt (0);])[
+            yystack.pop ();
+            yystate = yystack.stateAt (0);]b4_parse_trace_if([[
+            if (0 < yydebug)
+              yystack.print (yyDebugStream);]])[
+          }
+
+        if (label == YYABORT)
+            /* Leave the switch.  */
+            break;
+
+]b4_locations_if([
+        /* Muck with the stack to setup for yylloc.  */
+        yystack.push (0, null, yylloc);
+        yystack.push (0, null, yyerrloc);
+        yyloc = yylloc (yystack, 2);
+        yystack.pop (2);])[
+
+        /* Shift the error token.  */]b4_parse_trace_if([[
+        yySymbolPrint ("Shifting", yystos_[yyn],
+                       yylval]b4_locations_if([, yyloc])[);]])[
+
+        yystate = yyn;
+        yystack.push (yyn, yylval]b4_locations_if([, yyloc])[);
+        label = YYNEWSTATE;
+        break;
+
+        /* Accept.  */
+      case YYACCEPT:
+        ]b4_push_if([this.push_parse_initialized = false; return YYACCEPT;],
+                    [return true;])[
+
+        /* Abort.  */
+      case YYABORT:
+        ]b4_push_if([this.push_parse_initialized = false; return YYABORT;],
+                    [return false;])[
+      }
+}
+]b4_push_if([[
+  boolean push_parse_initialized = false;
+
+    /**
+     * (Re-)Initialize the state of the push parser.
+     */
+  public void push_parse_initialize()
+  {
+    /* Lookahead and lookahead in internal form.  */
+    this.yychar = yyempty_;
+    this.yytoken = 0;
+
+    /* State.  */
+    this.yyn = 0;
+    this.yylen = 0;
+    this.yystate = 0;
+    this.yystack = new YYStack ();
+    this.label = YYNEWSTATE;
+
+    /* Error handling.  */
+    this.yynerrs_ = 0;
+    ]b4_locations_if([/* The location where the error started.  */
+    this.yyerrloc = null;
+    this.yylloc = new b4_location_type (null, null);])[
+
+    /* Semantic value of the lookahead.  */
+    this.yylval = null;
+
+    yystack.push (this.yystate, this.yylval]b4_locations_if([, this.yylloc])[);
+
+    this.push_parse_initialized = true;
+
+  }
+]b4_locations_if([
+  /**
+   * Push parse given input from an external lexer.
+   *
+   * @@param yylextoken current token
+   * @@param yylexval current lval
+   * @@param yyylexpos current position
+   *
+   * @@return <tt>YYACCEPT, YYABORT, YYPUSH_MORE</tt>
+   */
+  public int push_parse (int yylextoken, b4_yystype yylexval, b4_position_type yylexpos)
+      b4_maybe_throws([b4_list2([b4_lex_throws], [b4_throws])])
+  {
+    return push_parse (yylextoken, yylexval, new b4_location_type (yylexpos));
+  }
+])[]])[
+
+]b4_both_if([[
+  /**
+   * Parse input from the scanner that was specified at object construction
+   * time.  Return whether the end of the input was reached successfully.
+   * This version of parse () is defined only when api.push-push=both.
+   *
+   * @@return <tt>true</tt> if the parsing succeeds.  Note that this does not
+   *          imply that there were no syntax errors.
+   */
+  public boolean parse () ]b4_maybe_throws([b4_list2([b4_lex_throws], [b4_throws])])[
+  {
+    if (yylexer == null)
+      throw new NullPointerException("Null Lexer");
+    int status;
+    do {
+      int token = yylexer.yylex();
+      ]b4_yystype[ lval = yylexer.getLVal();
+]b4_locations_if([dnl
+      b4_location_type yyloc = new b4_location_type (yylexer.getStartPos (),
+                                            yylexer.getEndPos ());])[
+      ]b4_locations_if([status = push_parse(token,lval,yyloc);],[
+      status = push_parse(token,lval);])[
+    } while (status == YYPUSH_MORE);
+    return (status == YYACCEPT);
+  }
+]])[
+
+  // Generate an error message.
+  private String yysyntax_error (int yystate, int tok)
+  {]b4_error_verbose_if([[
+    if (yyErrorVerbose)
+      {
+        /* There are many possibilities here to consider:
+           - If this state is a consistent state with a default action,
+             then the only way this function was invoked is if the
+             default action is an error action.  In that case, don't
+             check for expected tokens because there are none.
+           - The only way there can be no lookahead present (in tok) is
+             if this state is a consistent state with a default action.
+             Thus, detecting the absence of a lookahead is sufficient to
+             determine that there is no unexpected or expected token to
+             report.  In that case, just report a simple "syntax error".
+           - Don't assume there isn't a lookahead just because this
+             state is a consistent state with a default action.  There
+             might have been a previous inconsistent state, consistent
+             state with a non-default action, or user semantic action
+             that manipulated yychar.  (However, yychar is currently out
+             of scope during semantic actions.)
+           - Of course, the expected token list depends on states to
+             have correct lookahead information, and it depends on the
+             parser not to perform extra reductions after fetching a
+             lookahead from the scanner and before detecting a syntax
+             error.  Thus, state merging (from LALR or IELR) and default
+             reductions corrupt the expected token list.  However, the
+             list is correct for canonical LR with one exception: it
+             will still contain any token that will not be accepted due
+             to an error action in a later state.
+        */
+        if (tok != yyempty_)
+          {
+            /* FIXME: This method of building the message is not compatible
+               with internationalization.  */
+            StringBuffer res =
+              new StringBuffer ("syntax error, unexpected ");
+            res.append (yytnamerr_ (yytname_[tok]));
+            int yyn = yypact_[yystate];
+            if (!yyPactValueIsDefault (yyn))
+              {
+                /* Start YYX at -YYN if negative to avoid negative
+                   indexes in YYCHECK.  In other words, skip the first
+                   -YYN actions for this state because they are default
+                   actions.  */
+                int yyxbegin = yyn < 0 ? -yyn : 0;
+                /* Stay within bounds of both yycheck and yytname.  */
+                int yychecklim = yylast_ - yyn + 1;
+                int yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_;
+                int count = 0;
+                for (int x = yyxbegin; x < yyxend; ++x)
+                  if (yycheck_[x + yyn] == x && x != yy_error_token_
+                      && !yyTableValueIsError (yytable_[x + yyn]))
+                    ++count;
+                if (count < 5)
+                  {
+                    count = 0;
+                    for (int x = yyxbegin; x < yyxend; ++x)
+                      if (yycheck_[x + yyn] == x && x != yy_error_token_
+                          && !yyTableValueIsError (yytable_[x + yyn]))
+                        {
+                          res.append (count++ == 0 ? ", expecting " : " or ");
+                          res.append (yytnamerr_ (yytname_[x]));
+                        }
+                  }
+              }
+            return res.toString ();
+          }
+      }
+]])[
+    return "syntax error";
+  }
+
+  /**
+   * Whether the given <code>yypact_</code> value indicates a defaulted state.
+   * @@param yyvalue   the value to check
+   */
+  private static boolean yyPactValueIsDefault (int yyvalue)
+  {
+    return yyvalue == yypact_ninf_;
+  }
+
+  /**
+   * Whether the given <code>yytable_</code>
+   * value indicates a syntax error.
+   * @@param yyvalue the value to check
+   */
+  private static boolean yyTableValueIsError (int yyvalue)
+  {
+    return yyvalue == yytable_ninf_;
+  }
+
+  private static final ]b4_int_type_for([b4_pact])[ yypact_ninf_ = ]b4_pact_ninf[;
+  private static final ]b4_int_type_for([b4_table])[ yytable_ninf_ = ]b4_table_ninf[;
+
+  ]b4_parser_tables_define[
+
+  /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+     First, the terminals, then, starting at \a yyntokens_, nonterminals.  */
+  ]b4_typed_parser_table_define([String], [tname], [b4_tname])[
+
+]b4_parse_trace_if([[
+  ]b4_integral_parser_table_define([rline], [b4_rline],
+  [[YYRLINE[YYN] -- Source line where rule number YYN was defined.]])[
+
+
+  // Report on the debug stream that the rule yyrule is going to be reduced.
+  private void yyReducePrint (int yyrule, YYStack yystack)
+  {
+    if (yydebug == 0)
+      return;
+
+    int yylno = yyrline_[yyrule];
+    int yynrhs = yyr2_[yyrule];
+    /* Print the symbols being reduced, and their result.  */
+    yycdebug ("Reducing stack by rule " + (yyrule - 1)
+              + " (line " + yylno + "), ");
+
+    /* The symbols being reduced.  */
+    for (int yyi = 0; yyi < yynrhs; yyi++)
+      yySymbolPrint ("   $" + (yyi + 1) + " =",
+                     yystos_[yystack.stateAt(yynrhs - (yyi + 1))],
+                     ]b4_rhs_data(yynrhs, yyi + 1)b4_locations_if([,
+                     b4_rhs_location(yynrhs, yyi + 1)])[);
+  }]])[
+
+  /* YYTRANSLATE_(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
+     as returned by yylex, with out-of-bounds checking.  */
+  private static final ]b4_int_type_for([b4_translate])[ yytranslate_ (int t)
+]b4_api_token_raw_if(dnl
+[[  {
+    return t;
+  }
+]],
+[[  {
+    int user_token_number_max_ = ]b4_user_token_number_max[;
+    ]b4_int_type_for([b4_translate])[ undef_token_ = ]b4_undef_token_number[;
+
+    if (t <= 0)
+      return Lexer.EOF;
+    else if (t <= user_token_number_max_)
+      return yytranslate_table_[t];
+    else
+      return undef_token_;
+  }
+  ]b4_integral_parser_table_define([translate_table], [b4_translate])[
+]])[
+
+  private static final ]b4_int_type_for([b4_translate])[ yy_error_token_ = 1;
+
+  private static final int yylast_ = ]b4_last[;
+  private static final int yynnts_ = ]b4_nterms_number[;
+  private static final int yyempty_ = -2;
+  private static final int yyfinal_ = ]b4_final_state_number[;
+  private static final int yyntokens_ = ]b4_tokens_number[;
+
+/* User implementation code.  */
+]b4_percent_code_get[]dnl
+
+}
+
+b4_epilogue[]dnl
+b4_output_end
diff --git a/common/bison/skeletons/location.cc b/common/bison/skeletons/location.cc
new file mode 100644
index 0000000000000000000000000000000000000000..02583798f61e2f167dbefaeb71f485dc06671dfb
--- /dev/null
+++ b/common/bison/skeletons/location.cc
@@ -0,0 +1,373 @@
+# C++ skeleton for Bison
+
+# Copyright (C) 2002-2015, 2018-2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+m4_pushdef([b4_copyright_years],
+           [2002-2015, 2018-2019])
+
+
+# b4_position_file
+# ----------------
+# Name of the file containing the position class, if we want this file.
+b4_defines_if([b4_required_version_if([302], [],
+                                      [m4_define([b4_position_file], [position.hh])])])])
+
+
+# b4_location_file
+# ----------------
+# Name of the file containing the position/location class,
+# if we want this file.
+b4_percent_define_check_file([b4_location_file],
+                             [[api.location.file]],
+                             b4_defines_if([[location.hh]]))
+
+# b4_location_include
+# -------------------
+# If location.hh is to be generated, the name under which should it be
+# included.
+#
+# b4_location_path
+# ----------------
+# The path to use for the CPP guard.
+m4_ifdef([b4_location_file],
+[m4_define([b4_location_include],
+           [b4_percent_define_get([[api.location.include]],
+                                  ["b4_location_file"])])
+ m4_define([b4_location_path],
+           b4_percent_define_get([[api.location.include]],
+                                 ["b4_dir_prefix[]b4_location_file"]))
+ m4_define([b4_location_path],
+           m4_substr(m4_defn([b4_location_path]), 1, m4_eval(m4_len(m4_defn([b4_location_path])) - 2)))
+ ])
+
+
+
+# b4_location_define
+# ------------------
+# Define the position and location classes.
+m4_define([b4_location_define],
+[[  /// A point in a source file.
+  class position
+  {
+  public:
+    /// Type for line and column numbers.
+    typedef int counter_type;
+]m4_ifdef([b4_location_constructors], [[
+    /// Construct a position.
+    explicit position (]b4_percent_define_get([[filename_type]])[* f = YY_NULLPTR,
+                       counter_type l = ]b4_location_initial_line[,
+                       counter_type c = ]b4_location_initial_column[)
+      : filename (f)
+      , line (l)
+      , column (c)
+    {}
+
+]])[
+    /// Initialization.
+    void initialize (]b4_percent_define_get([[filename_type]])[* fn = YY_NULLPTR,
+                     counter_type l = ]b4_location_initial_line[,
+                     counter_type c = ]b4_location_initial_column[)
+    {
+      filename = fn;
+      line = l;
+      column = c;
+    }
+
+    /** \name Line and Column related manipulators
+     ** \{ */
+    /// (line related) Advance to the COUNT next lines.
+    void lines (counter_type count = 1)
+    {
+      if (count)
+        {
+          column = ]b4_location_initial_column[;
+          line = add_ (line, count, ]b4_location_initial_line[);
+        }
+    }
+
+    /// (column related) Advance to the COUNT next columns.
+    void columns (counter_type count = 1)
+    {
+      column = add_ (column, count, ]b4_location_initial_column[);
+    }
+    /** \} */
+
+    /// File name to which this position refers.
+    ]b4_percent_define_get([[filename_type]])[* filename;
+    /// Current line number.
+    counter_type line;
+    /// Current column number.
+    counter_type column;
+
+  private:
+    /// Compute max (min, lhs+rhs).
+    static counter_type add_ (counter_type lhs, counter_type rhs, counter_type min)
+    {
+      return lhs + rhs < min ? min : lhs + rhs;
+    }
+  };
+
+  /// Add \a width columns, in place.
+  inline position&
+  operator+= (position& res, position::counter_type width)
+  {
+    res.columns (width);
+    return res;
+  }
+
+  /// Add \a width columns.
+  inline position
+  operator+ (position res, position::counter_type width)
+  {
+    return res += width;
+  }
+
+  /// Subtract \a width columns, in place.
+  inline position&
+  operator-= (position& res, position::counter_type width)
+  {
+    return res += -width;
+  }
+
+  /// Subtract \a width columns.
+  inline position
+  operator- (position res, position::counter_type width)
+  {
+    return res -= width;
+  }
+]b4_percent_define_flag_if([[define_location_comparison]], [[
+  /// Compare two position objects.
+  inline bool
+  operator== (const position& pos1, const position& pos2)
+  {
+    return (pos1.line == pos2.line
+            && pos1.column == pos2.column
+            && (pos1.filename == pos2.filename
+                || (pos1.filename && pos2.filename
+                    && *pos1.filename == *pos2.filename)));
+  }
+
+  /// Compare two position objects.
+  inline bool
+  operator!= (const position& pos1, const position& pos2)
+  {
+    return !(pos1 == pos2);
+  }
+]])[
+  /** \brief Intercept output stream redirection.
+   ** \param ostr the destination output stream
+   ** \param pos a reference to the position to redirect
+   */
+  template <typename YYChar>
+  std::basic_ostream<YYChar>&
+  operator<< (std::basic_ostream<YYChar>& ostr, const position& pos)
+  {
+    if (pos.filename)
+      ostr << *pos.filename << ':';
+    return ostr << pos.line << '.' << pos.column;
+  }
+
+  /// Two points in a source file.
+  class location
+  {
+  public:
+    /// Type for line and column numbers.
+    typedef position::counter_type counter_type;
+]m4_ifdef([b4_location_constructors], [
+    /// Construct a location from \a b to \a e.
+    location (const position& b, const position& e)
+      : begin (b)
+      , end (e)
+    {}
+
+    /// Construct a 0-width location in \a p.
+    explicit location (const position& p = position ())
+      : begin (p)
+      , end (p)
+    {}
+
+    /// Construct a 0-width location in \a f, \a l, \a c.
+    explicit location (]b4_percent_define_get([[filename_type]])[* f,
+                       counter_type l = ]b4_location_initial_line[,
+                       counter_type c = ]b4_location_initial_column[)
+      : begin (f, l, c)
+      , end (f, l, c)
+    {}
+
+])[
+    /// Initialization.
+    void initialize (]b4_percent_define_get([[filename_type]])[* f = YY_NULLPTR,
+                     counter_type l = ]b4_location_initial_line[,
+                     counter_type c = ]b4_location_initial_column[)
+    {
+      begin.initialize (f, l, c);
+      end = begin;
+    }
+
+    /** \name Line and Column related manipulators
+     ** \{ */
+  public:
+    /// Reset initial location to final location.
+    void step ()
+    {
+      begin = end;
+    }
+
+    /// Extend the current location to the COUNT next columns.
+    void columns (counter_type count = 1)
+    {
+      end += count;
+    }
+
+    /// Extend the current location to the COUNT next lines.
+    void lines (counter_type count = 1)
+    {
+      end.lines (count);
+    }
+    /** \} */
+
+
+  public:
+    /// Beginning of the located region.
+    position begin;
+    /// End of the located region.
+    position end;
+  };
+
+  /// Join two locations, in place.
+  inline location&
+  operator+= (location& res, const location& end)
+  {
+    res.end = end.end;
+    return res;
+  }
+
+  /// Join two locations.
+  inline location
+  operator+ (location res, const location& end)
+  {
+    return res += end;
+  }
+
+  /// Add \a width columns to the end position, in place.
+  inline location&
+  operator+= (location& res, location::counter_type width)
+  {
+    res.columns (width);
+    return res;
+  }
+
+  /// Add \a width columns to the end position.
+  inline location
+  operator+ (location res, location::counter_type width)
+  {
+    return res += width;
+  }
+
+  /// Subtract \a width columns to the end position, in place.
+  inline location&
+  operator-= (location& res, location::counter_type width)
+  {
+    return res += -width;
+  }
+
+  /// Subtract \a width columns to the end position.
+  inline location
+  operator- (location res, location::counter_type width)
+  {
+    return res -= width;
+  }
+]b4_percent_define_flag_if([[define_location_comparison]], [[
+  /// Compare two location objects.
+  inline bool
+  operator== (const location& loc1, const location& loc2)
+  {
+    return loc1.begin == loc2.begin && loc1.end == loc2.end;
+  }
+
+  /// Compare two location objects.
+  inline bool
+  operator!= (const location& loc1, const location& loc2)
+  {
+    return !(loc1 == loc2);
+  }
+]])[
+  /** \brief Intercept output stream redirection.
+   ** \param ostr the destination output stream
+   ** \param loc a reference to the location to redirect
+   **
+   ** Avoid duplicate information.
+   */
+  template <typename YYChar>
+  std::basic_ostream<YYChar>&
+  operator<< (std::basic_ostream<YYChar>& ostr, const location& loc)
+  {
+    location::counter_type end_col
+      = 0 < loc.end.column ? loc.end.column - 1 : 0;
+    ostr << loc.begin;
+    if (loc.end.filename
+        && (!loc.begin.filename
+            || *loc.begin.filename != *loc.end.filename))
+      ostr << '-' << loc.end.filename << ':' << loc.end.line << '.' << end_col;
+    else if (loc.begin.line < loc.end.line)
+      ostr << '-' << loc.end.line << '.' << end_col;
+    else if (loc.begin.column < end_col)
+      ostr << '-' << end_col;
+    return ostr;
+  }
+]])
+
+
+m4_ifdef([b4_position_file], [[
+]b4_output_begin([b4_dir_prefix], [b4_position_file])[
+]b4_generated_by[
+// Starting with Bison 3.2, this file is useless: the structure it
+// used to define is now defined in "]b4_location_file[".
+//
+// To get rid of this file:
+// 1. add '%require "3.2"' (or newer) to your grammar file
+// 2. remove references to this file from your build system
+// 3. if you used to include it, include "]b4_location_file[" instead.
+
+#include ]b4_location_include[
+]b4_output_end[
+]])
+
+
+m4_ifdef([b4_location_file], [[
+]b4_output_begin([b4_dir_prefix], [b4_location_file])[
+]b4_copyright([Locations for Bison parsers in C++])[
+/**
+ ** \file ]b4_location_path[
+ ** Define the ]b4_namespace_ref[::location class.
+ */
+
+]b4_cpp_guard_open([b4_location_path])[
+
+# include <iostream>
+# include <string>
+
+]b4_null_define[
+
+]b4_namespace_open[
+]b4_location_define[
+]b4_namespace_close[
+]b4_cpp_guard_close([b4_location_path])[
+]b4_output_end[
+]])
+
+
+m4_popdef([b4_copyright_years])
diff --git a/common/bison/skeletons/stack.hh b/common/bison/skeletons/stack.hh
new file mode 100644
index 0000000000000000000000000000000000000000..cb52bcc271316158b16947b3c827de937bd69186
--- /dev/null
+++ b/common/bison/skeletons/stack.hh
@@ -0,0 +1,152 @@
+# C++ skeleton for Bison
+
+# Copyright (C) 2002-2015, 2018-2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+# b4_stack_file
+# -------------
+# Name of the file containing the stack class, if we want this file.
+b4_defines_if([b4_required_version_if([302], [],
+                                      [m4_define([b4_stack_file], [stack.hh])])])
+
+
+# b4_stack_define
+# ---------------
+m4_define([b4_stack_define],
+[[    /// A stack with random access from its top.
+    template <typename T, typename S = std::vector<T> >
+    class stack
+    {
+    public:
+      // Hide our reversed order.
+      typedef typename S::reverse_iterator iterator;
+      typedef typename S::const_reverse_iterator const_iterator;
+      typedef typename S::size_type size_type;
+      typedef typename std::ptrdiff_t index_type;
+
+      stack (size_type n = 200)
+        : seq_ (n)
+      {}
+
+      /// Random access.
+      ///
+      /// Index 0 returns the topmost element.
+      const T&
+      operator[] (index_type i) const
+      {
+        return seq_[size_type (size () - 1 - i)];
+      }
+
+      /// Random access.
+      ///
+      /// Index 0 returns the topmost element.
+      T&
+      operator[] (index_type i)
+      {
+        return seq_[size_type (size () - 1 - i)];
+      }
+
+      /// Steal the contents of \a t.
+      ///
+      /// Close to move-semantics.
+      void
+      push (YY_MOVE_REF (T) t)
+      {
+        seq_.push_back (T ());
+        operator[] (0).move (t);
+      }
+
+      /// Pop elements from the stack.
+      void
+      pop (std::ptrdiff_t n = 1) YY_NOEXCEPT
+      {
+        for (; 0 < n; --n)
+          seq_.pop_back ();
+      }
+
+      /// Pop all elements from the stack.
+      void
+      clear () YY_NOEXCEPT
+      {
+        seq_.clear ();
+      }
+
+      /// Number of elements on the stack.
+      index_type
+      size () const YY_NOEXCEPT
+      {
+        return index_type (seq_.size ());
+      }
+
+      std::ptrdiff_t
+      ssize () const YY_NOEXCEPT
+      {
+        return std::ptrdiff_t (size ());
+      }
+
+      /// Iterator on top of the stack (going downwards).
+      const_iterator
+      begin () const YY_NOEXCEPT
+      {
+        return seq_.rbegin ();
+      }
+
+      /// Bottom of the stack.
+      const_iterator
+      end () const YY_NOEXCEPT
+      {
+        return seq_.rend ();
+      }
+
+      /// Present a slice of the top of a stack.
+      class slice
+      {
+      public:
+        slice (const stack& stack, index_type range)
+          : stack_ (stack)
+          , range_ (range)
+        {}
+
+        const T&
+        operator[] (index_type i) const
+        {
+          return stack_[range_ - i];
+        }
+
+      private:
+        const stack& stack_;
+        index_type range_;
+      };
+
+    private:
+      stack (const stack&);
+      stack& operator= (const stack&);
+      /// The wrapped container.
+      S seq_;
+    };
+]])
+
+m4_ifdef([b4_stack_file],
+[b4_output_begin([b4_dir_prefix], [b4_stack_file])[
+]b4_generated_by[
+// Starting with Bison 3.2, this file is useless: the structure it
+// used to define is now defined with the parser itself.
+//
+// To get rid of this file:
+// 1. add '%require "3.2"' (or newer) to your grammar file
+// 2. remove references to this file from your build system.
+]b4_output_end[
+]])
diff --git a/common/bison/skeletons/variant.hh b/common/bison/skeletons/variant.hh
new file mode 100644
index 0000000000000000000000000000000000000000..be4a3ce7f88edf26834a9a1868041628519017eb
--- /dev/null
+++ b/common/bison/skeletons/variant.hh
@@ -0,0 +1,453 @@
+# C++ skeleton for Bison
+
+# Copyright (C) 2002-2015, 2018-2019 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+
+## --------- ##
+## variant.  ##
+## --------- ##
+
+# b4_symbol_variant(YYTYPE, YYVAL, ACTION, [ARGS])
+# ------------------------------------------------
+# Run some ACTION ("build", or "destroy") on YYVAL of symbol type
+# YYTYPE.
+m4_define([b4_symbol_variant],
+[m4_pushdef([b4_dollar_dollar],
+            [$2.$3< $][3 > (m4_shift3($@))])dnl
+switch ($1)
+    {
+b4_type_foreach([_b4_type_action])[]dnl
+      default:
+        break;
+    }
+m4_popdef([b4_dollar_dollar])dnl
+])
+
+
+# _b4_char_sizeof_counter
+# -----------------------
+# A counter used by _b4_char_sizeof_dummy to create fresh symbols.
+m4_define([_b4_char_sizeof_counter],
+[0])
+
+# _b4_char_sizeof_dummy
+# ---------------------
+# At each call return a new C++ identifier.
+m4_define([_b4_char_sizeof_dummy],
+[m4_define([_b4_char_sizeof_counter], m4_incr(_b4_char_sizeof_counter))dnl
+dummy[]_b4_char_sizeof_counter])
+
+
+# b4_char_sizeof(SYMBOL-NUMS)
+# ---------------------------
+# To be mapped on the list of type names to produce:
+#
+#    char dummy1[sizeof (type_name_1)];
+#    char dummy2[sizeof (type_name_2)];
+#
+# for defined type names.
+m4_define([b4_char_sizeof],
+[b4_symbol_if([$1], [has_type],
+[
+m4_map([      b4_symbol_tag_comment], [$@])dnl
+      char _b4_char_sizeof_dummy@{sizeof (b4_symbol([$1], [type]))@};
+])])
+
+
+# b4_variant_includes
+# -------------------
+# The needed includes for variants support.
+m4_define([b4_variant_includes],
+[b4_parse_assert_if([[#include <typeinfo>]])[
+#ifndef YY_ASSERT
+# include <cassert>
+# define YY_ASSERT assert
+#endif
+]])
+
+
+
+## -------------------------- ##
+## Adjustments for variants.  ##
+## -------------------------- ##
+
+
+# b4_value_type_declare
+# ---------------------
+# Define semantic_type.
+m4_define([b4_value_type_declare],
+[[  /// A buffer to store and retrieve objects.
+  ///
+  /// Sort of a variant, but does not keep track of the nature
+  /// of the stored data, since that knowledge is available
+  /// via the current parser state.
+  class semantic_type
+  {
+  public:
+    /// Type of *this.
+    typedef semantic_type self_type;
+
+    /// Empty construction.
+    semantic_type () YY_NOEXCEPT
+      : yybuffer_ ()]b4_parse_assert_if([
+      , yytypeid_ (YY_NULLPTR)])[
+    {}
+
+    /// Construct and fill.
+    template <typename T>
+    semantic_type (YY_RVREF (T) t)]b4_parse_assert_if([
+      : yytypeid_ (&typeid (T))])[
+    {
+      YY_ASSERT (sizeof (T) <= size);
+      new (yyas_<T> ()) T (YY_MOVE (t));
+    }
+
+    /// Destruction, allowed only if empty.
+    ~semantic_type () YY_NOEXCEPT
+    {]b4_parse_assert_if([
+      YY_ASSERT (!yytypeid_);
+    ])[}
+
+# if 201103L <= YY_CPLUSPLUS
+    /// Instantiate a \a T in here from \a t.
+    template <typename T, typename... U>
+    T&
+    emplace (U&&... u)
+    {]b4_parse_assert_if([
+      YY_ASSERT (!yytypeid_);
+      YY_ASSERT (sizeof (T) <= size);
+      yytypeid_ = & typeid (T);])[
+      return *new (yyas_<T> ()) T (std::forward <U>(u)...);
+    }
+# else
+    /// Instantiate an empty \a T in here.
+    template <typename T>
+    T&
+    emplace ()
+    {]b4_parse_assert_if([
+      YY_ASSERT (!yytypeid_);
+      YY_ASSERT (sizeof (T) <= size);
+      yytypeid_ = & typeid (T);])[
+      return *new (yyas_<T> ()) T ();
+    }
+
+    /// Instantiate a \a T in here from \a t.
+    template <typename T>
+    T&
+    emplace (const T& t)
+    {]b4_parse_assert_if([
+      YY_ASSERT (!yytypeid_);
+      YY_ASSERT (sizeof (T) <= size);
+      yytypeid_ = & typeid (T);])[
+      return *new (yyas_<T> ()) T (t);
+    }
+# endif
+
+    /// Instantiate an empty \a T in here.
+    /// Obsolete, use emplace.
+    template <typename T>
+    T&
+    build ()
+    {
+      return emplace<T> ();
+    }
+
+    /// Instantiate a \a T in here from \a t.
+    /// Obsolete, use emplace.
+    template <typename T>
+    T&
+    build (const T& t)
+    {
+      return emplace<T> (t);
+    }
+
+    /// Accessor to a built \a T.
+    template <typename T>
+    T&
+    as () YY_NOEXCEPT
+    {]b4_parse_assert_if([
+      YY_ASSERT (yytypeid_);
+      YY_ASSERT (*yytypeid_ == typeid (T));
+      YY_ASSERT (sizeof (T) <= size);])[
+      return *yyas_<T> ();
+    }
+
+    /// Const accessor to a built \a T (for %printer).
+    template <typename T>
+    const T&
+    as () const YY_NOEXCEPT
+    {]b4_parse_assert_if([
+      YY_ASSERT (yytypeid_);
+      YY_ASSERT (*yytypeid_ == typeid (T));
+      YY_ASSERT (sizeof (T) <= size);])[
+      return *yyas_<T> ();
+    }
+
+    /// Swap the content with \a that, of same type.
+    ///
+    /// Both variants must be built beforehand, because swapping the actual
+    /// data requires reading it (with as()), and this is not possible on
+    /// unconstructed variants: it would require some dynamic testing, which
+    /// should not be the variant's responsibility.
+    /// Swapping between built and (possibly) non-built is done with
+    /// self_type::move ().
+    template <typename T>
+    void
+    swap (self_type& that) YY_NOEXCEPT
+    {]b4_parse_assert_if([
+      YY_ASSERT (yytypeid_);
+      YY_ASSERT (*yytypeid_ == *that.yytypeid_);])[
+      std::swap (as<T> (), that.as<T> ());
+    }
+
+    /// Move the content of \a that to this.
+    ///
+    /// Destroys \a that.
+    template <typename T>
+    void
+    move (self_type& that)
+    {
+# if 201103L <= YY_CPLUSPLUS
+      emplace<T> (std::move (that.as<T> ()));
+# else
+      emplace<T> ();
+      swap<T> (that);
+# endif
+      that.destroy<T> ();
+    }
+
+# if 201103L <= YY_CPLUSPLUS
+    /// Move the content of \a that to this.
+    template <typename T>
+    void
+    move (self_type&& that)
+    {
+      emplace<T> (std::move (that.as<T> ()));
+      that.destroy<T> ();
+    }
+#endif
+
+    /// Copy the content of \a that to this.
+    template <typename T>
+    void
+    copy (const self_type& that)
+    {
+      emplace<T> (that.as<T> ());
+    }
+
+    /// Destroy the stored \a T.
+    template <typename T>
+    void
+    destroy ()
+    {
+      as<T> ().~T ();]b4_parse_assert_if([
+      yytypeid_ = YY_NULLPTR;])[
+    }
+
+  private:
+    /// Prohibit blind copies.
+    self_type& operator= (const self_type&);
+    semantic_type (const self_type&);
+
+    /// Accessor to raw memory as \a T.
+    template <typename T>
+    T*
+    yyas_ () YY_NOEXCEPT
+    {
+      void *yyp = yybuffer_.yyraw;
+      return static_cast<T*> (yyp);
+     }
+
+    /// Const accessor to raw memory as \a T.
+    template <typename T>
+    const T*
+    yyas_ () const YY_NOEXCEPT
+    {
+      const void *yyp = yybuffer_.yyraw;
+      return static_cast<const T*> (yyp);
+     }
+
+    /// An auxiliary type to compute the largest semantic type.
+    union union_type
+    {]b4_type_foreach([b4_char_sizeof])[    };
+
+    /// The size of the largest semantic type.
+    enum { size = sizeof (union_type) };
+
+    /// A buffer to store semantic values.
+    union
+    {
+      /// Strongest alignment constraints.
+      long double yyalign_me;
+      /// A buffer large enough to store any of the semantic values.
+      char yyraw[size];
+    } yybuffer_;]b4_parse_assert_if([
+
+    /// Whether the content is built: if defined, the name of the stored type.
+    const std::type_info *yytypeid_;])[
+  };
+]])
+
+
+# How the semantic value is extracted when using variants.
+
+# b4_symbol_value(VAL, SYMBOL-NUM, [TYPE])
+# ----------------------------------------
+# See README.
+m4_define([b4_symbol_value],
+[m4_ifval([$3],
+          [$1.as< $3 > ()],
+          [m4_ifval([$2],
+                    [b4_symbol_if([$2], [has_type],
+                                  [$1.as < b4_symbol([$2], [type]) > ()],
+                                  [$1])],
+                    [$1])])])
+
+# b4_symbol_value_template(VAL, SYMBOL-NUM, [TYPE])
+# -------------------------------------------------
+# Same as b4_symbol_value, but used in a template method.
+m4_define([b4_symbol_value_template],
+[m4_ifval([$3],
+          [$1.template as< $3 > ()],
+          [m4_ifval([$2],
+                    [b4_symbol_if([$2], [has_type],
+                                  [$1.template as < b4_symbol([$2], [type]) > ()],
+                                  [$1])],
+                    [$1])])])
+
+
+
+## ------------- ##
+## make_SYMBOL.  ##
+## ------------- ##
+
+
+# _b4_includes_tokens(SYMBOL-NUM...)
+# ----------------------------------
+# Expands to non-empty iff one of the SYMBOL-NUM denotes
+# a token.
+m4_define([_b4_is_token],
+          [b4_symbol_if([$1], [is_token], [1])])
+m4_define([_b4_includes_tokens],
+          [m4_map([_b4_is_token], [$@])])
+
+
+# _b4_token_maker_define(SYMBOL-NUM)
+# ----------------------------------
+# Declare make_SYMBOL for SYMBOL-NUM.  Use at class-level.
+m4_define([_b4_token_maker_define],
+[b4_token_visible_if([$1],
+[#if 201103L <= YY_CPLUSPLUS
+      static
+      symbol_type
+      make_[]_b4_symbol([$1], [id]) (b4_join(
+                 b4_symbol_if([$1], [has_type],
+                 [b4_symbol([$1], [type]) v]),
+                 b4_locations_if([location_type l])))
+      {
+        return symbol_type (b4_join([token::b4_symbol([$1], [id])],
+                                    b4_symbol_if([$1], [has_type], [std::move (v)]),
+                                    b4_locations_if([std::move (l)])));
+      }
+#else
+      static
+      symbol_type
+      make_[]_b4_symbol([$1], [id]) (b4_join(
+                 b4_symbol_if([$1], [has_type],
+                 [const b4_symbol([$1], [type])& v]),
+                 b4_locations_if([const location_type& l])))
+      {
+        return symbol_type (b4_join([token::b4_symbol([$1], [id])],
+                                    b4_symbol_if([$1], [has_type], [v]),
+                                    b4_locations_if([l])));
+      }
+#endif
+])])
+
+
+m4_define([_b4_type_clause],
+[b4_symbol_if([$1], [is_token],
+              [b4_symbol_if([$1], [has_id],
+                            [tok == token::b4_symbol([$1], [id])],
+                            [tok == b4_symbol([$1], [user_number])])])])
+
+
+# _b4_token_constructor_define(SYMBOL-NUM...)
+# -------------------------------------------
+# Define a unique make_symbol for all the SYMBOL-NUM (they
+# have the same type).  Use at class-level.
+m4_define([_b4_token_constructor_define],
+[m4_ifval(_b4_includes_tokens($@),
+[[#if 201103L <= YY_CPLUSPLUS
+      symbol_type (]b4_join(
+          [int tok],
+          b4_symbol_if([$1], [has_type],
+                       [b4_symbol([$1], [type]) v]),
+          b4_locations_if([location_type l]))[)
+        : super_type(]b4_join([token_type (tok)],
+                              b4_symbol_if([$1], [has_type], [std::move (v)]),
+                              b4_locations_if([std::move (l)]))[)
+      {
+        YY_ASSERT (]m4_join([ || ], m4_map_sep([_b4_type_clause], [, ], [$@]))[);
+      }
+#else
+      symbol_type (]b4_join(
+          [int tok],
+          b4_symbol_if([$1], [has_type],
+                       [const b4_symbol([$1], [type])& v]),
+          b4_locations_if([const location_type& l]))[)
+        : super_type(]b4_join([token_type (tok)],
+                              b4_symbol_if([$1], [has_type], [v]),
+                              b4_locations_if([l]))[)
+      {
+        YY_ASSERT (]m4_join([ || ], m4_map_sep([_b4_type_clause], [, ], [$@]))[);
+      }
+#endif
+]])])
+
+
+# b4_basic_symbol_constructor_define(SYMBOL-NUM)
+# ----------------------------------------------
+# Generate a constructor for basic_symbol from given type.
+m4_define([b4_basic_symbol_constructor_define],
+[[#if 201103L <= YY_CPLUSPLUS
+      basic_symbol (]b4_join(
+          [typename Base::kind_type t],
+          b4_symbol_if([$1], [has_type], [b4_symbol([$1], [type])&& v]),
+          b4_locations_if([location_type&& l]))[)
+        : Base (t)]b4_symbol_if([$1], [has_type], [
+        , value (std::move (v))])[]b4_locations_if([
+        , location (std::move (l))])[
+      {}
+#else
+      basic_symbol (]b4_join(
+          [typename Base::kind_type t],
+          b4_symbol_if([$1], [has_type], [const b4_symbol([$1], [type])& v]),
+          b4_locations_if([const location_type& l]))[)
+        : Base (t)]b4_symbol_if([$1], [has_type], [
+        , value (v)])[]b4_locations_if([
+        , location (l)])[
+      {}
+#endif
+]])
+
+
+# b4_token_constructor_define
+# ---------------------------
+# Define the overloaded versions of make_symbol for all the value types.
+m4_define([b4_token_constructor_define],
+[    // Implementation of make_symbol for each symbol type.
+b4_symbol_foreach([_b4_token_maker_define])])
diff --git a/common/bison/skeletons/yacc.c b/common/bison/skeletons/yacc.c
new file mode 100644
index 0000000000000000000000000000000000000000..2830c1dec6c5f46bd3debf4fe3c61a6bb0c267bd
--- /dev/null
+++ b/common/bison/skeletons/yacc.c
@@ -0,0 +1,1966 @@
+#                                                            -*- C -*-
+# Yacc compatible skeleton for Bison
+
+# Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software
+# Foundation, Inc.
+
+m4_pushdef([b4_copyright_years],
+           [1984, 1989-1990, 2000-2015, 2018-2019])
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+m4_include(b4_skeletonsdir/[c.m4])
+
+## ---------- ##
+## api.pure.  ##
+## ---------- ##
+
+b4_percent_define_default([[api.pure]], [[false]])
+b4_percent_define_check_values([[[[api.pure]],
+                                 [[false]], [[true]], [[]], [[full]]]])
+
+m4_define([b4_pure_flag], [[0]])
+m4_case(b4_percent_define_get([[api.pure]]),
+        [false], [m4_define([b4_pure_flag], [[0]])],
+        [true],  [m4_define([b4_pure_flag], [[1]])],
+        [],      [m4_define([b4_pure_flag], [[1]])],
+        [full],  [m4_define([b4_pure_flag], [[2]])])
+
+m4_define([b4_pure_if],
+[m4_case(b4_pure_flag,
+         [0], [$2],
+         [1], [$1],
+         [2], [$1])])
+         [m4_fatal([invalid api.pure value: ]$1)])])
+
+## --------------- ##
+## api.push-pull.  ##
+## --------------- ##
+
+b4_percent_define_default([[api.push-pull]], [[pull]])
+b4_percent_define_check_values([[[[api.push-pull]],
+                                 [[pull]], [[push]], [[both]]]])
+b4_define_flag_if([pull]) m4_define([b4_pull_flag], [[1]])
+b4_define_flag_if([push]) m4_define([b4_push_flag], [[1]])
+m4_case(b4_percent_define_get([[api.push-pull]]),
+        [pull], [m4_define([b4_push_flag], [[0]])],
+        [push], [m4_define([b4_pull_flag], [[0]])])
+
+# Handle BISON_USE_PUSH_FOR_PULL for the test suite.  So that push parsing
+# tests function as written, do not let BISON_USE_PUSH_FOR_PULL modify the
+# behavior of Bison at all when push parsing is already requested.
+b4_define_flag_if([use_push_for_pull])
+b4_use_push_for_pull_if([
+  b4_push_if([m4_define([b4_use_push_for_pull_flag], [[0]])],
+             [m4_define([b4_push_flag], [[1]])])])
+
+## ----------- ##
+## parse.lac.  ##
+## ----------- ##
+
+b4_percent_define_default([[parse.lac]], [[none]])
+b4_percent_define_default([[parse.lac.es-capacity-initial]], [[20]])
+b4_percent_define_default([[parse.lac.memory-trace]], [[failures]])
+b4_percent_define_check_values([[[[parse.lac]], [[full]], [[none]]]],
+                               [[[[parse.lac.memory-trace]],
+                                 [[failures]], [[full]]]])
+b4_define_flag_if([lac])
+m4_define([b4_lac_flag],
+          [m4_if(b4_percent_define_get([[parse.lac]]),
+                 [none], [[0]], [[1]])])
+
+## ---------------- ##
+## Default values.  ##
+## ---------------- ##
+
+# Stack parameters.
+m4_define_default([b4_stack_depth_max], [10000])
+m4_define_default([b4_stack_depth_init],  [200])
+
+
+# b4_yyerror_arg_loc_if(ARG)
+# --------------------------
+# Expand ARG iff yyerror is to be given a location as argument.
+m4_define([b4_yyerror_arg_loc_if],
+[b4_locations_if([m4_case(b4_pure_flag,
+                          [1], [m4_ifset([b4_parse_param], [$1])],
+                          [2], [$1])])])
+
+# b4_yyerror_args
+# ---------------
+# Arguments passed to yyerror: user args plus yylloc.
+m4_define([b4_yyerror_args],
+[b4_yyerror_arg_loc_if([&yylloc, ])dnl
+m4_ifset([b4_parse_param], [b4_args(b4_parse_param), ])])
+
+
+
+## ----------------- ##
+## Semantic Values.  ##
+## ----------------- ##
+
+
+# b4_lhs_value(SYMBOL-NUM, [TYPE])
+# --------------------------------
+# See README.
+m4_define([b4_lhs_value],
+[b4_symbol_value(yyval, [$1], [$2])])
+
+
+# b4_rhs_value(RULE-LENGTH, POS, [SYMBOL-NUM], [TYPE])
+# ----------------------------------------------------
+# See README.
+m4_define([b4_rhs_value],
+[b4_symbol_value([yyvsp@{b4_subtract([$2], [$1])@}], [$3], [$4])])
+
+
+## ----------- ##
+## Locations.  ##
+## ----------- ##
+
+# b4_lhs_location()
+# -----------------
+# Expansion of @$.
+m4_define([b4_lhs_location],
+[(yyloc)])
+
+
+# b4_rhs_location(RULE-LENGTH, POS)
+# ---------------------------------
+# Expansion of @POS, where the current rule has RULE-LENGTH symbols
+# on RHS.
+m4_define([b4_rhs_location],
+[(yylsp@{b4_subtract([$2], [$1])@})])
+
+
+## -------------- ##
+## Declarations.  ##
+## -------------- ##
+
+# b4_declare_scanner_communication_variables
+# ------------------------------------------
+# Declare the variables that are global, or local to YYPARSE if
+# pure-parser.
+m4_define([b4_declare_scanner_communication_variables], [[
+/* The lookahead symbol.  */
+int yychar;
+
+]b4_pure_if([[
+/* The semantic value of the lookahead symbol.  */
+/* Default value used for initialization, for pacifying older GCCs
+   or non-GCC compilers.  */
+YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
+YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);]b4_locations_if([[
+
+/* Location data for the lookahead symbol.  */
+static YYLTYPE yyloc_default]b4_yyloc_default[;
+YYLTYPE yylloc = yyloc_default;]])],
+[[/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;]b4_locations_if([[
+/* Location data for the lookahead symbol.  */
+YYLTYPE yylloc]b4_yyloc_default[;]])[
+/* Number of syntax errors so far.  */
+int yynerrs;]])])
+
+
+# b4_declare_parser_state_variables
+# ---------------------------------
+# Declare all the variables that are needed to maintain the parser state
+# between calls to yypush_parse.
+m4_define([b4_declare_parser_state_variables], [b4_pure_if([[
+    /* Number of syntax errors so far.  */
+    int yynerrs;
+]])[
+    yy_state_fast_t yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       'yyss': related to states.
+       'yyvs': related to semantic values.]b4_locations_if([[
+       'yyls': related to locations.]])[
+
+       Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yy_state_t yyssa[YYINITDEPTH];
+    yy_state_t *yyss;
+    yy_state_t *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;]b4_locations_if([[
+
+    /* The location stack.  */
+    YYLTYPE yylsa[YYINITDEPTH];
+    YYLTYPE *yyls;
+    YYLTYPE *yylsp;
+
+    /* The locations where the error started and ended.  */
+    YYLTYPE yyerror_range[3];]])[
+
+    YYPTRDIFF_T yystacksize;]b4_lac_if([[
+
+    yy_state_t yyesa@{]b4_percent_define_get([[parse.lac.es-capacity-initial]])[@};
+    yy_state_t *yyes;
+    YYPTRDIFF_T yyes_capacity;]])])
+
+
+# _b4_declare_yyparse_push
+# ------------------------
+# Declaration of yyparse (and dependencies) when using the push parser
+# (including in pull mode).
+m4_define([_b4_declare_yyparse_push],
+[[#ifndef YYPUSH_MORE_DEFINED
+# define YYPUSH_MORE_DEFINED
+enum { YYPUSH_MORE = 4 };
+#endif
+
+typedef struct ]b4_prefix[pstate ]b4_prefix[pstate;
+
+]b4_pull_if([b4_function_declare([b4_prefix[parse]], [[int]], b4_parse_param)
+])b4_function_declare([b4_prefix[push_parse]], [[int]],
+  [[b4_prefix[pstate *ps]], [[ps]]]b4_pure_if([,
+  [[[int pushed_char]], [[pushed_char]]],
+  [[b4_api_PREFIX[STYPE const *pushed_val]], [[pushed_val]]]b4_locations_if([,
+  [[b4_api_PREFIX[LTYPE *pushed_loc]], [[pushed_loc]]]])])m4_ifset([b4_parse_param], [,
+  b4_parse_param]))
+b4_pull_if([b4_function_declare([b4_prefix[pull_parse]], [[int]],
+  [[b4_prefix[pstate *ps]], [[ps]]]m4_ifset([b4_parse_param], [,
+  b4_parse_param]))])
+b4_function_declare([b4_prefix[pstate_new]], [b4_prefix[pstate *]],
+                    [[[void]], []])
+b4_function_declare([b4_prefix[pstate_delete]], [[void]],
+                   [[b4_prefix[pstate *ps]], [[ps]]])dnl
+])
+
+# _b4_declare_yyparse
+# -------------------
+# When not the push parser.
+m4_define([_b4_declare_yyparse],
+[b4_function_declare(b4_prefix[parse], [int], b4_parse_param)])
+
+
+# b4_declare_yyparse
+# ------------------
+m4_define([b4_declare_yyparse],
+[b4_push_if([_b4_declare_yyparse_push],
+            [_b4_declare_yyparse])[]dnl
+])
+
+
+# b4_shared_declarations
+# ----------------------
+# Declaration that might either go into the header (if --defines)
+# or open coded in the parser body.
+m4_define([b4_shared_declarations],
+[b4_cpp_guard_open([b4_spec_header_file])[
+]b4_declare_yydebug[
+]b4_percent_code_get([[requires]])[
+]b4_token_enums_defines[
+]b4_declare_yylstype[
+]b4_declare_yyparse[
+]b4_percent_code_get([[provides]])[
+]b4_cpp_guard_close([b4_spec_header_file])[]dnl
+])
+
+
+# b4_header_include_if(IF-TRUE, IF-FALSE)
+# ---------------------------------------
+# Run IF-TRUE if we generate an output file and api.header.include
+# is defined.
+m4_define([b4_header_include_if],
+[m4_ifval(m4_quote(b4_spec_header_file),
+          [b4_percent_define_ifdef([[api.header.include]],
+                                   [$1],
+                                   [$2])],
+          [$2])])
+
+m4_if(b4_spec_header_file, [[y.tab.h]],
+      [b4_percent_define_default([[api.header.include]],
+                                 [["@basename(]b4_spec_header_file[@)"]])])
+
+
+
+
+## -------------- ##
+## Output files.  ##
+## -------------- ##
+
+
+b4_defines_if([[
+]b4_output_begin([b4_spec_header_file])[
+]b4_copyright([Bison interface for Yacc-like parsers in C])[
+]b4_disclaimer[
+]b4_shared_declarations[
+]b4_output_end[
+]])# b4_defines_if
+
+b4_output_begin([b4_parser_file_name])[
+]b4_copyright([Bison implementation for Yacc-like parsers in C])[
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+]b4_disclaimer[
+]b4_identification[
+]b4_percent_code_get([[top]])[]dnl
+m4_if(b4_api_prefix, [yy], [],
+[[/* Substitute the type names.  */
+#define YYSTYPE         ]b4_api_PREFIX[STYPE]b4_locations_if([[
+#define YYLTYPE         ]b4_api_PREFIX[LTYPE]])])[
+]m4_if(b4_prefix, [yy], [],
+[[/* Substitute the variable and function names.  */]b4_pull_if([[
+#define yyparse         ]b4_prefix[parse]])b4_push_if([[
+#define yypush_parse    ]b4_prefix[push_parse]b4_pull_if([[
+#define yypull_parse    ]b4_prefix[pull_parse]])[
+#define yypstate_new    ]b4_prefix[pstate_new
+#define yypstate_delete ]b4_prefix[pstate_delete
+#define yypstate        ]b4_prefix[pstate]])[
+#define yylex           ]b4_prefix[lex
+#define yyerror         ]b4_prefix[error
+#define yydebug         ]b4_prefix[debug
+#define yynerrs         ]b4_prefix[nerrs]]b4_pure_if([], [[
+#define yylval          ]b4_prefix[lval
+#define yychar          ]b4_prefix[char]b4_locations_if([[
+#define yylloc          ]b4_prefix[lloc]])]))[
+
+]b4_user_pre_prologue[
+]b4_cast_define[
+]b4_null_define[
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE ]b4_error_verbose_if([1], [0])[
+#endif
+
+]b4_header_include_if([[#include ]b4_percent_define_get([[api.header.include]])],
+                      [m4_ifval(m4_quote(b4_spec_header_file),
+                                [/* Use api.header.include to #include this header
+   instead of duplicating it here.  */
+])b4_shared_declarations])[
+
+]b4_user_post_prologue[
+]b4_percent_code_get[]dnl
+
+[#ifdef short
+# undef short
+#endif
+
+]b4_c99_int_type_define[
+
+#ifndef YYPTRDIFF_T
+# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
+#  define YYPTRDIFF_T __PTRDIFF_TYPE__
+#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
+# elif defined PTRDIFF_MAX
+#  ifndef ptrdiff_t
+#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  endif
+#  define YYPTRDIFF_T ptrdiff_t
+#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
+# else
+#  define YYPTRDIFF_T long
+#  define YYPTRDIFF_MAXIMUM LONG_MAX
+# endif
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM                                  \
+  YY_CAST (YYPTRDIFF_T,                                 \
+           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
+            ? YYPTRDIFF_MAXIMUM                         \
+            : YY_CAST (YYSIZE_T, -1)))
+
+#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
+
+/* Stored state numbers (used for stacks). */
+typedef ]b4_int_type(0, m4_eval(b4_states_number - 1))[ yy_state_t;
+
+/* State numbers in computations.  */
+typedef int yy_state_fast_t;
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+]b4_attribute_define[
+
+]b4_parse_assert_if([[#ifdef NDEBUG
+# define YY_ASSERT(E) ((void) (0 && (E)))
+#else
+# include <assert.h> /* INFRINGES ON USER NAME SPACE */
+# define YY_ASSERT(E) assert (E)
+#endif
+]],
+[[#define YY_ASSERT(E) ((void) (0 && (E)))]])[
+
+#if ]b4_lac_if([[1]], [[! defined yyoverflow || YYERROR_VERBOSE]])[
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */]dnl
+b4_push_if([], [b4_lac_if([], [[
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif]])])[
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif]b4_lac_if([[
+# define YYCOPY_NEEDED 1]])[
+#endif]b4_lac_if([], [[ /* ! defined yyoverflow || YYERROR_VERBOSE */]])[
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (]b4_locations_if([[defined ]b4_api_PREFIX[LTYPE_IS_TRIVIAL && ]b4_api_PREFIX[LTYPE_IS_TRIVIAL \
+             && ]])[defined ]b4_api_PREFIX[STYPE_IS_TRIVIAL && ]b4_api_PREFIX[STYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yy_state_t yyss_alloc;
+  YYSTYPE yyvs_alloc;]b4_locations_if([
+  YYLTYPE yyls_alloc;])[
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+]b4_locations_if(
+[# define YYSTACK_BYTES(N) \
+     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE) \
+             + YYSIZEOF (YYLTYPE)) \
+      + 2 * YYSTACK_GAP_MAXIMUM)],
+[# define YYSTACK_BYTES(N) \
+     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)])[
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYPTRDIFF_T yynewbytes;                                         \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYPTRDIFF_T yyi;                      \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  ]b4_final_state_number[
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   ]b4_last[
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  ]b4_tokens_number[
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  ]b4_nterms_number[
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  ]b4_rules_number[
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  ]b4_states_number[
+
+#define YYUNDEFTOK  ]b4_undef_token_number[
+#define YYMAXUTOK   ]b4_user_token_number_max[
+
+
+/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, with out-of-bounds checking.  */
+]b4_api_token_raw_if(dnl
+[[#define YYTRANSLATE(YYX) (YYX)]],
+[[#define YYTRANSLATE(YYX)                                                \
+  (0 <= (YYX) && (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex.  */
+static const ]b4_int_type_for([b4_translate])[ yytranslate[] =
+{
+  ]b4_translate[
+};]])[
+
+#if ]b4_api_PREFIX[DEBUG
+]b4_integral_parser_table_define([rline], [b4_rline],
+     [[YYRLINE[YYN] -- Source line where rule number YYN was defined.]])[
+#endif
+
+#if ]b4_api_PREFIX[DEBUG || YYERROR_VERBOSE || ]b4_token_table_flag[
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  ]b4_tname[
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const ]b4_int_type_for([b4_toknum])[ yytoknum[] =
+{
+  ]b4_toknum[
+};
+# endif
+
+#define YYPACT_NINF (]b4_pact_ninf[)
+
+#define yypact_value_is_default(Yyn) \
+  ]b4_table_value_equals([[pact]], [[Yyn]], [b4_pact_ninf], [YYPACT_NINF])[
+
+#define YYTABLE_NINF (]b4_table_ninf[)
+
+#define yytable_value_is_error(Yyn) \
+  ]b4_table_value_equals([[table]], [[Yyn]], [b4_table_ninf], [YYTABLE_NINF])[
+
+]b4_parser_tables_define[
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                    \
+  do                                                              \
+    if (yychar == YYEMPTY)                                        \
+      {                                                           \
+        yychar = (Token);                                         \
+        yylval = (Value);                                         \
+        YYPOPSTACK (yylen);                                       \
+        yystate = *yyssp;                                         \]b4_lac_if([[
+        YY_LAC_DISCARD ("YYBACKUP");                              \]])[
+        goto yybackup;                                            \
+      }                                                           \
+    else                                                          \
+      {                                                           \
+        yyerror (]b4_yyerror_args[YY_("syntax error: cannot back up")); \
+        YYERROR;                                                  \
+      }                                                           \
+  while (0)
+
+/* Error token number */
+#define YYTERROR        1
+#define YYERRCODE       256
+
+]b4_locations_if([[
+]b4_yylloc_default_define[
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+]])[
+
+/* Enable debugging if requested.  */
+#if ]b4_api_PREFIX[DEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+]b4_yy_location_print_define[
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value]b4_locations_if([, Location])[]b4_user_args[); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+]b4_yy_symbol_print_define[
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+]b4_function_define([yy_stack_print], [static void],
+                   [[yy_state_t *yybottom], [yybottom]],
+                   [[yy_state_t *yytop],    [yytop]])[
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+]b4_function_define([yy_reduce_print], [static void],
+                   [[yy_state_t *yyssp], [yyssp]],
+                   [[YYSTYPE *yyvsp], [yyvsp]],
+    b4_locations_if([[[YYLTYPE *yylsp], [yylsp]],
+                   ])[[int yyrule], [yyrule]]m4_ifset([b4_parse_param], [,
+                   b4_parse_param]))[
+{
+  int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &]b4_rhs_value(yynrhs, yyi + 1)[
+                       ]b4_locations_if([, &]b4_rhs_location(yynrhs, yyi + 1))[]dnl
+                       b4_user_args[);
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, ]b4_locations_if([yylsp, ])[Rule]b4_user_args[); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !]b4_api_PREFIX[DEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !]b4_api_PREFIX[DEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH ]b4_stack_depth_init[
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH ]b4_stack_depth_max[
+#endif]b4_lac_if([[
+
+/* Given a state stack such that *YYBOTTOM is its bottom, such that
+   *YYTOP is either its top or is YYTOP_EMPTY to indicate an empty
+   stack, and such that *YYCAPACITY is the maximum number of elements it
+   can hold without a reallocation, make sure there is enough room to
+   store YYADD more elements.  If not, allocate a new stack using
+   YYSTACK_ALLOC, copy the existing elements, and adjust *YYBOTTOM,
+   *YYTOP, and *YYCAPACITY to reflect the new capacity and memory
+   location.  If *YYBOTTOM != YYBOTTOM_NO_FREE, then free the old stack
+   using YYSTACK_FREE.  Return 0 if successful or if no reallocation is
+   required.  Return 1 if memory is exhausted.  */
+static int
+yy_lac_stack_realloc (YYPTRDIFF_T *yycapacity, YYPTRDIFF_T yyadd,
+#if ]b4_api_PREFIX[DEBUG
+                      char const *yydebug_prefix,
+                      char const *yydebug_suffix,
+#endif
+                      yy_state_t **yybottom,
+                      yy_state_t *yybottom_no_free,
+                      yy_state_t **yytop, yy_state_t *yytop_empty)
+{
+  YYPTRDIFF_T yysize_old =
+    *yytop == yytop_empty ? 0 : *yytop - *yybottom + 1;
+  YYPTRDIFF_T yysize_new = yysize_old + yyadd;
+  if (*yycapacity < yysize_new)
+    {
+      YYPTRDIFF_T yyalloc = 2 * yysize_new;
+      yy_state_t *yybottom_new;
+      /* Use YYMAXDEPTH for maximum stack size given that the stack
+         should never need to grow larger than the main state stack
+         needs to grow without LAC.  */
+      if (YYMAXDEPTH < yysize_new)
+        {
+          YYDPRINTF ((stderr, "%smax size exceeded%s", yydebug_prefix,
+                      yydebug_suffix));
+          return 1;
+        }
+      if (YYMAXDEPTH < yyalloc)
+        yyalloc = YYMAXDEPTH;
+      yybottom_new =
+        YY_CAST (yy_state_t *,
+                 YYSTACK_ALLOC (YY_CAST (YYSIZE_T,
+                                         yyalloc * YYSIZEOF (*yybottom_new))));
+      if (!yybottom_new)
+        {
+          YYDPRINTF ((stderr, "%srealloc failed%s", yydebug_prefix,
+                      yydebug_suffix));
+          return 1;
+        }
+      if (*yytop != yytop_empty)
+        {
+          YYCOPY (yybottom_new, *yybottom, yysize_old);
+          *yytop = yybottom_new + (yysize_old - 1);
+        }
+      if (*yybottom != yybottom_no_free)
+        YYSTACK_FREE (*yybottom);
+      *yybottom = yybottom_new;
+      *yycapacity = yyalloc;]m4_if(b4_percent_define_get([[parse.lac.memory-trace]]),
+                                   [full], [[
+      YY_IGNORE_USELESS_CAST_BEGIN
+      YYDPRINTF ((stderr, "%srealloc to %ld%s", yydebug_prefix,
+                  YY_CAST (long, yyalloc), yydebug_suffix));
+      YY_IGNORE_USELESS_CAST_END]])[
+    }
+  return 0;
+}
+
+/* Establish the initial context for the current lookahead if no initial
+   context is currently established.
+
+   We define a context as a snapshot of the parser stacks.  We define
+   the initial context for a lookahead as the context in which the
+   parser initially examines that lookahead in order to select a
+   syntactic action.  Thus, if the lookahead eventually proves
+   syntactically unacceptable (possibly in a later context reached via a
+   series of reductions), the initial context can be used to determine
+   the exact set of tokens that would be syntactically acceptable in the
+   lookahead's place.  Moreover, it is the context after which any
+   further semantic actions would be erroneous because they would be
+   determined by a syntactically unacceptable token.
+
+   YY_LAC_ESTABLISH should be invoked when a reduction is about to be
+   performed in an inconsistent state (which, for the purposes of LAC,
+   includes consistent states that don't know they're consistent because
+   their default reductions have been disabled).  Iff there is a
+   lookahead token, it should also be invoked before reporting a syntax
+   error.  This latter case is for the sake of the debugging output.
+
+   For parse.lac=full, the implementation of YY_LAC_ESTABLISH is as
+   follows.  If no initial context is currently established for the
+   current lookahead, then check if that lookahead can eventually be
+   shifted if syntactic actions continue from the current context.
+   Report a syntax error if it cannot.  */
+#define YY_LAC_ESTABLISH                                         \
+do {                                                             \
+  if (!yy_lac_established)                                       \
+    {                                                            \
+      YYDPRINTF ((stderr,                                        \
+                  "LAC: initial context established for %s\n",   \
+                  yytname[yytoken]));                            \
+      yy_lac_established = 1;                                    \
+      {                                                          \
+        int yy_lac_status =                                      \
+          yy_lac (yyesa, &yyes, &yyes_capacity, yyssp, yytoken); \
+        if (yy_lac_status == 2)                                  \
+          goto yyexhaustedlab;                                   \
+        if (yy_lac_status == 1)                                  \
+          goto yyerrlab;                                         \
+      }                                                          \
+    }                                                            \
+} while (0)
+
+/* Discard any previous initial lookahead context because of Event,
+   which may be a lookahead change or an invalidation of the currently
+   established initial context for the current lookahead.
+
+   The most common example of a lookahead change is a shift.  An example
+   of both cases is syntax error recovery.  That is, a syntax error
+   occurs when the lookahead is syntactically erroneous for the
+   currently established initial context, so error recovery manipulates
+   the parser stacks to try to find a new initial context in which the
+   current lookahead is syntactically acceptable.  If it fails to find
+   such a context, it discards the lookahead.  */
+#if ]b4_api_PREFIX[DEBUG
+# define YY_LAC_DISCARD(Event)                                           \
+do {                                                                     \
+  if (yy_lac_established)                                                \
+    {                                                                    \
+      if (yydebug)                                                       \
+        YYFPRINTF (stderr, "LAC: initial context discarded due to "      \
+                   Event "\n");                                          \
+      yy_lac_established = 0;                                            \
+    }                                                                    \
+} while (0)
+#else
+# define YY_LAC_DISCARD(Event) yy_lac_established = 0
+#endif
+
+/* Given the stack whose top is *YYSSP, return 0 iff YYTOKEN can
+   eventually (after perhaps some reductions) be shifted, return 1 if
+   not, or return 2 if memory is exhausted.  As preconditions and
+   postconditions: *YYES_CAPACITY is the allocated size of the array to
+   which *YYES points, and either *YYES = YYESA or *YYES points to an
+   array allocated with YYSTACK_ALLOC.  yy_lac may overwrite the
+   contents of either array, alter *YYES and *YYES_CAPACITY, and free
+   any old *YYES other than YYESA.  */
+static int
+yy_lac (yy_state_t *yyesa, yy_state_t **yyes,
+        YYPTRDIFF_T *yyes_capacity, yy_state_t *yyssp, int yytoken)
+{
+  yy_state_t *yyes_prev = yyssp;
+  yy_state_t *yyesp = yyes_prev;
+  YYDPRINTF ((stderr, "LAC: checking lookahead %s:", yytname[yytoken]));
+  if (yytoken == YYUNDEFTOK)
+    {
+      YYDPRINTF ((stderr, " Always Err\n"));
+      return 1;
+    }
+  while (1)
+    {
+      int yyrule = yypact[*yyesp];
+      if (yypact_value_is_default (yyrule)
+          || (yyrule += yytoken) < 0 || YYLAST < yyrule
+          || yycheck[yyrule] != yytoken)
+        {
+          yyrule = yydefact[*yyesp];
+          if (yyrule == 0)
+            {
+              YYDPRINTF ((stderr, " Err\n"));
+              return 1;
+            }
+        }
+      else
+        {
+          yyrule = yytable[yyrule];
+          if (yytable_value_is_error (yyrule))
+            {
+              YYDPRINTF ((stderr, " Err\n"));
+              return 1;
+            }
+          if (0 < yyrule)
+            {
+              YYDPRINTF ((stderr, " S%d\n", yyrule));
+              return 0;
+            }
+          yyrule = -yyrule;
+        }
+      {
+        YYPTRDIFF_T yylen = yyr2[yyrule];
+        YYDPRINTF ((stderr, " R%d", yyrule - 1));
+        if (yyesp != yyes_prev)
+          {
+            YYPTRDIFF_T yysize = yyesp - *yyes + 1;
+            if (yylen < yysize)
+              {
+                yyesp -= yylen;
+                yylen = 0;
+              }
+            else
+              {
+                yylen -= yysize;
+                yyesp = yyes_prev;
+              }
+          }
+        if (yylen)
+          yyesp = yyes_prev -= yylen;
+      }
+      {
+        yy_state_fast_t yystate;
+        {
+          const int yylhs = yyr1[yyrule] - YYNTOKENS;
+          const int yyi = yypgoto[yylhs] + *yyesp;
+          yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyesp
+                     ? yytable[yyi]
+                     : yydefgoto[yylhs]);
+        }
+        if (yyesp == yyes_prev)
+          {
+            yyesp = *yyes;
+            YY_IGNORE_USELESS_CAST_BEGIN
+            *yyesp = YY_CAST (yy_state_t, yystate);
+            YY_IGNORE_USELESS_CAST_END
+          }
+        else
+          {
+            if (yy_lac_stack_realloc (yyes_capacity, 1,
+#if ]b4_api_PREFIX[DEBUG
+                                      " (", ")",
+#endif
+                                      yyes, yyesa, &yyesp, yyes_prev))
+              {
+                YYDPRINTF ((stderr, "\n"));
+                return 2;
+              }
+            YY_IGNORE_USELESS_CAST_BEGIN
+            *++yyesp = YY_CAST (yy_state_t, yystate);
+            YY_IGNORE_USELESS_CAST_END
+          }
+        YYDPRINTF ((stderr, " G%d", yystate));
+      }
+    }
+}]])[
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen(S) (YY_CAST (YYPTRDIFF_T, strlen (S)))
+#  else
+/* Return the length of YYSTR.  */
+]b4_function_define([yystrlen], [static YYPTRDIFF_T],
+   [[const char *yystr], [yystr]])[
+{
+  YYPTRDIFF_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+]b4_function_define([yystpcpy], [static char *],
+   [[char *yydest], [yydest]], [[const char *yysrc], [yysrc]])[
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYPTRDIFF_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYPTRDIFF_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            else
+              goto append;
+
+          append:
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (yyres)
+    return yystpcpy (yyres, yystr) - yyres;
+  else
+    return yystrlen (yystr);
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.]b4_lac_if([[  In order to see if a particular token T is a
+   valid looakhead, invoke yy_lac (YYESA, YYES, YYES_CAPACITY, YYSSP, T).]])[
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store]b4_lac_if([[ or if
+   yy_lac returned 2]])[.  */
+static int
+yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
+                ]b4_lac_if([[yy_state_t *yyesa, yy_state_t **yyes,
+                YYPTRDIFF_T *yyes_capacity, ]])[yy_state_t *yyssp, int yytoken)
+{
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat: reported tokens (one for the "unexpected",
+     one per "expected"). */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Actual size of YYARG. */
+  int yycount = 0;
+  /* Cumulated lengths of YYARG.  */
+  YYPTRDIFF_T yysize = 0;
+
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.]b4_lac_if([[
+       In the first two cases, it might appear that the current syntax
+       error should have been detected in the previous state when yy_lac
+       was invoked.  However, at that time, there might have been a
+       different syntax error that discarded a different initial context
+       during error recovery, leaving behind the current lookahead.]], [[
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.]])[
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
+      yysize = yysize0;]b4_lac_if([[
+      YYDPRINTF ((stderr, "Constructing syntax error message\n"));]])[
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {]b4_lac_if([[
+          int yyx;
+
+          for (yyx = 0; yyx < YYNTOKENS; ++yyx)
+            if (yyx != YYTERROR && yyx != YYUNDEFTOK)
+              {
+                {
+                  int yy_lac_status = yy_lac (yyesa, yyes, yyes_capacity,
+                                              yyssp, yyx);
+                  if (yy_lac_status == 2)
+                    return 2;
+                  if (yy_lac_status == 1)
+                    continue;
+                }]], [[
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {]])[
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYPTRDIFF_T yysize1
+                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
+                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
+                    yysize = yysize1;
+                  else
+                    return 2;
+                }
+              }
+        }]b4_lac_if([[
+# if ]b4_api_PREFIX[DEBUG
+      else if (yydebug)
+        YYFPRINTF (stderr, "No expected tokens.\n");
+# endif]])[
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+    default: /* Avoid compiler warnings. */
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  {
+    /* Don't count the "%s"s in the final size, but reserve room for
+       the terminator.  */
+    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;
+    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
+      yysize = yysize1;
+    else
+      return 2;
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          ++yyp;
+          ++yyformat;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+]b4_yydestruct_define[
+
+]b4_pure_if([], [
+
+b4_declare_scanner_communication_variables])[]b4_push_if([[
+
+struct yypstate
+  {]b4_declare_parser_state_variables[
+    /* Used to determine if this is the first time this instance has
+       been used.  */
+    int yynew;
+  };]b4_pure_if([], [[
+
+static char yypstate_allocated = 0;]])b4_pull_if([
+
+b4_function_define([[yyparse]], [[int]], b4_parse_param)[
+{
+  return yypull_parse (YY_NULLPTR]m4_ifset([b4_parse_param],
+                                  [[, ]b4_args(b4_parse_param)])[);
+}
+
+]b4_function_define([[yypull_parse]], [[int]],
+  [[[yypstate *yyps]], [[yyps]]]m4_ifset([b4_parse_param], [,
+  b4_parse_param]))[
+{]b4_pure_if([b4_locations_if([[
+  static YYLTYPE yyloc_default][]b4_yyloc_default[;
+  YYLTYPE yylloc = yyloc_default;]])])[
+  yypstate *yyps_local;
+  if (yyps)
+    yyps_local = yyps;
+  else
+    {
+      yyps_local = yypstate_new ();
+      if (!yyps_local)
+        {]b4_pure_if([[
+          yyerror (]b4_yyerror_args[YY_("memory exhausted"));]], [[
+          if (!yypstate_allocated)
+            yyerror (]b4_yyerror_args[YY_("memory exhausted"));]])[
+          return 2;
+        }
+    }
+  int yystatus;
+  do {]b4_pure_if([[
+    YYSTYPE yylval;
+    int ]])[yychar = ]b4_lex[;
+    yystatus =
+      yypush_parse (yyps_local]b4_pure_if([[, yychar, &yylval]b4_locations_if([[, &yylloc]])])m4_ifset([b4_parse_param], [, b4_args(b4_parse_param)])[);
+  } while (yystatus == YYPUSH_MORE);
+  if (!yyps)
+    yypstate_delete (yyps_local);
+  return yystatus;
+}]])[
+
+/* Initialize the parser data structure.  */
+]b4_function_define([[yypstate_new]], [[yypstate *]])[
+{
+  yypstate *yyps;]b4_pure_if([], [[
+  if (yypstate_allocated)
+    return YY_NULLPTR;]])[
+  yyps = YY_CAST (yypstate *, malloc (sizeof *yyps));
+  if (!yyps)
+    return YY_NULLPTR;
+  yyps->yynew = 1;]b4_pure_if([], [[
+  yypstate_allocated = 1;]])[
+  return yyps;
+}
+
+]b4_function_define([[yypstate_delete]], [[void]],
+                   [[[yypstate *yyps]], [[yyps]]])[
+{
+  if (yyps)
+    {
+#ifndef yyoverflow
+      /* If the stack was reallocated but the parse did not complete, then the
+         stack still needs to be freed.  */
+      if (!yyps->yynew && yyps->yyss != yyps->yyssa)
+        YYSTACK_FREE (yyps->yyss);
+#endif]b4_lac_if([[
+      if (!yyps->yynew && yyps->yyes != yyps->yyesa)
+        YYSTACK_FREE (yyps->yyes);]])[
+      free (yyps);]b4_pure_if([], [[
+      yypstate_allocated = 0;]])[
+    }
+}
+]b4_pure_if([[
+#define ]b4_prefix[nerrs yyps->]b4_prefix[nerrs]])[
+#define yystate yyps->yystate
+#define yyerrstatus yyps->yyerrstatus
+#define yyssa yyps->yyssa
+#define yyss yyps->yyss
+#define yyssp yyps->yyssp
+#define yyvsa yyps->yyvsa
+#define yyvs yyps->yyvs
+#define yyvsp yyps->yyvsp]b4_locations_if([[
+#define yylsa yyps->yylsa
+#define yyls yyps->yyls
+#define yylsp yyps->yylsp
+#define yyerror_range yyps->yyerror_range]])[
+#define yystacksize yyps->yystacksize]b4_lac_if([[
+#define yyesa yyps->yyesa
+#define yyes yyps->yyes
+#define yyes_capacity yyps->yyes_capacity]])[
+
+
+/*---------------.
+| yypush_parse.  |
+`---------------*/
+
+]b4_function_define([[yypush_parse]], [[int]],
+  [[[yypstate *yyps]], [[yyps]]]b4_pure_if([,
+  [[[int yypushed_char]], [[yypushed_char]]],
+  [[[YYSTYPE const *yypushed_val]], [[yypushed_val]]]b4_locations_if([,
+  [[[YYLTYPE *yypushed_loc]], [[yypushed_loc]]]])])m4_ifset([b4_parse_param], [,
+  b4_parse_param]))], [[
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+]b4_function_define([yyparse], [int], b4_parse_param)])[
+{]b4_pure_if([b4_declare_scanner_communication_variables
+])b4_push_if([b4_pure_if([], [[
+  int yypushed_char = yychar;
+  YYSTYPE yypushed_val = yylval;]b4_locations_if([[
+  YYLTYPE yypushed_loc = yylloc;]])
+])],
+  [b4_declare_parser_state_variables
+])b4_lac_if([[
+  int yy_lac_established = 0;]])[
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;]b4_locations_if([[
+  YYLTYPE yyloc;]])[
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N)]b4_locations_if([, yylsp -= (N)])[)
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;]b4_push_if([[
+
+  if (!yyps->yynew)
+    {
+      yyn = yypact[yystate];
+      goto yyread_pushed_token;
+    }]])[
+
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;]b4_locations_if([[
+  yylsp = yyls = yylsa;]])[
+  yystacksize = YYINITDEPTH;]b4_lac_if([[
+
+  yyes = yyesa;
+  yyes_capacity = ]b4_percent_define_get([[parse.lac.es-capacity-initial]])[;
+  if (YYMAXDEPTH < yyes_capacity)
+    yyes_capacity = YYMAXDEPTH;]])[
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+]m4_ifdef([b4_initial_action], [
+b4_dollar_pushdef([m4_define([b4_dollar_dollar_used])yylval], [], [],
+                  [b4_push_if([b4_pure_if([*])yypushed_loc], [yylloc])])dnl
+b4_user_initial_action
+b4_dollar_popdef[]dnl
+m4_ifdef([b4_dollar_dollar_used],[[  yyvsp[0] = yylval;
+]])])dnl
+b4_locations_if([[  yylsp[0] = ]b4_push_if([b4_pure_if([*])yypushed_loc], [yylloc])[;
+]])dnl
+[  goto yysetstate;
+
+
+/*------------------------------------------------------------.
+| yynewstate -- push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+
+/*--------------------------------------------------------------------.
+| yysetstate -- set current state (the top of the stack) to yystate.  |
+`--------------------------------------------------------------------*/
+yysetstate:
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
+  YY_IGNORE_USELESS_CAST_BEGIN
+  *yyssp = YY_CAST (yy_state_t, yystate);
+  YY_IGNORE_USELESS_CAST_END
+
+  if (yyss + yystacksize - 1 <= yyssp)
+#if !defined yyoverflow && !defined YYSTACK_RELOCATE
+    goto yyexhaustedlab;
+#else
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYPTRDIFF_T yysize = yyssp - yyss + 1;
+
+# if defined yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        yy_state_t *yyss1 = yyss;
+        YYSTYPE *yyvs1 = yyvs;]b4_locations_if([
+        YYLTYPE *yyls1 = yyls;])[
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * YYSIZEOF (*yyssp),
+                    &yyvs1, yysize * YYSIZEOF (*yyvsp),]b4_locations_if([
+                    &yyls1, yysize * YYSIZEOF (*yylsp),])[
+                    &yystacksize);
+        yyss = yyss1;
+        yyvs = yyvs1;]b4_locations_if([
+        yyls = yyls1;])[
+      }
+# else /* defined YYSTACK_RELOCATE */
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yy_state_t *yyss1 = yyss;
+        union yyalloc *yyptr =
+          YY_CAST (union yyalloc *,
+                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);]b4_locations_if([
+        YYSTACK_RELOCATE (yyls_alloc, yyls);])[
+# undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;]b4_locations_if([
+      yylsp = yyls + yysize - 1;])[
+
+      YY_IGNORE_USELESS_CAST_BEGIN
+      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
+                  YY_CAST (long, yystacksize)));
+      YY_IGNORE_USELESS_CAST_END
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {]b4_push_if([[
+      if (!yyps->yynew)
+        {]b4_use_push_for_pull_if([], [[
+          YYDPRINTF ((stderr, "Return for a new token:\n"));]])[
+          yyresult = YYPUSH_MORE;
+          goto yypushreturn;
+        }
+      yyps->yynew = 0;]b4_pure_if([], [[
+      /* Restoring the pushed token is only necessary for the first
+         yypush_parse invocation since subsequent invocations don't overwrite
+         it before jumping to yyread_pushed_token.  */
+      yychar = yypushed_char;
+      yylval = yypushed_val;]b4_locations_if([[
+      yylloc = yypushed_loc;]])])[
+yyread_pushed_token:]])[
+      YYDPRINTF ((stderr, "Reading a token: "));]b4_push_if([b4_pure_if([[
+      yychar = yypushed_char;
+      if (yypushed_val)
+        yylval = *yypushed_val;]b4_locations_if([[
+      if (yypushed_loc)
+        yylloc = *yypushed_loc;]])])], [[
+      yychar = ]b4_lex[;]])[
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)]b4_lac_if([[
+    {
+      YY_LAC_ESTABLISH;
+      goto yydefault;
+    }]], [[
+    goto yydefault;]])[
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;]b4_lac_if([[
+      YY_LAC_ESTABLISH;]])[
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END]b4_locations_if([
+  *++yylsp = yylloc;])[
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;]b4_lac_if([[
+  YY_LAC_DISCARD ("shift");]])[
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+]b4_locations_if(
+[[  /* Default location. */
+  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
+  yyerror_range[1] = yyloc;]])[
+  YY_REDUCE_PRINT (yyn);]b4_lac_if([[
+  {
+    int yychar_backup = yychar;
+    switch (yyn)
+      {
+]b4_user_actions[
+        default: break;
+      }
+    if (yychar_backup != yychar)
+      YY_LAC_DISCARD ("yychar change");
+  }]], [[
+  switch (yyn)
+    {
+]b4_user_actions[
+      default: break;
+    }]])[
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;]b4_locations_if([
+  *++yylsp = yyloc;])[
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+  {
+    const int yylhs = yyr1[yyn] - YYNTOKENS;
+    const int yyi = yypgoto[yylhs] + *yyssp;
+    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
+               ? yytable[yyi]
+               : yydefgoto[yylhs]);
+  }
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (]b4_yyerror_args[YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \]b4_lac_if([[
+                                        yyesa, &yyes, &yyes_capacity, \]])[
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;]b4_lac_if([[
+        if (yychar != YYEMPTY)
+          YY_LAC_ESTABLISH;]])[
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (]b4_yyerror_args[yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+]b4_locations_if([[  yyerror_range[1] = yylloc;]])[
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval]b4_locations_if([, &yylloc])[]b4_user_args[);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+  /* Pacify compilers when the user code never invokes YYERROR and the
+     label yyerrorlab therefore never appears in user code.  */
+  if (0)
+    YYERROR;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+]b4_locations_if([[      yyerror_range[1] = *yylsp;]])[
+      yydestruct ("Error: popping",
+                  yystos[yystate], yyvsp]b4_locations_if([, yylsp])[]b4_user_args[);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }]b4_lac_if([[
+
+  /* If the stack popping above didn't lose the initial context for the
+     current lookahead token, the shift below will for sure.  */
+  YY_LAC_DISCARD ("error recovery");]])[
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+]b4_locations_if([[
+  yyerror_range[2] = yylloc;
+  /* Using YYLLOC is tempting, but would change the location of
+     the lookahead.  YYLOC is available though.  */
+  YYLLOC_DEFAULT (yyloc, yyerror_range, 2);
+  *++yylsp = yyloc;]])[
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+
+#if ]b4_lac_if([[1]], [[!defined yyoverflow || YYERROR_VERBOSE]])[
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (]b4_yyerror_args[YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+
+/*-----------------------------------------------------.
+| yyreturn -- parsing is finished, return the result.  |
+`-----------------------------------------------------*/
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval]b4_locations_if([, &yylloc])[]b4_user_args[);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  yystos[*yyssp], yyvsp]b4_locations_if([, yylsp])[]b4_user_args[);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif]b4_lac_if([[
+  if (yyes != yyesa)
+    YYSTACK_FREE (yyes);]])b4_push_if([[
+  yyps->yynew = 1;
+
+
+/*-----------------------------------------.
+| yypushreturn -- ask for the next token.  |
+`-----------------------------------------*/
+yypushreturn:]])[
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  return yyresult;
+}
+]b4_epilogue[]dnl
+b4_output_end
diff --git a/common/bison/xslt/bison.xsl b/common/bison/xslt/bison.xsl
new file mode 100644
index 0000000000000000000000000000000000000000..5c1a358fa987d3241b9c3f16a20ff0fb11172f5b
--- /dev/null
+++ b/common/bison/xslt/bison.xsl
@@ -0,0 +1,105 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+    bison.xsl - common templates for Bison XSLT.
+
+    Copyright (C) 2007-2015, 2018-2019 Free Software Foundation, Inc.
+
+    This file is part of Bison, the GNU Compiler Compiler.
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+  -->
+
+<xsl:stylesheet version="1.0"
+  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+  xmlns:bison="http://www.gnu.org/software/bison/">
+
+<xsl:key
+  name="bison:symbolByName"
+  match="/bison-xml-report/grammar/nonterminals/nonterminal"
+  use="@name"
+/>
+<xsl:key
+  name="bison:symbolByName"
+  match="/bison-xml-report/grammar/terminals/terminal"
+  use="@name"
+/>
+<xsl:key
+  name="bison:ruleByNumber"
+  match="/bison-xml-report/grammar/rules/rule"
+  use="@number"
+/>
+<xsl:key
+  name="bison:ruleByLhs"
+  match="/bison-xml-report/grammar/rules/rule[
+         @usefulness != 'useless-in-grammar']"
+  use="lhs"
+/>
+<xsl:key
+  name="bison:ruleByRhs"
+  match="/bison-xml-report/grammar/rules/rule[
+         @usefulness != 'useless-in-grammar']"
+  use="rhs/symbol"
+/>
+
+<!-- For the specified state, output: #sr-conflicts,#rr-conflicts -->
+<xsl:template match="state" mode="bison:count-conflicts">
+  <xsl:variable name="transitions" select="actions/transitions"/>
+  <xsl:variable name="reductions" select="actions/reductions"/>
+  <xsl:variable
+    name="terminals"
+    select="
+      $transitions/transition[@type='shift']/@symbol
+      | $reductions/reduction/@symbol
+    "
+  />
+  <xsl:variable name="conflict-data">
+    <xsl:for-each select="$terminals">
+      <xsl:variable name="name" select="."/>
+      <xsl:if test="generate-id($terminals[. = $name][1]) = generate-id(.)">
+        <xsl:variable
+          name="shift-count"
+          select="count($transitions/transition[@symbol=$name])"
+        />
+        <xsl:variable
+          name="reduce-count"
+          select="count($reductions/reduction[@symbol=$name])"
+        />
+        <xsl:if test="$shift-count > 0 and $reduce-count > 0">
+          <xsl:text>s</xsl:text>
+        </xsl:if>
+        <xsl:if test="$reduce-count > 1">
+          <xsl:text>r</xsl:text>
+        </xsl:if>
+      </xsl:if>
+    </xsl:for-each>
+  </xsl:variable>
+  <xsl:value-of select="string-length(translate($conflict-data, 'r', ''))"/>
+  <xsl:text>,</xsl:text>
+  <xsl:value-of select="string-length(translate($conflict-data, 's', ''))"/>
+</xsl:template>
+
+<xsl:template name="space">
+  <xsl:param name="repeat">0</xsl:param>
+  <xsl:param name="fill" select="' '"/>
+  <xsl:if test="number($repeat) &gt;= 1">
+    <xsl:call-template name="space">
+      <xsl:with-param name="repeat" select="$repeat - 1"/>
+      <xsl:with-param name="fill" select="$fill"/>
+    </xsl:call-template>
+    <xsl:value-of select="$fill"/>
+  </xsl:if>
+</xsl:template>
+
+</xsl:stylesheet>
diff --git a/common/bison/xslt/xml2dot.xsl b/common/bison/xslt/xml2dot.xsl
new file mode 100644
index 0000000000000000000000000000000000000000..0a7419f588d778291da6d63a1aa560368ddf00e3
--- /dev/null
+++ b/common/bison/xslt/xml2dot.xsl
@@ -0,0 +1,401 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+    xml2dot.xsl - transform Bison XML Report into DOT.
+
+    Copyright (C) 2007-2015, 2018-2019 Free Software Foundation, Inc.
+
+    This file is part of Bison, the GNU Compiler Compiler.
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+    Written by Wojciech Polak <polak@gnu.org>.
+  -->
+
+<xsl:stylesheet version="1.0"
+  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+  xmlns:bison="http://www.gnu.org/software/bison/">
+
+<xsl:import href="bison.xsl"/>
+<xsl:output method="text" encoding="UTF-8" indent="no"/>
+
+<xsl:template match="/">
+  <xsl:apply-templates select="bison-xml-report"/>
+</xsl:template>
+
+<xsl:template match="bison-xml-report">
+  <xsl:text>// Generated by GNU Bison </xsl:text>
+  <xsl:value-of select="@version"/>
+  <xsl:text>.&#10;</xsl:text>
+  <xsl:text>// Report bugs to &lt;</xsl:text>
+  <xsl:value-of select="@bug-report"/>
+  <xsl:text>&gt;.&#10;</xsl:text>
+  <xsl:text>// Home page: &lt;</xsl:text>
+  <xsl:value-of select="@url"/>
+  <xsl:text>&gt;.&#10;&#10;</xsl:text>
+  <xsl:apply-templates select="automaton">
+    <xsl:with-param name="filename" select="filename"/>
+  </xsl:apply-templates>
+</xsl:template>
+
+<xsl:template match="automaton">
+  <xsl:param name="filename"/>
+  <xsl:text>digraph "</xsl:text>
+  <xsl:call-template name="escape">
+    <xsl:with-param name="subject" select="$filename"/>
+  </xsl:call-template>
+  <xsl:text>"&#10;{
+  node [fontname = courier, shape = box, colorscheme = paired6]
+  edge [fontname = courier]
+
+</xsl:text>
+  <xsl:apply-templates select="state"/>
+  <xsl:text>}&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="automaton/state">
+  <xsl:call-template name="output-node">
+    <xsl:with-param name="number" select="@number"/>
+    <xsl:with-param name="label">
+      <xsl:apply-templates select="itemset/item"/>
+    </xsl:with-param>
+  </xsl:call-template>
+  <xsl:apply-templates select="actions/transitions"/>
+  <xsl:apply-templates select="actions/reductions">
+    <xsl:with-param name="staten">
+      <xsl:value-of select="@number"/>
+    </xsl:with-param>
+  </xsl:apply-templates>
+</xsl:template>
+
+<xsl:template match="actions/reductions">
+  <xsl:param name="staten"/>
+  <xsl:for-each select='reduction'>
+    <!-- These variables are needed because the current context can't be
+         referred to directly in XPath expressions. -->
+    <xsl:variable name="rul">
+      <xsl:value-of select="@rule"/>
+    </xsl:variable>
+    <xsl:variable name="ena">
+      <xsl:value-of select="@enabled"/>
+    </xsl:variable>
+    <!-- The foreach's body is protected by this, so that we are actually
+         going to iterate once per reduction rule, and not per lookahead. -->
+    <xsl:if test='not(preceding-sibling::*[@rule=$rul and @enabled=$ena])'>
+      <xsl:variable name="rule">
+        <xsl:choose>
+          <!-- The acceptation state is referred to as 'accept' in the XML, but
+               just as '0' in the DOT. -->
+          <xsl:when test="@rule='accept'">
+            <xsl:text>0</xsl:text>
+          </xsl:when>
+          <xsl:otherwise>
+            <xsl:value-of select="@rule"/>
+          </xsl:otherwise>
+        </xsl:choose>
+      </xsl:variable>
+
+      <!-- The edge's beginning -->
+      <xsl:call-template name="reduction-edge-start">
+        <xsl:with-param name="state" select="$staten"/>
+        <xsl:with-param name="rule" select="$rule"/>
+        <xsl:with-param name="enabled" select="@enabled"/>
+      </xsl:call-template>
+
+      <!-- The edge's tokens -->
+      <!-- Don't show labels for the default action. In other cases, there will
+           always be at least one token, so 'label="[]"' will not occur. -->
+      <xsl:if test='$rule!=0 and not(../reduction[@enabled=$ena and @rule=$rule and @symbol="$default"])'>
+        <xsl:text>label="[</xsl:text>
+        <xsl:for-each select='../reduction[@enabled=$ena and @rule=$rule]'>
+          <xsl:call-template name="escape">
+            <xsl:with-param name="subject" select="@symbol"/>
+          </xsl:call-template>
+          <xsl:if test="position() != last ()">
+            <xsl:text>, </xsl:text>
+          </xsl:if>
+        </xsl:for-each>
+        <xsl:text>]", </xsl:text>
+      </xsl:if>
+
+      <!-- The edge's end -->
+      <xsl:text>style=solid]&#10;</xsl:text>
+
+      <!-- The diamond representing the reduction -->
+      <xsl:call-template name="reduction-node">
+        <xsl:with-param name="state" select="$staten"/>
+        <xsl:with-param name="rule" select="$rule"/>
+        <xsl:with-param name="color">
+          <xsl:choose>
+            <xsl:when test='@enabled="true"'>
+              <xsl:text>3</xsl:text>
+            </xsl:when>
+            <xsl:otherwise>
+              <xsl:text>5</xsl:text>
+            </xsl:otherwise>
+          </xsl:choose>
+        </xsl:with-param>
+      </xsl:call-template>
+    </xsl:if>
+  </xsl:for-each>
+</xsl:template>
+
+<xsl:template match="actions/transitions">
+  <xsl:apply-templates select="transition"/>
+</xsl:template>
+
+<xsl:template match="item">
+  <xsl:param name="prev-rule-number"
+    select="preceding-sibling::item[1]/@rule-number"/>
+  <xsl:apply-templates select="key('bison:ruleByNumber', @rule-number)">
+    <xsl:with-param name="point" select="@point"/>
+    <xsl:with-param name="num" select="@rule-number"/>
+    <xsl:with-param name="prev-lhs"
+      select="key('bison:ruleByNumber', $prev-rule-number)/lhs[text()]"
+   />
+  </xsl:apply-templates>
+  <xsl:apply-templates select="lookaheads"/>
+</xsl:template>
+
+<xsl:template match="rule">
+  <xsl:param name="point"/>
+  <xsl:param name="num"/>
+  <xsl:param name="prev-lhs"/>
+  <xsl:text>&#10;</xsl:text>
+  <xsl:choose>
+    <xsl:when test="$num &lt; 10">
+      <xsl:text>  </xsl:text>
+    </xsl:when>
+    <xsl:when test="$num &lt; 100">
+      <xsl:text> </xsl:text>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:text></xsl:text>
+    </xsl:otherwise>
+  </xsl:choose>
+  <xsl:value-of select="$num"/>
+  <xsl:text> </xsl:text>
+  <xsl:choose>
+  <xsl:when test="$prev-lhs = lhs[text()]">
+      <xsl:call-template name="lpad">
+        <xsl:with-param name="str" select="'|'"/>
+        <xsl:with-param name="pad" select="number(string-length(lhs[text()])) + 1"/>
+      </xsl:call-template>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:value-of select="lhs"/>
+      <xsl:text>:</xsl:text>
+    </xsl:otherwise>
+  </xsl:choose>
+  <xsl:if test="$point = 0">
+    <xsl:text> .</xsl:text>
+  </xsl:if>
+
+  <!-- RHS -->
+  <xsl:for-each select="rhs/symbol|rhs/empty">
+    <xsl:apply-templates select="."/>
+    <xsl:if test="$point = position()">
+      <xsl:text> .</xsl:text>
+    </xsl:if>
+  </xsl:for-each>
+</xsl:template>
+
+<xsl:template match="symbol">
+  <xsl:text> </xsl:text>
+  <xsl:value-of select="."/>
+</xsl:template>
+
+<xsl:template match="empty">
+  <xsl:text> %empty</xsl:text>
+</xsl:template>
+
+<xsl:template match="lookaheads">
+  <xsl:text>  [</xsl:text>
+  <xsl:apply-templates select="symbol"/>
+  <xsl:text>]</xsl:text>
+</xsl:template>
+
+<xsl:template match="lookaheads/symbol">
+  <xsl:value-of select="."/>
+  <xsl:if test="position() != last()">
+    <xsl:text>, </xsl:text>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template name="reduction-edge-start">
+  <xsl:param name="state"/>
+  <xsl:param name="rule"/>
+  <xsl:param name="enabled"/>
+
+  <xsl:text>  </xsl:text>
+  <xsl:value-of select="$state"/>
+  <xsl:text> -> "</xsl:text>
+  <xsl:value-of select="$state"/>
+  <xsl:text>R</xsl:text>
+  <xsl:value-of select="$rule"/>
+  <xsl:if test='$enabled = "false"'>
+    <xsl:text>d</xsl:text>
+  </xsl:if>
+  <xsl:text>" [</xsl:text>
+</xsl:template>
+
+<xsl:template name="reduction-node">
+  <xsl:param name="state"/>
+  <xsl:param name="rule"/>
+  <xsl:param name="color"/>
+
+  <xsl:text> "</xsl:text>
+  <xsl:value-of select="$state"/>
+  <xsl:text>R</xsl:text>
+  <xsl:value-of select="$rule"/>
+  <xsl:if test="$color = 5">
+    <xsl:text>d</xsl:text>
+  </xsl:if>
+  <xsl:text>" [label="</xsl:text>
+  <xsl:choose>
+  <xsl:when test="$rule = 0">
+    <xsl:text>Acc", fillcolor=1</xsl:text>
+  </xsl:when>
+  <xsl:otherwise>
+    <xsl:text>R</xsl:text>
+    <xsl:value-of select="$rule"/>
+    <xsl:text>", fillcolor=</xsl:text>
+    <xsl:value-of select="$color"/>
+  </xsl:otherwise>
+  </xsl:choose>
+  <xsl:text>, shape=diamond, style=filled]&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="transition">
+  <xsl:call-template name="output-edge">
+    <xsl:with-param name="src" select="../../../@number"/>
+    <xsl:with-param name="dst" select="@state"/>
+    <xsl:with-param name="style">
+      <xsl:choose>
+        <xsl:when test="@symbol = 'error'">
+          <xsl:text>dotted</xsl:text>
+        </xsl:when>
+        <xsl:when test="@type = 'shift'">
+          <xsl:text>solid</xsl:text>
+        </xsl:when>
+        <xsl:otherwise>
+          <xsl:text>dashed</xsl:text>
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:with-param>
+    <xsl:with-param name="label">
+      <xsl:if test="not(@symbol = 'error')">
+        <xsl:value-of select="@symbol"/>
+      </xsl:if>
+    </xsl:with-param>
+  </xsl:call-template>
+</xsl:template>
+
+<xsl:template name="output-node">
+  <xsl:param name="number"/>
+  <xsl:param name="label"/>
+  <xsl:text>  </xsl:text>
+  <xsl:value-of select="$number"/>
+  <xsl:text> [label="</xsl:text>
+  <xsl:text>State </xsl:text>
+  <xsl:value-of select="$number"/>
+  <xsl:text>\n</xsl:text>
+  <xsl:call-template name="escape">
+    <xsl:with-param name="subject" select="$label"/>
+  </xsl:call-template>
+  <xsl:text>\l"]&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template name="output-edge">
+  <xsl:param name="src"/>
+  <xsl:param name="dst"/>
+  <xsl:param name="style"/>
+  <xsl:param name="label"/>
+  <xsl:text>  </xsl:text>
+  <xsl:value-of select="$src"/>
+  <xsl:text> -> </xsl:text>
+  <xsl:value-of select="$dst"/>
+  <xsl:text> [style=</xsl:text>
+  <xsl:value-of select="$style"/>
+  <xsl:if test="$label and $label != ''">
+    <xsl:text> label="</xsl:text>
+    <xsl:call-template name="escape">
+      <xsl:with-param name="subject" select="$label"/>
+    </xsl:call-template>
+    <xsl:text>"</xsl:text>
+  </xsl:if>
+  <xsl:text>]&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template name="escape">
+  <xsl:param name="subject"/> <!-- required -->
+  <xsl:call-template name="string-replace">
+    <xsl:with-param name="subject">
+      <xsl:call-template name="string-replace">
+        <xsl:with-param name="subject">
+          <xsl:call-template name="string-replace">
+            <xsl:with-param name="subject" select="$subject"/>
+            <xsl:with-param name="search" select="'\'"/>
+            <xsl:with-param name="replace" select="'\\'"/>
+          </xsl:call-template>
+        </xsl:with-param>
+        <xsl:with-param name="search" select="'&quot;'"/>
+        <xsl:with-param name="replace" select="'\&quot;'"/>
+      </xsl:call-template>
+    </xsl:with-param>
+    <xsl:with-param name="search" select="'&#10;'"/>
+    <xsl:with-param name="replace" select="'\l'"/>
+  </xsl:call-template>
+</xsl:template>
+
+<xsl:template name="string-replace">
+  <xsl:param name="subject"/>
+  <xsl:param name="search"/>
+  <xsl:param name="replace"/>
+  <xsl:choose>
+    <xsl:when test="contains($subject, $search)">
+      <xsl:variable name="before" select="substring-before($subject, $search)"/>
+      <xsl:variable name="after" select="substring-after($subject, $search)"/>
+      <xsl:value-of select="$before"/>
+      <xsl:value-of select="$replace"/>
+      <xsl:call-template name="string-replace">
+        <xsl:with-param name="subject" select="$after"/>
+        <xsl:with-param name="search" select="$search"/>
+        <xsl:with-param name="replace" select="$replace"/>
+      </xsl:call-template>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:value-of select="$subject"/>
+    </xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+<xsl:template name="lpad">
+  <xsl:param name="str" select="''"/>
+  <xsl:param name="pad" select="0"/>
+  <xsl:variable name="diff" select="$pad - string-length($str)" />
+  <xsl:choose>
+    <xsl:when test="$diff &lt; 0">
+      <xsl:value-of select="$str"/>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:call-template name="space">
+        <xsl:with-param name="repeat" select="$diff"/>
+      </xsl:call-template>
+      <xsl:value-of select="$str"/>
+    </xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+</xsl:stylesheet>
diff --git a/common/bison/xslt/xml2text.xsl b/common/bison/xslt/xml2text.xsl
new file mode 100644
index 0000000000000000000000000000000000000000..72b56e719429f5c2b927ab4602fc55c7e6a6493d
--- /dev/null
+++ b/common/bison/xslt/xml2text.xsl
@@ -0,0 +1,564 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+    xml2text.xsl - transform Bison XML Report into plain text.
+
+    Copyright (C) 2007-2015, 2018-2019 Free Software Foundation, Inc.
+
+    This file is part of Bison, the GNU Compiler Compiler.
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+    Written by Wojciech Polak <polak@gnu.org>.
+  -->
+
+<xsl:stylesheet version="1.0"
+  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+  xmlns:bison="http://www.gnu.org/software/bison/">
+
+<xsl:import href="bison.xsl"/>
+<xsl:output method="text" encoding="UTF-8" indent="no"/>
+
+<xsl:template match="/">
+  <xsl:apply-templates select="bison-xml-report"/>
+</xsl:template>
+
+<xsl:template match="bison-xml-report">
+  <xsl:apply-templates select="grammar" mode="reductions"/>
+  <xsl:apply-templates select="grammar" mode="useless-in-parser"/>
+  <xsl:apply-templates select="automaton" mode="conflicts"/>
+  <xsl:apply-templates select="grammar"/>
+  <xsl:apply-templates select="automaton"/>
+</xsl:template>
+
+<xsl:template match="grammar" mode="reductions">
+  <xsl:apply-templates select="nonterminals" mode="useless-in-grammar"/>
+  <xsl:apply-templates select="terminals" mode="unused-in-grammar"/>
+  <xsl:apply-templates select="rules" mode="useless-in-grammar"/>
+</xsl:template>
+
+<xsl:template match="nonterminals" mode="useless-in-grammar">
+  <xsl:if test="nonterminal[@usefulness='useless-in-grammar']">
+    <xsl:text>Nonterminals useless in grammar&#10;&#10;</xsl:text>
+    <xsl:for-each select="nonterminal[@usefulness='useless-in-grammar']">
+      <xsl:text>   </xsl:text>
+      <xsl:value-of select="@name"/>
+      <xsl:text>&#10;</xsl:text>
+    </xsl:for-each>
+    <xsl:text>&#10;&#10;</xsl:text>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="terminals" mode="unused-in-grammar">
+  <xsl:if test="terminal[@usefulness='unused-in-grammar']">
+    <xsl:text>Terminals unused in grammar&#10;&#10;</xsl:text>
+    <xsl:for-each select="terminal[@usefulness='unused-in-grammar']">
+      <xsl:sort select="@symbol-number" data-type="number"/>
+      <xsl:text>   </xsl:text>
+      <xsl:value-of select="@name"/>
+      <xsl:text>&#10;</xsl:text>
+    </xsl:for-each>
+    <xsl:text>&#10;&#10;</xsl:text>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="rules" mode="useless-in-grammar">
+  <xsl:variable name="set" select="rule[@usefulness='useless-in-grammar']"/>
+  <xsl:if test="$set">
+    <xsl:text>Rules useless in grammar&#10;</xsl:text>
+    <xsl:call-template name="style-rule-set">
+      <xsl:with-param name="rule-set" select="$set"/>
+    </xsl:call-template>
+    <xsl:text>&#10;&#10;</xsl:text>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="grammar" mode="useless-in-parser">
+  <xsl:variable
+    name="set" select="rules/rule[@usefulness='useless-in-parser']"
+  />
+  <xsl:if test="$set">
+    <xsl:text>Rules useless in parser due to conflicts&#10;</xsl:text>
+    <xsl:call-template name="style-rule-set">
+      <xsl:with-param name="rule-set" select="$set"/>
+    </xsl:call-template>
+    <xsl:text>&#10;&#10;</xsl:text>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="grammar">
+  <xsl:text>Grammar&#10;</xsl:text>
+  <xsl:call-template name="style-rule-set">
+    <xsl:with-param
+      name="rule-set" select="rules/rule[@usefulness!='useless-in-grammar']"
+    />
+  </xsl:call-template>
+  <xsl:text>&#10;&#10;</xsl:text>
+  <xsl:apply-templates select="terminals"/>
+  <xsl:apply-templates select="nonterminals"/>
+</xsl:template>
+
+<xsl:template name="style-rule-set">
+  <xsl:param name="rule-set"/>
+  <xsl:for-each select="$rule-set">
+    <xsl:apply-templates select=".">
+      <xsl:with-param name="pad" select="'3'"/>
+      <xsl:with-param name="prev-lhs">
+        <xsl:if test="position()>1">
+          <xsl:variable name="position" select="position()"/>
+          <xsl:value-of select="$rule-set[$position - 1]/lhs"/>
+        </xsl:if>
+      </xsl:with-param>
+    </xsl:apply-templates>
+  </xsl:for-each>
+</xsl:template>
+
+<xsl:template match="grammar/terminals">
+  <xsl:text>Terminals, with rules where they appear&#10;&#10;</xsl:text>
+  <xsl:apply-templates select="terminal"/>
+  <xsl:text>&#10;&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="grammar/nonterminals">
+  <xsl:text>Nonterminals, with rules where they appear&#10;&#10;</xsl:text>
+  <xsl:apply-templates select="nonterminal[@usefulness!='useless-in-grammar']"/>
+</xsl:template>
+
+<xsl:template match="terminal">
+  <xsl:value-of select="@name"/>
+  <xsl:call-template name="line-wrap">
+    <xsl:with-param name="first-line-length">
+      <xsl:choose>
+        <xsl:when test="string-length(@name) &gt; 66">0</xsl:when>
+        <xsl:otherwise>
+          <xsl:value-of select="66 - string-length(@name)" />
+        </xsl:otherwise>
+      </xsl:choose>
+    </xsl:with-param>
+    <xsl:with-param name="line-length" select="66" />
+    <xsl:with-param name="text">
+      <xsl:value-of select="concat(' (', @token-number, ')')"/>
+      <xsl:for-each select="key('bison:ruleByRhs', @name)">
+        <xsl:value-of select="concat(' ', @number)"/>
+      </xsl:for-each>
+    </xsl:with-param>
+  </xsl:call-template>
+</xsl:template>
+
+<xsl:template match="nonterminal">
+  <xsl:value-of select="@name"/>
+  <xsl:value-of select="concat(' (', @symbol-number, ')')"/>
+  <xsl:text>&#10;</xsl:text>
+  <xsl:variable name="output">
+    <xsl:call-template name="line-wrap">
+      <xsl:with-param name="line-length" select="66" />
+      <xsl:with-param name="text">
+        <xsl:text>    </xsl:text>
+        <xsl:if test="key('bison:ruleByLhs', @name)">
+          <xsl:text>on@left:</xsl:text>
+          <xsl:for-each select="key('bison:ruleByLhs', @name)">
+            <xsl:value-of select="concat(' ', @number)"/>
+          </xsl:for-each>
+        </xsl:if>
+        <xsl:if test="key('bison:ruleByRhs', @name)">
+          <xsl:if test="key('bison:ruleByLhs', @name)">
+            <xsl:text>, </xsl:text>
+          </xsl:if>
+          <xsl:text>on@right:</xsl:text>
+          <xsl:for-each select="key('bison:ruleByRhs', @name)">
+            <xsl:value-of select="concat(' ', @number)"/>
+          </xsl:for-each>
+        </xsl:if>
+      </xsl:with-param>
+    </xsl:call-template>
+  </xsl:variable>
+  <xsl:value-of select="translate($output, '@', ' ')" />
+</xsl:template>
+
+<xsl:template match="automaton" mode="conflicts">
+  <xsl:variable name="conflict-report">
+    <xsl:apply-templates select="state" mode="conflicts"/>
+  </xsl:variable>
+  <xsl:if test="string-length($conflict-report) != 0">
+    <xsl:value-of select="$conflict-report"/>
+    <xsl:text>&#10;&#10;</xsl:text>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="state" mode="conflicts">
+  <xsl:variable name="conflict-counts">
+    <xsl:apply-templates select="." mode="bison:count-conflicts" />
+  </xsl:variable>
+  <xsl:variable
+    name="sr-count" select="substring-before($conflict-counts, ',')"
+  />
+  <xsl:variable
+    name="rr-count" select="substring-after($conflict-counts, ',')"
+  />
+  <xsl:if test="$sr-count > 0 or $rr-count > 0">
+    <xsl:value-of select="concat('State ', @number, ' conflicts:')"/>
+    <xsl:if test="$sr-count > 0">
+      <xsl:value-of select="concat(' ', $sr-count, ' shift/reduce')"/>
+      <xsl:if test="$rr-count > 0">
+        <xsl:value-of select="(',')"/>
+      </xsl:if>
+    </xsl:if>
+    <xsl:if test="$rr-count > 0">
+      <xsl:value-of select="concat(' ', $rr-count, ' reduce/reduce')"/>
+    </xsl:if>
+    <xsl:value-of select="'&#10;'"/>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="automaton">
+  <xsl:apply-templates select="state">
+    <xsl:with-param name="pad" select="'3'"/>
+  </xsl:apply-templates>
+</xsl:template>
+
+<xsl:template match="automaton/state">
+  <xsl:param name="pad"/>
+  <xsl:text>&#10;&#10;</xsl:text>
+  <xsl:text>State </xsl:text>
+  <xsl:value-of select="@number"/>
+  <xsl:text>&#10;&#10;</xsl:text>
+  <xsl:apply-templates select="itemset/item">
+    <xsl:with-param name="pad" select="$pad"/>
+  </xsl:apply-templates>
+  <xsl:apply-templates select="actions/transitions">
+    <xsl:with-param name="type" select="'shift'"/>
+  </xsl:apply-templates>
+  <xsl:apply-templates select="actions/errors"/>
+  <xsl:apply-templates select="actions/reductions"/>
+  <xsl:apply-templates select="actions/transitions">
+    <xsl:with-param name="type" select="'goto'"/>
+  </xsl:apply-templates>
+  <xsl:apply-templates select="solved-conflicts"/>
+</xsl:template>
+
+<xsl:template match="actions/transitions">
+  <xsl:param name="type"/>
+  <xsl:if test="transition[@type = $type]">
+    <xsl:text>&#10;</xsl:text>
+    <xsl:apply-templates select="transition[@type = $type]">
+      <xsl:with-param name="pad">
+        <xsl:call-template name="max-width-symbol">
+          <xsl:with-param name="node" select="transition[@type = $type]"/>
+        </xsl:call-template>
+      </xsl:with-param>
+    </xsl:apply-templates>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="actions/errors">
+  <xsl:if test="error">
+    <xsl:text>&#10;</xsl:text>
+    <xsl:apply-templates select="error">
+      <xsl:with-param name="pad">
+        <xsl:call-template name="max-width-symbol">
+          <xsl:with-param name="node" select="error"/>
+        </xsl:call-template>
+      </xsl:with-param>
+    </xsl:apply-templates>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="actions/reductions">
+  <xsl:if test="reduction">
+    <xsl:text>&#10;</xsl:text>
+    <xsl:apply-templates select="reduction">
+      <xsl:with-param name="pad">
+        <xsl:call-template name="max-width-symbol">
+          <xsl:with-param name="node" select="reduction"/>
+        </xsl:call-template>
+      </xsl:with-param>
+    </xsl:apply-templates>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="item">
+  <xsl:param name="pad"/>
+  <xsl:param name="prev-rule-number"
+             select="preceding-sibling::item[1]/@rule-number"/>
+  <xsl:apply-templates
+    select="key('bison:ruleByNumber', current()/@rule-number)"
+  >
+    <xsl:with-param name="itemset" select="'true'"/>
+    <xsl:with-param name="pad" select="$pad"/>
+    <xsl:with-param
+      name="prev-lhs"
+      select="key('bison:ruleByNumber', $prev-rule-number)/lhs[text()]"
+   />
+    <xsl:with-param name="point" select="@point"/>
+    <xsl:with-param name="lookaheads">
+      <xsl:apply-templates select="lookaheads"/>
+    </xsl:with-param>
+  </xsl:apply-templates>
+</xsl:template>
+
+<xsl:template match="rule">
+  <xsl:param name="itemset"/>
+  <xsl:param name="pad"/>
+  <xsl:param name="prev-lhs"/>
+  <xsl:param name="point"/>
+  <xsl:param name="lookaheads"/>
+
+  <xsl:if test="$itemset != 'true' and not($prev-lhs = lhs[text()])">
+    <xsl:text>&#10;</xsl:text>
+  </xsl:if>
+
+  <xsl:text>  </xsl:text>
+  <xsl:call-template name="lpad">
+    <xsl:with-param name="str" select="string(@number)"/>
+    <xsl:with-param name="pad" select="number($pad)"/>
+  </xsl:call-template>
+  <xsl:text> </xsl:text>
+
+  <!-- LHS -->
+  <xsl:choose>
+    <xsl:when test="$itemset != 'true' and $prev-lhs = lhs[text()]">
+      <xsl:call-template name="lpad">
+        <xsl:with-param name="str" select="'|'"/>
+        <xsl:with-param name="pad" select="number(string-length(lhs[text()])) + 1"/>
+      </xsl:call-template>
+    </xsl:when>
+    <xsl:when test="$itemset = 'true' and $prev-lhs = lhs[text()]">
+      <xsl:call-template name="lpad">
+        <xsl:with-param name="str" select="'|'"/>
+        <xsl:with-param name="pad" select="number(string-length(lhs[text()])) + 1"/>
+      </xsl:call-template>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:value-of select="lhs"/>
+      <xsl:text>:</xsl:text>
+    </xsl:otherwise>
+  </xsl:choose>
+
+  <!-- RHS -->
+  <xsl:for-each select="rhs/*">
+    <xsl:if test="position() = $point + 1">
+      <xsl:text> .</xsl:text>
+    </xsl:if>
+    <xsl:apply-templates select="."/>
+    <xsl:if test="position() = last() and position() = $point">
+      <xsl:text> .</xsl:text>
+    </xsl:if>
+  </xsl:for-each>
+  <xsl:if test="$lookaheads">
+    <xsl:value-of select="$lookaheads"/>
+  </xsl:if>
+
+  <xsl:text>&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="symbol">
+  <xsl:text> </xsl:text>
+  <xsl:value-of select="."/>
+</xsl:template>
+
+<xsl:template match="empty">
+  <xsl:text> %empty</xsl:text>
+</xsl:template>
+
+<xsl:template match="lookaheads">
+  <xsl:text>  [</xsl:text>
+  <xsl:apply-templates select="symbol"/>
+  <xsl:text>]</xsl:text>
+</xsl:template>
+
+<xsl:template match="lookaheads/symbol">
+  <xsl:value-of select="."/>
+  <xsl:if test="position() != last()">
+    <xsl:text>, </xsl:text>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="transition">
+  <xsl:param name="pad"/>
+  <xsl:text>    </xsl:text>
+  <xsl:call-template name="rpad">
+    <xsl:with-param name="str" select="string(@symbol)"/>
+    <xsl:with-param name="pad" select="number($pad) + 2"/>
+  </xsl:call-template>
+  <xsl:choose>
+    <xsl:when test="@type = 'shift'">
+      <xsl:text>shift, and go to state </xsl:text>
+      <xsl:value-of select="@state"/>
+    </xsl:when>
+    <xsl:when test="@type = 'goto'">
+      <xsl:text>go to state </xsl:text>
+      <xsl:value-of select="@state"/>
+    </xsl:when>
+  </xsl:choose>
+  <xsl:text>&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="error">
+  <xsl:param name="pad"/>
+  <xsl:text>    </xsl:text>
+  <xsl:call-template name="rpad">
+    <xsl:with-param name="str" select="string(@symbol)"/>
+    <xsl:with-param name="pad" select="number($pad) + 2"/>
+  </xsl:call-template>
+  <xsl:text>error</xsl:text>
+  <xsl:text> (</xsl:text>
+  <xsl:value-of select="text()"/>
+  <xsl:text>)</xsl:text>
+  <xsl:text>&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="reduction">
+  <xsl:param name="pad"/>
+  <xsl:text>    </xsl:text>
+  <xsl:call-template name="rpad">
+    <xsl:with-param name="str" select="string(@symbol)"/>
+    <xsl:with-param name="pad" select="number($pad) + 2"/>
+  </xsl:call-template>
+  <xsl:if test="@enabled = 'false'">
+    <xsl:text>[</xsl:text>
+  </xsl:if>
+  <xsl:choose>
+    <xsl:when test="@rule = 'accept'">
+      <xsl:text>accept</xsl:text>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:text>reduce using rule </xsl:text>
+      <xsl:value-of select="@rule"/>
+      <xsl:text> (</xsl:text>
+      <xsl:value-of
+          select="key('bison:ruleByNumber', current()/@rule)/lhs[text()]"/>
+      <xsl:text>)</xsl:text>
+    </xsl:otherwise>
+  </xsl:choose>
+  <xsl:if test="@enabled = 'false'">
+    <xsl:text>]</xsl:text>
+  </xsl:if>
+  <xsl:text>&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="solved-conflicts">
+  <xsl:if test="resolution">
+    <xsl:text>&#10;</xsl:text>
+    <xsl:apply-templates select="resolution"/>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="resolution">
+  <xsl:text>    Conflict between rule </xsl:text>
+  <xsl:value-of select="@rule"/>
+  <xsl:text> and token </xsl:text>
+  <xsl:value-of select="@symbol"/>
+  <xsl:text> resolved as </xsl:text>
+  <xsl:if test="@type = 'error'">
+    <xsl:text>an </xsl:text>
+  </xsl:if>
+  <xsl:value-of select="@type"/>
+  <xsl:text> (</xsl:text>
+  <xsl:value-of select="."/>
+  <xsl:text>).&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template name="max-width-symbol">
+  <xsl:param name="node"/>
+  <xsl:variable name="longest">
+    <xsl:for-each select="$node">
+      <xsl:sort data-type="number" select="string-length(@symbol)"
+                order="descending"/>
+      <xsl:if test="position() = 1">
+        <xsl:value-of select="string-length(@symbol)"/>
+      </xsl:if>
+    </xsl:for-each>
+  </xsl:variable>
+  <xsl:value-of select="$longest"/>
+</xsl:template>
+
+<xsl:template name="lpad">
+  <xsl:param name="str" select="''"/>
+  <xsl:param name="pad" select="0"/>
+  <xsl:variable name="diff" select="$pad - string-length($str)" />
+  <xsl:choose>
+    <xsl:when test="$diff &lt; 0">
+      <xsl:value-of select="$str"/>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:call-template name="space">
+        <xsl:with-param name="repeat" select="$diff"/>
+      </xsl:call-template>
+      <xsl:value-of select="$str"/>
+    </xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+<xsl:template name="rpad">
+  <xsl:param name="str" select="''"/>
+  <xsl:param name="pad" select="0"/>
+  <xsl:variable name="diff" select="$pad - string-length($str)"/>
+  <xsl:choose>
+    <xsl:when test="$diff &lt; 0">
+      <xsl:value-of select="$str"/>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:value-of select="$str"/>
+      <xsl:call-template name="space">
+        <xsl:with-param name="repeat" select="$diff"/>
+      </xsl:call-template>
+    </xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+<xsl:template name="line-wrap">
+  <xsl:param name="line-length"/> <!-- required -->
+  <xsl:param name="first-line-length" select="$line-length"/>
+  <xsl:param name="text"/> <!-- required -->
+  <xsl:choose>
+    <xsl:when test="normalize-space($text) = ''" />
+    <xsl:when test="string-length($text) &lt;= $first-line-length">
+      <xsl:value-of select="concat($text, '&#10;')" />
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:variable name="break-pos">
+        <xsl:call-template name="ws-search">
+          <xsl:with-param name="text" select="$text" />
+          <xsl:with-param name="start" select="$first-line-length+1" />
+        </xsl:call-template>
+      </xsl:variable>
+      <xsl:value-of select="substring($text, 1, $break-pos - 1)" />
+      <xsl:text>&#10;</xsl:text>
+      <xsl:call-template name="line-wrap">
+        <xsl:with-param name="line-length" select="$line-length" />
+        <xsl:with-param
+          name="text" select="concat('    ', substring($text, $break-pos+1))"
+        />
+      </xsl:call-template>
+    </xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+<xsl:template name="ws-search">
+  <xsl:param name="text"/> <!-- required -->
+  <xsl:param name="start"/> <!-- required -->
+  <xsl:variable name="search-text" select="substring($text, $start)" />
+  <xsl:choose>
+    <xsl:when test="not(contains($search-text, ' '))">
+      <xsl:value-of select="string-length($text)+1" />
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:value-of
+        select="$start + string-length(substring-before($search-text, ' '))"
+      />
+    </xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+</xsl:stylesheet>
diff --git a/common/bison/xslt/xml2xhtml.xsl b/common/bison/xslt/xml2xhtml.xsl
new file mode 100644
index 0000000000000000000000000000000000000000..087b0358ccbca848ad7317a43331c800cce31c91
--- /dev/null
+++ b/common/bison/xslt/xml2xhtml.xsl
@@ -0,0 +1,741 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+    xml2html.xsl - transform Bison XML Report into XHTML.
+
+    Copyright (C) 2007-2015, 2018-2019 Free Software Foundation, Inc.
+
+    This file is part of Bison, the GNU Compiler Compiler.
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+    Written by Wojciech Polak <polak@gnu.org>.
+  -->
+
+<xsl:stylesheet version="1.0"
+  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+  xmlns="http://www.w3.org/1999/xhtml"
+  xmlns:bison="http://www.gnu.org/software/bison/">
+
+<xsl:import href="bison.xsl"/>
+
+<xsl:output method="xml" encoding="UTF-8"
+            doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"
+            doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
+            indent="yes"/>
+
+<xsl:template match="/">
+  <html>
+    <head>
+      <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
+      <title>
+        <xsl:value-of select="bison-xml-report/filename"/>
+        <xsl:text> - GNU Bison XML Automaton Report</xsl:text>
+      </title>
+      <style type="text/css"><![CDATA[
+      body {
+        font-family: "Nimbus Sans L", Arial, sans-serif;
+        font-size: 9pt;
+      }
+      a:link {
+        color: #1f00ff;
+        text-decoration: none;
+      }
+      a:visited {
+        color: #1f00ff;
+        text-decoration: none;
+      }
+      a:hover {
+        color: red;
+      }
+      #menu a {
+        text-decoration: underline;
+      }
+      .i {
+        font-style: italic;
+      }
+      .pre {
+        font-family: monospace;
+        white-space: pre;
+      }
+      ol.decimal {
+        list-style-type: decimal;
+      }
+      ol.lower-alpha {
+        list-style-type: lower-alpha;
+      }
+      .point {
+        color: #cc0000;
+      }
+      #footer {
+        margin-top: 3.5em;
+        font-size: 7pt;
+      }
+      ]]></style>
+    </head>
+    <body>
+      <xsl:apply-templates select="bison-xml-report"/>
+      <xsl:text>&#10;&#10;</xsl:text>
+      <div id="footer"><hr />This document was generated using
+      <a href="http://www.gnu.org/software/bison/" title="GNU Bison">
+      GNU Bison <xsl:value-of select="/bison-xml-report/@version"/></a>
+      XML Automaton Report.<br />
+      <!-- default copying notice -->
+      Verbatim copying and distribution of this entire page is
+      permitted in any medium, provided this notice is preserved.</div>
+    </body>
+  </html>
+</xsl:template>
+
+<xsl:template match="bison-xml-report">
+  <h1>GNU Bison XML Automaton Report</h1>
+  <p>
+    input grammar: <span class="i"><xsl:value-of select="filename"/></span>
+  </p>
+
+  <xsl:text>&#10;&#10;</xsl:text>
+  <h3>Table of Contents</h3>
+  <ul id="menu">
+    <li>
+      <a href="#reductions">Reductions</a>
+      <ul class="lower-alpha">
+        <li><a href="#nonterminals_useless_in_grammar">Nonterminals useless in grammar</a></li>
+        <li><a href="#terminals_unused_in_grammar">Terminals unused in grammar</a></li>
+        <li><a href="#rules_useless_in_grammar">Rules useless in grammar</a></li>
+        <xsl:if test="grammar/rules/rule[@usefulness='useless-in-parser']">
+          <li><a href="#rules_useless_in_parser">Rules useless in parser due to conflicts</a></li>
+        </xsl:if>
+      </ul>
+    </li>
+    <li><a href="#conflicts">Conflicts</a></li>
+    <li>
+      <a href="#grammar">Grammar</a>
+      <ul class="lower-alpha">
+        <li><a href="#grammar">Itemset</a></li>
+        <li><a href="#terminals">Terminal symbols</a></li>
+        <li><a href="#nonterminals">Nonterminal symbols</a></li>
+      </ul>
+    </li>
+    <li><a href="#automaton">Automaton</a></li>
+  </ul>
+  <xsl:apply-templates select="grammar" mode="reductions"/>
+  <xsl:apply-templates select="grammar" mode="useless-in-parser"/>
+  <xsl:apply-templates select="automaton" mode="conflicts"/>
+  <xsl:apply-templates select="grammar"/>
+  <xsl:apply-templates select="automaton"/>
+</xsl:template>
+
+<xsl:template match="grammar" mode="reductions">
+  <h2>
+    <a name="reductions"/>
+    <xsl:text> Reductions</xsl:text>
+  </h2>
+  <xsl:apply-templates select="nonterminals" mode="useless-in-grammar"/>
+  <xsl:apply-templates select="terminals" mode="unused-in-grammar"/>
+  <xsl:apply-templates select="rules" mode="useless-in-grammar"/>
+</xsl:template>
+
+<xsl:template match="nonterminals" mode="useless-in-grammar">
+  <h3>
+    <a name="nonterminals_useless_in_grammar"/>
+    <xsl:text> Nonterminals useless in grammar</xsl:text>
+  </h3>
+  <xsl:text>&#10;&#10;</xsl:text>
+  <xsl:if test="nonterminal[@usefulness='useless-in-grammar']">
+    <p class="pre">
+      <xsl:for-each select="nonterminal[@usefulness='useless-in-grammar']">
+        <xsl:text>   </xsl:text>
+        <xsl:value-of select="@name"/>
+        <xsl:text>&#10;</xsl:text>
+      </xsl:for-each>
+      <xsl:text>&#10;&#10;</xsl:text>
+    </p>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="terminals" mode="unused-in-grammar">
+  <h3>
+    <a name="terminals_unused_in_grammar"/>
+    <xsl:text> Terminals unused in grammar</xsl:text>
+  </h3>
+  <xsl:text>&#10;&#10;</xsl:text>
+  <xsl:if test="terminal[@usefulness='unused-in-grammar']">
+    <p class="pre">
+      <xsl:for-each select="terminal[@usefulness='unused-in-grammar']">
+        <xsl:sort select="@symbol-number" data-type="number"/>
+        <xsl:text>   </xsl:text>
+        <xsl:value-of select="@name"/>
+        <xsl:text>&#10;</xsl:text>
+      </xsl:for-each>
+      <xsl:text>&#10;&#10;</xsl:text>
+    </p>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="rules" mode="useless-in-grammar">
+  <h3>
+    <a name="rules_useless_in_grammar"/>
+    <xsl:text> Rules useless in grammar</xsl:text>
+  </h3>
+  <xsl:text>&#10;</xsl:text>
+  <xsl:variable name="set" select="rule[@usefulness='useless-in-grammar']"/>
+  <xsl:if test="$set">
+    <p class="pre">
+      <xsl:call-template name="style-rule-set">
+        <xsl:with-param name="rule-set" select="$set"/>
+      </xsl:call-template>
+      <xsl:text>&#10;&#10;</xsl:text>
+    </p>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="grammar" mode="useless-in-parser">
+  <xsl:variable
+    name="set" select="rules/rule[@usefulness='useless-in-parser']"
+  />
+  <xsl:if test="$set">
+    <h2>
+      <a name="rules_useless_in_parser"/>
+      <xsl:text> Rules useless in parser due to conflicts</xsl:text>
+    </h2>
+    <xsl:text>&#10;</xsl:text>
+    <p class="pre">
+      <xsl:call-template name="style-rule-set">
+        <xsl:with-param name="rule-set" select="$set"/>
+      </xsl:call-template>
+    </p>
+    <xsl:text>&#10;&#10;</xsl:text>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="grammar">
+  <h2>
+    <a name="grammar"/>
+    <xsl:text> Grammar</xsl:text>
+  </h2>
+  <xsl:text>&#10;</xsl:text>
+  <p class="pre">
+    <xsl:call-template name="style-rule-set">
+      <xsl:with-param
+        name="rule-set" select="rules/rule[@usefulness!='useless-in-grammar']"
+      />
+    </xsl:call-template>
+  </p>
+  <xsl:text>&#10;&#10;</xsl:text>
+  <xsl:apply-templates select="terminals"/>
+  <xsl:apply-templates select="nonterminals"/>
+</xsl:template>
+
+<xsl:template name="style-rule-set">
+  <xsl:param name="rule-set"/>
+  <xsl:for-each select="$rule-set">
+    <xsl:apply-templates select=".">
+      <xsl:with-param name="pad" select="'3'"/>
+      <xsl:with-param name="prev-lhs">
+        <xsl:if test="position()>1">
+          <xsl:variable name="position" select="position()"/>
+          <xsl:value-of select="$rule-set[$position - 1]/lhs"/>
+        </xsl:if>
+      </xsl:with-param>
+    </xsl:apply-templates>
+  </xsl:for-each>
+</xsl:template>
+
+<xsl:template match="automaton" mode="conflicts">
+  <h2>
+    <a name="conflicts"/>
+    <xsl:text> Conflicts</xsl:text>
+  </h2>
+  <xsl:text>&#10;&#10;</xsl:text>
+  <xsl:variable name="conflict-report">
+    <xsl:apply-templates select="state" mode="conflicts"/>
+  </xsl:variable>
+  <xsl:if test="string-length($conflict-report) != 0">
+    <p class="pre">
+      <xsl:copy-of select="$conflict-report"/>
+      <xsl:text>&#10;&#10;</xsl:text>
+    </p>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="state" mode="conflicts">
+  <xsl:variable name="conflict-counts">
+    <xsl:apply-templates select="." mode="bison:count-conflicts" />
+  </xsl:variable>
+  <xsl:variable
+    name="sr-count" select="substring-before($conflict-counts, ',')"
+  />
+  <xsl:variable
+    name="rr-count" select="substring-after($conflict-counts, ',')"
+  />
+  <xsl:if test="$sr-count > 0 or $rr-count > 0">
+    <a>
+      <xsl:attribute name="href">
+        <xsl:value-of select="concat('#state_', @number)"/>
+      </xsl:attribute>
+      <xsl:value-of select="concat('State ', @number)"/>
+    </a>
+    <xsl:text> conflicts:</xsl:text>
+    <xsl:if test="$sr-count > 0">
+      <xsl:value-of select="concat(' ', $sr-count, ' shift/reduce')"/>
+      <xsl:if test="$rr-count > 0">
+        <xsl:value-of select="(',')"/>
+      </xsl:if>
+    </xsl:if>
+    <xsl:if test="$rr-count > 0">
+      <xsl:value-of select="concat(' ', $rr-count, ' reduce/reduce')"/>
+    </xsl:if>
+    <xsl:value-of select="'&#10;'"/>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="grammar/terminals">
+  <h3>
+    <a name="terminals"/>
+    <xsl:text> Terminals, with rules where they appear</xsl:text>
+  </h3>
+  <xsl:text>&#10;&#10;</xsl:text>
+  <p class="pre">
+    <xsl:apply-templates select="terminal"/>
+  </p>
+  <xsl:text>&#10;&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="grammar/nonterminals">
+  <h3>
+    <a name="nonterminals"/>
+    <xsl:text> Nonterminals, with rules where they appear</xsl:text>
+  </h3>
+  <xsl:text>&#10;&#10;</xsl:text>
+  <p class="pre">
+    <xsl:apply-templates
+      select="nonterminal[@usefulness!='useless-in-grammar']"
+    />
+  </p>
+</xsl:template>
+
+<xsl:template match="terminal">
+  <b><xsl:value-of select="@name"/></b>
+  <xsl:value-of select="concat(' (', @token-number, ')')"/>
+  <xsl:for-each select="key('bison:ruleByRhs', @name)">
+    <xsl:apply-templates select="." mode="number-link"/>
+  </xsl:for-each>
+  <xsl:text>&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="nonterminal">
+  <b><xsl:value-of select="@name"/></b>
+  <xsl:value-of select="concat(' (', @symbol-number, ')')"/>
+  <xsl:text>&#10;    </xsl:text>
+  <xsl:if test="key('bison:ruleByLhs', @name)">
+    <xsl:text>on left:</xsl:text>
+    <xsl:for-each select="key('bison:ruleByLhs', @name)">
+      <xsl:apply-templates select="." mode="number-link"/>
+    </xsl:for-each>
+  </xsl:if>
+  <xsl:if test="key('bison:ruleByRhs', @name)">
+    <xsl:if test="key('bison:ruleByLhs', @name)">
+      <xsl:text>&#10;    </xsl:text>
+    </xsl:if>
+    <xsl:text>on right:</xsl:text>
+    <xsl:for-each select="key('bison:ruleByRhs', @name)">
+      <xsl:apply-templates select="." mode="number-link"/>
+    </xsl:for-each>
+  </xsl:if>
+  <xsl:text>&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="rule" mode="number-link">
+  <xsl:text> </xsl:text>
+  <a>
+    <xsl:attribute name="href">
+      <xsl:value-of select="concat('#rule_', @number)"/>
+    </xsl:attribute>
+    <xsl:value-of select="@number"/>
+  </a>
+</xsl:template>
+
+<xsl:template match="automaton">
+  <h2>
+    <a name="automaton"/>
+    <xsl:text> Automaton</xsl:text>
+  </h2>
+  <xsl:apply-templates select="state">
+    <xsl:with-param name="pad" select="'3'"/>
+  </xsl:apply-templates>
+</xsl:template>
+
+<xsl:template match="automaton/state">
+  <xsl:param name="pad"/>
+  <xsl:text>&#10;&#10;</xsl:text>
+  <h3>
+    <a>
+      <xsl:attribute name="name">
+        <xsl:value-of select="concat('state_', @number)"/>
+      </xsl:attribute>
+    </a>
+    <xsl:text>state </xsl:text>
+    <xsl:value-of select="@number"/>
+  </h3>
+  <xsl:text>&#10;&#10;</xsl:text>
+  <p class="pre">
+    <xsl:apply-templates select="itemset/item">
+      <xsl:with-param name="pad" select="$pad"/>
+    </xsl:apply-templates>
+    <xsl:apply-templates select="actions/transitions">
+      <xsl:with-param name="type" select="'shift'"/>
+    </xsl:apply-templates>
+    <xsl:apply-templates select="actions/errors"/>
+    <xsl:apply-templates select="actions/reductions"/>
+    <xsl:apply-templates select="actions/transitions">
+      <xsl:with-param name="type" select="'goto'"/>
+    </xsl:apply-templates>
+    <xsl:apply-templates select="solved-conflicts"/>
+  </p>
+</xsl:template>
+
+<xsl:template match="actions/transitions">
+  <xsl:param name="type"/>
+  <xsl:if test="transition[@type = $type]">
+    <xsl:text>&#10;</xsl:text>
+    <xsl:apply-templates select="transition[@type = $type]">
+      <xsl:with-param name="pad">
+        <xsl:call-template name="max-width-symbol">
+          <xsl:with-param name="node" select="transition[@type = $type]"/>
+        </xsl:call-template>
+      </xsl:with-param>
+    </xsl:apply-templates>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="actions/errors">
+  <xsl:if test="error">
+    <xsl:text>&#10;</xsl:text>
+    <xsl:apply-templates select="error">
+      <xsl:with-param name="pad">
+        <xsl:call-template name="max-width-symbol">
+          <xsl:with-param name="node" select="error"/>
+        </xsl:call-template>
+      </xsl:with-param>
+    </xsl:apply-templates>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="actions/reductions">
+  <xsl:if test="reduction">
+    <xsl:text>&#10;</xsl:text>
+    <xsl:apply-templates select="reduction">
+      <xsl:with-param name="pad">
+        <xsl:call-template name="max-width-symbol">
+          <xsl:with-param name="node" select="reduction"/>
+        </xsl:call-template>
+      </xsl:with-param>
+    </xsl:apply-templates>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="item">
+  <xsl:param name="pad"/>
+  <xsl:param name="prev-rule-number"
+             select="preceding-sibling::item[1]/@rule-number"/>
+  <xsl:apply-templates
+    select="key('bison:ruleByNumber', current()/@rule-number)"
+  >
+    <xsl:with-param name="itemset" select="'true'"/>
+    <xsl:with-param name="pad" select="$pad"/>
+    <xsl:with-param name="prev-lhs"
+      select="key('bison:ruleByNumber', $prev-rule-number)/lhs[text()]"
+   />
+    <xsl:with-param name="point" select="@point"/>
+    <xsl:with-param name="lookaheads">
+      <xsl:apply-templates select="lookaheads"/>
+    </xsl:with-param>
+  </xsl:apply-templates>
+</xsl:template>
+
+<xsl:template match="rule">
+  <xsl:param name="itemset"/>
+  <xsl:param name="pad"/>
+  <xsl:param name="prev-lhs"/>
+  <xsl:param name="point"/>
+  <xsl:param name="lookaheads"/>
+
+  <xsl:if test="$itemset != 'true' and not($prev-lhs = lhs[text()])">
+    <xsl:text>&#10;</xsl:text>
+  </xsl:if>
+
+  <xsl:if test="$itemset != 'true'">
+    <a>
+      <xsl:attribute name="name">
+        <xsl:value-of select="concat('rule_', @number)"/>
+      </xsl:attribute>
+    </a>
+  </xsl:if>
+  <xsl:text>  </xsl:text>
+
+  <xsl:choose>
+    <xsl:when test="$itemset = 'true'">
+      <a>
+        <xsl:attribute name="href">
+          <xsl:value-of select="concat('#rule_', @number)"/>
+        </xsl:attribute>
+        <xsl:call-template name="lpad">
+          <xsl:with-param name="str" select="string(@number)"/>
+          <xsl:with-param name="pad" select="number($pad)"/>
+        </xsl:call-template>
+      </a>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:call-template name="lpad">
+        <xsl:with-param name="str" select="string(@number)"/>
+        <xsl:with-param name="pad" select="number($pad)"/>
+      </xsl:call-template>
+    </xsl:otherwise>
+  </xsl:choose>
+  <xsl:text> </xsl:text>
+
+  <!-- LHS -->
+  <xsl:choose>
+    <xsl:when test="$itemset != 'true' and $prev-lhs = lhs[text()]">
+      <xsl:call-template name="lpad">
+        <xsl:with-param name="str" select="'|'"/>
+        <xsl:with-param name="pad" select="number(string-length(lhs[text()])) + 2"/>
+      </xsl:call-template>
+    </xsl:when>
+    <xsl:when test="$itemset = 'true' and $prev-lhs = lhs[text()]">
+      <xsl:call-template name="lpad">
+        <xsl:with-param name="str" select="'|'"/>
+        <xsl:with-param name="pad" select="number(string-length(lhs[text()])) + 2"/>
+      </xsl:call-template>
+    </xsl:when>
+    <xsl:otherwise>
+      <span class="i">
+        <xsl:value-of select="lhs"/>
+      </span>
+      <xsl:text> &#8594;</xsl:text>
+    </xsl:otherwise>
+  </xsl:choose>
+
+  <!-- RHS -->
+  <xsl:for-each select="rhs/*">
+    <xsl:if test="position() = $point + 1">
+      <xsl:text> </xsl:text>
+      <span class="point">.</span>
+    </xsl:if>
+    <xsl:apply-templates select="."/>
+    <xsl:if test="position() = last() and position() = $point">
+      <xsl:text> </xsl:text>
+      <span class="point">.</span>
+    </xsl:if>
+  </xsl:for-each>
+  <xsl:if test="$lookaheads">
+    <xsl:value-of select="$lookaheads"/>
+  </xsl:if>
+
+  <xsl:text>&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="symbol">
+  <xsl:text> </xsl:text>
+  <xsl:choose>
+    <xsl:when test="name(key('bison:symbolByName', .)) = 'nonterminal'">
+      <span class="i"><xsl:value-of select="."/></span>
+    </xsl:when>
+    <xsl:otherwise>
+      <b><xsl:value-of select="."/></b>
+    </xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+<xsl:template match="empty">
+  <xsl:text> %empty</xsl:text>
+</xsl:template>
+
+<xsl:template match="lookaheads">
+  <xsl:text>  [</xsl:text>
+  <xsl:apply-templates select="symbol"/>
+  <xsl:text>]</xsl:text>
+</xsl:template>
+
+<xsl:template match="lookaheads/symbol">
+  <xsl:value-of select="."/>
+  <xsl:if test="position() != last()">
+    <xsl:text>, </xsl:text>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="transition">
+  <xsl:param name="pad"/>
+  <xsl:text>    </xsl:text>
+  <xsl:call-template name="rpad">
+    <xsl:with-param name="str" select="string(@symbol)"/>
+    <xsl:with-param name="pad" select="number($pad) + 2"/>
+  </xsl:call-template>
+  <xsl:choose>
+    <xsl:when test="@type = 'shift'">
+      <a>
+        <xsl:attribute name="href">
+          <xsl:value-of select="concat('#state_', @state)"/>
+        </xsl:attribute>
+        <xsl:value-of select="concat('shift, and go to state ', @state)"/>
+      </a>
+    </xsl:when>
+    <xsl:when test="@type = 'goto'">
+      <a>
+        <xsl:attribute name="href">
+          <xsl:value-of select="concat('#state_', @state)"/>
+        </xsl:attribute>
+        <xsl:value-of select="concat('go to state ', @state)"/>
+      </a>
+    </xsl:when>
+  </xsl:choose>
+  <xsl:text>&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="error">
+  <xsl:param name="pad"/>
+  <xsl:text>    </xsl:text>
+  <xsl:call-template name="rpad">
+    <xsl:with-param name="str" select="string(@symbol)"/>
+    <xsl:with-param name="pad" select="number($pad) + 2"/>
+  </xsl:call-template>
+  <xsl:text>error</xsl:text>
+  <xsl:text> (</xsl:text>
+  <xsl:value-of select="text()"/>
+  <xsl:text>)</xsl:text>
+  <xsl:text>&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="reduction">
+  <xsl:param name="pad"/>
+  <xsl:text>    </xsl:text>
+  <xsl:call-template name="rpad">
+    <xsl:with-param name="str" select="string(@symbol)"/>
+    <xsl:with-param name="pad" select="number($pad) + 2"/>
+  </xsl:call-template>
+  <xsl:if test="@enabled = 'false'">
+    <xsl:text>[</xsl:text>
+  </xsl:if>
+  <xsl:choose>
+    <xsl:when test="@rule = 'accept'">
+      <xsl:text>accept</xsl:text>
+    </xsl:when>
+    <xsl:otherwise>
+      <a>
+        <xsl:attribute name="href">
+          <xsl:value-of select="concat('#rule_', @rule)"/>
+        </xsl:attribute>
+        <xsl:value-of select="concat('reduce using rule ', @rule)"/>
+      </a>
+      <xsl:text> (</xsl:text>
+      <xsl:value-of
+        select="key('bison:ruleByNumber', current()/@rule)/lhs[text()]"
+      />
+      <xsl:text>)</xsl:text>
+    </xsl:otherwise>
+  </xsl:choose>
+  <xsl:if test="@enabled = 'false'">
+    <xsl:text>]</xsl:text>
+  </xsl:if>
+  <xsl:text>&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template match="solved-conflicts">
+  <xsl:if test="resolution">
+    <xsl:text>&#10;</xsl:text>
+    <xsl:apply-templates select="resolution"/>
+  </xsl:if>
+</xsl:template>
+
+<xsl:template match="resolution">
+  <xsl:text>    Conflict between </xsl:text>
+  <a>
+    <xsl:attribute name="href">
+      <xsl:value-of select="concat('#rule_', @rule)"/>
+    </xsl:attribute>
+    <xsl:value-of select="concat('rule ',@rule)"/>
+  </a>
+  <xsl:text> and token </xsl:text>
+  <xsl:value-of select="@symbol"/>
+  <xsl:text> resolved as </xsl:text>
+  <xsl:if test="@type = 'error'">
+    <xsl:text>an </xsl:text>
+  </xsl:if>
+  <xsl:value-of select="@type"/>
+  <xsl:text> (</xsl:text>
+  <xsl:value-of select="."/>
+  <xsl:text>).&#10;</xsl:text>
+</xsl:template>
+
+<xsl:template name="max-width-symbol">
+  <xsl:param name="node"/>
+  <xsl:variable name="longest">
+    <xsl:for-each select="$node">
+      <xsl:sort data-type="number" select="string-length(@symbol)"
+                order="descending"/>
+      <xsl:if test="position() = 1">
+        <xsl:value-of select="string-length(@symbol)"/>
+      </xsl:if>
+    </xsl:for-each>
+  </xsl:variable>
+  <xsl:value-of select="$longest"/>
+</xsl:template>
+
+<xsl:template name="lpad">
+  <xsl:param name="str" select="''"/>
+  <xsl:param name="pad" select="0"/>
+  <xsl:variable name="diff" select="$pad - string-length($str)" />
+  <xsl:choose>
+    <xsl:when test="$diff &lt; 0">
+      <xsl:value-of select="$str"/>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:call-template name="space">
+        <xsl:with-param name="repeat" select="$diff"/>
+      </xsl:call-template>
+      <xsl:value-of select="$str"/>
+    </xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+<xsl:template name="rpad">
+  <xsl:param name="str" select="''"/>
+  <xsl:param name="pad" select="0"/>
+  <xsl:variable name="diff" select="$pad - string-length($str)"/>
+  <xsl:choose>
+    <xsl:when test="$diff &lt; 0">
+      <xsl:value-of select="$str"/>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:value-of select="$str"/>
+      <xsl:call-template name="space">
+        <xsl:with-param name="repeat" select="$diff"/>
+      </xsl:call-template>
+    </xsl:otherwise>
+  </xsl:choose>
+</xsl:template>
+
+<xsl:template name="space">
+  <xsl:param name="repeat">0</xsl:param>
+  <xsl:param name="fill" select="' '"/>
+  <xsl:if test="number($repeat) &gt;= 1">
+    <xsl:call-template name="space">
+      <xsl:with-param name="repeat" select="$repeat - 1"/>
+      <xsl:with-param name="fill" select="$fill"/>
+    </xsl:call-template>
+    <xsl:value-of select="$fill"/>
+  </xsl:if>
+</xsl:template>
+
+</xsl:stylesheet>
diff --git a/common/flex/FlexLexer.h b/common/flex/FlexLexer.h
new file mode 100644
index 0000000000000000000000000000000000000000..c4dad2b1421d45824c13fc1e9fc01525b0ad8cd6
--- /dev/null
+++ b/common/flex/FlexLexer.h
@@ -0,0 +1,220 @@
+// -*-C++-*-
+// FlexLexer.h -- define interfaces for lexical analyzer classes generated
+// by flex
+
+// Copyright (c) 1993 The Regents of the University of California.
+// All rights reserved.
+//
+// This code is derived from software contributed to Berkeley by
+// Kent Williams and Tom Epperly.
+//
+//  Redistribution and use in source and binary forms, with or without
+//  modification, are permitted provided that the following conditions
+//  are met:
+
+//  1. Redistributions of source code must retain the above copyright
+//  notice, this list of conditions and the following disclaimer.
+//  2. Redistributions in binary form must reproduce the above copyright
+//  notice, this list of conditions and the following disclaimer in the
+//  documentation and/or other materials provided with the distribution.
+
+//  Neither the name of the University nor the names of its contributors
+//  may be used to endorse or promote products derived from this software
+//  without specific prior written permission.
+
+//  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+//  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+//  PURPOSE.
+
+// This file defines FlexLexer, an abstract class which specifies the
+// external interface provided to flex C++ lexer objects, and yyFlexLexer,
+// which defines a particular lexer class.
+//
+// If you want to create multiple lexer classes, you use the -P flag
+// to rename each yyFlexLexer to some other xxFlexLexer.  You then
+// include <FlexLexer.h> in your other sources once per lexer class:
+//
+//      #undef yyFlexLexer
+//      #define yyFlexLexer xxFlexLexer
+//      #include <FlexLexer.h>
+//
+//      #undef yyFlexLexer
+//      #define yyFlexLexer zzFlexLexer
+//      #include <FlexLexer.h>
+//      ...
+
+#ifndef __FLEX_LEXER_H
+// Never included before - need to define base class.
+#define __FLEX_LEXER_H
+
+#include <iostream>
+
+extern "C++" {
+
+struct yy_buffer_state;
+typedef int yy_state_type;
+
+class FlexLexer
+{
+public:
+  virtual ~FlexLexer()        { }
+
+  const char* YYText() const  { return yytext; }
+  int YYLeng()        const   { return yyleng; }
+
+  virtual void
+  yy_switch_to_buffer( yy_buffer_state* new_buffer ) = 0;
+  virtual yy_buffer_state* yy_create_buffer( std::istream* s, int size ) = 0;
+  virtual yy_buffer_state* yy_create_buffer( std::istream& s, int size ) = 0;
+  virtual void yy_delete_buffer( yy_buffer_state* b ) = 0;
+  virtual void yyrestart( std::istream* s ) = 0;
+  virtual void yyrestart( std::istream& s ) = 0;
+
+  virtual int yylex() = 0;
+
+  // Call yylex with new input/output sources.
+  int yylex( std::istream& new_in, std::ostream& new_out )
+  {
+    switch_streams( new_in, new_out );
+    return yylex();
+  }
+
+  int yylex( std::istream* new_in, std::ostream* new_out = 0)
+  {
+    switch_streams( new_in, new_out );
+    return yylex();
+  }
+
+  // Switch to new input/output streams.  A nil stream pointer
+  // indicates "keep the current one".
+  virtual void switch_streams( std::istream* new_in,
+                               std::ostream* new_out ) = 0;
+  virtual void switch_streams( std::istream& new_in,
+                               std::ostream& new_out ) = 0;
+
+  int lineno() const          { return yylineno; }
+
+  int debug() const           { return yy_flex_debug; }
+  void set_debug( int flag )  { yy_flex_debug = flag; }
+
+protected:
+  char* yytext;
+  int yyleng;
+  int yylineno;       // only maintained if you use %option yylineno
+  int yy_flex_debug;  // only has effect with -d or "%option debug"
+};
+
+}
+#endif // FLEXLEXER_H
+
+#if defined(yyFlexLexer) || ! defined(yyFlexLexerOnce)
+// Either this is the first time through (yyFlexLexerOnce not defined),
+// or this is a repeated include to define a different flavor of
+// yyFlexLexer, as discussed in the flex manual.
+# define yyFlexLexerOnce
+
+extern "C++" {
+
+class yyFlexLexer : public FlexLexer {
+public:
+  // arg_yyin and arg_yyout default to the cin and cout, but we
+  // only make that assignment when initializing in yylex().
+  yyFlexLexer( std::istream& arg_yyin, std::ostream& arg_yyout );
+  yyFlexLexer( std::istream* arg_yyin = 0, std::ostream* arg_yyout = 0 );
+private:
+  void ctor_common();
+
+public:
+
+  virtual ~yyFlexLexer();
+
+  void yy_switch_to_buffer( yy_buffer_state* new_buffer );
+  yy_buffer_state* yy_create_buffer( std::istream* s, int size );
+  yy_buffer_state* yy_create_buffer( std::istream& s, int size );
+  void yy_delete_buffer( yy_buffer_state* b );
+  void yyrestart( std::istream* s );
+  void yyrestart( std::istream& s );
+
+  void yypush_buffer_state( yy_buffer_state* new_buffer );
+  void yypop_buffer_state();
+
+  virtual int yylex();
+  virtual void switch_streams( std::istream& new_in, std::ostream& new_out );
+  virtual void switch_streams( std::istream* new_in = 0, std::ostream* new_out = 0 );
+  virtual int yywrap();
+
+protected:
+  virtual int LexerInput( char* buf, int max_size );
+  virtual void LexerOutput( const char* buf, int size );
+  virtual void LexerError( const char* msg );
+
+  void yyunput( int c, char* buf_ptr );
+  int yyinput();
+
+  void yy_load_buffer_state();
+  void yy_init_buffer( yy_buffer_state* b, std::istream& s );
+  void yy_flush_buffer( yy_buffer_state* b );
+
+  int yy_start_stack_ptr;
+  int yy_start_stack_depth;
+  int* yy_start_stack;
+
+  void yy_push_state( int new_state );
+  void yy_pop_state();
+  int yy_top_state();
+
+  yy_state_type yy_get_previous_state();
+  yy_state_type yy_try_NUL_trans( yy_state_type current_state );
+  int yy_get_next_buffer();
+
+  std::istream yyin;  // input source for default LexerInput
+  std::ostream yyout; // output sink for default LexerOutput
+
+  // yy_hold_char holds the character lost when yytext is formed.
+  char yy_hold_char;
+
+  // Number of characters read into yy_ch_buf.
+  int yy_n_chars;
+
+  // Points to current character in buffer.
+  char* yy_c_buf_p;
+
+  int yy_init;                // whether we need to initialize
+  int yy_start;               // start state number
+
+  // Flag which is used to allow yywrap()'s to do buffer switches
+  // instead of setting up a fresh yyin.  A bit of a hack ...
+  int yy_did_buffer_switch_on_eof;
+
+
+  size_t yy_buffer_stack_top; /**< index of top of stack. */
+  size_t yy_buffer_stack_max; /**< capacity of stack. */
+  yy_buffer_state ** yy_buffer_stack; /**< Stack as an array. */
+  void yyensure_buffer_stack(void);
+
+  // The following are not always needed, but may be depending
+  // on use of certain flex features (like REJECT or yymore()).
+
+  yy_state_type yy_last_accepting_state;
+  char* yy_last_accepting_cpos;
+
+  yy_state_type* yy_state_buf;
+  yy_state_type* yy_state_ptr;
+
+  char* yy_full_match;
+  int* yy_full_state;
+  int yy_full_lp;
+
+  int yy_lp;
+  int yy_looking_for_trail_begin;
+
+  int yy_more_flag;
+  int yy_more_len;
+  int yy_more_offset;
+  int yy_prev_more_offset;
+};
+
+}
+
+#endif // yyFlexLexer || ! yyFlexLexerOnce
diff --git a/common/flex/NOTICE b/common/flex/NOTICE
new file mode 100644
index 0000000000000000000000000000000000000000..684b011026dd719137ef01764f002c2c27a2bb52
--- /dev/null
+++ b/common/flex/NOTICE
@@ -0,0 +1,42 @@
+Flex carries the copyright used for BSD software, slightly modified
+because it originated at the Lawrence Berkeley (not Livermore!) Laboratory,
+which operates under a contract with the Department of Energy:
+
+Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007 The Flex Project.
+
+Copyright (c) 1990, 1997 The Regents of the University of California.
+All rights reserved.
+
+This code is derived from software contributed to Berkeley by
+Vern Paxson.
+
+The United States Government has rights in this work pursuant
+to contract no. DE-AC03-76SF00098 between the United States
+Department of Energy and the University of California.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+
+Neither the name of the University nor the names of its contributors
+may be used to endorse or promote products derived from this software
+without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.
+
+This basically says "do whatever you please with this software except
+remove this notice or take advantage of the University's (or the flex
+authors') name".
+
+Note that the "flex.skl" scanner skeleton carries no copyright notice.
+You are free to do whatever you please with scanners generated using flex;
+for them, you are not even bound by the above copyright.
diff --git a/common/framework/desugar.jar b/common/framework/desugar.jar
new file mode 100644
index 0000000000000000000000000000000000000000..42402f484b0f0705449c9c3afe77b7ced2e8679f
Binary files /dev/null and b/common/framework/desugar.jar differ
diff --git a/common/framework/dx.jar b/common/framework/dx.jar
new file mode 100644
index 0000000000000000000000000000000000000000..ef90a14d8f2a6deda26da6ca50682e3384e74dfe
Binary files /dev/null and b/common/framework/dx.jar differ
diff --git a/common/framework/javac_extractor.jar b/common/framework/javac_extractor.jar
new file mode 100644
index 0000000000000000000000000000000000000000..181fbf4b0b3cc1a398621907e553a9d7bea7715b
Binary files /dev/null and b/common/framework/javac_extractor.jar differ
diff --git a/common/framework/turbine.jar b/common/framework/turbine.jar
new file mode 100644
index 0000000000000000000000000000000000000000..632fbd34a6036a40f15da159ffebb8f38a7945de
Binary files /dev/null and b/common/framework/turbine.jar differ
diff --git a/darwin-x86/bin/acp b/darwin-x86/bin/acp
new file mode 100755
index 0000000000000000000000000000000000000000..8caf4f1ea340b9e84c7c95523239200a551fc350
Binary files /dev/null and b/darwin-x86/bin/acp differ
diff --git a/darwin-x86/bin/aidl b/darwin-x86/bin/aidl
new file mode 100755
index 0000000000000000000000000000000000000000..2f909085618c16d91bf9ab85ea1cfa84578b66e2
Binary files /dev/null and b/darwin-x86/bin/aidl differ
diff --git a/darwin-x86/bin/bison b/darwin-x86/bin/bison
new file mode 100755
index 0000000000000000000000000000000000000000..a9d6ef3c1f00ccd47afa05028b4b9afede961ddd
Binary files /dev/null and b/darwin-x86/bin/bison differ
diff --git a/darwin-x86/bin/bpfmt b/darwin-x86/bin/bpfmt
new file mode 100755
index 0000000000000000000000000000000000000000..54b3b2f36f23c2a1cda1888354c03e5097b12b05
Binary files /dev/null and b/darwin-x86/bin/bpfmt differ
diff --git a/darwin-x86/bin/bzip2 b/darwin-x86/bin/bzip2
new file mode 100755
index 0000000000000000000000000000000000000000..7e42bdd778789e50159f0192549c12cc373fa164
Binary files /dev/null and b/darwin-x86/bin/bzip2 differ
diff --git a/darwin-x86/bin/ckati b/darwin-x86/bin/ckati
new file mode 100755
index 0000000000000000000000000000000000000000..5b52146e1ebc320862aaea71b30a10e0a2e745ae
Binary files /dev/null and b/darwin-x86/bin/ckati differ
diff --git a/darwin-x86/bin/ckati_stamp_dump b/darwin-x86/bin/ckati_stamp_dump
new file mode 100755
index 0000000000000000000000000000000000000000..f05d63141f1a7becd15f67d6f57e7b942074c3b1
Binary files /dev/null and b/darwin-x86/bin/ckati_stamp_dump differ
diff --git a/darwin-x86/bin/flex b/darwin-x86/bin/flex
new file mode 100755
index 0000000000000000000000000000000000000000..4244c68e6ef52eb57910a992b4366747b9032510
Binary files /dev/null and b/darwin-x86/bin/flex differ
diff --git a/darwin-x86/bin/gavinhoward-bc b/darwin-x86/bin/gavinhoward-bc
new file mode 100755
index 0000000000000000000000000000000000000000..8689edd97b1a368bf1c601410303acbc3dbc1cf2
Binary files /dev/null and b/darwin-x86/bin/gavinhoward-bc differ
diff --git a/darwin-x86/bin/go_extractor b/darwin-x86/bin/go_extractor
new file mode 100755
index 0000000000000000000000000000000000000000..26ef86d83f9a5105579648636c128ce0bcbf0675
Binary files /dev/null and b/darwin-x86/bin/go_extractor differ
diff --git a/darwin-x86/bin/hidl-lint b/darwin-x86/bin/hidl-lint
new file mode 100755
index 0000000000000000000000000000000000000000..eb8f2a5a90d4fda7946c4fee260356738a88c38d
Binary files /dev/null and b/darwin-x86/bin/hidl-lint differ
diff --git a/darwin-x86/bin/m4 b/darwin-x86/bin/m4
new file mode 100755
index 0000000000000000000000000000000000000000..4cc8dd23f4a784f13af08d982ce2b38333184c8a
Binary files /dev/null and b/darwin-x86/bin/m4 differ
diff --git a/darwin-x86/bin/make b/darwin-x86/bin/make
new file mode 100755
index 0000000000000000000000000000000000000000..d451a866e392ffc8a802d1ef1ce71cdf3bc4f117
Binary files /dev/null and b/darwin-x86/bin/make differ
diff --git a/darwin-x86/bin/ninja b/darwin-x86/bin/ninja
new file mode 100755
index 0000000000000000000000000000000000000000..06f8030ff596b6addc11938729e65b1dde6f487b
Binary files /dev/null and b/darwin-x86/bin/ninja differ
diff --git a/darwin-x86/bin/one-true-awk b/darwin-x86/bin/one-true-awk
new file mode 100755
index 0000000000000000000000000000000000000000..b73576d6955d092d79c7b3b6cecc666f8c90caac
Binary files /dev/null and b/darwin-x86/bin/one-true-awk differ
diff --git a/darwin-x86/bin/py2-cmd b/darwin-x86/bin/py2-cmd
new file mode 100755
index 0000000000000000000000000000000000000000..90e3941c0788070a3b144d1d249b3d8c083d01b4
Binary files /dev/null and b/darwin-x86/bin/py2-cmd differ
diff --git a/darwin-x86/bin/py3-cmd b/darwin-x86/bin/py3-cmd
new file mode 100755
index 0000000000000000000000000000000000000000..1fa01d3a10b2fda75b70cdf4860a851d84a650cf
Binary files /dev/null and b/darwin-x86/bin/py3-cmd differ
diff --git a/darwin-x86/bin/soong_zip b/darwin-x86/bin/soong_zip
new file mode 100755
index 0000000000000000000000000000000000000000..4b67116de5a3f75ddc18b4cf38c3a0c6e9c98b1e
Binary files /dev/null and b/darwin-x86/bin/soong_zip differ
diff --git a/darwin-x86/bin/toybox b/darwin-x86/bin/toybox
new file mode 100755
index 0000000000000000000000000000000000000000..1f583f37980ec9ea9d58d6ca44731031f51fecf4
Binary files /dev/null and b/darwin-x86/bin/toybox differ
diff --git a/darwin-x86/bin/xz b/darwin-x86/bin/xz
new file mode 100755
index 0000000000000000000000000000000000000000..213a77147648fa6cd082826323b5fe2c9d9e98c1
Binary files /dev/null and b/darwin-x86/bin/xz differ
diff --git a/darwin-x86/bin/zip2zip b/darwin-x86/bin/zip2zip
new file mode 100755
index 0000000000000000000000000000000000000000..92dd68b07e81b4794caaa4a82be80404f30b133f
Binary files /dev/null and b/darwin-x86/bin/zip2zip differ
diff --git a/darwin-x86/bin/zipalign b/darwin-x86/bin/zipalign
new file mode 100755
index 0000000000000000000000000000000000000000..dd116bad5ed4a624f338fb4f4e6977ce1f389c90
Binary files /dev/null and b/darwin-x86/bin/zipalign differ
diff --git a/darwin-x86/bin/ziptime b/darwin-x86/bin/ziptime
new file mode 100755
index 0000000000000000000000000000000000000000..727012e534249ade97e9f458e73d0f61317a8542
Binary files /dev/null and b/darwin-x86/bin/ziptime differ
diff --git a/darwin-x86/bin/ziptool b/darwin-x86/bin/ziptool
new file mode 100755
index 0000000000000000000000000000000000000000..60493a24b4bf29ace95a3a6402ff10a0003fa800
Binary files /dev/null and b/darwin-x86/bin/ziptool differ
diff --git a/darwin-x86/lib64/libbase.dylib b/darwin-x86/lib64/libbase.dylib
new file mode 100755
index 0000000000000000000000000000000000000000..ce4291d72f6f9e0328fdfa68ef9b4bcdb0a519d6
Binary files /dev/null and b/darwin-x86/lib64/libbase.dylib differ
diff --git a/darwin-x86/lib64/libc++.dylib b/darwin-x86/lib64/libc++.dylib
new file mode 100755
index 0000000000000000000000000000000000000000..aa5edcd323d8a3f4ca5e3fc5e10448dd583ca62d
Binary files /dev/null and b/darwin-x86/lib64/libc++.dylib differ
diff --git a/darwin-x86/lib64/libcrypto-host.dylib b/darwin-x86/lib64/libcrypto-host.dylib
new file mode 100755
index 0000000000000000000000000000000000000000..39962f753aef8c1e1c26ba5845232f45ec299333
Binary files /dev/null and b/darwin-x86/lib64/libcrypto-host.dylib differ
diff --git a/darwin-x86/lib64/libcutils.dylib b/darwin-x86/lib64/libcutils.dylib
new file mode 100755
index 0000000000000000000000000000000000000000..865df61d4525d2502919eae285253c9bb7c47585
Binary files /dev/null and b/darwin-x86/lib64/libcutils.dylib differ
diff --git a/darwin-x86/lib64/libjsoncpp.dylib b/darwin-x86/lib64/libjsoncpp.dylib
new file mode 100755
index 0000000000000000000000000000000000000000..f09af653c1eeeb15bb43a10ffe94e987f9ad2b7b
Binary files /dev/null and b/darwin-x86/lib64/libjsoncpp.dylib differ
diff --git a/darwin-x86/lib64/liblog.dylib b/darwin-x86/lib64/liblog.dylib
new file mode 100755
index 0000000000000000000000000000000000000000..1a717d89559f999a02c251389640bb561e84ad65
Binary files /dev/null and b/darwin-x86/lib64/liblog.dylib differ
diff --git a/darwin-x86/lib64/libssl-host.dylib b/darwin-x86/lib64/libssl-host.dylib
new file mode 100755
index 0000000000000000000000000000000000000000..ea58d59779d92f6d4ee968404ad99b986852721b
Binary files /dev/null and b/darwin-x86/lib64/libssl-host.dylib differ
diff --git a/darwin-x86/lib64/libz-host.dylib b/darwin-x86/lib64/libz-host.dylib
new file mode 100755
index 0000000000000000000000000000000000000000..114c143ad43a2a70d3b41bb306dab5221e330723
Binary files /dev/null and b/darwin-x86/lib64/libz-host.dylib differ
diff --git a/darwin-x86/lib64/libziparchive.dylib b/darwin-x86/lib64/libziparchive.dylib
new file mode 100755
index 0000000000000000000000000000000000000000..ec7661186c854d9271148d1ad7d0c90da86322ff
Binary files /dev/null and b/darwin-x86/lib64/libziparchive.dylib differ
diff --git a/linux-x86/asan/bin/acp b/linux-x86/asan/bin/acp
new file mode 100755
index 0000000000000000000000000000000000000000..fabfd69a20134912d7c525562959d9940b22325e
Binary files /dev/null and b/linux-x86/asan/bin/acp differ
diff --git a/linux-x86/asan/bin/aidl b/linux-x86/asan/bin/aidl
new file mode 100755
index 0000000000000000000000000000000000000000..13390bde6f69e6ba9d4fcce63f805641d633388b
Binary files /dev/null and b/linux-x86/asan/bin/aidl differ
diff --git a/linux-x86/asan/bin/ckati b/linux-x86/asan/bin/ckati
new file mode 100755
index 0000000000000000000000000000000000000000..f4e5174b88696c463addbfe4840f144ffd45f1fb
Binary files /dev/null and b/linux-x86/asan/bin/ckati differ
diff --git a/linux-x86/asan/bin/gavinhoward-bc b/linux-x86/asan/bin/gavinhoward-bc
new file mode 100755
index 0000000000000000000000000000000000000000..2a44fab1361c2fc635e3075e8dae3ba168cef3de
Binary files /dev/null and b/linux-x86/asan/bin/gavinhoward-bc differ
diff --git a/linux-x86/asan/bin/ninja b/linux-x86/asan/bin/ninja
new file mode 100755
index 0000000000000000000000000000000000000000..91ef03818efaa6565b0ce16d0e54fa5bffc97458
Binary files /dev/null and b/linux-x86/asan/bin/ninja differ
diff --git a/linux-x86/asan/bin/toybox b/linux-x86/asan/bin/toybox
new file mode 100755
index 0000000000000000000000000000000000000000..d445585365f90e2e18b07f5a5679131c1c1678b4
Binary files /dev/null and b/linux-x86/asan/bin/toybox differ
diff --git a/linux-x86/asan/bin/zipalign b/linux-x86/asan/bin/zipalign
new file mode 100755
index 0000000000000000000000000000000000000000..41ac1f1395804d68d427eee54a4e2f8bc3f6f9e3
Binary files /dev/null and b/linux-x86/asan/bin/zipalign differ
diff --git a/linux-x86/asan/bin/ziptime b/linux-x86/asan/bin/ziptime
new file mode 100755
index 0000000000000000000000000000000000000000..b4af6f3f705d52f1ff10565cbebebb47608098de
Binary files /dev/null and b/linux-x86/asan/bin/ziptime differ
diff --git a/linux-x86/asan/bin/ziptool b/linux-x86/asan/bin/ziptool
new file mode 100755
index 0000000000000000000000000000000000000000..5d196714b133266ce389ec3510516fc90b8398aa
Binary files /dev/null and b/linux-x86/asan/bin/ziptool differ
diff --git a/linux-x86/asan/lib64/libbase.so b/linux-x86/asan/lib64/libbase.so
new file mode 100755
index 0000000000000000000000000000000000000000..229428e4d65dde81274b1e76175995443a16f70d
Binary files /dev/null and b/linux-x86/asan/lib64/libbase.so differ
diff --git a/linux-x86/asan/lib64/libc++.so b/linux-x86/asan/lib64/libc++.so
new file mode 100755
index 0000000000000000000000000000000000000000..7a1048e7af98748fcd29e6e84ac88451d6f5de2c
Binary files /dev/null and b/linux-x86/asan/lib64/libc++.so differ
diff --git a/linux-x86/asan/lib64/libcrypto-host.so b/linux-x86/asan/lib64/libcrypto-host.so
new file mode 100755
index 0000000000000000000000000000000000000000..55859386d32cf132a6d07b79a1a74f9432176395
Binary files /dev/null and b/linux-x86/asan/lib64/libcrypto-host.so differ
diff --git a/linux-x86/asan/lib64/libcutils.so b/linux-x86/asan/lib64/libcutils.so
new file mode 100755
index 0000000000000000000000000000000000000000..e532e5477220d38e256ed22d97f762f656110ed0
Binary files /dev/null and b/linux-x86/asan/lib64/libcutils.so differ
diff --git a/linux-x86/asan/lib64/libjemalloc.so b/linux-x86/asan/lib64/libjemalloc.so
new file mode 100755
index 0000000000000000000000000000000000000000..a593709a0af379e1e02a91a1826a10c1d528540a
Binary files /dev/null and b/linux-x86/asan/lib64/libjemalloc.so differ
diff --git a/linux-x86/asan/lib64/liblog.so b/linux-x86/asan/lib64/liblog.so
new file mode 100755
index 0000000000000000000000000000000000000000..f6ca221af90ec1f83e5871074009f99fd636573b
Binary files /dev/null and b/linux-x86/asan/lib64/liblog.so differ
diff --git a/linux-x86/asan/lib64/libz-host.so b/linux-x86/asan/lib64/libz-host.so
new file mode 100755
index 0000000000000000000000000000000000000000..37dc84bee4ce06e86cc847ca32e1a8d58b72734e
Binary files /dev/null and b/linux-x86/asan/lib64/libz-host.so differ
diff --git a/linux-x86/asan/lib64/libziparchive.so b/linux-x86/asan/lib64/libziparchive.so
new file mode 100755
index 0000000000000000000000000000000000000000..faf958c0d73e32c54d28f7bb6e6f6a03ab114dd2
Binary files /dev/null and b/linux-x86/asan/lib64/libziparchive.so differ
diff --git a/linux-x86/bin/acp b/linux-x86/bin/acp
new file mode 100755
index 0000000000000000000000000000000000000000..2c1a7d9d14edd4a99937b4882c2a5a619a766b59
Binary files /dev/null and b/linux-x86/bin/acp differ
diff --git a/linux-x86/bin/aidl b/linux-x86/bin/aidl
new file mode 100755
index 0000000000000000000000000000000000000000..56bd375517a8d9119029f9c8364fb326d2bd2199
Binary files /dev/null and b/linux-x86/bin/aidl differ
diff --git a/linux-x86/bin/bison b/linux-x86/bin/bison
new file mode 100755
index 0000000000000000000000000000000000000000..5931a7b9b1c9740ca0debaf19b495e209682b646
Binary files /dev/null and b/linux-x86/bin/bison differ
diff --git a/linux-x86/bin/bpfmt b/linux-x86/bin/bpfmt
new file mode 100755
index 0000000000000000000000000000000000000000..71f6ae07a9a266d9b16ae00c3f13d3b0dadbc12c
Binary files /dev/null and b/linux-x86/bin/bpfmt differ
diff --git a/linux-x86/bin/bzip2 b/linux-x86/bin/bzip2
new file mode 100755
index 0000000000000000000000000000000000000000..8d3c9e1b81c76c7e7cb209f85d816516f4c08a94
Binary files /dev/null and b/linux-x86/bin/bzip2 differ
diff --git a/linux-x86/bin/ckati b/linux-x86/bin/ckati
new file mode 100755
index 0000000000000000000000000000000000000000..2720ef80532746d3d9139ad2f92795d35a88594d
Binary files /dev/null and b/linux-x86/bin/ckati differ
diff --git a/linux-x86/bin/ckati_stamp_dump b/linux-x86/bin/ckati_stamp_dump
new file mode 100755
index 0000000000000000000000000000000000000000..53159e1cb3878b5840bfe8c26b617e881e815800
Binary files /dev/null and b/linux-x86/bin/ckati_stamp_dump differ
diff --git a/linux-x86/bin/flex b/linux-x86/bin/flex
new file mode 100755
index 0000000000000000000000000000000000000000..b88f206b713f541b478cd13a846643c652c889be
Binary files /dev/null and b/linux-x86/bin/flex differ
diff --git a/linux-x86/bin/gavinhoward-bc b/linux-x86/bin/gavinhoward-bc
new file mode 100755
index 0000000000000000000000000000000000000000..bde8d4501d902602281d85f506318f13230404d2
Binary files /dev/null and b/linux-x86/bin/gavinhoward-bc differ
diff --git a/linux-x86/bin/go_extractor b/linux-x86/bin/go_extractor
new file mode 100755
index 0000000000000000000000000000000000000000..9d7fd8f7eceace57f3206a9e484b84511b39a4d8
Binary files /dev/null and b/linux-x86/bin/go_extractor differ
diff --git a/linux-x86/bin/hidl-lint b/linux-x86/bin/hidl-lint
new file mode 100755
index 0000000000000000000000000000000000000000..10b882e4e7eb9ac5451a30eeb2a4eeaccd899520
Binary files /dev/null and b/linux-x86/bin/hidl-lint differ
diff --git a/linux-x86/bin/m4 b/linux-x86/bin/m4
new file mode 100755
index 0000000000000000000000000000000000000000..2d826066a55b57695448d38ff66ba286801a9927
Binary files /dev/null and b/linux-x86/bin/m4 differ
diff --git a/linux-x86/bin/make b/linux-x86/bin/make
new file mode 100755
index 0000000000000000000000000000000000000000..581dadef8b7be4e28a7d27ac42be4434734d369a
Binary files /dev/null and b/linux-x86/bin/make differ
diff --git a/linux-x86/bin/ninja b/linux-x86/bin/ninja
new file mode 100755
index 0000000000000000000000000000000000000000..a741b8c75dd718d52ec031969f89c2149018df2a
Binary files /dev/null and b/linux-x86/bin/ninja differ
diff --git a/linux-x86/bin/nsjail b/linux-x86/bin/nsjail
new file mode 100755
index 0000000000000000000000000000000000000000..81e71cac4d6f12cbaedee97e7ba451e8fedc600d
Binary files /dev/null and b/linux-x86/bin/nsjail differ
diff --git a/linux-x86/bin/one-true-awk b/linux-x86/bin/one-true-awk
new file mode 100755
index 0000000000000000000000000000000000000000..94e44979ece0498cdbbbb081076350bad0eaa85f
Binary files /dev/null and b/linux-x86/bin/one-true-awk differ
diff --git a/linux-x86/bin/py2-cmd b/linux-x86/bin/py2-cmd
new file mode 100755
index 0000000000000000000000000000000000000000..bb5167e3d0e29521436ec54487be99571ac24c20
Binary files /dev/null and b/linux-x86/bin/py2-cmd differ
diff --git a/linux-x86/bin/py3-cmd b/linux-x86/bin/py3-cmd
new file mode 100755
index 0000000000000000000000000000000000000000..1c2bdb4852df368159dfcaa3093955f96eafe159
Binary files /dev/null and b/linux-x86/bin/py3-cmd differ
diff --git a/linux-x86/bin/soong_zip b/linux-x86/bin/soong_zip
new file mode 100755
index 0000000000000000000000000000000000000000..08540cea760a8b24db6399cbdb54b81632485b1b
Binary files /dev/null and b/linux-x86/bin/soong_zip differ
diff --git a/linux-x86/bin/toybox b/linux-x86/bin/toybox
new file mode 100755
index 0000000000000000000000000000000000000000..d9ead70501aef6a89d5fcdf2a1958a30b7d4fd53
Binary files /dev/null and b/linux-x86/bin/toybox differ
diff --git a/linux-x86/bin/xz b/linux-x86/bin/xz
new file mode 100755
index 0000000000000000000000000000000000000000..da59e0a31c1b4769cb617f5c18dbe8e33fc1a6fc
Binary files /dev/null and b/linux-x86/bin/xz differ
diff --git a/linux-x86/bin/zip2zip b/linux-x86/bin/zip2zip
new file mode 100755
index 0000000000000000000000000000000000000000..a6d9a3a6a41eb6fd5987efe4534e5baa9ff28065
Binary files /dev/null and b/linux-x86/bin/zip2zip differ
diff --git a/linux-x86/bin/zipalign b/linux-x86/bin/zipalign
new file mode 100755
index 0000000000000000000000000000000000000000..4f064c1889c4eb9d84bb416e57696e210ce0e7b0
Binary files /dev/null and b/linux-x86/bin/zipalign differ
diff --git a/linux-x86/bin/ziptime b/linux-x86/bin/ziptime
new file mode 100755
index 0000000000000000000000000000000000000000..1b418794c424b4df90fd18de8406368e4a664029
Binary files /dev/null and b/linux-x86/bin/ziptime differ
diff --git a/linux-x86/bin/ziptool b/linux-x86/bin/ziptool
new file mode 100755
index 0000000000000000000000000000000000000000..d07aa07054880538d137c1024d17a2216d02ec64
Binary files /dev/null and b/linux-x86/bin/ziptool differ
diff --git a/linux-x86/lib64/libbase.so b/linux-x86/lib64/libbase.so
new file mode 100755
index 0000000000000000000000000000000000000000..3205da79b008bbce22a9a5a184b4acb1a711c555
Binary files /dev/null and b/linux-x86/lib64/libbase.so differ
diff --git a/linux-x86/lib64/libc++.so b/linux-x86/lib64/libc++.so
new file mode 100755
index 0000000000000000000000000000000000000000..a59b307747b2214bd9e6a184adb30ed9495298c3
Binary files /dev/null and b/linux-x86/lib64/libc++.so differ
diff --git a/linux-x86/lib64/libcrypto-host.so b/linux-x86/lib64/libcrypto-host.so
new file mode 100755
index 0000000000000000000000000000000000000000..a3e648b05725c10670bab3b66ce87774146c9f41
Binary files /dev/null and b/linux-x86/lib64/libcrypto-host.so differ
diff --git a/linux-x86/lib64/libcutils.so b/linux-x86/lib64/libcutils.so
new file mode 100755
index 0000000000000000000000000000000000000000..a65bb34181c9d22f13262432c5f2e400e3ad2d14
Binary files /dev/null and b/linux-x86/lib64/libcutils.so differ
diff --git a/linux-x86/lib64/libjemalloc.so b/linux-x86/lib64/libjemalloc.so
new file mode 100755
index 0000000000000000000000000000000000000000..f22d7279214b23ca0e192089278005d990772040
Binary files /dev/null and b/linux-x86/lib64/libjemalloc.so differ
diff --git a/linux-x86/lib64/libjsoncpp.so b/linux-x86/lib64/libjsoncpp.so
new file mode 100755
index 0000000000000000000000000000000000000000..cdb7a81a5571fd5ea67946ca0abb78885519ee16
Binary files /dev/null and b/linux-x86/lib64/libjsoncpp.so differ
diff --git a/linux-x86/lib64/liblog.so b/linux-x86/lib64/liblog.so
new file mode 100755
index 0000000000000000000000000000000000000000..f6aea6f2ca760ed9288cbb25341dcb91726a443a
Binary files /dev/null and b/linux-x86/lib64/liblog.so differ
diff --git a/linux-x86/lib64/libprotobuf-cpp-full.so b/linux-x86/lib64/libprotobuf-cpp-full.so
new file mode 100755
index 0000000000000000000000000000000000000000..f126c27f358a197b7eefeb6f1a3dd7c674d59ac2
Binary files /dev/null and b/linux-x86/lib64/libprotobuf-cpp-full.so differ
diff --git a/linux-x86/lib64/libssl-host.so b/linux-x86/lib64/libssl-host.so
new file mode 100755
index 0000000000000000000000000000000000000000..40b3c486652c2b2f7cbdb006fd8f43192db388bb
Binary files /dev/null and b/linux-x86/lib64/libssl-host.so differ
diff --git a/linux-x86/lib64/libz-host.so b/linux-x86/lib64/libz-host.so
new file mode 100755
index 0000000000000000000000000000000000000000..9849ded8c3e1b1f872e80bc36ffa1c143f5700c6
Binary files /dev/null and b/linux-x86/lib64/libz-host.so differ
diff --git a/linux-x86/lib64/libziparchive.so b/linux-x86/lib64/libziparchive.so
new file mode 100755
index 0000000000000000000000000000000000000000..49d74367c40cc4610c7a252e59adf6385b99ed28
Binary files /dev/null and b/linux-x86/lib64/libziparchive.so differ
diff --git a/manifest.xml b/manifest.xml
new file mode 100644
index 0000000000000000000000000000000000000000..e81f68b987c7094d2a2d03177ee39387ef9663bf
--- /dev/null
+++ b/manifest.xml
@@ -0,0 +1,175 @@
+<?xml version='1.0' encoding='UTF-8'?>
+
+<manifest>
+  <remote fetch=".." name="aosp" review="https://android-review.googlesource.com/" />
+
+  <default remote="aosp" revision="master" />
+
+  <project name="platform/external/bzip2" path="external/bzip2" revision="4b94ddbfd09e8ef07f7ffe434afc7f6b84ec68eb" />
+
+  <project clone-depth="1" name="platform/prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.17-4.8" path="prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.17-4.8" revision="4533a4d0efa68949dc3c0dfec00214feaddd6c7b" />
+
+  <project name="platform/external/go-creachadair-stringset" path="external/go-creachadair-stringset" revision="580fe893c0cd9bc1cb41a735b6ff456901f00e83" />
+
+  <project name="platform/external/golang-protobuf" path="external/golang-protobuf" revision="e183852c920ef6c36d9fd89a8c4233e98241c776" />
+
+  <project name="platform/build/soong" path="build/soong" revision="1b7599d91883bfdf359e46cc0ada7278eaf8e9ed">
+    <linkfile dest="Android.bp" src="root.bp" />
+
+    <linkfile dest="bootstrap.bash" src="bootstrap.bash" />
+</project>
+
+  <project name="platform/external/desugar" path="external/desugar" revision="3041d69a3395243035260e72e56b43835c70a6cd" />
+
+  <project name="platform/external/ninja" path="external/ninja" revision="e5a9d70b45ebecf68a8aec37edf5857b4d635c4e" />
+
+  <project name="platform/build/blueprint" path="build/blueprint" revision="ec5085e613aefc6f3e4037823bd67d9caed804f0" />
+
+  <project clone-depth="1" name="platform/prebuilts/jdk/jdk8" path="prebuilts/jdk/jdk8" revision="74e4f1844dfa9b8df9e0fe2ff34a2ecc24d52b07" />
+
+  <project name="platform/external/googleapis" path="external/googleapis" revision="cf713bac0768fa14bad9fd1a537f8529fc8a7911" />
+
+  <project clone-depth="1" groups="pdk" name="platform/prebuilts/remoteexecution-client" path="prebuilts/remoteexecution-client" revision="888369e69128a27f84daa478dbaff1a4bb52c423" />
+
+  <project name="platform/external/flex" path="external/flex" revision="3b24cfa05d36ee2888dccedd341a9582a53842f2" />
+
+  <project name="platform/external/jsoncpp" path="external/jsoncpp" revision="870657e4a28fc426a158254ed49c5f4cbdc690c0" />
+
+  <project name="platform/external/googletest" path="external/googletest" revision="52bd651cda2cf4c54f13d7a9450fe933af9e1818" />
+
+  <project name="platform/external/sqlite" path="external/sqlite" revision="5df6d01fec036b0e6954b4e0e79adbea982a3020" />
+
+  <project clone-depth="1" name="platform/prebuilts/build-tools" path="prebuilts/build-tools" revision="6327989d4a9236f59b0db23d43dfeab8ab304d92" />
+
+  <project name="platform/bionic" path="bionic" revision="19377a55c5fedd917019ac38382c0e921b8ce09d" />
+
+  <project name="platform/external/icu" path="external/icu" revision="2d57dc7a110fcd3cabce9de8242593473104e98c" />
+
+  <project clone-depth="1" groups="linux" name="platform/prebuilts/go/linux-x86" path="prebuilts/go/linux-x86" revision="3affa1d2632b48f9589ab4c91ca1b825d7c73a87" />
+
+  <project name="platform/external/zlib" path="external/zlib" revision="38881db65155e099d9ce40ad7cd634d83c4841b9" />
+
+  <project name="platform/external/libcxxabi" path="external/libcxxabi" revision="965a0b9300d80c4c3326c562c486159c09f16589" />
+
+  <project clone-depth="1" name="platform/prebuilts/gcc/linux-x86/x86/x86_64-linux-android-4.9" path="prebuilts/gcc/linux-x86/x86/x86_64-linux-android-4.9" revision="516fb636454e34e39c2ee7729183b07194bfe7c0" />
+
+  <project name="platform/external/clang" path="external/clang" revision="f482f355345a3e42e41be48861075aeef690a78d" />
+
+  <project clone-depth="1" groups="darwin" name="platform/prebuilts/go/darwin-x86" path="prebuilts/go/darwin-x86" revision="3d0e53b900fd8e721733b7d54a1acef694a47333" />
+
+  <project clone-depth="1" groups="linux" name="platform/prebuilts/clang/host/windows-x86" path="prebuilts/clang/host/windows-x86" revision="9531f57f4a57964f84be7146f42715511e6ddec1" />
+
+  <project clone-depth="1" name="platform/prebuilts/jdk/jdk11" path="prebuilts/jdk/jdk11" revision="bffdb0223ff2898246bbd14a6b17d8920ac600de" />
+
+  <project name="platform/external/selinux" path="external/selinux" revision="1ea855ee67517de609aa1e78851f623fc696e143" />
+
+  <project name="platform/external/kythe" path="external/kythe" revision="4579888e523bf89d6b32ed63a258b1be4203dbeb" />
+
+  <project name="platform/external/golang-x-tools" path="external/golang-x-tools" revision="bcc6484babb4e999e4bdb6a982bfa7e92fc640d2" />
+
+  <project clone-depth="1" groups="linux" name="platform/prebuilts/clang/host/linux-x86" path="prebuilts/clang/host/linux-x86" revision="27fa4eeb5967e0bae5aef6de643739bef2a58726" />
+
+  <project name="platform/external/dagger2" path="external/dagger2" revision="3809f3dd127716a59f14536b19fe5cab0e0a445e" />
+
+  <project name="platform/external/boringssl" path="external/boringssl" revision="1a0ca7b15ef06d64f10184131fc5ffa50cd12746" />
+
+  <project clone-depth="1" groups="linux" name="platform/prebuilts/ninja/linux-x86" path="prebuilts/ninja/linux-x86" revision="6369b19fc3fbe765636af75d394627e2b92599ed" />
+
+  <project name="platform/external/zopfli" path="external/zopfli" revision="7723d6077849ae5c66e105b232ddfbfc11faa09b" />
+
+  <project name="platform/external/expat" path="external/expat" revision="9060df1c8101801e0bebcddc13816ae435686019" />
+
+  <project name="platform/build/kati" path="build/kati" revision="d4641a8f4179234bf95f334fac6621edcaf40370" />
+
+  <project clone-depth="1" name="platform/prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8" path="prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.15-4.8" revision="d9aafaade740ca38612c742f6d87debf362132ea" />
+
+  <project clone-depth="1" name="platform/prebuilts/clang-tools" path="prebuilts/clang-tools" revision="881a52803087ac26382a0eab2326234f41211826" />
+
+  <project name="toolchain/make" revision="7424963d66959fdf2868ba66eff5360b0eadf2ea" />
+
+  <project name="platform/external/toybox" path="external/toybox" revision="00fed19ade154fab0c0c8d5f7378a9aa46cbd26d" />
+
+  <project clone-depth="1" groups="darwin" name="platform/prebuilts/gcc/darwin-x86/host/headers" path="prebuilts/gcc/darwin-x86/host/headers" revision="4ac4f7cc41cf3c9e36fc3d6cf37fd1cfa9587a68" />
+
+  <project clone-depth="1" name="platform/external/error_prone" path="external/error_prone" revision="10ee074fc64acde7e1b54715053b84baae43b710" />
+
+  <project name="platform/external/jsr305" path="external/jsr305" revision="c39448de67f76105bf4ba6d0f6ffda7a3b00ece6" />
+
+  <project name="platform/external/libunwind" path="external/libunwind" revision="b517b41431d30f54cb649fd7d2fb2422e3e849a2" />
+
+  <project name="platform/system/core" path="system/core" revision="67095b28de43087e74b93b8f913338bb2d40a0b7" />
+
+  <project name="platform/external/nsjail" path="external/nsjail" revision="a25cd900710305660a653c6b63d76286d8d6cdfe" />
+
+  <project clone-depth="1" groups="pdk,tools" name="platform/prebuilts/tools" path="prebuilts/tools" revision="5e29761bc39522429b5c8c3a0a91d193f6328047" />
+
+  <project name="platform/external/guava" path="external/guava" revision="e4500bcb91dc065d442a3b7eeac47447d6507bc4" />
+
+  <project name="platform/external/libffi" path="external/libffi" revision="48ed0ceaa52de017f739f014f03d4035fd48638f" />
+
+  <project name="platform/external/jemalloc" path="external/jemalloc" revision="e3ff6769f8262841c98245e21b96dc67536759dc" />
+
+  <project clone-depth="1" name="platform/prebuilts/jdk/jdk9" path="prebuilts/jdk/jdk9" revision="3447ef32fa4961229942fa345c8707c7f9e00246" />
+
+  <project name="platform/external/llvm" path="external/llvm" revision="c10415f4fb599cbb121fdd4919014b4801e9e0cc" />
+
+  <project name="platform/external/bc" path="external/bc" revision="63f3305c6e52ff824f08bc7ccc806e5df3d3a2a1" />
+
+  <project name="toolchain/m4" revision="e0fa9d57f818d550ccef84d1520923f2a942f5ba" />
+
+  <project clone-depth="1" groups="darwin" name="platform/prebuilts/gcc/darwin-x86/host/i686-apple-darwin-4.2.1" path="prebuilts/gcc/darwin-x86/host/i686-apple-darwin-4.2.1" revision="b616fc20ee024ace07f39b13a1f5a2bbdb67f8f7" />
+
+  <project name="platform/external/python/cpython3" path="external/python/cpython3" revision="5eb9adac16e15310335f606837915f11ccd1812e" />
+
+  <project name="platform/external/compiler-rt" path="external/compiler-rt" revision="54b43ff2d8e92841cb46f2162f4fa1489719ff27" />
+
+  <project name="platform/external/golang-x-sync" path="external/golang-x-sync" revision="bf7c9e83a86ea08d93262ec468a53e866728e36a" />
+
+  <project name="platform/external/pcre" path="external/pcre" revision="5a8c54003e6070401460e269350bb355804eb45f" />
+
+  <project name="platform/external/libcxx" path="external/libcxx" revision="eda4e913a505662922fc9c6f74dc8b3b12f1ed27" />
+
+  <project clone-depth="1" groups="linux" name="platform/prebuilts/gcc/linux-x86/host/x86_64-w64-mingw32-4.8" path="prebuilts/gcc/linux-x86/host/x86_64-w64-mingw32-4.8" revision="3cbae8d4e0140abbfa0e120567ef1d5b24b3f8d2" />
+
+  <project name="platform/external/libunwind_llvm" path="external/libunwind_llvm" revision="98d90944b3ef000dd6716c57a480f52a6726749d" />
+
+  <project name="platform/external/safe-iop" path="external/safe-iop" revision="b805514f31a231a0e78a18f296c0454fcadead1a" />
+
+  <project name="platform/external/fmtlib" path="external/fmtlib" revision="2ea04745efe22c936ceb530d6dd89c6eeafe303b" />
+
+  <project name="platform/system/tools/hidl" path="system/tools/hidl" revision="1f8b63c2f6b4f8d954485a592ae30cadbd30378e" />
+
+  <project name="platform/system/tools/aidl" path="system/tools/aidl" revision="a3617e6f09f14141ee536f55f60dbb7adc5f7714" />
+
+  <project name="platform/build" path="build/make" revision="f53f313c368b95bc079f69f4370ea69a60b95678">
+    <linkfile dest="build/tools" src="tools" />
+</project>
+
+  <project clone-depth="1" name="platform/prebuilts/misc" path="prebuilts/misc" revision="b378fddc5826f348bc4b1797d6cb30345bf30d4c" />
+
+  <project name="platform/external/bison" path="external/bison" revision="ef635029c745e1fb2602f5ab3fb142855532f7a5" />
+
+  <project name="platform/external/bazelbuild-remote-apis" path="external/bazelbuild-remote-apis" revision="e0e5a5351a4571f63506eec04ee49a3dd1e60327" />
+
+  <project clone-depth="1" groups="darwin" name="platform/prebuilts/clang/host/darwin-x86" path="prebuilts/clang/host/darwin-x86" revision="9180130e429b04b8105011e7b7b64676b10abc23" />
+
+  <project name="platform/external/arm-optimized-routines" path="external/arm-optimized-routines" revision="8e87a22a6f08662389737c31469df00a4c4dcedc" />
+
+  <project name="platform/external/protobuf" path="external/protobuf" revision="df8e6979660e15686401a28a8dcb0a83d193ea00" />
+
+  <project name="toolchain/xz" revision="ac90d9b11e02bd6837917f7e981ed40dc2cb7d1b" />
+
+  <project clone-depth="1" groups="darwin" name="platform/prebuilts/ninja/darwin-x86" path="prebuilts/ninja/darwin-x86" revision="00f798346dedb4a7a6a6dcc9ad32ff09d66ee0db" />
+
+  <project name="platform/external/one-true-awk" path="external/one-true-awk" revision="8cc21e2906ed803de4c90eb58e52a150d4f15404" />
+
+  <project name="platform/external/python/cpython2" path="external/python/cpython2" revision="edba983036eab94d6c8eb211198f5ae5a874b7b0" />
+
+  <project name="platform/development" path="development" revision="56d21f5ebb7b1f9074c3745f182226e06806f079" />
+
+  <project name="platform/dalvik" path="dalvik" revision="1537e27bdc17e87c45e6269546f45ed7fbb91d19" />
+
+  <project name="toolchain/go" revision="84ee4dd45a7bd83c16e385bfd3ce9ce405431adf" />
+
+  <project name="platform/external/turbine" path="external/turbine" revision="b3b9a496c8200bc0c7db1f5628fdfd2c0269dea2" />
+</manifest>
diff --git a/path/README b/path/README
new file mode 100644
index 0000000000000000000000000000000000000000..fa127f60e83b07d6e1015c222a06fbbf5698f1f8
--- /dev/null
+++ b/path/README
@@ -0,0 +1,3 @@
+These directories will be added to $PATH during the build in order to provide
+some common tools normally found in the system $PATH. They're all symlinks into
+the prebuilts found elsewhere in this repository.
diff --git a/path/darwin-x86/awk b/path/darwin-x86/awk
new file mode 120000
index 0000000000000000000000000000000000000000..ced0fa9daf0f13a56f7a20b4fa5a8f9078647d48
--- /dev/null
+++ b/path/darwin-x86/awk
@@ -0,0 +1 @@
+../../darwin-x86/bin/one-true-awk
\ No newline at end of file
diff --git a/path/darwin-x86/basename b/path/darwin-x86/basename
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/basename
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/bc b/path/darwin-x86/bc
new file mode 120000
index 0000000000000000000000000000000000000000..cba69d5479b8f67b11076319d74bf07463122cc5
--- /dev/null
+++ b/path/darwin-x86/bc
@@ -0,0 +1 @@
+../../darwin-x86/bin/gavinhoward-bc
\ No newline at end of file
diff --git a/path/darwin-x86/bzcat b/path/darwin-x86/bzcat
new file mode 120000
index 0000000000000000000000000000000000000000..c2beadb8aff258560df3152751fd8a215f6467f6
--- /dev/null
+++ b/path/darwin-x86/bzcat
@@ -0,0 +1 @@
+../../darwin-x86/bin/bzip2
\ No newline at end of file
diff --git a/path/darwin-x86/bzip2 b/path/darwin-x86/bzip2
new file mode 120000
index 0000000000000000000000000000000000000000..c2beadb8aff258560df3152751fd8a215f6467f6
--- /dev/null
+++ b/path/darwin-x86/bzip2
@@ -0,0 +1 @@
+../../darwin-x86/bin/bzip2
\ No newline at end of file
diff --git a/path/darwin-x86/cat b/path/darwin-x86/cat
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/cat
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/chmod b/path/darwin-x86/chmod
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/chmod
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/cmp b/path/darwin-x86/cmp
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/cmp
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/comm b/path/darwin-x86/comm
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/comm
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/cp b/path/darwin-x86/cp
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/cp
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/cut b/path/darwin-x86/cut
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/cut
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/date b/path/darwin-x86/date
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/date
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/dirname b/path/darwin-x86/dirname
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/dirname
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/du b/path/darwin-x86/du
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/du
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/echo b/path/darwin-x86/echo
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/echo
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/egrep b/path/darwin-x86/egrep
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/egrep
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/env b/path/darwin-x86/env
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/env
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/find b/path/darwin-x86/find
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/find
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/getconf b/path/darwin-x86/getconf
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/getconf
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/grep b/path/darwin-x86/grep
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/grep
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/gzip b/path/darwin-x86/gzip
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/gzip
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/head b/path/darwin-x86/head
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/head
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/hostname b/path/darwin-x86/hostname
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/hostname
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/id b/path/darwin-x86/id
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/id
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/ln b/path/darwin-x86/ln
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/ln
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/ls b/path/darwin-x86/ls
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/ls
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/md5sum b/path/darwin-x86/md5sum
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/md5sum
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/mkdir b/path/darwin-x86/mkdir
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/mkdir
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/mktemp b/path/darwin-x86/mktemp
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/mktemp
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/mv b/path/darwin-x86/mv
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/mv
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/od b/path/darwin-x86/od
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/od
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/paste b/path/darwin-x86/paste
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/paste
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/pwd b/path/darwin-x86/pwd
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/pwd
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/python b/path/darwin-x86/python
new file mode 120000
index 0000000000000000000000000000000000000000..c34aaaece2b30225e421c74625e045eb79d73c05
--- /dev/null
+++ b/path/darwin-x86/python
@@ -0,0 +1 @@
+../../darwin-x86/bin/py2-cmd
\ No newline at end of file
diff --git a/path/darwin-x86/python2 b/path/darwin-x86/python2
new file mode 120000
index 0000000000000000000000000000000000000000..c34aaaece2b30225e421c74625e045eb79d73c05
--- /dev/null
+++ b/path/darwin-x86/python2
@@ -0,0 +1 @@
+../../darwin-x86/bin/py2-cmd
\ No newline at end of file
diff --git a/path/darwin-x86/python2.7 b/path/darwin-x86/python2.7
new file mode 120000
index 0000000000000000000000000000000000000000..c34aaaece2b30225e421c74625e045eb79d73c05
--- /dev/null
+++ b/path/darwin-x86/python2.7
@@ -0,0 +1 @@
+../../darwin-x86/bin/py2-cmd
\ No newline at end of file
diff --git a/path/darwin-x86/python3 b/path/darwin-x86/python3
new file mode 120000
index 0000000000000000000000000000000000000000..6c67d34605533b3d650ec90c3eccf45a9d644ab2
--- /dev/null
+++ b/path/darwin-x86/python3
@@ -0,0 +1 @@
+../../darwin-x86/bin/py3-cmd
\ No newline at end of file
diff --git a/path/darwin-x86/readlink b/path/darwin-x86/readlink
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/readlink
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/realpath b/path/darwin-x86/realpath
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/realpath
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/rm b/path/darwin-x86/rm
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/rm
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/rmdir b/path/darwin-x86/rmdir
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/rmdir
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/sed b/path/darwin-x86/sed
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/sed
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/seq b/path/darwin-x86/seq
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/seq
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/setsid b/path/darwin-x86/setsid
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/setsid
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/sha1sum b/path/darwin-x86/sha1sum
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/sha1sum
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/sha256sum b/path/darwin-x86/sha256sum
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/sha256sum
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/sha512sum b/path/darwin-x86/sha512sum
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/sha512sum
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/sleep b/path/darwin-x86/sleep
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/sleep
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/sort b/path/darwin-x86/sort
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/sort
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/stat b/path/darwin-x86/stat
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/stat
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/tail b/path/darwin-x86/tail
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/tail
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/tar b/path/darwin-x86/tar
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/tar
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/tee b/path/darwin-x86/tee
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/tee
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/timeout b/path/darwin-x86/timeout
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/timeout
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/touch b/path/darwin-x86/touch
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/touch
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/true b/path/darwin-x86/true
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/true
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/truncate b/path/darwin-x86/truncate
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/truncate
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/uname b/path/darwin-x86/uname
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/uname
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/uniq b/path/darwin-x86/uniq
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/uniq
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/unix2dos b/path/darwin-x86/unix2dos
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/unix2dos
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/wc b/path/darwin-x86/wc
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/wc
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/which b/path/darwin-x86/which
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/which
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/whoami b/path/darwin-x86/whoami
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/whoami
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/xargs b/path/darwin-x86/xargs
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/xargs
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/xxd b/path/darwin-x86/xxd
new file mode 120000
index 0000000000000000000000000000000000000000..feaf26c826e71fe0bd681dbba295255f2872b8ad
--- /dev/null
+++ b/path/darwin-x86/xxd
@@ -0,0 +1 @@
+../../darwin-x86/bin/toybox
\ No newline at end of file
diff --git a/path/darwin-x86/xz b/path/darwin-x86/xz
new file mode 120000
index 0000000000000000000000000000000000000000..ae6572bb110a82b2ec9d9e1973c8a1402804ac82
--- /dev/null
+++ b/path/darwin-x86/xz
@@ -0,0 +1 @@
+../../darwin-x86/bin/xz
\ No newline at end of file
diff --git a/path/darwin-x86/xzcat b/path/darwin-x86/xzcat
new file mode 120000
index 0000000000000000000000000000000000000000..ae6572bb110a82b2ec9d9e1973c8a1402804ac82
--- /dev/null
+++ b/path/darwin-x86/xzcat
@@ -0,0 +1 @@
+../../darwin-x86/bin/xz
\ No newline at end of file
diff --git a/path/darwin-x86/zipinfo b/path/darwin-x86/zipinfo
new file mode 120000
index 0000000000000000000000000000000000000000..14d6ca7faa51665ca6d5c77ed7e0fbc11a3944a2
--- /dev/null
+++ b/path/darwin-x86/zipinfo
@@ -0,0 +1 @@
+../../darwin-x86/bin/ziptool
\ No newline at end of file
diff --git a/path/linux-x86/awk b/path/linux-x86/awk
new file mode 120000
index 0000000000000000000000000000000000000000..28cb5057fd3af6cdb4350500839ba6e6e3a5fd1f
--- /dev/null
+++ b/path/linux-x86/awk
@@ -0,0 +1 @@
+../../linux-x86/bin/one-true-awk
\ No newline at end of file
diff --git a/path/linux-x86/basename b/path/linux-x86/basename
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/basename
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/bc b/path/linux-x86/bc
new file mode 120000
index 0000000000000000000000000000000000000000..1b33fcb45323133c418fd81518933bf52a444a54
--- /dev/null
+++ b/path/linux-x86/bc
@@ -0,0 +1 @@
+../../linux-x86/bin/gavinhoward-bc
\ No newline at end of file
diff --git a/path/linux-x86/bzcat b/path/linux-x86/bzcat
new file mode 120000
index 0000000000000000000000000000000000000000..690843d3ace818c28c114d4be2c6d816f378ddb1
--- /dev/null
+++ b/path/linux-x86/bzcat
@@ -0,0 +1 @@
+../../linux-x86/bin/bzip2
\ No newline at end of file
diff --git a/path/linux-x86/bzip2 b/path/linux-x86/bzip2
new file mode 120000
index 0000000000000000000000000000000000000000..690843d3ace818c28c114d4be2c6d816f378ddb1
--- /dev/null
+++ b/path/linux-x86/bzip2
@@ -0,0 +1 @@
+../../linux-x86/bin/bzip2
\ No newline at end of file
diff --git a/path/linux-x86/cat b/path/linux-x86/cat
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/cat
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/chmod b/path/linux-x86/chmod
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/chmod
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/cmp b/path/linux-x86/cmp
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/cmp
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/comm b/path/linux-x86/comm
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/comm
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/cp b/path/linux-x86/cp
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/cp
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/cut b/path/linux-x86/cut
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/cut
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/date b/path/linux-x86/date
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/date
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/dirname b/path/linux-x86/dirname
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/dirname
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/du b/path/linux-x86/du
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/du
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/echo b/path/linux-x86/echo
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/echo
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/egrep b/path/linux-x86/egrep
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/egrep
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/env b/path/linux-x86/env
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/env
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/find b/path/linux-x86/find
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/find
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/getconf b/path/linux-x86/getconf
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/getconf
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/grep b/path/linux-x86/grep
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/grep
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/gzip b/path/linux-x86/gzip
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/gzip
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/head b/path/linux-x86/head
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/head
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/hostname b/path/linux-x86/hostname
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/hostname
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/id b/path/linux-x86/id
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/id
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/ln b/path/linux-x86/ln
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/ln
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/ls b/path/linux-x86/ls
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/ls
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/md5sum b/path/linux-x86/md5sum
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/md5sum
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/mkdir b/path/linux-x86/mkdir
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/mkdir
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/mktemp b/path/linux-x86/mktemp
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/mktemp
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/mv b/path/linux-x86/mv
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/mv
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/od b/path/linux-x86/od
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/od
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/paste b/path/linux-x86/paste
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/paste
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/pgrep b/path/linux-x86/pgrep
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/pgrep
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/pkill b/path/linux-x86/pkill
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/pkill
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/ps b/path/linux-x86/ps
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/ps
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/pwd b/path/linux-x86/pwd
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/pwd
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/python b/path/linux-x86/python
new file mode 120000
index 0000000000000000000000000000000000000000..8ec5dcd050d48f7d6eb6a6cf8c8766de20babeef
--- /dev/null
+++ b/path/linux-x86/python
@@ -0,0 +1 @@
+../../linux-x86/bin/py2-cmd
\ No newline at end of file
diff --git a/path/linux-x86/python2 b/path/linux-x86/python2
new file mode 120000
index 0000000000000000000000000000000000000000..8ec5dcd050d48f7d6eb6a6cf8c8766de20babeef
--- /dev/null
+++ b/path/linux-x86/python2
@@ -0,0 +1 @@
+../../linux-x86/bin/py2-cmd
\ No newline at end of file
diff --git a/path/linux-x86/python2.7 b/path/linux-x86/python2.7
new file mode 120000
index 0000000000000000000000000000000000000000..8ec5dcd050d48f7d6eb6a6cf8c8766de20babeef
--- /dev/null
+++ b/path/linux-x86/python2.7
@@ -0,0 +1 @@
+../../linux-x86/bin/py2-cmd
\ No newline at end of file
diff --git a/path/linux-x86/python3 b/path/linux-x86/python3
new file mode 120000
index 0000000000000000000000000000000000000000..94246bc9d6bc28dbfbb260848c4d4e873bb17443
--- /dev/null
+++ b/path/linux-x86/python3
@@ -0,0 +1 @@
+../../linux-x86/bin/py3-cmd
\ No newline at end of file
diff --git a/path/linux-x86/readlink b/path/linux-x86/readlink
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/readlink
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/realpath b/path/linux-x86/realpath
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/realpath
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/rm b/path/linux-x86/rm
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/rm
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/rmdir b/path/linux-x86/rmdir
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/rmdir
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/sed b/path/linux-x86/sed
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/sed
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/seq b/path/linux-x86/seq
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/seq
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/setsid b/path/linux-x86/setsid
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/setsid
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/sha1sum b/path/linux-x86/sha1sum
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/sha1sum
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/sha256sum b/path/linux-x86/sha256sum
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/sha256sum
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/sha512sum b/path/linux-x86/sha512sum
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/sha512sum
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/sleep b/path/linux-x86/sleep
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/sleep
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/sort b/path/linux-x86/sort
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/sort
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/stat b/path/linux-x86/stat
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/stat
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/tail b/path/linux-x86/tail
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/tail
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/tar b/path/linux-x86/tar
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/tar
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/tee b/path/linux-x86/tee
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/tee
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/timeout b/path/linux-x86/timeout
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/timeout
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/touch b/path/linux-x86/touch
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/touch
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/true b/path/linux-x86/true
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/true
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/truncate b/path/linux-x86/truncate
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/truncate
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/uname b/path/linux-x86/uname
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/uname
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/uniq b/path/linux-x86/uniq
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/uniq
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/unix2dos b/path/linux-x86/unix2dos
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/unix2dos
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/wc b/path/linux-x86/wc
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/wc
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/which b/path/linux-x86/which
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/which
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/whoami b/path/linux-x86/whoami
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/whoami
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/xargs b/path/linux-x86/xargs
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/xargs
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/xxd b/path/linux-x86/xxd
new file mode 120000
index 0000000000000000000000000000000000000000..c6b4b1f8c883641301c669c6eac0664d26321f4f
--- /dev/null
+++ b/path/linux-x86/xxd
@@ -0,0 +1 @@
+../../linux-x86/bin/toybox
\ No newline at end of file
diff --git a/path/linux-x86/xz b/path/linux-x86/xz
new file mode 120000
index 0000000000000000000000000000000000000000..1a705221cd3c0f8029f1c967cf356f2929866af8
--- /dev/null
+++ b/path/linux-x86/xz
@@ -0,0 +1 @@
+../../linux-x86/bin/xz
\ No newline at end of file
diff --git a/path/linux-x86/xzcat b/path/linux-x86/xzcat
new file mode 120000
index 0000000000000000000000000000000000000000..1a705221cd3c0f8029f1c967cf356f2929866af8
--- /dev/null
+++ b/path/linux-x86/xzcat
@@ -0,0 +1 @@
+../../linux-x86/bin/xz
\ No newline at end of file
diff --git a/path/linux-x86/zipinfo b/path/linux-x86/zipinfo
new file mode 120000
index 0000000000000000000000000000000000000000..65cc6abc83291f03bdb764a4b189d71becbf4fbf
--- /dev/null
+++ b/path/linux-x86/zipinfo
@@ -0,0 +1 @@
+../../linux-x86/bin/ziptool
\ No newline at end of file
diff --git a/update-prebuilts.sh b/update-prebuilts.sh
new file mode 100755
index 0000000000000000000000000000000000000000..39911701a6653e3ab9bb20d7ad5d7b928537173b
--- /dev/null
+++ b/update-prebuilts.sh
@@ -0,0 +1,52 @@
+#!/bin/bash -e
+
+if [ -z $1 ]; then
+    echo "usage: $0 <build number>"
+    exit 1
+fi
+
+readonly BUILD_NUMBER=$1
+
+cd "$(dirname $0)"
+
+if ! git diff HEAD --quiet; then
+    echo "must be run with a clean prebuilts/build-tools project"
+    exit 1
+fi
+
+readonly tmpdir=$(mktemp -d)
+
+function finish {
+    if [ ! -z "${tmpdir}" ]; then
+        rm -rf "${tmpdir}"
+    fi
+}
+trap finish EXIT
+
+function fetch_artifact() {
+    /google/data/ro/projects/android/fetch_artifact --bid ${BUILD_NUMBER} --target $1 "$2" "$3"
+}
+
+fetch_artifact linux build-prebuilts.zip "${tmpdir}/linux.zip"
+fetch_artifact linux build-common-prebuilts.zip "${tmpdir}/common.zip"
+fetch_artifact linux manifest_${BUILD_NUMBER}.xml "${tmpdir}/manifest.xml"
+fetch_artifact darwin_mac build-prebuilts.zip "${tmpdir}/darwin.zip"
+
+function unzip_to() {
+    rm -rf "$1"
+    mkdir "$1"
+    unzip -q -d "$1" "$2"
+}
+
+unzip_to linux-x86 "${tmpdir}/linux.zip"
+unzip_to common "${tmpdir}/common.zip"
+unzip_to darwin-x86 "${tmpdir}/darwin.zip"
+
+cp -f "${tmpdir}/manifest.xml" manifest.xml
+
+git add manifest.xml linux-x86 darwin-x86 common
+git commit -m "Update build-tools to ab/${BUILD_NUMBER}
+
+https://ci.android.com/builds/branches/aosp-build-tools/grid?head=${BUILD_NUMBER}&tail=${BUILD_NUMBER}
+
+Test: treehugger"

commit 1f172cc0ab9f8e218a21debe576afbe21a7b401b
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2021-10-10 18:47:54-0400

    constify JNINativeMethod tables
---
 luni/src/main/native/android_system_OsConstants.cpp            | 2 +-
 luni/src/main/native/java_lang_StringToReal.cpp                | 2 +-
 luni/src/main/native/java_lang_invoke_MethodHandle.cpp         | 2 +-
 luni/src/main/native/java_lang_invoke_VarHandle.cpp            | 2 +-
 luni/src/main/native/libcore_icu_ICU.cpp                       | 2 +-
 luni/src/main/native/libcore_io_AsynchronousCloseMonitor.cpp   | 2 +-
 luni/src/main/native/libcore_io_Linux.cpp                      | 2 +-
 luni/src/main/native/libcore_io_Memory.cpp                     | 2 +-
 luni/src/main/native/libcore_math_NativeBN.cpp                 | 2 +-
 luni/src/main/native/libcore_util_NativeAllocationRegistry.cpp | 2 +-
 luni/src/main/native/org_apache_harmony_xml_ExpatParser.cpp    | 4 ++--
 luni/src/main/native/sun_misc_Unsafe.cpp                       | 2 +-
 ojluni/src/main/native/Character.cpp                           | 2 +-
 13 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/luni/src/main/native/android_system_OsConstants.cpp b/luni/src/main/native/android_system_OsConstants.cpp
index 50e3c104666014782d2537db11b4f34d2c7b3e20..8ad66d2742bb97d7761911b6862a8c9f3da1e55e 100644
--- a/luni/src/main/native/android_system_OsConstants.cpp
+++ b/luni/src/main/native/android_system_OsConstants.cpp
@@ -715,16 +715,16 @@ static void OsConstants_initConstants(JNIEnv* env, jclass c) {
     initConstant(env, c, "_SC_XOPEN_ENH_I18N", _SC_XOPEN_ENH_I18N);
     initConstant(env, c, "_SC_XOPEN_LEGACY", _SC_XOPEN_LEGACY);
     initConstant(env, c, "_SC_XOPEN_REALTIME", _SC_XOPEN_REALTIME);
     initConstant(env, c, "_SC_XOPEN_REALTIME_THREADS", _SC_XOPEN_REALTIME_THREADS);
     initConstant(env, c, "_SC_XOPEN_SHM", _SC_XOPEN_SHM);
     initConstant(env, c, "_SC_XOPEN_UNIX", _SC_XOPEN_UNIX);
     initConstant(env, c, "_SC_XOPEN_VERSION", _SC_XOPEN_VERSION);
     initConstant(env, c, "_SC_XOPEN_XCU_VERSION", _SC_XOPEN_XCU_VERSION);
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     NATIVE_METHOD(OsConstants, initConstants, "()V"),
 };
 void register_android_system_OsConstants(JNIEnv* env) {
     jniRegisterNativeMethods(env, "android/system/OsConstants", gMethods, NELEM(gMethods));
 }
diff --git a/luni/src/main/native/java_lang_StringToReal.cpp b/luni/src/main/native/java_lang_StringToReal.cpp
index 7a4928563948b29767d86316a930b3d72f912d7e..edd71fad700f2faeed427b9c76fc0d95f8d46a7e 100644
--- a/luni/src/main/native/java_lang_StringToReal.cpp
+++ b/luni/src/main/native/java_lang_StringToReal.cpp
@@ -885,17 +885,17 @@ static jfloat StringToReal_parseFltImpl(JNIEnv* env, jclass, jstring s, jint e)
 }
 
 static jdouble StringToReal_parseDblImpl(JNIEnv* env, jclass, jstring s, jint e) {
     ScopedUtfChars str(env, s);
     if (str.c_str() == NULL) {
         return 0.0;
     }
     return createDouble(env, str.c_str(), e);
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     NATIVE_METHOD(StringToReal, parseFltImpl, "(Ljava/lang/String;I)F"),
     NATIVE_METHOD(StringToReal, parseDblImpl, "(Ljava/lang/String;I)D"),
 };
 void register_java_lang_StringToReal(JNIEnv* env) {
     jniRegisterNativeMethods(env, "java/lang/StringToReal", gMethods, NELEM(gMethods));
 }
diff --git a/luni/src/main/native/java_lang_invoke_MethodHandle.cpp b/luni/src/main/native/java_lang_invoke_MethodHandle.cpp
index 0441d4552dc6c9cc05a88294759462477b4fab44..3335c6de9aceee606d20c06991f331f916e90fb5 100644
--- a/luni/src/main/native/java_lang_invoke_MethodHandle.cpp
+++ b/luni/src/main/native/java_lang_invoke_MethodHandle.cpp
@@ -22,18 +22,18 @@ static jobject MethodHandle_invokeExact(JNIEnv* env, jobject, jobjectArray) {
             "MethodHandle.invokeExact cannot be invoked reflectively.");
     return nullptr;
 }
 
 static jobject MethodHandle_invoke(JNIEnv* env, jobject, jobjectArray) {
     jniThrowException(env, "java/lang/UnsupportedOperationException",
             "MethodHandle.invoke cannot be invoked reflectively.");
     return nullptr;
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     NATIVE_METHOD(MethodHandle, invokeExact, "([Ljava/lang/Object;)Ljava/lang/Object;"),
     NATIVE_METHOD(MethodHandle, invoke, "([Ljava/lang/Object;)Ljava/lang/Object;"),
 };
 
 void register_java_lang_invoke_MethodHandle(JNIEnv* env) {
     jniRegisterNativeMethods(env, "java/lang/invoke/MethodHandle", gMethods, NELEM(gMethods));
 }
diff --git a/luni/src/main/native/java_lang_invoke_VarHandle.cpp b/luni/src/main/native/java_lang_invoke_VarHandle.cpp
index e1cc1c7f8b5f61f046cabf2c6357a027b2d1d25c..9f5215a52049145709f98c646a9c38f25d6b8006 100644
--- a/luni/src/main/native/java_lang_invoke_VarHandle.cpp
+++ b/luni/src/main/native/java_lang_invoke_VarHandle.cpp
@@ -203,21 +203,21 @@ static jboolean VarHandle_weakCompareAndSetPlain(JNIEnv* env, jobject, jobjectAr
   ThrowUnsupportedOperationForAccessMode(env, "weakCompareAndSetPlain");
   return JNI_FALSE;
 }
 
 static jboolean VarHandle_weakCompareAndSetRelease(JNIEnv* env, jobject, jobjectArray) {
   // Only reachable with reflection (see comment in ThrowUnsupportedOperationForAccessMode).
   ThrowUnsupportedOperationForAccessMode(env, "weakCompareAndSetRelease");
   return JNI_FALSE;
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
   NATIVE_METHOD(VarHandle, compareAndExchange, "([Ljava/lang/Object;)Ljava/lang/Object;"),
   NATIVE_METHOD(VarHandle, compareAndExchangeAcquire, "([Ljava/lang/Object;)Ljava/lang/Object;"),
   NATIVE_METHOD(VarHandle, compareAndExchangeRelease, "([Ljava/lang/Object;)Ljava/lang/Object;"),
   NATIVE_METHOD(VarHandle, compareAndSet, "([Ljava/lang/Object;)Z"),
   NATIVE_METHOD(VarHandle, get, "([Ljava/lang/Object;)Ljava/lang/Object;"),
   NATIVE_METHOD(VarHandle, getAcquire, "([Ljava/lang/Object;)Ljava/lang/Object;"),
   NATIVE_METHOD(VarHandle, getAndAdd, "([Ljava/lang/Object;)Ljava/lang/Object;"),
   NATIVE_METHOD(VarHandle, getAndAddAcquire, "([Ljava/lang/Object;)Ljava/lang/Object;"),
   NATIVE_METHOD(VarHandle, getAndAddRelease, "([Ljava/lang/Object;)Ljava/lang/Object;"),
   NATIVE_METHOD(VarHandle, getAndBitwiseAnd, "([Ljava/lang/Object;)Ljava/lang/Object;"),
diff --git a/luni/src/main/native/libcore_icu_ICU.cpp b/luni/src/main/native/libcore_icu_ICU.cpp
index f9401d1edb742640202421ed819d987575627b01..1531ad1ca593d37be3586a42116edd5a4020ad91 100644
--- a/luni/src/main/native/libcore_icu_ICU.cpp
+++ b/luni/src/main/native/libcore_icu_ICU.cpp
@@ -105,21 +105,21 @@ static jstring ICU_getIcuVersion(JNIEnv* env, jclass) {
     u_getVersion(icuVersion);
     return versionString(env, icuVersion);
 }
 
 static jstring ICU_getUnicodeVersion(JNIEnv* env, jclass) {
     UVersionInfo unicodeVersion;
     u_getUnicodeVersion(unicodeVersion);
     return versionString(env, unicodeVersion);
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     NATIVE_METHOD(ICU, getAvailableLocalesNative, "()[Ljava/lang/String;"),
     NATIVE_METHOD(ICU, getCldrVersion, "()Ljava/lang/String;"),
     NATIVE_METHOD(ICU, getDefaultLocale, "()Ljava/lang/String;"),
     NATIVE_METHOD(ICU, getIcuVersion, "()Ljava/lang/String;"),
     NATIVE_METHOD(ICU, getISO3Country, "(Ljava/lang/String;)Ljava/lang/String;"),
     NATIVE_METHOD(ICU, getISO3Language, "(Ljava/lang/String;)Ljava/lang/String;"),
     NATIVE_METHOD(ICU, getISOCountriesNative, "()[Ljava/lang/String;"),
     NATIVE_METHOD(ICU, getISOLanguagesNative, "()[Ljava/lang/String;"),
     NATIVE_METHOD(ICU, getScript, "(Ljava/lang/String;)Ljava/lang/String;"),
     NATIVE_METHOD(ICU, getUnicodeVersion, "()Ljava/lang/String;"),
diff --git a/luni/src/main/native/libcore_io_AsynchronousCloseMonitor.cpp b/luni/src/main/native/libcore_io_AsynchronousCloseMonitor.cpp
index e99edd6c4f965f8babd443dadeb9b2b4468fc987..61b75bcd35809cb98d52f4fd68d9632d292c050b 100644
--- a/luni/src/main/native/libcore_io_AsynchronousCloseMonitor.cpp
+++ b/luni/src/main/native/libcore_io_AsynchronousCloseMonitor.cpp
@@ -19,17 +19,17 @@
 #include <nativehelper/JNIPlatformHelp.h>
 #include <nativehelper/jni_macros.h>
 
 #include "AsynchronousCloseMonitor.h"
 
 static void AsynchronousCloseMonitor_signalBlockedThreads(JNIEnv* env, jclass, jobject javaFd) {
     int fd = jniGetFDFromFileDescriptor(env, javaFd);
     AsynchronousCloseMonitor::signalBlockedThreads(fd);
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     NATIVE_METHOD(AsynchronousCloseMonitor, signalBlockedThreads, "(Ljava/io/FileDescriptor;)V"),
 };
 void register_libcore_io_AsynchronousCloseMonitor(JNIEnv* env) {
     AsynchronousCloseMonitor::init();
     jniRegisterNativeMethods(env, "libcore/io/AsynchronousCloseMonitor", gMethods, NELEM(gMethods));
 }
diff --git a/luni/src/main/native/libcore_io_Linux.cpp b/luni/src/main/native/libcore_io_Linux.cpp
index d7b6c22aa57993216a12f23ec6d7ffcf036a9bcc..996085b1423ca98db85a658f953696ba7bbdeb9e 100755
--- a/luni/src/main/native/libcore_io_Linux.cpp
+++ b/luni/src/main/native/libcore_io_Linux.cpp
@@ -2734,21 +2734,21 @@ static jint Linux_writev(JNIEnv* env, jobject, jobject javaFd, jobjectArray buff
     IoVec<ScopedBytesRO> ioVec(env, env->GetArrayLength(buffers));
     if (!ioVec.init(buffers, offsets, byteCounts)) {
         return -1;
     }
     return IO_FAILURE_RETRY(env, ssize_t, writev, javaFd, ioVec.get(), ioVec.size());
 }
 
 #define NATIVE_METHOD_OVERLOAD(className, functionName, signature, variant) \
     { #functionName, signature, reinterpret_cast<void*>(className ## _ ## functionName ## variant) }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     NATIVE_METHOD(Linux, accept, "(Ljava/io/FileDescriptor;Ljava/net/SocketAddress;)Ljava/io/FileDescriptor;"),
     NATIVE_METHOD(Linux, access, "(Ljava/lang/String;I)Z"),
     NATIVE_METHOD(Linux, android_fdsan_exchange_owner_tag, "(Ljava/io/FileDescriptor;JJ)V"),
     NATIVE_METHOD(Linux, android_fdsan_get_owner_tag, "(Ljava/io/FileDescriptor;)J"),
     NATIVE_METHOD(Linux, android_fdsan_get_tag_type, "(J)Ljava/lang/String;"),
     NATIVE_METHOD(Linux, android_fdsan_get_tag_value, "(J)J"),
     NATIVE_METHOD(Linux, android_getaddrinfo, "(Ljava/lang/String;Landroid/system/StructAddrinfo;I)[Ljava/net/InetAddress;"),
     NATIVE_METHOD(Linux, bind, "(Ljava/io/FileDescriptor;Ljava/net/InetAddress;I)V"),
     NATIVE_METHOD_OVERLOAD(Linux, bind, "(Ljava/io/FileDescriptor;Ljava/net/SocketAddress;)V", SocketAddress),
     NATIVE_METHOD(Linux, capget,
diff --git a/luni/src/main/native/libcore_io_Memory.cpp b/luni/src/main/native/libcore_io_Memory.cpp
index b8a8845000606d68749d44af6cddedeb5d845aeb..7dec85dab80a68a8170921c74c22af90c3acd04b 100644
--- a/luni/src/main/native/libcore_io_Memory.cpp
+++ b/luni/src/main/native/libcore_io_Memory.cpp
@@ -283,21 +283,21 @@ static void Memory_unsafeBulkPut(JNIEnv* env, jclass, jbyteArray dstArray, jint
     jbyte* srcBytes = reinterpret_cast<jbyte*>(env->GetPrimitiveArrayCritical(srcArray, NULL));
     if (srcBytes == NULL) {
         return;
     }
     jbyte* dst = dstBytes.get() + dstOffset;
     const jbyte* src = srcBytes + srcOffset*sizeofElement;
     unsafeBulkCopy(dst, src, byteCount, sizeofElement, swap);
     env->ReleasePrimitiveArrayCritical(srcArray, srcBytes, 0);
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     NATIVE_METHOD(Memory, memmove, "(Ljava/lang/Object;ILjava/lang/Object;IJ)V"),
     FAST_NATIVE_METHOD(Memory, peekByte, "(J)B"),
     NATIVE_METHOD(Memory, peekByteArray, "(J[BII)V"),
     NATIVE_METHOD(Memory, peekCharArray, "(J[CIIZ)V"),
     NATIVE_METHOD(Memory, peekDoubleArray, "(J[DIIZ)V"),
     NATIVE_METHOD(Memory, peekFloatArray, "(J[FIIZ)V"),
     FAST_NATIVE_METHOD(Memory, peekIntNative, "(J)I"),
     NATIVE_METHOD(Memory, peekIntArray, "(J[IIIZ)V"),
     FAST_NATIVE_METHOD(Memory, peekLongNative, "(J)J"),
     NATIVE_METHOD(Memory, peekLongArray, "(J[JIIZ)V"),
diff --git a/luni/src/main/native/libcore_math_NativeBN.cpp b/luni/src/main/native/libcore_math_NativeBN.cpp
index dc4b947358b2ed091e4e879c2809414e44ccd700..c6af376f6bc1448bf7605160b3844c4fd4dfc557 100644
--- a/luni/src/main/native/libcore_math_NativeBN.cpp
+++ b/luni/src/main/native/libcore_math_NativeBN.cpp
@@ -157,21 +157,21 @@ static void NativeBN_BN_div(JNIEnv* env, jclass, jlong q, jlong rem, jlong num,
 }
 
 static void NativeBN_BN_mod_exp(JNIEnv* env, jclass, jlong r, jlong a, jlong p, jlong m) {
   Unique_BN_CTX ctx(BN_CTX_new());
   BN_CTX* ctxp = ctx.get();
   if (!ctxp || !BN_mod_exp(toBigNum(r), toBigNum(a), toBigNum(p), toBigNum(m), ctxp)) {
     throwException(env);
   }
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
    NATIVE_METHOD(NativeBN, BN_div, "(JJJJ)V"),
    NATIVE_METHOD(NativeBN, BN_free, "(J)V"),
    NATIVE_METHOD(NativeBN, BN_mod_exp, "(JJJJ)V"),
    NATIVE_METHOD(NativeBN, BN_mul, "(JJJ)V"),
    NATIVE_METHOD(NativeBN, BN_new, "()J"),
    NATIVE_METHOD(NativeBN, bn2litEndInts, "(J)[I"),
    NATIVE_METHOD(NativeBN, litEndInts2bn, "([IIZJ)V"),
 };
 void register_libcore_math_NativeBN(JNIEnv* env) {
     jniRegisterNativeMethods(env, "libcore/math/NativeBN", gMethods, NELEM(gMethods));
diff --git a/luni/src/main/native/libcore_util_NativeAllocationRegistry.cpp b/luni/src/main/native/libcore_util_NativeAllocationRegistry.cpp
index ded578a95800f4802ff985d3448c8843babb31f5..faaa5c7a7c462ca8b31b9cadaa21d158479cea2f 100644
--- a/luni/src/main/native/libcore_util_NativeAllocationRegistry.cpp
+++ b/luni/src/main/native/libcore_util_NativeAllocationRegistry.cpp
@@ -22,18 +22,18 @@ typedef void (*FreeFunction)(void*);
 static void NativeAllocationRegistry_applyFreeFunction(JNIEnv*,
                                                        jclass,
                                                        jlong freeFunction,
                                                        jlong ptr) {
     void* nativePtr = reinterpret_cast<void*>(static_cast<uintptr_t>(ptr));
     FreeFunction nativeFreeFunction
         = reinterpret_cast<FreeFunction>(static_cast<uintptr_t>(freeFunction));
     nativeFreeFunction(nativePtr);
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     NATIVE_METHOD(NativeAllocationRegistry, applyFreeFunction, "(JJ)V"),
 };
 
 void register_libcore_util_NativeAllocationRegistry(JNIEnv* env) {
     jniRegisterNativeMethods(env, "libcore/util/NativeAllocationRegistry",
         gMethods, NELEM(gMethods));
 }
diff --git a/luni/src/main/native/org_apache_harmony_xml_ExpatParser.cpp b/luni/src/main/native/org_apache_harmony_xml_ExpatParser.cpp
index fdabcf7159117840c97d2f65cb0f6c94d365ce82..62a2cd37b76ae95e50b5a8c45dbcda534d3f6451 100644
--- a/luni/src/main/native/org_apache_harmony_xml_ExpatParser.cpp
+++ b/luni/src/main/native/org_apache_harmony_xml_ExpatParser.cpp
@@ -1359,35 +1359,35 @@ static void ExpatParser_staticInitialize(JNIEnv* env, jobject classObject, jstri
             "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");
     if (unparsedEntityDeclMethod == NULL) return;
 
     internMethod = env->GetMethodID(JniConstants::GetStringClass(env), "intern", "()Ljava/lang/String;");
     if (internMethod == NULL) return;
 
     // Reference to "".
     emptyString = reinterpret_cast<jstring>(env->NewGlobalRef(empty));
 }
 
-static JNINativeMethod parserMethods[] = {
+static const JNINativeMethod parserMethods[] = {
     NATIVE_METHOD(ExpatParser, appendString, "(JLjava/lang/String;Z)V"),
     NATIVE_METHOD(ExpatParser, appendBytes, "(J[BII)V"),
     NATIVE_METHOD(ExpatParser, appendChars, "(J[CII)V"),
     NATIVE_METHOD(ExpatParser, cloneAttributes, "(JI)J"),
     NATIVE_METHOD(ExpatParser, column, "(J)I"),
     NATIVE_METHOD(ExpatParser, createEntityParser, "(JLjava/lang/String;)J"),
     NATIVE_METHOD(ExpatParser, initialize, "(Ljava/lang/String;Z)J"),
     NATIVE_METHOD(ExpatParser, line, "(J)I"),
     NATIVE_METHOD(ExpatParser, release, "(J)V"),
     NATIVE_METHOD(ExpatParser, releaseParser, "(J)V"),
     NATIVE_METHOD(ExpatParser, staticInitialize, "(Ljava/lang/String;)V"),
 };
 
-static JNINativeMethod attributeMethods[] = {
+static const JNINativeMethod attributeMethods[] = {
     NATIVE_METHOD(ExpatAttributes, freeAttributes, "(J)V"),
     NATIVE_METHOD(ExpatAttributes, getIndexForQName, "(JLjava/lang/String;)I"),
     NATIVE_METHOD(ExpatAttributes, getIndex, "(JLjava/lang/String;Ljava/lang/String;)I"),
     NATIVE_METHOD(ExpatAttributes, getLocalName, "(JJI)Ljava/lang/String;"),
     NATIVE_METHOD(ExpatAttributes, getQName, "(JJI)Ljava/lang/String;"),
     NATIVE_METHOD(ExpatAttributes, getURI, "(JJI)Ljava/lang/String;"),
     NATIVE_METHOD(ExpatAttributes, getValueByIndex, "(JI)Ljava/lang/String;"),
     NATIVE_METHOD(ExpatAttributes, getValueForQName, "(JLjava/lang/String;)Ljava/lang/String;"),
     NATIVE_METHOD(ExpatAttributes, getValue, "(JLjava/lang/String;Ljava/lang/String;)Ljava/lang/String;"),
 };
diff --git a/luni/src/main/native/sun_misc_Unsafe.cpp b/luni/src/main/native/sun_misc_Unsafe.cpp
index 49848a2db2b0a613e3ddb1884d533d558aa06fcb..87b2feac80743a5b3ba98e1d696a63f1a0400516 100644
--- a/luni/src/main/native/sun_misc_Unsafe.cpp
+++ b/luni/src/main/native/sun_misc_Unsafe.cpp
@@ -16,16 +16,16 @@
 
 #define LOG_TAG "Unsafe"
 
 #include <nativehelper/JNIHelp.h>
 #include <nativehelper/jni_macros.h>
 
 static jobject Unsafe_allocateInstance(JNIEnv* env, jclass, jclass c) {
   return env->AllocObject(c);
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
   NATIVE_METHOD(Unsafe, allocateInstance, "(Ljava/lang/Class;)Ljava/lang/Object;"),
 };
 void register_sun_misc_Unsafe(JNIEnv* env) {
   jniRegisterNativeMethods(env, "sun/misc/Unsafe", gMethods, NELEM(gMethods));
 }
diff --git a/ojluni/src/main/native/Character.cpp b/ojluni/src/main/native/Character.cpp
index 3e27c674d2f6fcca4e95bd162e1784d469555596..719190c81aebb94b2ae478c006a818ec9a57ba6b 100644
--- a/ojluni/src/main/native/Character.cpp
+++ b/ojluni/src/main/native/Character.cpp
@@ -151,21 +151,21 @@ Character_getNameImpl(JNIEnv* env, jclass, jint codePoint) {
     // that aren't unassigned but that don't have names, and those strings aren't in the form
     // Java specifies.
     bool isControl = (codePoint <= 0x1f || (codePoint >= 0x7f && codePoint <= 0x9f));
     UCharNameChoice nameType = isControl ? U_EXTENDED_CHAR_NAME : U_UNICODE_CHAR_NAME;
     UErrorCode status = U_ZERO_ERROR;
     char buf[BUFSIZ]; // TODO: is there a more sensible upper bound?
     int32_t byteCount = u_charName(codePoint, nameType, &buf[0], sizeof(buf), &status);
     return (U_FAILURE(status) || byteCount == 0) ? NULL : env->NewStringUTF(buf);
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
   FAST_NATIVE_METHOD(Character, digitImpl, "(II)I"),
   FAST_NATIVE_METHOD(Character, getDirectionalityImpl, "(I)B"),
   NATIVE_METHOD(Character, getNameImpl, "(I)Ljava/lang/String;"),
   FAST_NATIVE_METHOD(Character, getNumericValueImpl, "(I)I"),
   FAST_NATIVE_METHOD(Character, getTypeImpl, "(I)I"),
   FAST_NATIVE_METHOD(Character, isAlphabeticImpl, "(I)Z"),
   FAST_NATIVE_METHOD(Character, isDefinedImpl, "(I)Z"),
   FAST_NATIVE_METHOD(Character, isDigitImpl, "(I)Z"),
   FAST_NATIVE_METHOD(Character, isIdentifierIgnorableImpl, "(I)Z"),
   FAST_NATIVE_METHOD(Character, isIdeographicImpl, "(I)Z"),

commit d9a7eb555490d40b83a2c51f8a2a59386d4e9e48
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Wed 2021-07-28 17:13:00-0700

    ZipFile: Add support for opening zip files by fd paths
    
    In some cases, it can be useful to open and parse zip files that are
    only available by fd reference. For example, file descriptors of APKs
    containing files to load may be sent via Binder IPC for clients to use.
    
    Unfortuantely, while it is already possible for StrictJarFile to open
    APKs by file descriptor, using that API is not an option because our
    /proc/self/fd/## path is passed to DexPathList for use in ClassLoader
    implementations.
    
    This is necessary for compatibility with Google Play Services' dynamic
    module system (Dynamite) without weakening the SELinux sandbox to allow
    other apps to open module APKs from
    /data/user_de/0/com.google.android.gms/app_chimera/m.
    
    Change-Id: Ibb099307a4267707f2de73369b5665b7af26352b
---
 ojluni/src/main/native/ZipFile.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/ojluni/src/main/native/ZipFile.c b/ojluni/src/main/native/ZipFile.c
index daf5d8efffff19ac0c02a1296841b485d394a016..a7dce3cf2882af5d8998e5a4c02e70eadb6bc649 100644
--- a/ojluni/src/main/native/ZipFile.c
+++ b/ojluni/src/main/native/ZipFile.c
@@ -102,21 +102,26 @@ ZipFile_open(JNIEnv *env, jclass cls, jstring name,
         zip = ZIP_Get_From_Cache(path, &msg, lastModified);
         if (zip == 0 && msg == 0) {
             ZFILE zfd = 0;
 #ifdef WIN32
             zfd = winFileHandleOpen(env, name, flag);
             if (zfd == -1) {
                 /* Exception already pending. */
                 goto finally;
             }
 #else
-            zfd = JVM_Open(path, flag, 0);
+            if (!strncmp("/proc/self/fd/", path, strlen("/proc/self/fd/")) &&
+                    sscanf(path, "/proc/self/fd/%d", &zfd) == 1) {
+                zfd = dup(zfd);
+            } else {
+                zfd = JVM_Open(path, flag, 0);
+            }
             if (zfd < 0) {
                 throwFileNotFoundException(env, name);
                 goto finally;
             }
 #endif
             zip = ZIP_Put_In_Cache0(path, zfd, &msg, lastModified, usemmap);
         }
 
         if (zip != 0) {
             result = ptr_to_jlong(zip);

commit 7fe2eb0fe63aa08e3a78289604c06eb256e4bcf3
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Sat 2021-07-31 01:48:58-0700

    libcore: Add hooks for Dynamite module support in GmsCompat
    
    These hooks are necessary for GmsCompat to support Google Play Services'
    dynamic module system (Dynamite) without weakening the SELinux sandbox
    to allow other apps to open module APKs from
    /data/user_de/0/com.google.android.gms/app_chimera/m.
    
    To minimize changes in libcore, each hook is a simple interface method
    call that delegates the actual hook code to GmsCompat in
    frameworks/base.
    
    Change-Id: I49c7c2b2fe8b356137dbc90955a7b63684253457
---
 api/module-lib-current.txt                         | 19 +++++++++++++++
 .../dalvik/system/DelegateLastClassLoader.java     | 18 ++++++++++++++-
 .../src/main/java/dalvik/system/DexPathList.java   | 27 ++++++++++++++++++++++
 ojluni/src/main/java/java/io/File.java             | 20 ++++++++++++++++
 4 files changed, 83 insertions(+), 1 deletion(-)

diff --git a/api/module-lib-current.txt b/api/module-lib-current.txt
index 15741a780574b6e8464aa507a8ce8ccd448e4b2d..acaaf62c767b4cc36f159bc07c0c327e6dd93dec 100644
--- a/api/module-lib-current.txt
+++ b/api/module-lib-current.txt
@@ -219,38 +219,53 @@ package dalvik.system {
     method public void warnIfOpen();
   }
 
   public static interface CloseGuard.Reporter {
     method public void report(String, Throwable);
     method public default void report(String);
   }
 
   public final class DelegateLastClassLoader extends dalvik.system.PathClassLoader {
     ctor public DelegateLastClassLoader(String, String, ClassLoader, ClassLoader[]);
+    field public static volatile java.util.function.Function<java.lang.String,java.lang.String> librarySearchPathHook;
   }
 
   @Deprecated public final class DexFile {
     method @Deprecated @NonNull public static dalvik.system.DexFile.OptimizationInfo getDexFileOptimizationInfo(@NonNull String, @NonNull String) throws java.io.FileNotFoundException;
     method @Deprecated @Nullable public static String[] getDexFileOutputPaths(@NonNull String, @NonNull String) throws java.io.FileNotFoundException;
     method @Deprecated public static int getDexOptNeeded(@NonNull String, @NonNull String, @NonNull String, @Nullable String, boolean, boolean) throws java.io.FileNotFoundException, java.io.IOException;
     method @Deprecated @NonNull public static String getSafeModeCompilerFilter(@NonNull String);
     method @Deprecated public static boolean isProfileGuidedCompilerFilter(@NonNull String);
     method @Deprecated public static boolean isValidCompilerFilter(@NonNull String);
     field @Deprecated public static final int DEX2OAT_FOR_FILTER = 3; // 0x3
     field @Deprecated public static final int NO_DEXOPT_NEEDED = 0; // 0x0
   }
 
   @Deprecated public static final class DexFile.OptimizationInfo {
     method @Deprecated @NonNull public String getReason();
     method @Deprecated @NonNull public String getStatus();
   }
 
+  public final class DexPathList {
+    ctor public DexPathList(ClassLoader, String);
+    ctor public DexPathList(ClassLoader, String, String, java.io.File);
+    method public void addDexPath(String, java.io.File);
+    method public void addDexPath(String, java.io.File, boolean);
+    method public void addNativePath(java.util.Collection<java.lang.String>);
+    method public Class<?> findClass(String, java.util.List<java.lang.Throwable>);
+    method public String findLibrary(String);
+    method public java.net.URL findResource(String);
+    method public java.util.Enumeration<java.net.URL> findResources(String);
+    method public java.util.List<java.io.File> getNativeLibraryDirectories();
+    field public static volatile java.util.function.Function<dalvik.system.DexPathList,java.nio.ByteBuffer[]> postConstructorBufferHook;
+  }
+
   public class PathClassLoader extends dalvik.system.BaseDexClassLoader {
     ctor public PathClassLoader(@NonNull String, @Nullable String, @Nullable ClassLoader, @Nullable ClassLoader[]);
   }
 
   public final class RuntimeHooks {
     method public static void setTimeZoneIdSupplier(@NonNull java.util.function.Supplier<java.lang.String>);
     method public static void setUncaughtExceptionPreHandler(@Nullable java.lang.Thread.UncaughtExceptionHandler);
   }
 
   public abstract class SocketTagger {
@@ -373,20 +388,24 @@ package dalvik.system {
     method public static void postForkSystemServer(int);
     method public static void preFork();
     method public static void startZygoteNoThreadCreation();
     method public static void stopZygoteNoThreadCreation();
   }
 
 }
 
 package java.io {
 
+  public class File implements java.lang.Comparable<java.io.File> java.io.Serializable {
+    field public static volatile java.util.function.Function<java.io.File,java.lang.Long> lastModifiedHook;
+  }
+
   public final class FileDescriptor {
     method public int getInt$();
     method public void setInt$(int);
   }
 
   public class FileInputStream extends java.io.InputStream {
     ctor public FileInputStream(java.io.FileDescriptor, boolean);
   }
 
 }
diff --git a/dalvik/src/main/java/dalvik/system/DelegateLastClassLoader.java b/dalvik/src/main/java/dalvik/system/DelegateLastClassLoader.java
index 5966139a3b5c08c6373ad429a60968c8b22bdc55..0231d9ed231af1150f3194926d618c475dd9f8b3 100644
--- a/dalvik/src/main/java/dalvik/system/DelegateLastClassLoader.java
+++ b/dalvik/src/main/java/dalvik/system/DelegateLastClassLoader.java
@@ -18,38 +18,48 @@ package dalvik.system;
 
 import static android.annotation.SystemApi.Client.MODULE_LIBRARIES;
 
 import android.annotation.SystemApi;
 
 import sun.misc.CompoundEnumeration;
 
 import java.io.IOException;
 import java.net.URL;
 import java.util.Enumeration;
+import java.util.function.Function;
 
+import libcore.api.CorePlatformApi;
 import libcore.util.NonNull;
 import libcore.util.Nullable;
 
 /**
  * A {@code ClassLoader} implementation that implements a <b>delegate last</b> lookup policy.
  * For every class or resource this loader is requested to load, the following lookup order
  * is employed:
  *
  * <ul>
  *     <li>The boot classpath is always searched first</li>
  *     <li>Then, the list of {@code dex} files associated with this classloaders's
  *     {@code dexPath} is searched.</li>
  *     <li>Finally, this classloader will delegate to the specified {@code parent}.</li>
  * </ul>
  */
 public final class DelegateLastClassLoader extends PathClassLoader {
 
+    /**
+     * Pre-constructor librarySearchPath hook for GmsCompat
+     * @hide
+     */
+    @SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)
+    @CorePlatformApi(status = CorePlatformApi.Status.STABLE)
+    public static volatile Function<String, String> librarySearchPathHook;
+
     /**
      * Whether resource loading delegates to the parent class loader. True by default.
      */
     private final boolean delegateResourceLoading;
 
     /**
      * Equivalent to calling {@link #DelegateLastClassLoader(String, String, ClassLoader, boolean)}
      * with {@code librarySearchPath = null, delegateResourceLoading = true}.
      */
     public DelegateLastClassLoader(String dexPath, ClassLoader parent) {
@@ -96,21 +106,21 @@ public final class DelegateLastClassLoader extends PathClassLoader {
      * @param librarySearchPath the list of directories containing native libraries, delimited
      *                          by {@code File.pathSeparator}; may be {@code null}.
      * @param parent the parent class loader. May be {@code null} for the boot classloader.
      * @param delegateResourceLoading whether to delegate resource loading to the parent if
      *                                the resource is not found. This does not affect class
      *                                loading delegation.
      */
 
     public DelegateLastClassLoader(@NonNull String dexPath, @Nullable String librarySearchPath,
             @Nullable ClassLoader parent, boolean delegateResourceLoading) {
-        super(dexPath, librarySearchPath, parent);
+        super(dexPath, filterLibrarySearchPath(librarySearchPath), parent);
         this.delegateResourceLoading = delegateResourceLoading;
     }
 
     /**
      * Creates a {@code DelegateLastClassLoader} that operates on a given {@code dexPath}
      * and a {@code librarySearchPath}.
      *
      * The {@code dexPath} should consist of one or more of the following, separated by
      * {@code File.pathSeparator}, which is {@code ":"} on Android.
      *
@@ -135,20 +145,26 @@ public final class DelegateLastClassLoader extends PathClassLoader {
     @libcore.api.CorePlatformApi(status = libcore.api.CorePlatformApi.Status.STABLE)
     @SystemApi(client = MODULE_LIBRARIES)
     public DelegateLastClassLoader(
             String dexPath, String librarySearchPath, ClassLoader parent,
             ClassLoader[] sharedLibraryLoaders) {
         super(dexPath, librarySearchPath, parent, sharedLibraryLoaders);
         // Delegating is the default behavior.
         this.delegateResourceLoading = true;
     }
 
+    private static String filterLibrarySearchPath(String librarySearchPath) {
+        return librarySearchPathHook == null ?
+                librarySearchPath :
+                librarySearchPathHook.apply(librarySearchPath);
+    }
+
     @Override
     protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
         // First, check whether the class has already been loaded. Return it if that's the
         // case.
         Class<?> cl = findLoadedClass(name);
         if (cl != null) {
             return cl;
         }
 
         // Next, check whether the class in question is present in the boot classpath.
diff --git a/dalvik/src/main/java/dalvik/system/DexPathList.java b/dalvik/src/main/java/dalvik/system/DexPathList.java
index acf5e6635e7a4f28316dd021e6bc02416fdf55af..ee2bf10d473e82b3589aea02d35060d18424d675 100644
--- a/dalvik/src/main/java/dalvik/system/DexPathList.java
+++ b/dalvik/src/main/java/dalvik/system/DexPathList.java
@@ -9,37 +9,41 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package dalvik.system;
 
+import android.annotation.SystemApi;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.system.ErrnoException;
 import android.system.StructStat;
 
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.List;
 import java.util.Objects;
+import java.util.function.Function;
+
+import libcore.api.CorePlatformApi;
 import libcore.io.ClassPathURLStreamHandler;
 import libcore.io.IoUtils;
 import libcore.io.Libcore;
 
 import static android.system.OsConstants.S_ISDIR;
 
 /**
  * A pair of lists of entries, associated with a {@code ClassLoader}.
  * One of the lists is a dex/resource path &mdash; typically referred
  * to as a "class path" &mdash; list, and the other names directories
@@ -47,24 +51,34 @@ import static android.system.OsConstants.S_ISDIR;
  * a {@code .jar} or {@code .zip} file containing an optional
  * top-level {@code classes.dex} file as well as arbitrary resources,
  * or a plain {@code .dex} file (with no possibility of associated
  * resources).
  *
  * <p>This class also contains methods to use these lists to look up
  * classes and resources.</p>
  *
  * @hide
  */
+@SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)
+@CorePlatformApi(status = CorePlatformApi.Status.STABLE)
 public final class DexPathList {
     private static final String DEX_SUFFIX = ".dex";
     private static final String zipSeparator = "!/";
 
+    /**
+     * Post-constructor hook for GmsCompat
+     * @hide
+     */
+    @SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)
+    @CorePlatformApi(status = CorePlatformApi.Status.STABLE)
+    public static volatile Function<DexPathList, ByteBuffer[]> postConstructorBufferHook;
+
     /** class definition context */
     @UnsupportedAppUsage
     private final ClassLoader definingContext;
 
     /**
      * List of dex/resource (class path) elements.
      * Should be called pathElements, but the Facebook app uses reflection
      * to modify 'dexElements' (http://b/7726934).
      */
     @UnsupportedAppUsage
@@ -180,20 +194,32 @@ public final class DexPathList {
         this.systemNativeLibraryDirectories =
                 splitPaths(System.getProperty("java.library.path"), true);
         this.nativeLibraryPathElements = makePathElements(getAllNativeLibraryDirectories());
 
         if (suppressedExceptions.size() > 0) {
             this.dexElementsSuppressedExceptions =
                 suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);
         } else {
             dexElementsSuppressedExceptions = null;
         }
+
+        runGmsCompatHook();
+    }
+
+    private void runGmsCompatHook() {
+        if (postConstructorBufferHook != null) {
+            ByteBuffer[] buffers = postConstructorBufferHook.apply(this);
+            if (buffers != null) {
+                dexElements = null;
+                initByteBufferDexPath(buffers);
+            }
+        }
     }
 
     @Override public String toString() {
         return "DexPathList[" + Arrays.toString(dexElements) +
             ",nativeLibraryDirectories=" +
             Arrays.toString(getAllNativeLibraryDirectories().toArray()) + "]";
     }
 
     /**
      * For BaseDexClassLoader.getLdLibraryPath.
@@ -325,20 +351,21 @@ public final class DexPathList {
                     }
                 }
                 result.add(new File(path));
             }
         }
 
         return result;
     }
 
     // This method is not used anymore. Kept around only because there are many legacy users of it.
+    /** @hide */
     @SuppressWarnings("unused")
     @UnsupportedAppUsage
     public static Element[] makeInMemoryDexElements(ByteBuffer[] dexFiles,
             List<IOException> suppressedExceptions) {
         Element[] elements = new Element[dexFiles.length];
         int elementPos = 0;
         for (ByteBuffer buf : dexFiles) {
             try {
                 DexFile dex = new DexFile(new ByteBuffer[] { buf }, /* classLoader */ null,
                         /* dexElements */ null);
diff --git a/ojluni/src/main/java/java/io/File.java b/ojluni/src/main/java/java/io/File.java
index 003753411843534fb1d4521722f2e435c229a73b..06cd18c6bc867004cdd31d401bdc7a9fd712e713 100644
--- a/ojluni/src/main/java/java/io/File.java
+++ b/ojluni/src/main/java/java/io/File.java
@@ -19,29 +19,35 @@
  * 2 along with this work; if not, write to the Free Software Foundation,
  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  *
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
 package java.io;
 
+import android.annotation.SystemApi;
+
+import libcore.api.CorePlatformApi;
+
 import java.net.URI;
 import java.net.URL;
 import java.net.MalformedURLException;
 import java.net.URISyntaxException;
 import java.util.List;
 import java.util.ArrayList;
 import java.security.AccessController;
 import java.nio.file.Path;
 import java.nio.file.FileSystems;
+import java.util.function.Function;
+
 import sun.security.action.GetPropertyAction;
 
 // Android-added: Info about UTF-8 usage in filenames.
 /**
  * An abstract representation of file and directory pathnames.
  *
  * <p> User interfaces and operating systems use system-dependent <em>pathname
  * strings</em> to name files and directories.  This class presents an
  * abstract, system-independent view of hierarchical pathnames.  An
  * <em>abstract pathname</em> has two components:
@@ -154,20 +160,28 @@ import sun.security.action.GetPropertyAction;
 
 public class File
     implements Serializable, Comparable<File>
 {
 
     /**
      * The FileSystem object representing the platform's local file system.
      */
     private static final FileSystem fs = DefaultFileSystem.getFileSystem();
 
+    /**
+     * File#lastModified() hook for GmsCompat
+     * @hide
+     */
+    @SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)
+    @CorePlatformApi(status = CorePlatformApi.Status.STABLE)
+    public static volatile Function<File, Long> lastModifiedHook;
+
     /**
      * This abstract pathname's normalized pathname string. A normalized
      * pathname string uses the default name-separator character and does not
      * contain any duplicate or redundant separators.
      *
      * @serial
      */
     private final String path;
 
     /**
@@ -927,20 +941,26 @@ public class File
      *          method denies read access to the file
      */
     public long lastModified() {
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
             security.checkRead(path);
         }
         if (isInvalid()) {
             return 0L;
         }
+        if (lastModifiedHook != null) {
+            Long lastModified = lastModifiedHook.apply(this);
+            if (lastModified != null) {
+                return lastModified;
+            }
+        }
         return fs.getLastModifiedTime(this);
     }
 
     /**
      * Returns the length of the file denoted by this abstract pathname.
      * The return value is unspecified if this pathname denotes a directory.
      *
      * <p> Where it is required to distinguish an I/O exception from the case
      * that {@code 0L} is returned, or where several attributes of the same file
      * are required at the same time, then the {@link

commit f97cbc543dfa12d8f125243d16a9a5acfc6e2968
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2019-09-11 06:46:38-0400

    add parameter for avoiding full preload with exec
---
 api/module-lib-current.txt                         |  2 ++
 .../src/main/java/dalvik/system/ZygoteHooks.java   | 26 ++++++++++++++++++++--
 .../api/legacy_platform/current.txt                |  2 ++
 .../api/stable_platform/current.txt                |  2 ++
 4 files changed, 30 insertions(+), 2 deletions(-)

diff --git a/api/module-lib-current.txt b/api/module-lib-current.txt
index acaaf62c767b4cc36f159bc07c0c327e6dd93dec..ff55992acc6007812c94aafac9a9371e647fe8a0 100644
--- a/api/module-lib-current.txt
+++ b/api/module-lib-current.txt
@@ -374,21 +374,23 @@ package dalvik.system {
     field public static final int ACCESS_METHOD_REFLECTION = 1; // 0x1
   }
 
   public final class VMStack {
     method @Nullable @dalvik.annotation.optimization.FastNative public static dalvik.system.AnnotatedStackTraceElement[] getAnnotatedThreadStackTrace(Thread);
   }
 
   public final class ZygoteHooks {
     method public static void gcAndFinalize();
     method public static boolean isIndefiniteThreadSuspensionSafe();
+    method public static void onBeginPreload(boolean);
     method public static void onBeginPreload();
+    method public static void onEndPreload(boolean);
     method public static void onEndPreload();
     method public static void postForkChild(int, boolean, boolean, String);
     method public static void postForkCommon();
     method public static void postForkSystemServer(int);
     method public static void preFork();
     method public static void startZygoteNoThreadCreation();
     method public static void stopZygoteNoThreadCreation();
   }
 
 }
diff --git a/dalvik/src/main/java/dalvik/system/ZygoteHooks.java b/dalvik/src/main/java/dalvik/system/ZygoteHooks.java
index a17a2574f7bcdde75ff66eac63b11782d56010d8..763511d21870e7b0058eda5f52474286b57167f2 100644
--- a/dalvik/src/main/java/dalvik/system/ZygoteHooks.java
+++ b/dalvik/src/main/java/dalvik/system/ZygoteHooks.java
@@ -55,55 +55,77 @@ public final class ZygoteHooks {
     @libcore.api.CorePlatformApi(status = libcore.api.CorePlatformApi.Status.STABLE)
     public static native void startZygoteNoThreadCreation();
 
     /**
      * Called when the zygote begins preloading classes and data.
      *
      * @hide
      */
     @SystemApi(client = MODULE_LIBRARIES)
     @libcore.api.CorePlatformApi(status = libcore.api.CorePlatformApi.Status.STABLE)
-    public static void onBeginPreload() {
+    public static void onBeginPreload(boolean fullPreload) {
         com.android.i18n.system.ZygoteHooks.onBeginPreload();
 
         ICU.initializeCacheInZygote();
 
         // Look up JaCoCo on the boot classpath, if it exists. This will be used later for enabling
         // memory-mapped Java coverage.
         try {
           Class<?> jacocoOfflineClass = Class.forName("org.jacoco.agent.rt.internal.Offline");
           enableMemoryMappedDataMethod = jacocoOfflineClass.getMethod("enableMemoryMappedData");
         } catch (ClassNotFoundException e) {
           // JaCoCo was not on the boot classpath, so this is not a coverage build.
         } catch (NoSuchMethodException e) {
           // Method was not found in the JaCoCo Offline class. The version of JaCoCo is not
           // compatible with memory-mapped coverage.
           throw new RuntimeException(e);
         }
     }
 
+    /**
+     * Called when the zygote begins preloading classes and data.
+     *
+     * @hide
+     */
+    @SystemApi(client = MODULE_LIBRARIES)
+    @libcore.api.CorePlatformApi(status = libcore.api.CorePlatformApi.Status.STABLE)
+    public static void onBeginPreload() {
+        onBeginPreload(true);
+    }
+
     /**
      * Called when the zygote has completed preloading classes and data.
      *
      * @hide
      */
     @SystemApi(client = MODULE_LIBRARIES)
     @libcore.api.CorePlatformApi(status = libcore.api.CorePlatformApi.Status.STABLE)
-    public static void onEndPreload() {
+    public static void onEndPreload(boolean fullPreload) {
         com.android.i18n.system.ZygoteHooks.onEndPreload();
 
         // Clone standard descriptors as originals closed / rebound during zygote post fork.
         FileDescriptor.in.cloneForFork();
         FileDescriptor.out.cloneForFork();
         FileDescriptor.err.cloneForFork();
     }
 
+    /**
+     * Called when the zygote has completed preloading classes and data.
+     *
+     * @hide
+     */
+    @SystemApi(client = MODULE_LIBRARIES)
+    @libcore.api.CorePlatformApi(status = libcore.api.CorePlatformApi.Status.STABLE)
+    public static void onEndPreload() {
+        onEndPreload(true);
+    }
+
     /**
      * Runs several special GCs to try to clean up a few generations of
      * softly- and final-reachable objects, along with any other garbage.
      * This is only useful just before a fork().
      *
      * @hide
      */
     @SystemApi(client = MODULE_LIBRARIES)
     @libcore.api.CorePlatformApi(status = libcore.api.CorePlatformApi.Status.STABLE)
     public static void gcAndFinalize() {
diff --git a/mmodules/core_platform_api/api/legacy_platform/current.txt b/mmodules/core_platform_api/api/legacy_platform/current.txt
index 15741a780574b6e8464aa507a8ce8ccd448e4b2d..e554dd77cb84cd647b38ddf40fad63f8adba4e8d 100644
--- a/mmodules/core_platform_api/api/legacy_platform/current.txt
+++ b/mmodules/core_platform_api/api/legacy_platform/current.txt
@@ -359,21 +359,23 @@ package dalvik.system {
     field public static final int ACCESS_METHOD_REFLECTION = 1; // 0x1
   }
 
   public final class VMStack {
     method @Nullable @dalvik.annotation.optimization.FastNative public static dalvik.system.AnnotatedStackTraceElement[] getAnnotatedThreadStackTrace(Thread);
   }
 
   public final class ZygoteHooks {
     method public static void gcAndFinalize();
     method public static boolean isIndefiniteThreadSuspensionSafe();
+    method public static void onBeginPreload(boolean);
     method public static void onBeginPreload();
+    method public static void onEndPreload(boolean);
     method public static void onEndPreload();
     method public static void postForkChild(int, boolean, boolean, String);
     method public static void postForkCommon();
     method public static void postForkSystemServer(int);
     method public static void preFork();
     method public static void startZygoteNoThreadCreation();
     method public static void stopZygoteNoThreadCreation();
   }
 
 }
diff --git a/mmodules/core_platform_api/api/stable_platform/current.txt b/mmodules/core_platform_api/api/stable_platform/current.txt
index 15741a780574b6e8464aa507a8ce8ccd448e4b2d..e554dd77cb84cd647b38ddf40fad63f8adba4e8d 100644
--- a/mmodules/core_platform_api/api/stable_platform/current.txt
+++ b/mmodules/core_platform_api/api/stable_platform/current.txt
@@ -359,21 +359,23 @@ package dalvik.system {
     field public static final int ACCESS_METHOD_REFLECTION = 1; // 0x1
   }
 
   public final class VMStack {
     method @Nullable @dalvik.annotation.optimization.FastNative public static dalvik.system.AnnotatedStackTraceElement[] getAnnotatedThreadStackTrace(Thread);
   }
 
   public final class ZygoteHooks {
     method public static void gcAndFinalize();
     method public static boolean isIndefiniteThreadSuspensionSafe();
+    method public static void onBeginPreload(boolean);
     method public static void onBeginPreload();
+    method public static void onEndPreload(boolean);
     method public static void onEndPreload();
     method public static void postForkChild(int, boolean, boolean, String);
     method public static void postForkCommon();
     method public static void postForkSystemServer(int);
     method public static void preFork();
     method public static void startZygoteNoThreadCreation();
     method public static void stopZygoteNoThreadCreation();
   }
 
 }

commit f60a66c6a82d16cdc804cf775218fbcf7e3d1731 (HEAD, m/master, grapheneos/12)
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2021-10-14 17:00:10-0400

    disable ICU cache pinning for exec spawning
---
 dalvik/src/main/java/dalvik/system/ZygoteHooks.java | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/dalvik/src/main/java/dalvik/system/ZygoteHooks.java b/dalvik/src/main/java/dalvik/system/ZygoteHooks.java
index 763511d21870e7b0058eda5f52474286b57167f2..179c19ac8d5a54f92acf444e82e5727ea1db77a5 100644
--- a/dalvik/src/main/java/dalvik/system/ZygoteHooks.java
+++ b/dalvik/src/main/java/dalvik/system/ZygoteHooks.java
@@ -56,23 +56,25 @@ public final class ZygoteHooks {
     public static native void startZygoteNoThreadCreation();
 
     /**
      * Called when the zygote begins preloading classes and data.
      *
      * @hide
      */
     @SystemApi(client = MODULE_LIBRARIES)
     @libcore.api.CorePlatformApi(status = libcore.api.CorePlatformApi.Status.STABLE)
     public static void onBeginPreload(boolean fullPreload) {
-        com.android.i18n.system.ZygoteHooks.onBeginPreload();
+        if (fullPreload) {
+            com.android.i18n.system.ZygoteHooks.onBeginPreload();
 
-        ICU.initializeCacheInZygote();
+            ICU.initializeCacheInZygote();
+        }
 
         // Look up JaCoCo on the boot classpath, if it exists. This will be used later for enabling
         // memory-mapped Java coverage.
         try {
           Class<?> jacocoOfflineClass = Class.forName("org.jacoco.agent.rt.internal.Offline");
           enableMemoryMappedDataMethod = jacocoOfflineClass.getMethod("enableMemoryMappedData");
         } catch (ClassNotFoundException e) {
           // JaCoCo was not on the boot classpath, so this is not a coverage build.
         } catch (NoSuchMethodException e) {
           // Method was not found in the JaCoCo Offline class. The version of JaCoCo is not
@@ -93,21 +95,23 @@ public final class ZygoteHooks {
     }
 
     /**
      * Called when the zygote has completed preloading classes and data.
      *
      * @hide
      */
     @SystemApi(client = MODULE_LIBRARIES)
     @libcore.api.CorePlatformApi(status = libcore.api.CorePlatformApi.Status.STABLE)
     public static void onEndPreload(boolean fullPreload) {
-        com.android.i18n.system.ZygoteHooks.onEndPreload();
+        if (fullPreload) {
+            com.android.i18n.system.ZygoteHooks.onEndPreload();
+        }
 
         // Clone standard descriptors as originals closed / rebound during zygote post fork.
         FileDescriptor.in.cloneForFork();
         FileDescriptor.out.cloneForFork();
         FileDescriptor.err.cloneForFork();
     }
 
     /**
      * Called when the zygote has completed preloading classes and data.
      *

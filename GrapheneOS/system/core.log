commit 0b3bd63d593f3182ab6295695dc092f8a9b0eb20
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2018-12-13 09:26:25-0500

    increase max_map_count for hardened malloc
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 rootdir/init.rc | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index 5116c0fead7905fcc2485f00d60430f06cbd2f3e..7176c694cc631ab623f883f37808cbbf3a8513ac 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -1017,20 +1017,22 @@ on boot
     chmod 0664 /sys/block/zram0/writeback
 
     # to access F2FS sysfs on dm-<num> directly
     mkdir /dev/sys/fs/by-name 0755 system system
     symlink /sys/fs/f2fs/${dev.mnt.blk.data} /dev/sys/fs/by-name/userdata
 
     # to access dm-<num> sysfs
     mkdir /dev/sys/block/by-name 0755 system system
     symlink /sys/devices/virtual/block/${dev.mnt.blk.data} /dev/sys/block/by-name/userdata
 
+    write /proc/sys/vm/max_map_count 1048576
+
     # F2FS tuning. Set cp_interval larger than dirty_expire_centisecs, 30 secs,
     # to avoid power consumption when system becomes mostly idle. Be careful
     # to make it too large, since it may bring userdata loss, if they
     # are not aware of using fsync()/sync() to prepare sudden power-cut.
     write /dev/sys/fs/by-name/userdata/cp_interval 200
     write /dev/sys/fs/by-name/userdata/gc_urgent_sleep_time 50
     write /dev/sys/fs/by-name/userdata/iostat_enable 1
 
     # limit discard size to 128MB in order to avoid long IO latency
     # for filesystem tuning first (dm or sda)

commit 8edccf1498a72f50deb3f5056d961ffaf1fc1d07
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2015-02-06 11:46:34-0500

    tighten up mount permissions
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 init/first_stage_init.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/init/first_stage_init.cpp b/init/first_stage_init.cpp
index c7b7b0c134b3f0a51bcb3239cca4814c9961f63a..3ccacf56e004f403695b1cab7d9f7e2730cc5037 100644
--- a/init/first_stage_init.cpp
+++ b/init/first_stage_init.cpp
@@ -195,35 +195,35 @@ int FirstStageMain(int argc, char** argv) {
     umask(0);
 
     CHECKCALL(clearenv());
     CHECKCALL(setenv("PATH", _PATH_DEFPATH, 1));
     // Get the basic filesystem setup we need put together in the initramdisk
     // on / and then we'll let the rc file figure out the rest.
     CHECKCALL(mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755"));
     CHECKCALL(mkdir("/dev/pts", 0755));
     CHECKCALL(mkdir("/dev/socket", 0755));
     CHECKCALL(mkdir("/dev/dm-user", 0755));
-    CHECKCALL(mount("devpts", "/dev/pts", "devpts", 0, NULL));
+    CHECKCALL(mount("devpts", "/dev/pts", "devpts", MS_NOSUID|MS_NOEXEC, NULL));
 #define MAKE_STR(x) __STRING(x)
-    CHECKCALL(mount("proc", "/proc", "proc", 0, "hidepid=2,gid=" MAKE_STR(AID_READPROC)));
+    CHECKCALL(mount("proc", "/proc", "proc", MS_NOSUID|MS_NODEV|MS_NOEXEC, "hidepid=2,gid=" MAKE_STR(AID_READPROC)));
 #undef MAKE_STR
     // Don't expose the raw commandline to unprivileged processes.
     CHECKCALL(chmod("/proc/cmdline", 0440));
     std::string cmdline;
     android::base::ReadFileToString("/proc/cmdline", &cmdline);
     // Don't expose the raw bootconfig to unprivileged processes.
     chmod("/proc/bootconfig", 0440);
     std::string bootconfig;
     android::base::ReadFileToString("/proc/bootconfig", &bootconfig);
     gid_t groups[] = {AID_READPROC};
     CHECKCALL(setgroups(arraysize(groups), groups));
-    CHECKCALL(mount("sysfs", "/sys", "sysfs", 0, NULL));
+    CHECKCALL(mount("sysfs", "/sys", "sysfs", MS_NOSUID|MS_NODEV|MS_NOEXEC, NULL));
     CHECKCALL(mount("selinuxfs", "/sys/fs/selinux", "selinuxfs", 0, NULL));
 
     CHECKCALL(mknod("/dev/kmsg", S_IFCHR | 0600, makedev(1, 11)));
 
     if constexpr (WORLD_WRITABLE_KMSG) {
         CHECKCALL(mknod("/dev/kmsg_debug", S_IFCHR | 0622, makedev(1, 11)));
     }
 
     CHECKCALL(mknod("/dev/random", S_IFCHR | 0666, makedev(1, 8)));
     CHECKCALL(mknod("/dev/urandom", S_IFCHR | 0666, makedev(1, 9)));

commit c3a604a43cc055b1aba406b7b10ef2844a036189
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2016-06-15 17:51:42-0400

    add properties for controlling deny_new_usb
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 rootdir/init.rc | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index 7176c694cc631ab623f883f37808cbbf3a8513ac..03453be5cbc318408be56fcc2faaa2539ccdf902 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -1158,20 +1158,32 @@ on property:sys.sysctl.extra_free_kbytes=*
 
 # Allow users to drop caches
 on property:perf.drop_caches=3
     write /proc/sys/vm/drop_caches 3
     setprop perf.drop_caches 0
 
 # "tcp_default_init_rwnd" Is too long!
 on property:net.tcp_def_init_rwnd=*
     write /proc/sys/net/ipv4/tcp_default_init_rwnd ${net.tcp_def_init_rwnd}
 
+on property:persist.security.deny_new_usb=disabled
+    write /proc/sys/kernel/deny_new_usb 0
+
+on property:persist.security.deny_new_usb=enabled
+    write /proc/sys/kernel/deny_new_usb 1
+
+on property:persist.security.deny_new_usb=dynamic
+    write /proc/sys/kernel/deny_new_usb 1
+
+on property:security.deny_new_usb=*
+    write /proc/sys/kernel/deny_new_usb ${security.deny_new_usb}
+
 # perf_event_open syscall security:
 # Newer kernels have the ability to control the use of the syscall via SELinux
 # hooks. init tests for this, and sets sys_init.perf_lsm_hooks to 1 if the
 # kernel has the hooks. In this case, the system-wide perf_event_paranoid
 # sysctl is set to -1 (unrestricted use), and the SELinux policy is used for
 # controlling access. On older kernels, the paranoid value is the only means of
 # controlling access. It is normally 3 (allow only root), but the shell user
 # can lower it to 1 (allowing thread-scoped pofiling) via security.perf_harden.
 on property:sys.init.perf_lsm_hooks=1
     write /proc/sys/kernel/perf_event_paranoid -1

commit ddf48612c160b13552588af4d64bc7bb55571618
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-07-16 14:49:29-0400

    enable kernel mitigations for link races
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 rootdir/init.rc | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index 03453be5cbc318408be56fcc2faaa2539ccdf902..832766e0b9fff93b9321abe7de0fe57dadf9ff88 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -280,20 +280,23 @@ on init
     mkdir /mnt/runtime/full/self 0755 root root
 
     # Symlink to keep legacy apps working in multi-user world
     symlink /storage/self/primary /mnt/sdcard
     symlink /mnt/user/0/primary /mnt/runtime/default/self/primary
 
     write /proc/sys/kernel/panic_on_oops 1
     write /proc/sys/kernel/hung_task_timeout_secs 0
     write /proc/cpu/alignment 4
 
+    write /proc/sys/fs/protected_hardlinks 1
+    write /proc/sys/fs/protected_symlinks 1
+
     # scheduler tunables
     # Disable auto-scaling of scheduler tunables with hotplug. The tunables
     # will vary across devices in unpredictable ways if allowed to scale with
     # cpu cores.
     write /proc/sys/kernel/sched_tunable_scaling 0
     write /proc/sys/kernel/sched_latency_ns 10000000
     write /proc/sys/kernel/sched_wakeup_granularity_ns 2000000
     write /proc/sys/kernel/sched_child_runs_first 0
 
     write /proc/sys/kernel/randomize_va_space 2

commit fc8f654d4f905ee88c3cdd3494c6a65b2de6d5a1
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-07-16 14:54:28-0400

    enable kernel mitigations for file spoofing
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 rootdir/init.rc | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index 832766e0b9fff93b9321abe7de0fe57dadf9ff88..b27bb71bcd966728d85615d70e9c967af8a406db 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -283,20 +283,23 @@ on init
     symlink /storage/self/primary /mnt/sdcard
     symlink /mnt/user/0/primary /mnt/runtime/default/self/primary
 
     write /proc/sys/kernel/panic_on_oops 1
     write /proc/sys/kernel/hung_task_timeout_secs 0
     write /proc/cpu/alignment 4
 
     write /proc/sys/fs/protected_hardlinks 1
     write /proc/sys/fs/protected_symlinks 1
 
+    write /proc/sys/fs/protected_fifos 2
+    write /proc/sys/fs/protected_regular 2
+
     # scheduler tunables
     # Disable auto-scaling of scheduler tunables with hotplug. The tunables
     # will vary across devices in unpredictable ways if allowed to scale with
     # cpu cores.
     write /proc/sys/kernel/sched_tunable_scaling 0
     write /proc/sys/kernel/sched_latency_ns 10000000
     write /proc/sys/kernel/sched_wakeup_granularity_ns 2000000
     write /proc/sys/kernel/sched_child_runs_first 0
 
     write /proc/sys/kernel/randomize_va_space 2

commit e3f9fc0f142294720e0cc69b6b80a336747def72
Author: flawedworld <38294951+flawedworld@users.noreply.github.com>
Date:   Mon 2021-04-05 03:02:51+0100

    add a property for controlling ptrace_scope
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 rootdir/init.rc | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index b27bb71bcd966728d85615d70e9c967af8a406db..59a42334df906f157053411621dfbf6337affb9c 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -1176,20 +1176,26 @@ on property:persist.security.deny_new_usb=disabled
 
 on property:persist.security.deny_new_usb=enabled
     write /proc/sys/kernel/deny_new_usb 1
 
 on property:persist.security.deny_new_usb=dynamic
     write /proc/sys/kernel/deny_new_usb 1
 
 on property:security.deny_new_usb=*
     write /proc/sys/kernel/deny_new_usb ${security.deny_new_usb}
 
+on property:persist.native_debug=true
+    write /proc/sys/kernel/yama/ptrace_scope 0
+
+on property:persist.native_debug=false
+    write /proc/sys/kernel/yama/ptrace_scope 2
+
 # perf_event_open syscall security:
 # Newer kernels have the ability to control the use of the syscall via SELinux
 # hooks. init tests for this, and sets sys_init.perf_lsm_hooks to 1 if the
 # kernel has the hooks. In this case, the system-wide perf_event_paranoid
 # sysctl is set to -1 (unrestricted use), and the SELinux policy is used for
 # controlling access. On older kernels, the paranoid value is the only means of
 # controlling access. It is normally 3 (allow only root), but the shell user
 # can lower it to 1 (allowing thread-scoped pofiling) via security.perf_harden.
 on property:sys.init.perf_lsm_hooks=1
     write /proc/sys/kernel/perf_event_paranoid -1

commit 3ab75101ae79e416c9c74a524b9b736da4762bf5 (HEAD, tag: SP2A.220305.012.2022030801, m/master, grapheneos/12.1)
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2022-03-10 13:37:52-0500

    Revert "init: Wait for snapuserd before starting second stage"
    
    This reverts commit 7043054dfee9e29cd9a77903d7d63ed2a07e1707.
---
 init/snapuserd_transition.cpp | 58 -------------------------------------------
 init/snapuserd_transition.h   |  1 -
 2 files changed, 59 deletions(-)

diff --git a/init/snapuserd_transition.cpp b/init/snapuserd_transition.cpp
index 7fd3f65ca621e8ba5f380adde93fd8e1c32512d2..40467b7d37bc84727fe7434ce6f9fd4ce1ee8a8d 100644
--- a/init/snapuserd_transition.cpp
+++ b/init/snapuserd_transition.cpp
@@ -25,21 +25,20 @@
 #include <filesystem>
 #include <string>
 #include <string_view>
 
 #include <android-base/file.h>
 #include <android-base/logging.h>
 #include <android-base/parseint.h>
 #include <android-base/strings.h>
 #include <android-base/unique_fd.h>
 #include <cutils/sockets.h>
-#include <fs_avb/fs_avb.h>
 #include <libsnapshot/snapshot.h>
 #include <libsnapshot/snapuserd_client.h>
 #include <private/android_filesystem_config.h>
 #include <procinfo/process_map.h>
 #include <selinux/android.h>
 
 #include "block_dev_initializer.h"
 #include "service_utils.h"
 #include "util.h"
 
@@ -221,70 +220,20 @@ void SnapuserdSelinuxHelper::FinishTransition() {
     selinux_android_restorecon("/dev/kmsg", 0);
     selinux_android_restorecon("/dev/dm-user", SELINUX_ANDROID_RESTORECON_RECURSE);
 
     RelaunchFirstStageSnapuserd();
 
     if (munlockall() < 0) {
         PLOG(ERROR) << "munlockall failed";
     }
 }
 
-/*
- * Before starting init second stage, we will wait
- * for snapuserd daemon to be up and running; bionic libc
- * may read /system/etc/selinux/plat_property_contexts file
- * before invoking main() function. This will happen if
- * init initializes property during second stage. Any access
- * to /system without snapuserd daemon will lead to a deadlock.
- *
- * Thus, we do a simple probe by reading system partition. This
- * read will eventually be serviced by daemon confirming that
- * daemon is up and running. Furthermore, we are still in the kernel
- * domain and sepolicy has not been enforced yet. Thus, access
- * to these device mapper block devices are ok even though
- * we may see audit logs.
- */
-bool SnapuserdSelinuxHelper::TestSnapuserdIsReady() {
-    std::string dev = "/dev/block/mapper/system"s + fs_mgr_get_slot_suffix();
-    android::base::unique_fd fd(open(dev.c_str(), O_RDONLY | O_DIRECT));
-    if (fd < 0) {
-        PLOG(ERROR) << "open " << dev << " failed";
-        return false;
-    }
-
-    void* addr;
-    ssize_t page_size = getpagesize();
-    if (posix_memalign(&addr, page_size, page_size) < 0) {
-        PLOG(ERROR) << "posix_memalign with page size " << page_size;
-        return false;
-    }
-
-    std::unique_ptr<void, decltype(&::free)> buffer(addr, ::free);
-
-    int iter = 0;
-    while (iter < 10) {
-        ssize_t n = TEMP_FAILURE_RETRY(pread(fd.get(), buffer.get(), page_size, 0));
-        if (n < 0) {
-            // Wait for sometime before retry
-            std::this_thread::sleep_for(100ms);
-        } else if (n == page_size) {
-            return true;
-        } else {
-            LOG(ERROR) << "pread returned: " << n << " from: " << dev << " expected: " << page_size;
-        }
-
-        iter += 1;
-    }
-
-    return false;
-}
-
 void SnapuserdSelinuxHelper::RelaunchFirstStageSnapuserd() {
     auto fd = GetRamdiskSnapuserdFd();
     if (!fd) {
         LOG(FATAL) << "Environment variable " << kSnapuserdFirstStageFdVar << " was not set!";
     }
     unsetenv(kSnapuserdFirstStageFdVar);
 
     RestoreconRamdiskSnapuserd(fd.value());
 
     pid_t pid = fork();
@@ -292,27 +241,20 @@ void SnapuserdSelinuxHelper::RelaunchFirstStageSnapuserd() {
         PLOG(FATAL) << "Fork to relaunch snapuserd failed";
     }
     if (pid > 0) {
         // We don't need the descriptor anymore, and it should be closed to
         // avoid leaking into subprocesses.
         close(fd.value());
 
         setenv(kSnapuserdFirstStagePidVar, std::to_string(pid).c_str(), 1);
 
         LOG(INFO) << "Relaunched snapuserd with pid: " << pid;
-
-        if (!TestSnapuserdIsReady()) {
-            PLOG(FATAL) << "snapuserd daemon failed to launch";
-        } else {
-            LOG(INFO) << "snapuserd daemon is up and running";
-        }
-
         return;
     }
 
     // Make sure the descriptor is gone after we exec.
     if (fcntl(fd.value(), F_SETFD, FD_CLOEXEC) < 0) {
         PLOG(FATAL) << "fcntl FD_CLOEXEC failed for snapuserd fd";
     }
 
     std::vector<char*> argv;
     for (auto& arg : argv_) {
diff --git a/init/snapuserd_transition.h b/init/snapuserd_transition.h
index 757af13776e42e4228b3618dffb70c1def00b0e2..a5ab652b7c2a73ee1c213d8218e87c85890cd915 100644
--- a/init/snapuserd_transition.h
+++ b/init/snapuserd_transition.h
@@ -44,21 +44,20 @@ class SnapuserdSelinuxHelper final {
     // Return a helper for facilitating the selinux transition of snapuserd.
     // If snapuserd is not in use, null is returned. StartTransition() should
     // be called after reading policy. FinishTransition() should be called
     // after loading policy. In between, no reads of /system or other dynamic
     // partitions are possible.
     static std::unique_ptr<SnapuserdSelinuxHelper> CreateIfNeeded();
 
   private:
     void RelaunchFirstStageSnapuserd();
     void ExecSnapuserd();
-    bool TestSnapuserdIsReady();
 
     std::unique_ptr<SnapshotManager> sm_;
     BlockDevInitializer block_dev_init_;
     pid_t old_pid_;
     std::vector<std::string> argv_;
 };
 
 // Remove /dev/socket/snapuserd. This ensures that (1) the existing snapuserd
 // will receive no new requests, and (2) the next copy we transition to can
 // own the socket.

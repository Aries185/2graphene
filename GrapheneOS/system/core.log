commit 731a9ef2f1b4a28632b4a8bab159d1d2843b1521
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2018-12-13 09:26:25-0500

    increase max_map_count for hardened malloc
---
 rootdir/init.rc | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index a9af0b094da4e7bbdde03fbe98ca200566e1289e..9dd5444578199e1be0c5ffcc3239de333f54208a 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -847,20 +847,22 @@ on boot
     # parameters to match how it is managing things.
     write /proc/sys/vm/overcommit_memory 1
     write /proc/sys/vm/min_free_order_shift 4
 
     # System server manages zram writeback
     chown root system /sys/block/zram0/idle
     chmod 0664 /sys/block/zram0/idle
     chown root system /sys/block/zram0/writeback
     chmod 0664 /sys/block/zram0/writeback
 
+    write /proc/sys/vm/max_map_count 1048576
+
     # Tweak background writeout
     write /proc/sys/vm/dirty_expire_centisecs 200
     write /proc/sys/vm/dirty_background_ratio  5
 
     # F2FS tuning. Set cp_interval larger than dirty_expire_centisecs
     # to avoid power consumption when system becomes mostly idle. Be careful
     # to make it too large, since it may bring userdata loss, if they
     # are not aware of using fsync()/sync() to prepare sudden power-cut.
     write /sys/fs/f2fs/${dev.mnt.blk.data}/cp_interval 200
     write /sys/fs/f2fs/${dev.mnt.blk.data}/gc_urgent_sleep_time 50

commit 3116c299ffb301a67023ddb4369c030abaad8f32
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2015-02-06 11:46:34-0500

    tighten up mount permissions
---
 init/first_stage_init.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/init/first_stage_init.cpp b/init/first_stage_init.cpp
index 021557697c36fdc08468fe5d61453c1918e97a65..ff16ff344b8a56a0b619c1abf95aa0bfaca8ad97 100644
--- a/init/first_stage_init.cpp
+++ b/init/first_stage_init.cpp
@@ -185,31 +185,31 @@ int FirstStageMain(int argc, char** argv) {
     // Clear the umask.
     umask(0);
 
     CHECKCALL(clearenv());
     CHECKCALL(setenv("PATH", _PATH_DEFPATH, 1));
     // Get the basic filesystem setup we need put together in the initramdisk
     // on / and then we'll let the rc file figure out the rest.
     CHECKCALL(mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755"));
     CHECKCALL(mkdir("/dev/pts", 0755));
     CHECKCALL(mkdir("/dev/socket", 0755));
-    CHECKCALL(mount("devpts", "/dev/pts", "devpts", 0, NULL));
+    CHECKCALL(mount("devpts", "/dev/pts", "devpts", MS_NOSUID|MS_NOEXEC, NULL));
 #define MAKE_STR(x) __STRING(x)
-    CHECKCALL(mount("proc", "/proc", "proc", 0, "hidepid=2,gid=" MAKE_STR(AID_READPROC)));
+    CHECKCALL(mount("proc", "/proc", "proc", MS_NOSUID|MS_NODEV|MS_NOEXEC, "hidepid=2,gid=" MAKE_STR(AID_READPROC)));
 #undef MAKE_STR
     // Don't expose the raw commandline to unprivileged processes.
     CHECKCALL(chmod("/proc/cmdline", 0440));
     std::string cmdline;
     android::base::ReadFileToString("/proc/cmdline", &cmdline);
     gid_t groups[] = {AID_READPROC};
     CHECKCALL(setgroups(arraysize(groups), groups));
-    CHECKCALL(mount("sysfs", "/sys", "sysfs", 0, NULL));
+    CHECKCALL(mount("sysfs", "/sys", "sysfs", MS_NOSUID|MS_NODEV|MS_NOEXEC, NULL));
     CHECKCALL(mount("selinuxfs", "/sys/fs/selinux", "selinuxfs", 0, NULL));
 
     CHECKCALL(mknod("/dev/kmsg", S_IFCHR | 0600, makedev(1, 11)));
 
     if constexpr (WORLD_WRITABLE_KMSG) {
         CHECKCALL(mknod("/dev/kmsg_debug", S_IFCHR | 0622, makedev(1, 11)));
     }
 
     CHECKCALL(mknod("/dev/random", S_IFCHR | 0666, makedev(1, 8)));
     CHECKCALL(mknod("/dev/urandom", S_IFCHR | 0666, makedev(1, 9)));

commit 1c2a540a3af0204088a8dc7f7616a28b8e8c219a
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2015-02-06 11:41:57-0500

    zero sensitive information with explicit_bzero
---
 init/security.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/init/security.cpp b/init/security.cpp
index 6cbe642c081b13c12d7d951b0620d2dcf52e4b89..82fc8ca6413cb55f1ea7ef53968cc64968243478 100644
--- a/init/security.cpp
+++ b/init/security.cpp
@@ -71,20 +71,21 @@ Result<void> MixHwrngIntoLinuxRngAction(const BuiltinArguments&) {
     while (total_bytes_written < sizeof(buf)) {
         ssize_t chunk_size =
             TEMP_FAILURE_RETRY(read(hwrandom_fd, buf, sizeof(buf) - total_bytes_written));
         if (chunk_size == -1) {
             return ErrnoError() << "Failed to read from /dev/hw_random";
         } else if (chunk_size == 0) {
             return Error() << "Failed to read from /dev/hw_random: EOF";
         }
 
         chunk_size = TEMP_FAILURE_RETRY(write(urandom_fd, buf, chunk_size));
+        explicit_bzero(buf, chunk_size);
         if (chunk_size == -1) {
             return ErrnoError() << "Failed to write to /dev/urandom";
         }
         total_bytes_written += chunk_size;
     }
 
     LOG(INFO) << "Mixed " << total_bytes_written << " bytes from /dev/hw_random into /dev/urandom";
     return {};
 }
 

commit af343f08a6dc856ad9f518866302d94a3b967cf8
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2016-06-15 17:51:42-0400

    add properties for controlling deny_new_usb
---
 rootdir/init.rc | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index 9dd5444578199e1be0c5ffcc3239de333f54208a..7ef43016e86db545c9cb076fc311f981f4894df2 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -989,20 +989,32 @@ on property:sys.boot_completed=1
 # system server cannot write to /proc/sys files,
 # and chown/chmod does not work for /proc/sys/ entries.
 # So proxy writes through init.
 on property:sys.sysctl.extra_free_kbytes=*
     write /proc/sys/vm/extra_free_kbytes ${sys.sysctl.extra_free_kbytes}
 
 # "tcp_default_init_rwnd" Is too long!
 on property:sys.sysctl.tcp_def_init_rwnd=*
     write /proc/sys/net/ipv4/tcp_default_init_rwnd ${sys.sysctl.tcp_def_init_rwnd}
 
+on property:persist.security.deny_new_usb=disabled
+    write /proc/sys/kernel/deny_new_usb 0
+
+on property:persist.security.deny_new_usb=enabled
+    write /proc/sys/kernel/deny_new_usb 1
+
+on property:persist.security.deny_new_usb=dynamic
+    write /proc/sys/kernel/deny_new_usb 1
+
+on property:security.deny_new_usb=*
+    write /proc/sys/kernel/deny_new_usb ${security.deny_new_usb}
+
 # perf_event_open syscall security:
 # Newer kernels have the ability to control the use of the syscall via SELinux
 # hooks. init tests for this, and sets sys_init.perf_lsm_hooks to 1 if the
 # kernel has the hooks. In this case, the system-wide perf_event_paranoid
 # sysctl is set to -1 (unrestricted use), and the SELinux policy is used for
 # controlling access. On older kernels, the paranoid value is the only means of
 # controlling access. It is normally 3 (allow only root), but the shell user
 # can lower it to 1 (allowing thread-scoped pofiling) via security.perf_harden.
 on property:sys.init.perf_lsm_hooks=1
     write /proc/sys/kernel/perf_event_paranoid -1

commit 3fe948b4b99f2139eff47a95a6943adcb58efeb7
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-07-16 14:49:29-0400

    enable kernel mitigations for link races
---
 rootdir/init.rc | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index 7ef43016e86db545c9cb076fc311f981f4894df2..4fefe9c89dae14a8a8a8e32dacca5d9ba0d46b5e 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -221,20 +221,23 @@ on init
     mkdir /mnt/runtime/full/self 0755 root root
 
     # Symlink to keep legacy apps working in multi-user world
     symlink /storage/self/primary /mnt/sdcard
     symlink /mnt/user/0/primary /mnt/runtime/default/self/primary
 
     write /proc/sys/kernel/panic_on_oops 1
     write /proc/sys/kernel/hung_task_timeout_secs 0
     write /proc/cpu/alignment 4
 
+    write /proc/sys/fs/protected_hardlinks 1
+    write /proc/sys/fs/protected_symlinks 1
+
     # scheduler tunables
     # Disable auto-scaling of scheduler tunables with hotplug. The tunables
     # will vary across devices in unpredictable ways if allowed to scale with
     # cpu cores.
     write /proc/sys/kernel/sched_tunable_scaling 0
     write /proc/sys/kernel/sched_latency_ns 10000000
     write /proc/sys/kernel/sched_wakeup_granularity_ns 2000000
     write /proc/sys/kernel/sched_child_runs_first 0
 
     write /proc/sys/kernel/randomize_va_space 2

commit 6f2d9deff97d5b54fa44c18e2f75d263c68e7935
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-07-16 14:54:28-0400

    enable kernel mitigations for file spoofing
---
 rootdir/init.rc | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index 4fefe9c89dae14a8a8a8e32dacca5d9ba0d46b5e..d2f8d74529a30aa7fda1f9873c8871b2cc5af87b 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -224,20 +224,23 @@ on init
     symlink /storage/self/primary /mnt/sdcard
     symlink /mnt/user/0/primary /mnt/runtime/default/self/primary
 
     write /proc/sys/kernel/panic_on_oops 1
     write /proc/sys/kernel/hung_task_timeout_secs 0
     write /proc/cpu/alignment 4
 
     write /proc/sys/fs/protected_hardlinks 1
     write /proc/sys/fs/protected_symlinks 1
 
+    write /proc/sys/fs/protected_fifos 2
+    write /proc/sys/fs/protected_regular 2
+
     # scheduler tunables
     # Disable auto-scaling of scheduler tunables with hotplug. The tunables
     # will vary across devices in unpredictable ways if allowed to scale with
     # cpu cores.
     write /proc/sys/kernel/sched_tunable_scaling 0
     write /proc/sys/kernel/sched_latency_ns 10000000
     write /proc/sys/kernel/sched_wakeup_granularity_ns 2000000
     write /proc/sys/kernel/sched_child_runs_first 0
 
     write /proc/sys/kernel/randomize_va_space 2

commit 358670be6efa18b3202c4a563419d3946e69bf1d (tag: RQ3A.210705.001.2021.07.07.19, tag: RQ3A.210605.005.2021.06.08.06)
Author: flawedworld <38294951+flawedworld@users.noreply.github.com>
Date:   Mon 2021-04-05 03:02:51+0100

    add a property for controlling ptrace_scope
---
 rootdir/init.rc | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/rootdir/init.rc b/rootdir/init.rc
index d2f8d74529a30aa7fda1f9873c8871b2cc5af87b..d60dfa7b653f491cc74d6b7507541f0fb444f55a 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -1007,20 +1007,26 @@ on property:persist.security.deny_new_usb=disabled
 
 on property:persist.security.deny_new_usb=enabled
     write /proc/sys/kernel/deny_new_usb 1
 
 on property:persist.security.deny_new_usb=dynamic
     write /proc/sys/kernel/deny_new_usb 1
 
 on property:security.deny_new_usb=*
     write /proc/sys/kernel/deny_new_usb ${security.deny_new_usb}
 
+on property:persist.native_debug=true
+    write /proc/sys/kernel/yama/ptrace_scope 0
+
+on property:persist.native_debug=false
+    write /proc/sys/kernel/yama/ptrace_scope 2
+
 # perf_event_open syscall security:
 # Newer kernels have the ability to control the use of the syscall via SELinux
 # hooks. init tests for this, and sets sys_init.perf_lsm_hooks to 1 if the
 # kernel has the hooks. In this case, the system-wide perf_event_paranoid
 # sysctl is set to -1 (unrestricted use), and the SELinux policy is used for
 # controlling access. On older kernels, the paranoid value is the only means of
 # controlling access. It is normally 3 (allow only root), but the shell user
 # can lower it to 1 (allowing thread-scoped pofiling) via security.perf_harden.
 on property:sys.init.perf_lsm_hooks=1
     write /proc/sys/kernel/perf_event_paranoid -1

commit be11b59725aa6118b0e1f0712572e835c3d50746 (HEAD, tag: RQ3A.210805.001.A1.2021.08.03.03, m/master)
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2021-07-22 17:12:00-0400

    fix use-after-free from event handling closures
---
 init/epoll.cpp | 10 ++++++----
 init/epoll.h   |  5 +++--
 2 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/init/epoll.cpp b/init/epoll.cpp
index 17d63fa5d8598bc16b01b72119aa5506dc93fccb..f3370a8f7a90cf0c1ae610819415fca787d1b9e6 100644
--- a/init/epoll.cpp
+++ b/init/epoll.cpp
@@ -35,21 +35,22 @@ Result<void> Epoll::Open() {
     if (epoll_fd_ == -1) {
         return ErrnoError() << "epoll_create1 failed";
     }
     return {};
 }
 
 Result<void> Epoll::RegisterHandler(int fd, std::function<void()> handler, uint32_t events) {
     if (!events) {
         return Error() << "Must specify events";
     }
-    auto [it, inserted] = epoll_handlers_.emplace(fd, std::move(handler));
+    auto sp = std::make_shared<std::function<void()>>(std::move(handler));
+    auto [it, inserted] = epoll_handlers_.emplace(fd, std::move(sp));
     if (!inserted) {
         return Error() << "Cannot specify two epoll handlers for a given FD";
     }
     epoll_event ev;
     ev.events = events;
     // std::map's iterators do not get invalidated until erased, so we use the
     // pointer to the std::function in the map directly for epoll_ctl.
     ev.data.ptr = reinterpret_cast<void*>(&it->second);
     if (epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &ev) == -1) {
         Result<void> result = ErrnoError() << "epoll_ctl failed to add fd";
@@ -62,32 +63,33 @@ Result<void> Epoll::RegisterHandler(int fd, std::function<void()> handler, uint3
 Result<void> Epoll::UnregisterHandler(int fd) {
     if (epoll_ctl(epoll_fd_, EPOLL_CTL_DEL, fd, nullptr) == -1) {
         return ErrnoError() << "epoll_ctl failed to remove fd";
     }
     if (epoll_handlers_.erase(fd) != 1) {
         return Error() << "Attempting to remove epoll handler for FD without an existing handler";
     }
     return {};
 }
 
-Result<std::vector<std::function<void()>*>> Epoll::Wait(
+Result<std::vector<std::shared_ptr<std::function<void()>>>> Epoll::Wait(
         std::optional<std::chrono::milliseconds> timeout) {
     int timeout_ms = -1;
     if (timeout && timeout->count() < INT_MAX) {
         timeout_ms = timeout->count();
     }
     const auto max_events = epoll_handlers_.size();
     epoll_event ev[max_events];
     auto num_events = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd_, ev, max_events, timeout_ms));
     if (num_events == -1) {
         return ErrnoError() << "epoll_wait failed";
     }
-    std::vector<std::function<void()>*> pending_functions;
+    std::vector<std::shared_ptr<std::function<void()>>> pending_functions;
     for (int i = 0; i < num_events; ++i) {
-        pending_functions.emplace_back(reinterpret_cast<std::function<void()>*>(ev[i].data.ptr));
+        auto sp = *reinterpret_cast<std::shared_ptr<std::function<void()>>*>(ev[i].data.ptr);
+        pending_functions.emplace_back(std::move(sp));
     }
 
     return pending_functions;
 }
 
 }  // namespace init
 }  // namespace android
diff --git a/init/epoll.h b/init/epoll.h
index c32a6614fe2ebbeeaed178eee9894c00cccf8bb5..eca91ac04826d58a68cd1f6b92e3d2ae936fc3e9 100644
--- a/init/epoll.h
+++ b/init/epoll.h
@@ -15,37 +15,38 @@
  */
 
 #pragma once
 
 #include <stdint.h>
 #include <sys/epoll.h>
 
 #include <chrono>
 #include <functional>
 #include <map>
+#include <memory>
 #include <optional>
 #include <vector>
 
 #include <android-base/unique_fd.h>
 
 #include "result.h"
 
 namespace android {
 namespace init {
 
 class Epoll {
   public:
     Epoll();
 
     Result<void> Open();
     Result<void> RegisterHandler(int fd, std::function<void()> handler, uint32_t events = EPOLLIN);
     Result<void> UnregisterHandler(int fd);
-    Result<std::vector<std::function<void()>*>> Wait(
+    Result<std::vector<std::shared_ptr<std::function<void()>>>> Wait(
             std::optional<std::chrono::milliseconds> timeout);
 
   private:
     android::base::unique_fd epoll_fd_;
-    std::map<int, std::function<void()>> epoll_handlers_;
+    std::map<int, std::shared_ptr<std::function<void()>>> epoll_handlers_;
 };
 
 }  // namespace init
 }  // namespace android

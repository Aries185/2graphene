commit b3f472c9c261aa955e6ead89a11d6dbf06391ead (HEAD, tag: SP1A.211105.002.2021110617, m/master, grapheneos/12)
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2020-09-09 01:53:11-0400

    pad filenames to 32 bytes instead of 16 or 4 bytes
    
    This was adopted before the earliest stable release of GrapheneOS, so
    backwards compatibility is not implemented anymore.
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 libfscrypt/fscrypt.cpp | 14 ++------------
 1 file changed, 2 insertions(+), 12 deletions(-)

diff --git a/libfscrypt/fscrypt.cpp b/libfscrypt/fscrypt.cpp
index f6e97f11a0fff52b80b0f2f0b9fc07dd4d857697..b9cd70048874c8ce5fa8843b21b1e692618e030e 100644
--- a/libfscrypt/fscrypt.cpp
+++ b/libfscrypt/fscrypt.cpp
@@ -219,32 +219,22 @@ bool ParseOptionsForApiLevel(unsigned int first_api_level, const std::string& op
                 options->flags |= FSCRYPT_POLICY_FLAG_IV_INO_LBLK_32;
             } else if (flag == "wrappedkey_v0") {
                 options->use_hw_wrapped_key = true;
             } else {
                 LOG(ERROR) << "Unknown flag: " << flag;
                 return false;
             }
         }
     }
 
-    // In the original setting of v1 policies and AES-256-CTS we used 4-byte
-    // padding of filenames, so retain that on old first_api_levels.
-    //
-    // For everything else, use 16-byte padding.  This is more secure (it helps
-    // hide the length of filenames), and it makes the inputs evenly divisible
-    // into cipher blocks which is more efficient for encryption and decryption.
-    if (first_api_level <= __ANDROID_API_Q__ && options->version == 1 &&
-        options->filenames_mode == FSCRYPT_MODE_AES_256_CTS) {
-        options->flags |= FSCRYPT_POLICY_FLAGS_PAD_4;
-    } else {
-        options->flags |= FSCRYPT_POLICY_FLAGS_PAD_16;
-    }
+    // GrapheneOS has always used the maximum 32 byte padding.
+    options->flags |= FSCRYPT_POLICY_FLAGS_PAD_32;
 
     // Use DIRECT_KEY for Adiantum, since it's much more efficient but just as
     // secure since Android doesn't reuse the same master key for multiple
     // encryption modes.
     if (options->contents_mode == FSCRYPT_MODE_ADIANTUM) {
         if (options->filenames_mode != FSCRYPT_MODE_ADIANTUM) {
             LOG(ERROR) << "Adiantum must be both contents and filenames mode or neither, invalid "
                           "options: "
                        << options_string;
             return false;

commit 54a5760f716a2af32770f05d3c2d08d5b9369063
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Tue 2021-10-05 21:01:17-0700

    fonts: Use variable font for Roboto Regular
    
    I'm not sure why Google decided to revert to a static variant of *only*
    the regular non-italic and non-condensed weight, but using the default
    "Roboto" font for the lock screen clock (i.e. AOSP default) is broken
    with the change:
        - Clock is too bold when notifications are present (because SystemUI
          loads the regular font but can't change the weight to be less
          bold)
        - Weight animation between lock screen and AOD is broken (because
          weight can't be animated without the variable font)
        - AOD clock font is too bold (could cause burn-in)
    
    Switch back to the variable font in order to fix the clock issues.
    
    Change-Id: Ia2e5ef52e4edb5d4275f6d5faf8c74266b784762
---
 data/fonts/fonts.xml | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/data/fonts/fonts.xml b/data/fonts/fonts.xml
index 4ae0fc4ae6ed93db604db863cbd93b0e10d1f30c..48da31b90eed16a3f534151178a6d10c0fbd9922 100644
--- a/data/fonts/fonts.xml
+++ b/data/fonts/fonts.xml
@@ -32,21 +32,25 @@
         <font weight="200" style="normal">Roboto-Regular.ttf
           <axis tag="ital" stylevalue="0" />
           <axis tag="wdth" stylevalue="100" />
           <axis tag="wght" stylevalue="200" />
         </font>
         <font weight="300" style="normal">Roboto-Regular.ttf
           <axis tag="ital" stylevalue="0" />
           <axis tag="wdth" stylevalue="100" />
           <axis tag="wght" stylevalue="300" />
         </font>
-        <font weight="400" style="normal">RobotoStatic-Regular.ttf</font>
+        <font weight="400" style="normal">Roboto-Regular.ttf
+          <axis tag="ital" stylevalue="0" />
+          <axis tag="wdth" stylevalue="100" />
+          <axis tag="wght" stylevalue="400" />
+        </font>
         <font weight="500" style="normal">Roboto-Regular.ttf
           <axis tag="ital" stylevalue="0" />
           <axis tag="wdth" stylevalue="100" />
           <axis tag="wght" stylevalue="500" />
         </font>
         <font weight="600" style="normal">Roboto-Regular.ttf
           <axis tag="ital" stylevalue="0" />
           <axis tag="wdth" stylevalue="100" />
           <axis tag="wght" stylevalue="600" />
         </font>

commit 3dcf5a3719d239a47b1780c20fe3a09037d57760
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2016-10-15 20:09:49-0400

    enable doze and app standby
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 0abeff91e511fdb68bea997b083648436c833ceb..bdd9cd3231c5b5c8dc53a8fc9f6bec3516bcf5c6 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -242,21 +242,21 @@
          ActivityManager based on screen size. -->
     <integer name="config_extraFreeKbytesAdjust">0</integer>
 
     <!-- Set this to true to enable the platform's auto-power-save modes like doze and
          app standby.  These are not enabled by default because they require a standard
          cloud-to-device messaging service for apps to interact correctly with the modes
          (such as to be able to deliver an instant message to the device even when it is
          dozing).  This should be enabled if you have such services and expect apps to
          correctly use them when installed on your device.  Otherwise, keep this disabled
          so that applications can still use their own mechanisms. -->
-    <bool name="config_enableAutoPowerModes">false</bool>
+    <bool name="config_enableAutoPowerModes">true</bool>
 
     <!-- Whether (if true) this is a kind of device that can be moved around (eg. phone/laptop),
          or (if false) something for which movement is either not measurable or should not count
          toward power states (eg. tv/soundbar). -->
     <bool name="config_autoPowerModeUseMotionSensor">true</bool>
 
     <!-- The threshold angle for any motion detection in auto-power save modes.
          In hundreths of a degree. -->
     <integer name="config_autoPowerModeThresholdAngle">200</integer>
 

commit 08fce1d6fa9a100f7bed0e9f30dab29eef0c6317
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2017-06-15 19:35:32-0400

    enable boot/bootloader/radio version checks
    
    This enables the Build.isBuildConsistent checks after tweaking the radio
    check to stop failing when the radio hasn't been turned on. The property
    used to check the radio version (gsm.baseband.version) is only set once
    the radio is turned on and initialized.
    
    The API documentation already claims that this is done.
---
 core/java/android/os/Build.java | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/core/java/android/os/Build.java b/core/java/android/os/Build.java
index 6bf394dc347b5fd2b0e7f0ed069eeea81b99c3b6..c4f5fa37977d30649f9194a66e9e74ea8feafdfa 100755
--- a/core/java/android/os/Build.java
+++ b/core/java/android/os/Build.java
@@ -1242,45 +1242,43 @@ public class Build {
         }
 
         if (!TextUtils.isEmpty(vendor)) {
             if (!Objects.equals(system, vendor)) {
                 Slog.e(TAG, "Mismatched fingerprints; system reported " + system
                         + " but vendor reported " + vendor);
                 return false;
             }
         }
 
-        /* TODO: Figure out issue with checks failing
         if (!TextUtils.isEmpty(bootimage)) {
             if (!Objects.equals(system, bootimage)) {
                 Slog.e(TAG, "Mismatched fingerprints; system reported " + system
                         + " but bootimage reported " + bootimage);
                 return false;
             }
         }
 
         if (!TextUtils.isEmpty(requiredBootloader)) {
             if (!Objects.equals(currentBootloader, requiredBootloader)) {
                 Slog.e(TAG, "Mismatched bootloader version: build requires " + requiredBootloader
                         + " but runtime reports " + currentBootloader);
                 return false;
             }
         }
 
-        if (!TextUtils.isEmpty(requiredRadio)) {
+        if (!TextUtils.isEmpty(requiredRadio) && !TextUtils.isEmpty(currentRadio)) {
             if (!Objects.equals(currentRadio, requiredRadio)) {
                 Slog.e(TAG, "Mismatched radio version: build requires " + requiredRadio
                         + " but runtime reports " + currentRadio);
                 return false;
             }
         }
-        */
 
         return true;
     }
 
     /** Build information for a particular device partition. */
     public static class Partition {
         /** The name identifying the system partition. */
         public static final String PARTITION_NAME_SYSTEM = "system";
 
         private final String mName;

commit 6004bc702d4b89f119c8c0313116f775878eff08
Author: flawedworld <38294951+flawedworld@users.noreply.github.com>
Date:   Fri 2021-07-16 02:00:19+0000

    Display UART notification on user builds
    
    The prior implementation relied on checking the init.svc.console prop,
    however as the console service is never launched on a user build due to
    it requiring ro.debuggable=1 , the UART notification will never appear.
    If UART is enabled the kernel cmdline is changed so that console is no
    longer null so use this to determine if UART is enabled and use the old
    method as an additional check.
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 .../android/server/am/ActivityManagerService.java  | 23 +++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index c78d5d538f8dc5ebbcf25abc1aca782f60ac477a..e3e23964eed6cf3e1e25a6954811d69872079b74 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -396,40 +396,42 @@ import com.android.server.wm.ActivityTaskManagerService;
 import com.android.server.wm.WindowManagerInternal;
 import com.android.server.wm.WindowManagerService;
 import com.android.server.wm.WindowProcessController;
 
 import dalvik.system.VMRuntime;
 
 import libcore.util.EmptyArray;
 
 import java.io.File;
 import java.io.FileDescriptor;
+import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.nio.charset.StandardCharsets;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
+import java.util.Scanner;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 
 public class ActivityManagerService extends IActivityManager.Stub
         implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback, ActivityManagerGlobalLock {
 
     private static final String SYSTEM_PROPERTY_DEVICE_PROVISIONED =
             "persist.sys.device_provisioned";
@@ -4767,22 +4769,41 @@ public class ActivityManagerService extends IActivityManager.Stub
                     });
             maybeLogUserspaceRebootEvent();
             mUserController.scheduleStartProfiles();
         }
         // UART is on if init's console service is running, send a warning notification.
         showConsoleNotificationIfActive();
 
         t.traceEnd();
     }
 
+    private static Boolean isUartEnabled() {
+        // console=null should be set in the kernel cmdline when UART is off
+        final String console_string = "console=null";
+        boolean isEnabled = false;
+        try (Scanner sc = new Scanner(new FileInputStream("/proc/cmdline"))) {
+            StringBuilder scOutput = new StringBuilder();
+            while (sc.hasNextLine()){
+                scOutput.append(sc.nextLine());
+            }
+            isEnabled = !scOutput.toString().contains(console_string);
+        } catch (IOException ignored) {}
+        // This check will only work on userdebug and eng builds due
+        // to the console service not being present on user builds.
+        if (SystemProperties.get("init.svc.console").equals("running")) {
+            isEnabled = true;
+        }
+        return isEnabled;
+    }
+
     private void showConsoleNotificationIfActive() {
-        if (!SystemProperties.get("init.svc.console").equals("running")) {
+        if (!isUartEnabled()) {
             return;
         }
         String title = mContext
                 .getString(com.android.internal.R.string.console_running_notification_title);
         String message = mContext
                 .getString(com.android.internal.R.string.console_running_notification_message);
         Notification notification =
                 new Notification.Builder(mContext, SystemNotificationChannels.DEVELOPER)
                         .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)
                         .setWhen(0)

commit f576f32ffb656995f58e592faf9674e758d91096
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2018-03-09 20:23:12-0500

    use round adaptive icon mask and parse round icons
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 core/res/res/values/config.xml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index bdd9cd3231c5b5c8dc53a8fc9f6bec3516bcf5c6..9e42e922105f468b43fda82e011fc65a53514520 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -3672,21 +3672,21 @@
     <bool name="config_pinnerHomeApp">false</bool>
 
     <!-- True if assistant app should be pinned via Pinner Service -->
     <bool name="config_pinnerAssistantApp">false</bool>
 
     <!-- Number of days preloaded file cache should be preserved on a device before it can be
          deleted -->
     <integer name="config_keepPreloadsMinDays">7</integer>
 
     <!-- Flag indicating whether round icons should be parsed from the application manifest. -->
-    <bool name="config_useRoundIcon">false</bool>
+    <bool name="config_useRoundIcon">true</bool>
 
     <!-- Flag indicating whether the assist disclosure can be disabled using
          ASSIST_DISCLOSURE_ENABLED. -->
     <bool name="config_allowDisablingAssistDisclosure">true</bool>
 
     <!-- True if the device supports system navigation keys. -->
     <bool name="config_supportSystemNavigationKeys">false</bool>
 
     <!-- emergency call number for the emergency affordance -->
     <string name="config_emergency_call_number" translatable="false">112</string>
@@ -3769,21 +3769,21 @@
          1.0 corresponds to 1x animator scale, 0 means that there will be no transition
          animations. Note that this is only a default and will be overridden by a
          user-set value if toggled by settings so the "Transition animation scale" setting
          should also be hidden if intended to be permanent. -->
     <item name="config_appTransitionAnimationDurationScaleDefault" format="float" type="dimen">1.0</item>
 
     <!-- Flag indicates that whether non-system apps can be installed on internal storage. -->
     <bool name="config_allow3rdPartyAppOnInternal">true</bool>
 
     <!-- Specifies the path that is used by AdaptiveIconDrawable class to crop launcher icons. -->
-    <string name="config_icon_mask" translatable="false">"M50,0L92,0C96.42,0 100,4.58 100 8L100,92C100, 96.42 96.42 100 92 100L8 100C4.58, 100 0 96.42 0 92L0 8 C 0 4.42 4.42 0 8 0L50 0Z"</string>
+    <string name="config_icon_mask" translatable="false">"M50 0C77.6 0 100 22.4 100 50C100 77.6 77.6 100 50 100C22.4 100 0 77.6 0 50C0 22.4 22.4 0 50 0Z"</string>
 
     <!-- The component name, flattened to a string, for the default accessibility service to be
          enabled by the accessibility shortcut. This service must be trusted, as it can be activated
          without explicit consent of the user. If no accessibility service with the specified name
          exists on the device, the accessibility shortcut will be disabled by default. -->
     <string name="config_defaultAccessibilityService" translatable="false"></string>
 
     <!-- Flag indicates that whether escrow token API is enabled for TrustAgent -->
     <!-- Warning: This API can be dangerous when not implemented properly. In particular,
          escrow token must NOT be retrievable from device storage. In other words, either

commit 6a011cb17ff80422ac168ac679f3d01a8159e922
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2018-11-28 01:08:00-0500

    enable gesture navigation by default
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 9e42e922105f468b43fda82e011fc65a53514520..5cdf92b05d5a51578ed81f7c151e32b0519628e9 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -3441,21 +3441,21 @@
          1 - Nav bar is always translucent when the freeform stack is visible, otherwise always
              opaque.
          2 - Nav bar is never forced opaque.
          -->
     <integer name="config_navBarOpacityMode">0</integer>
 
     <!-- Controls the navigation bar interaction mode:
          0: 3 button mode (back, home, overview buttons)
          1: 2 button mode (back, home buttons + swipe up for overview)
          2: gestures only for back, home and overview -->
-    <integer name="config_navBarInteractionMode">0</integer>
+    <integer name="config_navBarInteractionMode">2</integer>
 
     <!-- Controls whether the nav bar can move from the bottom to the side in landscape.
          Only applies if the device display is not square. -->
     <bool name="config_navBarCanMove">true</bool>
 
     <!-- Controls whether the navigation bar lets through taps. -->
     <bool name="config_navBarTapThrough">false</bool>
 
     <!-- Controls whether the side edge gestures can always trigger the transient nav bar to
          show. -->

commit 98492978e30b138495f8557404031956516210f8
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2021-10-09 00:54:03-0400

    revert to pre-12 power button behavior
---
 core/res/res/values/config.xml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 5cdf92b05d5a51578ed81f7c151e32b0519628e9..3071bd79ac6171a8bc25bbfb879bf8b8578fa3c8 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -948,21 +948,21 @@
     <integer name="config_attentiveWarningDuration">30000</integer>
 
     <!-- Control the behavior when the user long presses the power button.
             0 - Nothing
             1 - Global actions menu
             2 - Power off (with confirmation)
             3 - Power off (without confirmation)
             4 - Go to voice assist
             5 - Go to assistant (Settings.Secure.ASSISTANT)
     -->
-    <integer name="config_longPressOnPowerBehavior">5</integer>
+    <integer name="config_longPressOnPowerBehavior">1</integer>
 
     <!-- The time in milliseconds after which a press on power button is considered "long". -->
     <integer name="config_longPressOnPowerDurationMs">500</integer>
 
     <!-- The possible UI options to be surfaced for configuring long press power on duration
          action. Value set in config_longPressOnPowerDurationMs should be one of the available
          options to allow users to restore default. -->
     <integer-array name="config_longPressOnPowerDurationSettings">
         <item>250</item>
         <item>350</item>
@@ -980,21 +980,21 @@
             0 - Nothing
             1 - Global actions menu
     -->
     <integer name="config_veryLongPressOnPowerBehavior">0</integer>
 
     <!-- Control the behavior when the user presses the power and volume up buttons together.
             0 - Nothing
             1 - Mute toggle
             2 - Global actions menu
     -->
-    <integer name="config_keyChordPowerVolumeUp">2</integer>
+    <integer name="config_keyChordPowerVolumeUp">1</integer>
 
     <!-- Control the behavior when the user long presses the back button.  Non-zero values are only
          valid for watches as part of CDD/CTS.
             0 - Nothing
             1 - Go to voice assist
     -->
     <integer name="config_longPressOnBackBehavior">0</integer>
 
     <!-- Allows activities to be launched on a long press on power during device setup. -->
     <bool name="config_allowStartActivityForLongPressOnPowerInSetup">false</bool>

commit 04eb764bb5a4e64b466f0590a8a9cb8a985b8674
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2018-11-28 01:14:54-0500

    enable multi user UI
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 3071bd79ac6171a8bc25bbfb879bf8b8578fa3c8..f4b2e512591a8fa273d22385484b523dd3cee42e 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2504,21 +2504,21 @@
           - to enable feature (fully enforced) for a complete allowlist: 1
           - to enable feature for an incomplete allowlist (so use implicit allowlist mode): 5
           - to enable feature but implicitly allowlist for SYSTEM user to ease local development: 9
           - to disable feature completely if it had never been enabled: 16
           - to henceforth disable feature and try to undo its previous effects: 0
         Note: This list must be kept current with PACKAGE_WHITELIST_MODE_PROP in
         frameworks/base/services/core/java/com/android/server/pm/UserSystemPackageInstaller.java -->
     <integer name="config_userTypePackageWhitelistMode">13</integer> <!-- 1+4+8 -->
 
     <!-- Whether UI for multi user should be shown -->
-    <bool name="config_enableMultiUserUI">false</bool>
+    <bool name="config_enableMultiUserUI">true</bool>
 
     <!-- Whether the new Auto Selection Network UI should be shown -->
     <bool name="config_enableNewAutoSelectNetworkUI">false</bool>
 
     <!-- If true, then we do not ask user for permission for apps to connect to USB devices.
          Do not set this to true for production devices. Doing so will cause you to fail CTS. -->
     <bool name="config_disableUsbPermissionDialogs">false</bool>
 
     <!-- Activity to handle Usb Device connection in USB Host side. Keeping it to null value will
          lead into handling it inside system using Intent resolution. Non-null contents will have

commit 99566f9f0abbfb28a4bc4113c389be25c8bbe0c2
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2018-11-28 01:16:09-0500

    raise maximum users to 4
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index f4b2e512591a8fa273d22385484b523dd3cee42e..5cab160c58c06e11e17b7ad8a29bbcab24477873 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2470,21 +2470,21 @@
     <integer-array translatable="false" name="config_oemUsbModeOverride">
     </integer-array>
 
     <!-- Set to true to add links to Cell Broadcast app from Settings and MMS app. -->
     <bool name="config_cellBroadcastAppLinks">true</bool>
 
     <!-- The default value if the SyncStorageEngine should sync automatically or not -->
     <bool name="config_syncstorageengine_masterSyncAutomatically">true</bool>
 
     <!--  Maximum number of supported users -->
-    <integer name="config_multiuserMaximumUsers">1</integer>
+    <integer name="config_multiuserMaximumUsers">4</integer>
 
     <!-- Maximum number of users we allow to be running at a time -->
     <integer name="config_multiuserMaxRunningUsers">3</integer>
 
     <!-- Whether to delay user data locking for background user.
          If false, user switched-out from user switching will still be in running state until
          config_multiuserMaxRunningUsers is reached. Once config_multiuserMaxRunningUsers is
          reached, user will be stopped and user data is locked.
          If true, user switched out from user switching will always be stopped but its user data
          is not locked. Total number of unlocked users will be limited by

commit 5314fd5602004f7adf6134bbf58eb9e79402b204
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2018-12-04 00:34:24-0500

    disable bluetooth by default
---
 packages/SettingsProvider/res/values/defaults.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/packages/SettingsProvider/res/values/defaults.xml b/packages/SettingsProvider/res/values/defaults.xml
index 8e6e251ff3f25ce4240f894c652a3c2adcd86f76..53324ba4d9664dc170a81c39dcf77d1affe7812a 100644
--- a/packages/SettingsProvider/res/values/defaults.xml
+++ b/packages/SettingsProvider/res/values/defaults.xml
@@ -29,21 +29,21 @@
     <bool name="def_auto_time">true</bool>
     <bool name="def_auto_time_zone">true</bool>
     <bool name="def_accelerometer_rotation">false</bool>
     <!-- Default screen brightness, from 0 to 255.  102 is 40%. -->
     <integer name="def_screen_brightness">102</integer>
     <bool name="def_screen_brightness_automatic_mode">false</bool>
     <fraction name="def_window_animation_scale">100%</fraction>
     <fraction name="def_window_transition_scale">100%</fraction>
     <bool name="def_haptic_feedback">true</bool>
 
-    <bool name="def_bluetooth_on">true</bool>
+    <bool name="def_bluetooth_on">false</bool>
     <bool name="def_wifi_display_on">false</bool>
     <bool name="def_install_non_market_apps">false</bool>
     <!-- 0 == off, 3 == on -->
     <integer name="def_location_mode">3</integer>
     <bool name="assisted_gps_enabled">true</bool>
     <bool name="def_netstats_enabled">true</bool>
     <bool name="def_usb_mass_storage_enabled">true</bool>
     <bool name="def_wifi_on">false</bool>
     <!-- 0 == never, 1 == only when plugged in, 2 == always -->
     <integer name="def_wifi_sleep_policy">2</integer>

commit 147399949f47e9434a455be9e327d4fbdb967ea4
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2017-06-29 10:16:52-0400

    increase default max password length to 64
---
 core/java/android/app/admin/DevicePolicyManager.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/java/android/app/admin/DevicePolicyManager.java b/core/java/android/app/admin/DevicePolicyManager.java
index 0fe80c45ad2a6e8943fffee2a9f6e944c5f8f60d..d7ace96010d9a35940462c1f3e23176e52daeeed 100644
--- a/core/java/android/app/admin/DevicePolicyManager.java
+++ b/core/java/android/app/admin/DevicePolicyManager.java
@@ -2784,21 +2784,21 @@ public class DevicePolicyManager {
      *
      * @see #ACTION_GET_PROVISIONING_MODE
      */
     public static final String ACTION_ADMIN_POLICY_COMPLIANCE =
             "android.app.action.ADMIN_POLICY_COMPLIANCE";
 
     /**
      * Maximum supported password length. Kind-of arbitrary.
      * @hide
      */
-    public static final int MAX_PASSWORD_LENGTH = 16;
+    public static final int MAX_PASSWORD_LENGTH = 64;
 
     /**
      * Service Action: Service implemented by a device owner or profile owner supervision app to
      * provide a secondary lockscreen.
      * @hide
      */
     @SystemApi
     public static final String ACTION_BIND_SECONDARY_LOCKSCREEN_SERVICE =
             "android.app.action.BIND_SECONDARY_LOCKSCREEN_SERVICE";
 

commit 15b3ed7f0826e3eeeeee675bae5253c4bf43fb06
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2017-09-12 01:52:11-0400

    use permanent fingerprint lockout immediately
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 .../biometrics/sensors/fingerprint/hidl/LockoutFrameworkImpl.java       | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/LockoutFrameworkImpl.java b/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/LockoutFrameworkImpl.java
index dc5dace98825d97a848af0bb9902e0651080d9fe..2f745264422743eecd18be72fe61992d60908201 100644
--- a/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/LockoutFrameworkImpl.java
+++ b/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/LockoutFrameworkImpl.java
@@ -34,21 +34,21 @@ import com.android.server.biometrics.sensors.LockoutTracker;
 /**
  * Tracks and enforces biometric lockout for biometric sensors that do not support lockout in the
  * HAL.
  */
 public class LockoutFrameworkImpl implements LockoutTracker {
 
     private static final String TAG = "LockoutTracker";
     private static final String ACTION_LOCKOUT_RESET =
             "com.android.server.biometrics.sensors.fingerprint.ACTION_LOCKOUT_RESET";
     private static final int MAX_FAILED_ATTEMPTS_LOCKOUT_TIMED = 5;
-    private static final int MAX_FAILED_ATTEMPTS_LOCKOUT_PERMANENT = 20;
+    private static final int MAX_FAILED_ATTEMPTS_LOCKOUT_PERMANENT = 5;
     private static final long FAIL_LOCKOUT_TIMEOUT_MS = 30 * 1000;
     private static final String KEY_LOCKOUT_RESET_USER = "lockout_reset_user";
 
     private final class LockoutReceiver extends BroadcastReceiver {
         @Override
         public void onReceive(Context context, Intent intent) {
             Slog.v(TAG, "Resetting lockout: " + intent.getAction());
             if (ACTION_LOCKOUT_RESET.equals(intent.getAction())) {
                 final int user = intent.getIntExtra(KEY_LOCKOUT_RESET_USER, 0);
                 resetFailedAttemptsForUser(false /* clearAttemptCounter */, user);

commit 586087549fc48b4a4124cb1f5e7b0be6152a9e22
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2021-01-03 09:24:21-0500

    use black wallpaper by default
---
 core/res/res/drawable-nodpi/default_wallpaper.png   | Bin 489912 -> 235 bytes
 .../drawable-sw600dp-nodpi/default_wallpaper.png    | Bin 1197339 -> 625 bytes
 .../drawable-sw720dp-nodpi/default_wallpaper.png    | Bin 1930496 -> 974 bytes
 3 files changed, 0 insertions(+), 0 deletions(-)

diff --git a/core/res/res/drawable-nodpi/default_wallpaper.png b/core/res/res/drawable-nodpi/default_wallpaper.png
index ce546f0a11e7617627a93fec9a30e44489464224..d60ef83a86e37501e9aecdff42c6cd3609e54355 100644
Binary files a/core/res/res/drawable-nodpi/default_wallpaper.png and b/core/res/res/drawable-nodpi/default_wallpaper.png differ
diff --git a/core/res/res/drawable-sw600dp-nodpi/default_wallpaper.png b/core/res/res/drawable-sw600dp-nodpi/default_wallpaper.png
index af8e2512385a541569e0745d24361467eefeb5c9..7b7e940d10638a06fed603050803533e160d3bc2 100644
Binary files a/core/res/res/drawable-sw600dp-nodpi/default_wallpaper.png and b/core/res/res/drawable-sw600dp-nodpi/default_wallpaper.png differ
diff --git a/core/res/res/drawable-sw720dp-nodpi/default_wallpaper.png b/core/res/res/drawable-sw720dp-nodpi/default_wallpaper.png
index cb00d82a826fa820787239bfaae22ea28e211f62..68e63312cfa8371060748249e09fe19ee3da9d7a 100644
Binary files a/core/res/res/drawable-sw720dp-nodpi/default_wallpaper.png and b/core/res/res/drawable-sw720dp-nodpi/default_wallpaper.png differ

commit 30bcc9529ccc7b49abbd538536fa5bd3e9abe2cf
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2021-10-09 03:22:39-0400

    use rounded corners in system UI
    
    Based on kdrag0n's work for ProtonAOSP.
---
 core/res/res/values/config.xml | 8 ++++----
 core/res/res/values/dimens.xml | 4 ++--
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 5cab160c58c06e11e17b7ad8a29bbcab24477873..e2edb28e13b58d1d2af1e1a6181be468ad956372 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -4104,27 +4104,27 @@
     <string translatable="false" name="config_deviceSpecificAudioService"></string>
 
     <!-- Class name of the device specific implementation of DisplayAreaPolicy.Provider
          or empty if the default should be used. -->
     <string translatable="false" name="config_deviceSpecificDisplayAreaPolicyProvider"></string>
 
     <!-- Component name of media projection permission dialog -->
     <string name="config_mediaProjectionPermissionDialogComponent" translatable="false">com.android.systemui/com.android.systemui.media.MediaProjectionPermissionActivity</string>
 
     <!-- Corner radius of system dialogs -->
-    <dimen name="config_dialogCornerRadius">2dp</dimen>
+    <dimen name="config_dialogCornerRadius">28dp</dimen>
     <!-- Corner radius of system buttons -->
-    <dimen name="config_buttonCornerRadius">@dimen/control_corner_material</dimen>
+    <dimen name="config_buttonCornerRadius">4dp</dimen>
     <!-- Corner radius for bottom sheet system dialogs -->
-    <dimen name="config_bottomDialogCornerRadius">@dimen/config_dialogCornerRadius</dimen>
+    <dimen name="config_bottomDialogCornerRadius">16dp</dimen>
     <!-- Corner radius of system progress bars -->
-    <dimen name="config_progressBarCornerRadius">@dimen/progress_bar_corner_material</dimen>
+    <dimen name="config_progressBarCornerRadius">1000dp</dimen>
     <!-- Controls whether system buttons use all caps for text -->
     <bool name="config_buttonTextAllCaps">true</bool>
     <!-- Name of the font family used for system surfaces where the font should use medium weight -->
     <string name="config_headlineFontFamilyMedium" translateable="false">@string/font_family_button_material</string>
     <!-- Name of a font family to use for body text. -->
     <string name="config_bodyFontFamily" translatable="false">sans-serif</string>
     <!-- Name of a font family to use for medium body text. -->
     <string name="config_bodyFontFamilyMedium" translatable="false">sans-serif-medium</string>
 
     <!-- Size of icon shown beside a preference locked by admin -->
diff --git a/core/res/res/values/dimens.xml b/core/res/res/values/dimens.xml
index a666a5b4b7960b2369a2304a8b2db19b17178c6d..5addc5271cf05bb3cc37a7e06819a0349c0e1df6 100644
--- a/core/res/res/values/dimens.xml
+++ b/core/res/res/values/dimens.xml
@@ -932,21 +932,21 @@
     <dimen name="waterfall_display_right_edge_size">0px</dimen>
     <dimen name="waterfall_display_bottom_edge_size">0px</dimen>
 
     <dimen name="default_background_blur_radius">100dp</dimen>
     <!-- The maximum height of a thumbnail in a ThumbnailTemplate. The image will be reduced to that height in case they are bigger. -->
     <dimen name="controls_thumbnail_image_max_height">140dp</dimen>
     <!-- The maximum width of a thumbnail in a ThumbnailTemplate. The image will be reduced to that width in case they are bigger.-->
     <dimen name="controls_thumbnail_image_max_width">280dp</dimen>
 
     <!-- System-provided radius for the background view of app widgets. The resolved value of this resource may change at runtime. -->
-    <dimen name="system_app_widget_background_radius">16dp</dimen>
+    <dimen name="system_app_widget_background_radius">28dp</dimen>
     <!-- System-provided radius for inner views on app widgets. The resolved value of this resource may change at runtime. -->
-    <dimen name="system_app_widget_inner_radius">8dp</dimen>
+    <dimen name="system_app_widget_inner_radius">20dp</dimen>
     <!-- System-provided padding for inner views on app widgets. The resolved value of this resource may change at runtime. @removed -->
     <dimen name="__removed_system_app_widget_internal_padding">16dp</dimen>
 
     <!-- The width/height of the icon view on staring surface. -->
     <dimen name="starting_surface_icon_size">160dp</dimen>
     <!-- The default width/height of the icon on the spec of adaptive icon drawable. -->
     <dimen name="starting_surface_default_icon_size">108dp</dimen>
 </resources>

commit 00e28425bae4c7d7bab947851e2807451d897b59
Author: inthewaves <inthewaves@pm.me>
Date:   Tue 2020-10-06 16:02:25-0700

    switch to providing WebView via Vanadium
---
 core/res/res/xml/config_webview_packages.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/xml/config_webview_packages.xml b/core/res/res/xml/config_webview_packages.xml
index f062b59a008c900260a691e55b6328a5ca6692c2..1db99d8bc404e5b496541ca44e962d61e84a46c6 100644
--- a/core/res/res/xml/config_webview_packages.xml
+++ b/core/res/res/xml/config_webview_packages.xml
@@ -9,13 +9,13 @@
 
      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
 
 <webviewproviders>
     <!-- The default WebView implementation -->
-    <webviewprovider description="Android WebView" packageName="com.android.webview" availableByDefault="true">
+    <webviewprovider description="Vanadium" packageName="app.vanadium.webview" availableByDefault="true">
     </webviewprovider>
 </webviewproviders>

commit 048b3990944d99031a527afa4f8509919d04d9a8
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2020-09-27 17:37:28-0400

    add 2 button navigation overlay
---
 packages/overlays/Android.mk | 1 +
 1 file changed, 1 insertion(+)

diff --git a/packages/overlays/Android.mk b/packages/overlays/Android.mk
index 928892c60e47ae5b7fa247c02c1320569c58c0ec..a6bb258bccb0d907557854d710ab90a18264d3ee 100644
--- a/packages/overlays/Android.mk
+++ b/packages/overlays/Android.mk
@@ -20,20 +20,21 @@ LOCAL_LICENSE_KINDS := SPDX-license-identifier-Apache-2.0
 LOCAL_LICENSE_CONDITIONS := notice
 LOCAL_NOTICE_FILE := $(LOCAL_PATH)/../../NOTICE
 LOCAL_REQUIRED_MODULES := \
 	DisplayCutoutEmulationCornerOverlay \
 	DisplayCutoutEmulationDoubleOverlay \
     DisplayCutoutEmulationHoleOverlay \
 	DisplayCutoutEmulationTallOverlay \
 	DisplayCutoutEmulationWaterfallOverlay \
 	FontNotoSerifSourceOverlay \
 	NavigationBarMode3ButtonOverlay \
+	NavigationBarMode2ButtonOverlay \
 	NavigationBarModeGesturalOverlay \
 	NavigationBarModeGesturalOverlayNarrowBack \
 	NavigationBarModeGesturalOverlayWideBack \
 	NavigationBarModeGesturalOverlayExtraWideBack \
         OneHandedModeGesturalOverlay \
 	preinstalled-packages-platform-overlays.xml
 
 include $(BUILD_PHONY_PACKAGE)
 include $(CLEAR_VARS)
 

commit 38bd1787b8aa5562ffc8f0c53b55af9534effdb3
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2019-05-11 15:47:05-0400

    GrapheneOS logo mask
---
 core/res/assets/images/android-logo-mask.png | Bin 12104 -> 5937 bytes
 1 file changed, 0 insertions(+), 0 deletions(-)

diff --git a/core/res/assets/images/android-logo-mask.png b/core/res/assets/images/android-logo-mask.png
index 5512c0ad8a83b8df0b5d396fb2dac9487a240a4d..fae0c03f594e4bd23e843afb3bc8a1e09653dfb5 100644
Binary files a/core/res/assets/images/android-logo-mask.png and b/core/res/assets/images/android-logo-mask.png differ

commit 289c2b8fc566d7ad53da7d5e04292d184e2f9873
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2017-09-06 21:40:48-0400

    always set deprecated Build.SERIAL to UNKNOWN
    
    Only support fetching the serial number via the new Build.getSerial()
    requiring the READ_PHONE_STATE permission.
---
 .../core/java/com/android/server/am/ActivityManagerService.java    | 7 +------
 1 file changed, 1 insertion(+), 6 deletions(-)

diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index e3e23964eed6cf3e1e25a6954811d69872079b74..6a84b3ae42a85d0dfa8357e189e92de0716a1f72 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -4447,26 +4447,21 @@ public class ActivityManagerService extends IActivityManager.Stub
                 notifyPackageUse(instr.mClass.getPackageName(),
                                  PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION);
             }
             ProtoLog.v(WM_DEBUG_CONFIGURATION, "Binding proc %s with config %s",
                     processName, app.getWindowProcessController().getConfiguration());
             ApplicationInfo appInfo = instr != null ? instr.mTargetInfo : app.info;
             app.setCompat(compatibilityInfoForPackage(appInfo));
 
             ProfilerInfo profilerInfo = mAppProfiler.setupProfilerInfoLocked(thread, app, instr);
 
-            // We deprecated Build.SERIAL and it is not accessible to
-            // Instant Apps and target APIs higher than O MR1. Since access to the serial
-            // is now behind a permission we push down the value.
-            final String buildSerial = (!appInfo.isInstantApp()
-                    && appInfo.targetSdkVersion < Build.VERSION_CODES.P)
-                            ? sTheRealBuildSerial : Build.UNKNOWN;
+            final String buildSerial = Build.UNKNOWN;
 
             // Figure out whether the app needs to run in autofill compat mode.
             AutofillOptions autofillOptions = null;
             if (UserHandle.getAppId(app.info.uid) >= Process.FIRST_APPLICATION_UID) {
                 final AutofillManagerInternal afm = LocalServices.getService(
                         AutofillManagerInternal.class);
                 if (afm != null) {
                     autofillOptions = afm.getAutofillOptions(
                             app.info.packageName, app.info.longVersionCode, app.userId);
                 }

commit efe0fc4744585b712bfb7bcc68c9f812a60806f8
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Tue 2021-10-05 21:01:09-0700

    SystemUI: Require unlocking to use sensitive QS tiles
    
    - Airplane mode
    - Battery saver
    - Bluetooth
    - Cellular
    - DataSaver
    - Hotspot
    - NFC
    - Rotation lock
    - Wi-Fi
    - Work mode
    
    This is the same idea as the following commits from GrapheneOS, but
    simplified to reduce changes made to each individual QS tile:
    
    commit 45670099ed63c9fbde6ff1bd13d27b674416d21d
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:22:41 2020 -0700
    
        require unlocking to use work mode tile
    
    commit 4b7c9559dfba84e10142fcd53b3edac9c75b0748
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:21:16 2020 -0700
    
        require unlocking to use battery saver tile
    
    commit f45c24a4728531441c60320eda0a4fce4285de06
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:19:36 2020 -0700
    
        require unlocking to use cellular quick tile
    
    commit c18f6f868aee5b8f27fcc1966089f814f9f89ab2
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:15:46 2020 -0700
    
        require unlocking to use hotspot quick tile
    
    commit 442c94e1ee499eed467863362f8eb62bb88027a4
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:13:58 2020 -0700
    
        require unlocking to use data saver quick tile
    
    commit cf84259708f9bf650c8494e16025725b1bfa5e23
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:11:58 2020 -0700
    
        require unlocking to use rotation lock quick tile
    
    commit 61eb5a6392c53e4d44cb91cdb4df27c3055ef439
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:08:33 2020 -0700
    
        require unlocking to use Wi-Fi quick tile
    
    commit ad122f0a5a46e2445b5866d3ff83fdc7623b76f6
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:05:18 2020 -0700
    
        require unlocking to use airplane mode quick tile
    
    commit a3686b6f905fb734b3a4f6db545e8a3ef3fc3cc7
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:02:20 2020 -0700
    
        require unlocking to use Bluetooth quick tile
    
    commit 3046535a40f53835eb0b57d4c12a29828ba90f30
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 16:47:59 2020 -0700
    
        require unlocking to use NFC quick tile
    
    Change-Id: I515f4bdd30f84a4a76f4807afcf3cc5a3ce42fa9
---
 .../systemui/qs/tiles/AirplaneModeTile.java        | 14 ++++--
 .../systemui/qs/tiles/BatterySaverTile.java        | 14 ++++--
 .../android/systemui/qs/tiles/BluetoothTile.java   | 14 ++++--
 .../android/systemui/qs/tiles/CellularTile.java    | 14 ++++--
 .../android/systemui/qs/tiles/DataSaverTile.java   | 14 ++++--
 .../com/android/systemui/qs/tiles/HotspotTile.java | 15 ++++--
 .../src/com/android/systemui/qs/tiles/NfcTile.java | 14 ++++--
 .../systemui/qs/tiles/RotationLockTile.java        | 14 ++++--
 .../systemui/qs/tiles/SecureQSTile.kt (new)        | 58 ++++++++++++++++++++++
 .../com/android/systemui/qs/tiles/WifiTile.java    | 14 ++++--
 .../android/systemui/qs/tiles/WorkModeTile.java    | 14 ++++--
 11 files changed, 158 insertions(+), 41 deletions(-)

diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/AirplaneModeTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/AirplaneModeTile.java
index 22cd6f86b16529d2a6a7aff7766c744d658797f4..f76966030528fd08427eeab7c82756d5966ee746 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/AirplaneModeTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/AirplaneModeTile.java
@@ -41,68 +41,74 @@ import com.android.systemui.broadcast.BroadcastDispatcher;
 import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.GlobalSetting;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import javax.inject.Inject;
 
 import dagger.Lazy;
 
 /** Quick settings tile: Airplane mode **/
-public class AirplaneModeTile extends QSTileImpl<BooleanState> {
+public class AirplaneModeTile extends SecureQSTile<BooleanState> {
     private final Icon mIcon = ResourceIcon.get(com.android.internal.R.drawable.ic_qs_airplane);
     private final GlobalSetting mSetting;
     private final BroadcastDispatcher mBroadcastDispatcher;
     private final Lazy<ConnectivityManager> mLazyConnectivityManager;
 
     private boolean mListening;
 
     @Inject
     public AirplaneModeTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
             BroadcastDispatcher broadcastDispatcher,
-            Lazy<ConnectivityManager> lazyConnectivityManager
+            Lazy<ConnectivityManager> lazyConnectivityManager,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mBroadcastDispatcher = broadcastDispatcher;
         mLazyConnectivityManager = lazyConnectivityManager;
 
         mSetting = new GlobalSetting(mContext, mHandler, Global.AIRPLANE_MODE_ON) {
             @Override
             protected void handleValueChanged(int value) {
                 // mHandler is the background handler so calling this is OK
                 handleRefreshState(value);
             }
         };
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
-    public void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         boolean airplaneModeEnabled = mState.value;
         MetricsLogger.action(mContext, getMetricsCategory(), !airplaneModeEnabled);
         if (!airplaneModeEnabled && TelephonyProperties.in_ecm_mode().orElse(false)) {
             mActivityStarter.postStartActivityDismissingKeyguard(
                     new Intent(TelephonyManager.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS), 0);
             return;
         }
         setEnabled(!airplaneModeEnabled);
     }
 
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/BatterySaverTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/BatterySaverTile.java
index e3024fa0eddc4dce9dc72a6415343193ae558c8e..f68572bc3e758f0e92fe95cbe8157bdbee38b218 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/BatterySaverTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/BatterySaverTile.java
@@ -33,25 +33,26 @@ import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.SecureSetting;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.policy.BatteryController;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.systemui.util.settings.SecureSettings;
 
 import javax.inject.Inject;
 
-public class BatterySaverTile extends QSTileImpl<BooleanState> implements
+public class BatterySaverTile extends SecureQSTile<BooleanState> implements
         BatteryController.BatteryStateChangeCallback {
 
     private final BatteryController mBatteryController;
     @VisibleForTesting
     protected final SecureSetting mSetting;
 
     private int mLevel;
     private boolean mPowerSave;
     private boolean mCharging;
     private boolean mPluggedIn;
@@ -62,24 +63,25 @@ public class BatterySaverTile extends QSTileImpl<BooleanState> implements
     public BatterySaverTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
             BatteryController batteryController,
-            SecureSettings secureSettings
+            SecureSettings secureSettings,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mBatteryController = batteryController;
         mBatteryController.observe(getLifecycle(), this);
         int currentUser = host.getUserContext().getUserId();
         mSetting = new SecureSetting(
                 secureSettings,
                 mHandler,
                 Secure.LOW_POWER_WARNING_ACKNOWLEDGED,
                 currentUser
         ) {
             @Override
@@ -116,21 +118,25 @@ public class BatterySaverTile extends QSTileImpl<BooleanState> implements
         super.handleSetListening(listening);
         mSetting.setListening(listening);
     }
 
     @Override
     public Intent getLongClickIntent() {
         return new Intent(Intent.ACTION_POWER_USAGE_SUMMARY);
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         if (getState().state == Tile.STATE_UNAVAILABLE) {
             return;
         }
         mBatteryController.setPowerSaveMode(!mPowerSave);
     }
 
     @Override
     public CharSequence getTileLabel() {
         return mContext.getString(R.string.battery_detail_switch_title);
     }
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/BluetoothTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/BluetoothTile.java
index 65b6617c5a25212ea2f67ee4fa9b76767a8d28b0..7c24a8c9c10e587731945fc4f94270fa22f40a9b 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/BluetoothTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/BluetoothTile.java
@@ -46,65 +46,71 @@ import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.DetailAdapter;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSDetailItems;
 import com.android.systemui.qs.QSDetailItems.Item;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.policy.BluetoothController;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Bluetooth **/
-public class BluetoothTile extends QSTileImpl<BooleanState> {
+public class BluetoothTile extends SecureQSTile<BooleanState> {
     private static final Intent BLUETOOTH_SETTINGS = new Intent(Settings.ACTION_BLUETOOTH_SETTINGS);
 
     private final BluetoothController mController;
     private final BluetoothDetailAdapter mDetailAdapter;
 
     @Inject
     public BluetoothTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
-            BluetoothController bluetoothController
+            BluetoothController bluetoothController,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mController = bluetoothController;
         mDetailAdapter = (BluetoothDetailAdapter) createDetailAdapter();
         mController.observe(getLifecycle(), mCallback);
     }
 
     @Override
     public DetailAdapter getDetailAdapter() {
         return mDetailAdapter;
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         // Secondary clicks are header clicks, just toggle.
         final boolean isEnabled = mState.value;
         // Immediately enter transient enabling state when turning bluetooth on.
         refreshState(isEnabled ? null : ARG_SHOW_TRANSIENT_ENABLING);
         mController.setBluetoothEnabled(!isEnabled);
     }
 
     @Override
     public Intent getLongClickIntent() {
         return new Intent(Settings.ACTION_BLUETOOTH_SETTINGS);
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java
index 8e886e82d352cb5326beb6d6638d4ef4a3e3f63b..a36ec20ec9e280f0e03e09a583804860f8bb6e3b 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java
@@ -50,51 +50,53 @@ import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.DetailAdapter;
 import com.android.systemui.plugins.qs.QSIconView;
 import com.android.systemui.plugins.qs.QSTile.SignalState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.SignalTileView;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.phone.SystemUIDialog;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.systemui.statusbar.policy.NetworkController;
 import com.android.systemui.statusbar.policy.NetworkController.IconState;
 import com.android.systemui.statusbar.policy.NetworkController.MobileDataIndicators;
 import com.android.systemui.statusbar.policy.NetworkController.SignalCallback;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Cellular **/
-public class CellularTile extends QSTileImpl<SignalState> {
+public class CellularTile extends SecureQSTile<SignalState> {
     private static final String ENABLE_SETTINGS_DATA_PLAN = "enable.settings.data.plan";
 
     private final NetworkController mController;
     private final DataUsageController mDataController;
     private final CellularDetailAdapter mDetailAdapter;
 
     private final CellSignalCallback mSignalCallback = new CellSignalCallback();
 
     @Inject
     public CellularTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
-            NetworkController networkController
+            NetworkController networkController,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mController = networkController;
         mDataController = mController.getMobileDataController();
         mDetailAdapter = new CellularDetailAdapter();
         mController.observe(getLifecycle(), mSignalCallback);
     }
 
     @Override
     public SignalState newTileState() {
         return new SignalState();
     }
@@ -111,21 +113,25 @@ public class CellularTile extends QSTileImpl<SignalState> {
 
     @Override
     public Intent getLongClickIntent() {
         if (getState().state == Tile.STATE_UNAVAILABLE) {
             return new Intent(Settings.ACTION_WIRELESS_SETTINGS);
         }
         return getCellularSettingIntent();
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         if (getState().state == Tile.STATE_UNAVAILABLE) {
             return;
         }
         if (mDataController.isMobileDataEnabled()) {
             maybeShowDisableDialog();
         } else {
             mDataController.setMobileDataEnabled(true);
         }
     }
 
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/DataSaverTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/DataSaverTile.java
index 5a11ff83ff9e74b9d59a3c696deea847cf217fe5..a1030b05aa01b9ae044a650887eadd6d590ac759 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/DataSaverTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/DataSaverTile.java
@@ -33,57 +33,63 @@ import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.phone.SystemUIDialog;
 import com.android.systemui.statusbar.policy.DataSaverController;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import javax.inject.Inject;
 
-public class DataSaverTile extends QSTileImpl<BooleanState> implements
+public class DataSaverTile extends SecureQSTile<BooleanState> implements
         DataSaverController.Listener{
 
     private final DataSaverController mDataSaverController;
 
     @Inject
     public DataSaverTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
-            DataSaverController dataSaverController
+            DataSaverController dataSaverController,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mDataSaverController = dataSaverController;
         mDataSaverController.observe(getLifecycle(), this);
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
     public Intent getLongClickIntent() {
         return new Intent(Settings.ACTION_DATA_SAVER_SETTINGS);
     }
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         if (mState.value
                 || Prefs.getBoolean(mContext, Prefs.Key.QS_DATA_SAVER_DIALOG_SHOWN, false)) {
             // Do it right away.
             toggleDataSaver();
             return;
         }
         // Shows dialog first
         SystemUIDialog dialog = new SystemUIDialog(mContext);
         dialog.setTitle(com.android.internal.R.string.data_saver_enable_title);
         dialog.setMessage(com.android.internal.R.string.data_saver_description);
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java
index 87edc2cf8bac0c2f3942c3f8a9d279d3031d4cfb..fbf0255c60be7c1ba9cf3615d7f496aa690ef70f 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java
@@ -35,49 +35,50 @@ import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.policy.DataSaverController;
 import com.android.systemui.statusbar.policy.HotspotController;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Hotspot **/
-public class HotspotTile extends QSTileImpl<BooleanState> {
-
+public class HotspotTile extends SecureQSTile<BooleanState> {
     private final Icon mEnabledStatic = ResourceIcon.get(R.drawable.ic_hotspot);
 
     private final HotspotController mHotspotController;
     private final DataSaverController mDataSaverController;
 
     private final HotspotAndDataSaverCallbacks mCallbacks = new HotspotAndDataSaverCallbacks();
     private boolean mListening;
 
     @Inject
     public HotspotTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
             HotspotController hotspotController,
-            DataSaverController dataSaverController
+            DataSaverController dataSaverController,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mHotspotController = hotspotController;
         mDataSaverController = dataSaverController;
         mHotspotController.observe(this, mCallbacks);
         mDataSaverController.observe(this, mCallbacks);
     }
 
     @Override
     public boolean isAvailable() {
         return mHotspotController.isHotspotSupported();
     }
@@ -101,21 +102,25 @@ public class HotspotTile extends QSTileImpl<BooleanState> {
     public Intent getLongClickIntent() {
         return new Intent(Settings.ACTION_WIFI_TETHER_SETTING);
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         final boolean isEnabled = mState.value;
         if (!isEnabled && mDataSaverController.isDataSaverEnabled()) {
             return;
         }
         // Immediately enter transient enabling state when turning hotspot on.
         refreshState(isEnabled ? null : ARG_SHOW_TRANSIENT_ENABLING);
         mHotspotController.setHotspotEnabled(!isEnabled);
     }
 
     @Override
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java
index cd2e27a41f1e75eb974c16878a9692b225aa9c54..590215101fb368eec81536fd4f19e1e5bb8287e0 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java
@@ -38,48 +38,50 @@ import com.android.systemui.R;
 import com.android.systemui.broadcast.BroadcastDispatcher;
 import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Enable/Disable NFC **/
-public class NfcTile extends QSTileImpl<BooleanState> {
+public class NfcTile extends SecureQSTile<BooleanState> {
 
     private static final String NFC = "nfc";
     private final Icon mIcon = ResourceIcon.get(R.drawable.ic_qs_nfc);
 
     private NfcAdapter mAdapter;
     private BroadcastDispatcher mBroadcastDispatcher;
 
     private boolean mListening;
 
     @Inject
     public NfcTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
-            BroadcastDispatcher broadcastDispatcher
+            BroadcastDispatcher broadcastDispatcher,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mBroadcastDispatcher = broadcastDispatcher;
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
     public void handleSetListening(boolean listening) {
@@ -107,21 +109,25 @@ public class NfcTile extends QSTileImpl<BooleanState> {
     @Override
     protected void handleUserSwitch(int newUserId) {
     }
 
     @Override
     public Intent getLongClickIntent() {
         return new Intent(Settings.ACTION_NFC_SETTINGS);
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         if (getAdapter() == null) {
             return;
         }
         if (!getAdapter().isEnabled()) {
             getAdapter().enable();
         } else {
             getAdapter().disable();
         }
     }
 
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/RotationLockTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/RotationLockTile.java
index 4e936b8137affc1a90b7a20c0dff427288788f1d..9f44717df160bee0b9f3718c33be46cb226fd0d3 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/RotationLockTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/RotationLockTile.java
@@ -42,28 +42,29 @@ import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.SecureSetting;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.policy.BatteryController;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.systemui.statusbar.policy.RotationLockController;
 import com.android.systemui.statusbar.policy.RotationLockController.RotationLockControllerCallback;
 import com.android.systemui.util.settings.SecureSettings;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Rotation **/
-public class RotationLockTile extends QSTileImpl<BooleanState> implements
+public class RotationLockTile extends SecureQSTile<BooleanState> implements
         BatteryController.BatteryStateChangeCallback {
 
     private final Icon mIcon = ResourceIcon.get(com.android.internal.R.drawable.ic_qs_auto_rotate);
     private final RotationLockController mController;
     private final SensorPrivacyManager mPrivacyManager;
     private final BatteryController mBatteryController;
     private final SecureSetting mSetting;
 
     @Inject
     public RotationLockTile(
@@ -71,24 +72,25 @@ public class RotationLockTile extends QSTileImpl<BooleanState> implements
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
             RotationLockController rotationLockController,
             SensorPrivacyManager privacyManager,
             BatteryController batteryController,
-            SecureSettings secureSettings
+            SecureSettings secureSettings,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mController = rotationLockController;
         mController.observe(this, mCallback);
         mPrivacyManager = privacyManager;
         mBatteryController = batteryController;
         mPrivacyManager
                 .addSensorPrivacyListener(CAMERA, (sensor, enabled) -> refreshState());
         int currentUser = host.getUserContext().getUserId();
         mSetting = new SecureSetting(
                 secureSettings,
                 mHandler,
@@ -113,21 +115,25 @@ public class RotationLockTile extends QSTileImpl<BooleanState> implements
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
     public Intent getLongClickIntent() {
         return new Intent(Settings.ACTION_AUTO_ROTATE_SETTINGS);
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         final boolean newState = !mState.value;
         mController.setRotationLocked(!newState);
         refreshState(newState);
     }
 
     @Override
     public CharSequence getTileLabel() {
         return getState().label;
     }
 
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/SecureQSTile.kt b/packages/SystemUI/src/com/android/systemui/qs/tiles/SecureQSTile.kt
new file mode 100644
index 0000000000000000000000000000000000000000..30a5461fbb597bcf46bb107c1176559564bf2bc1
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/SecureQSTile.kt
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.systemui.qs.tiles
+
+import android.os.Handler
+import android.os.Looper
+import android.view.View
+import com.android.systemui.plugins.qs.QSTile
+import com.android.systemui.qs.QSHost
+import com.android.systemui.plugins.FalsingManager
+import com.android.internal.logging.MetricsLogger
+import com.android.systemui.plugins.ActivityStarter
+import com.android.systemui.plugins.statusbar.StatusBarStateController
+import com.android.systemui.qs.logging.QSLogger
+import com.android.systemui.statusbar.policy.KeyguardStateController
+import com.android.systemui.qs.tileimpl.QSTileImpl
+
+internal abstract class SecureQSTile<TState : QSTile.State> protected constructor(
+    host: QSHost, backgroundLooper: Looper, mainHandler: Handler, falsingManager: FalsingManager,
+    metricsLogger: MetricsLogger, statusBarStateController: StatusBarStateController,
+    activityStarter: ActivityStarter, qsLogger: QSLogger,
+    private val mKeyguard: KeyguardStateController,
+) : QSTileImpl<TState>(
+    host, backgroundLooper, mainHandler, falsingManager, metricsLogger, statusBarStateController,
+    activityStarter, qsLogger,
+) {
+    abstract override fun newTileState(): TState
+
+    protected abstract fun handleClick(view: View?, keyguardShowing: Boolean)
+
+    override fun handleClick(view: View?) {
+        handleClick(view, mKeyguard.isMethodSecure && mKeyguard.isShowing)
+    }
+
+    protected fun checkKeyguard(view: View?, keyguardShowing: Boolean): Boolean {
+        return if (keyguardShowing) {
+            mActivityStarter.postQSRunnableDismissingKeyguard {
+                handleClick(view, false)
+            }
+            true
+        } else {
+            false
+        }
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/WifiTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/WifiTile.java
index 41a3020191a6f8aad1c00bb4c7d08cc3c3b85aaf..75f7bdb8a9cbcc1ca6d502f052e9e55b160c90b9 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/WifiTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/WifiTile.java
@@ -45,33 +45,34 @@ import com.android.systemui.plugins.qs.QSIconView;
 import com.android.systemui.plugins.qs.QSTile;
 import com.android.systemui.plugins.qs.QSTile.SignalState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.AlphaControlledSignalTileView;
 import com.android.systemui.qs.QSDetailItems;
 import com.android.systemui.qs.QSDetailItems.Item;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSIconViewImpl;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.systemui.statusbar.policy.NetworkController;
 import com.android.systemui.statusbar.policy.NetworkController.AccessPointController;
 import com.android.systemui.statusbar.policy.NetworkController.SignalCallback;
 import com.android.systemui.statusbar.policy.NetworkController.WifiIndicators;
 import com.android.systemui.statusbar.policy.WifiIcons;
 import com.android.wifitrackerlib.WifiEntry;
 
 import java.util.List;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Wifi **/
-public class WifiTile extends QSTileImpl<SignalState> {
+public class WifiTile extends SecureQSTile<SignalState> {
     private static final Intent WIFI_SETTINGS = new Intent(Settings.ACTION_WIFI_SETTINGS);
 
     protected final NetworkController mController;
     private final AccessPointController mWifiController;
     private final WifiDetailAdapter mDetailAdapter;
     private final QSTile.SignalState mStateBeforeClick = newTileState();
 
     protected final WifiSignalCallback mSignalCallback = new WifiSignalCallback();
     private boolean mExpectDisabled;
 
@@ -79,24 +80,25 @@ public class WifiTile extends QSTileImpl<SignalState> {
     public WifiTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
             NetworkController networkController,
-            AccessPointController accessPointController
+            AccessPointController accessPointController,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mController = networkController;
         mWifiController = accessPointController;
         mDetailAdapter = (WifiDetailAdapter) createDetailAdapter();
         mController.observe(getLifecycle(), mSignalCallback);
         mStateBeforeClick.spec = "wifi";
     }
 
     @Override
     public SignalState newTileState() {
         return new SignalState();
@@ -125,21 +127,25 @@ public class WifiTile extends QSTileImpl<SignalState> {
     public QSIconView createTileView(Context context) {
         return new AlphaControlledSignalTileView(context);
     }
 
     @Override
     public Intent getLongClickIntent() {
         return WIFI_SETTINGS;
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         // Secondary clicks are header clicks, just toggle.
         mState.copyTo(mStateBeforeClick);
         boolean wifiEnabled = mState.value;
         // Immediately enter transient state when turning on wifi.
         refreshState(wifiEnabled ? null : ARG_SHOW_TRANSIENT_ENABLING);
         mController.setWifiEnabled(!wifiEnabled);
         mExpectDisabled = wifiEnabled;
         if (mExpectDisabled) {
             mHandler.postDelayed(() -> {
                 if (mExpectDisabled) {
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/WorkModeTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/WorkModeTile.java
index 8df8c63702c3671a7c5e2bfb2edc2efb2388c17d..7fc1726632eaa8cba0eedd25840a4f080a75c40a 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/WorkModeTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/WorkModeTile.java
@@ -32,60 +32,66 @@ import com.android.systemui.R;
 import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.phone.ManagedProfileController;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Work profile on/off */
-public class WorkModeTile extends QSTileImpl<BooleanState> implements
+public class WorkModeTile extends SecureQSTile<BooleanState> implements
         ManagedProfileController.Callback {
     private final Icon mIcon = ResourceIcon.get(R.drawable.stat_sys_managed_profile_status);
 
     private final ManagedProfileController mProfileController;
 
     @Inject
     public WorkModeTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
-            ManagedProfileController managedProfileController
+            ManagedProfileController managedProfileController,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mProfileController = managedProfileController;
         mProfileController.observe(getLifecycle(), this);
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
     public Intent getLongClickIntent() {
         return new Intent(Settings.ACTION_MANAGED_PROFILE_SETTINGS);
     }
 
     @Override
-    public void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         mProfileController.setWorkModeEnabled(!mState.value);
     }
 
     @Override
     public boolean isAvailable() {
         return mProfileController.hasActiveProfile();
     }
 
     @Override
     public void onManagedProfileChanged() {

commit 0fb71d62bd5dc16cead31b65da6a3e39d6f6f7ed
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2019-03-17 19:54:30-0400

    stop auto-granting location to system browsers
---
 .../server/pm/permission/DefaultPermissionGrantPolicy.java  | 13 -------------
 1 file changed, 13 deletions(-)

diff --git a/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java b/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
index 301914615562e148f103e51ce377b3fde1d000de..91ab884b4c12bf01764adc779ed55930c3fa46ee 100644
--- a/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
+++ b/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
@@ -698,33 +698,20 @@ final class DefaultPermissionGrantPolicy {
                 getDefaultSystemHandlerActivityPackage(pm,
                         DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE, userId),
                 userId, CONTACTS_PERMISSIONS);
 
         // Email
         grantPermissionsToSystemPackage(pm,
                 getDefaultSystemHandlerActivityPackageForCategory(pm,
                         Intent.CATEGORY_APP_EMAIL, userId),
                 userId, CONTACTS_PERMISSIONS, CALENDAR_PERMISSIONS);
 
-        // Browser
-        String browserPackage = ArrayUtils.firstOrNull(getKnownPackages(
-                PackageManagerInternal.PACKAGE_BROWSER, userId));
-        if (browserPackage == null) {
-            browserPackage = getDefaultSystemHandlerActivityPackageForCategory(pm,
-                    Intent.CATEGORY_APP_BROWSER, userId);
-            if (!pm.isSystemPackage(browserPackage)) {
-                browserPackage = null;
-            }
-        }
-        grantPermissionsToPackage(pm, browserPackage, userId, false /* ignoreSystemPackage */,
-                true /*whitelistRestrictedPermissions*/, FOREGROUND_LOCATION_PERMISSIONS);
-
         // Voice interaction
         if (voiceInteractPackageNames != null) {
             for (String voiceInteractPackageName : voiceInteractPackageNames) {
                 grantPermissionsToSystemPackage(pm, voiceInteractPackageName, userId,
                         CONTACTS_PERMISSIONS, CALENDAR_PERMISSIONS, MICROPHONE_PERMISSIONS,
                         PHONE_PERMISSIONS, SMS_PERMISSIONS, ALWAYS_LOCATION_PERMISSIONS,
                         NEARBY_DEVICES_PERMISSIONS);
             }
         }
 

commit 0d70bb45a06c154a02cfb23203a1fd0b9eb1f50c
Author: inthewaves <inthewaves@pm.me>
Date:   Sat 2020-09-12 12:28:34-0700

    support new special runtime permissions
    
    These are treated as a runtime permission even for legacy apps. They
    need to be granted by default for all apps to maintain compatibility.
    
    Ported from 10: 4d5d82f4e2fb9ff68158bf30f3944591bb74dd04
    
    Changes from 10:
    - It seems like parts of PackageManagerService#resetUserChangesToRuntimePermissionsAndFlagsLPw
    were refactored into PermissionManagerService#resetRuntimePermissionsInternal.
    As a result, PackageManagerService is no longer modified.
    
    [kdrag0n: Ported to Android 12]
    Signed-off-by: Danny Lin <danny@kdrag0n.dev>
---
 .../pm/permission/PermissionManagerService.java    | 25 +++++++++++++++++-----
 1 file changed, 20 insertions(+), 5 deletions(-)

diff --git a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
index 54a6c678e0da97a90a6c0ef4f0cbbb9150a99c9a..41b43e3c38bde52f111be3ef8e733af0a6fe0460 100644
--- a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
+++ b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
@@ -1518,21 +1518,22 @@ public class PermissionManagerService extends IPermissionManager.Stub {
             if (!(uidState.hasPermissionState(permName)
                     || pkg.getRequestedPermissions().contains(permName))) {
                 throw new SecurityException("Package " + pkg.getPackageName()
                         + " has not requested permission " + permName);
             }
 
             // If a permission review is required for legacy apps we represent
             // their permissions as always granted runtime ones since we need
             // to keep the review required permission flag per user while an
             // install permission's state is shared across all users.
-            if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.M && bp.isRuntime()) {
+            if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.M && bp.isRuntime() &&
+                    !isSpecialRuntimePermission(permName)) {
                 return;
             }
 
             final int flags = uidState.getPermissionFlags(permName);
             if ((flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0) {
                 Log.e(TAG, "Cannot grant system fixed permission "
                         + permName + " for package " + packageName);
                 return;
             }
             if (!overridePolicy && (flags & PackageManager.FLAG_PERMISSION_POLICY_FIXED) != 0) {
@@ -1561,21 +1562,22 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                 //  per-user. It isn't documented behavior and relatively rarely used anyway.
                 if (!uidState.grantPermission(bp)) {
                     return;
                 }
             } else {
                 if (ps.getInstantApp(userId) && !bp.isInstant()) {
                     throw new SecurityException("Cannot grant non-ephemeral permission" + permName
                             + " for package " + packageName);
                 }
 
-                if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.M) {
+                if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.M &&
+                    !isSpecialRuntimePermission(permName)) {
                     Slog.w(TAG, "Cannot grant runtime permission to a legacy app");
                     return;
                 }
 
                 if (!uidState.grantPermission(bp)) {
                     return;
                 }
             }
         }
 
@@ -1686,21 +1688,22 @@ public class PermissionManagerService extends IPermissionManager.Stub {
             if (!(uidState.hasPermissionState(permName)
                     || pkg.getRequestedPermissions().contains(permName))) {
                 throw new SecurityException("Package " + pkg.getPackageName()
                         + " has not requested permission " + permName);
             }
 
             // If a permission review is required for legacy apps we represent
             // their permissions as always granted runtime ones since we need
             // to keep the review required permission flag per user while an
             // install permission's state is shared across all users.
-            if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.M && bp.isRuntime()) {
+            if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.M && bp.isRuntime() &&
+                    !isSpecialRuntimePermission(permName)) {
                 return;
             }
 
             final int flags = uidState.getPermissionFlags(permName);
             // Only the system may revoke SYSTEM_FIXED permissions.
             if ((flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0
                     && UserHandle.getCallingAppId() != Process.SYSTEM_UID) {
                 throw new SecurityException("Non-System UID cannot revoke system fixed permission "
                         + permName + " for package " + packageName);
             }
@@ -1891,21 +1894,22 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                 continue;
             }
 
             // Never clobber system or policy.
             if ((oldFlags & policyOrSystemFlags) != 0) {
                 continue;
             }
 
             // If this permission was granted by default or role, make sure it is.
             if ((oldFlags & FLAG_PERMISSION_GRANTED_BY_DEFAULT) != 0
-                    || (oldFlags & FLAG_PERMISSION_GRANTED_BY_ROLE) != 0) {
+                    || (oldFlags & FLAG_PERMISSION_GRANTED_BY_ROLE) != 0
+                    || isSpecialRuntimePermission(permName)) {
                 // PermissionPolicyService will handle the app op for runtime permissions later.
                 grantRuntimePermissionInternal(packageName, permName, false,
                         Process.SYSTEM_UID, userId, delayingPermCallback);
             // In certain cases we should leave the state unchanged:
             // -- If permission review is enabled the permissions for a legacy apps
             // are represented as constantly granted runtime ones
             // -- If the permission was split from a non-runtime permission
             } else if ((flags & FLAG_PERMISSION_REVIEW_REQUIRED) == 0
                     && !isPermissionSplitFromNonRuntime(permName, targetSdk)) {
                 // Otherwise, reset the permission.
@@ -2580,20 +2584,24 @@ public class PermissionManagerService extends IPermissionManager.Stub {
     private int[] getPermissionGidsInternal(@NonNull String permissionName, @UserIdInt int userId) {
         synchronized (mLock) {
             Permission permission = mRegistry.getPermission(permissionName);
             if (permission == null) {
                 return EmptyArray.INT;
             }
             return permission.computeGids(userId);
         }
     }
 
+    public static boolean isSpecialRuntimePermission(final String permission) {
+        return false;
+    }
+
     /**
      * Restore the permission state for a package.
      *
      * <ul>
      *     <li>During boot the state gets restored from the disk</li>
      *     <li>During app update the state gets restored from the last version of the app</li>
      * </ul>
      *
      * @param pkg the package the permissions belong to
      * @param replace if the package is getting replaced (this might change the requested
@@ -2959,20 +2967,27 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                             // Hard restricted permissions cannot be held.
                             } else if (!permissionPolicyInitialized
                                     || (!hardRestricted || restrictionExempt)) {
                                 if ((origPermState != null && origPermState.isGranted())
                                         || legacyActivityRecognitionPermission != null) {
                                     if (!uidState.grantPermission(bp)) {
                                         wasChanged = true;
                                     }
                                 }
                             }
+
+                            if (isSpecialRuntimePermission(permName) &&
+                                    origPermState == null) {
+                                if (uidState.grantPermission(bp)) {
+                                    wasChanged = true;
+                                }
+                            }
                         } else {
                             if (origPermState == null) {
                                 // New permission
                                 if (PLATFORM_PACKAGE_NAME.equals(
                                         bp.getPackageName())) {
                                     if (!bp.isRemoved()) {
                                         flags |= FLAG_PERMISSION_REVIEW_REQUIRED
                                                 | FLAG_PERMISSION_REVOKED_COMPAT;
                                         wasChanged = true;
                                     }
@@ -3796,21 +3811,21 @@ public class PermissionManagerService extends IPermissionManager.Stub {
             synchronized (mLock) {
                 final Permission bp = mRegistry.getPermission(permission);
                 shouldGrantPermission = bp != null && (bp.isRuntime() || bp.isDevelopment())
                         && (!instantApp || bp.isInstant())
                         && (supportsRuntimePermissions || !bp.isRuntimeOnly())
                         && (permissions == null || permissions.contains(permission));
             }
             if (shouldGrantPermission) {
                 final int flags = getPermissionFlagsInternal(pkg.getPackageName(), permission,
                         myUid, userId);
-                if (supportsRuntimePermissions) {
+                if (supportsRuntimePermissions || isSpecialRuntimePermission(permission)) {
                     // Installer cannot change immutable permissions.
                     if ((flags & immutableFlags) == 0) {
                         grantRuntimePermissionInternal(pkg.getPackageName(), permission, false,
                                 myUid, userId, mDefaultPermissionCallback);
                     }
                 } else {
                     // In permission review mode we clear the review flag and the revoked compat
                     // flag when we are asked to install the app with all permissions granted.
                     if ((flags & compatFlags) != 0) {
                         updatePermissionFlagsInternal(pkg.getPackageName(), permission, compatFlags,

commit bbd8f3d700683708a357c2ddcf1f09cfe24a8842
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2019-03-17 11:59:15-0400

    make INTERNET into a special runtime permission
    
    Ported from 10: 5e2898e9d21dd6802bb0b0139e7e496c41e1cd80
---
 core/res/AndroidManifest.xml                                            | 2 +-
 .../java/com/android/server/pm/permission/PermissionManagerService.java | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index cd6af189a04acdf968815b5a36adf1cfde19d44a..9fa38e3d35f7d38a9273a691d302b27f23319664 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -1715,21 +1715,21 @@
     <!-- Permissions for accessing networks -->
     <!-- ======================================= -->
     <eat-comment />
 
     <!-- Allows applications to open network sockets.
          <p>Protection level: normal
     -->
     <permission android:name="android.permission.INTERNET"
         android:description="@string/permdesc_createNetworkSockets"
         android:label="@string/permlab_createNetworkSockets"
-        android:protectionLevel="normal|instant" />
+        android:protectionLevel="dangerous|instant" />
 
     <!-- Allows applications to access information about networks.
          <p>Protection level: normal
     -->
     <permission android:name="android.permission.ACCESS_NETWORK_STATE"
         android:description="@string/permdesc_accessNetworkState"
         android:label="@string/permlab_accessNetworkState"
         android:protectionLevel="normal|instant" />
 
     <!-- Allows applications to access information about Wi-Fi networks.
diff --git a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
index 41b43e3c38bde52f111be3ef8e733af0a6fe0460..22d3fd41ea64b152a1fe56c333b8cd5d0c503542 100644
--- a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
+++ b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
@@ -2585,21 +2585,21 @@ public class PermissionManagerService extends IPermissionManager.Stub {
         synchronized (mLock) {
             Permission permission = mRegistry.getPermission(permissionName);
             if (permission == null) {
                 return EmptyArray.INT;
             }
             return permission.computeGids(userId);
         }
     }
 
     public static boolean isSpecialRuntimePermission(final String permission) {
-        return false;
+        return Manifest.permission.INTERNET.equals(permission);
     }
 
     /**
      * Restore the permission state for a package.
      *
      * <ul>
      *     <li>During boot the state gets restored from the disk</li>
      *     <li>During app update the state gets restored from the last version of the app</li>
      * </ul>
      *

commit 3d6b349a843d4a68cfaa406839969b51d0effb5a
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2017-07-21 11:23:07-0400

    add a NETWORK permission group for INTERNET
    
    Ported from 10: b5c9f9407d5f5407686ea8c02fa67573ddc07824
    
    Changes from 10:
    - Needed to run `m api-stubs-docs-non-updatable-update-current-api`
    to fix the "You have tried to change the API from what has been
    previously approved" errors.
---
 core/api/current.txt            | 2 ++
 core/res/AndroidManifest.xml    | 8 ++++++++
 core/res/res/values/strings.xml | 5 +++++
 3 files changed, 15 insertions(+)

diff --git a/core/api/current.txt b/core/api/current.txt
index 1de47b548a5c81c95e636b5ea4d1d7aee2edb7b9..b4ef39a9e5571f3e281e719246d96016e3ee3991 100644
--- a/core/api/current.txt
+++ b/core/api/current.txt
@@ -195,20 +195,22 @@ package android {
   public static final class Manifest.permission_group {
     ctor public Manifest.permission_group();
     field public static final String ACTIVITY_RECOGNITION = "android.permission-group.ACTIVITY_RECOGNITION";
     field public static final String CALENDAR = "android.permission-group.CALENDAR";
     field public static final String CALL_LOG = "android.permission-group.CALL_LOG";
     field public static final String CAMERA = "android.permission-group.CAMERA";
     field public static final String CONTACTS = "android.permission-group.CONTACTS";
     field public static final String LOCATION = "android.permission-group.LOCATION";
     field public static final String MICROPHONE = "android.permission-group.MICROPHONE";
     field public static final String NEARBY_DEVICES = "android.permission-group.NEARBY_DEVICES";
+    field public static final String NETWORK = "android.permission-group.NETWORK";
+    field public static final String OTHER_SENSORS = "android.permission-group.OTHER_SENSORS";
     field public static final String PHONE = "android.permission-group.PHONE";
     field public static final String SENSORS = "android.permission-group.SENSORS";
     field public static final String SMS = "android.permission-group.SMS";
     field public static final String STORAGE = "android.permission-group.STORAGE";
   }
 
   public final class R {
     ctor public R();
   }
 
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index 9fa38e3d35f7d38a9273a691d302b27f23319664..5b7bcf7e9b35116d38242be91da9b87e6b8aedd0 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -1709,24 +1709,32 @@
          @hide
     -->
     <permission android:name="android.permission.ACCESS_MOCK_LOCATION"
         android:protectionLevel="signature" />
 
     <!-- ======================================= -->
     <!-- Permissions for accessing networks -->
     <!-- ======================================= -->
     <eat-comment />
 
+    <!-- Network access -->
+    <permission-group android:name="android.permission-group.NETWORK"
+        android:icon="@drawable/perm_group_network"
+        android:label="@string/permgrouplab_network"
+        android:description="@string/permgroupdesc_network"
+        android:priority="900" />
+
     <!-- Allows applications to open network sockets.
          <p>Protection level: normal
     -->
     <permission android:name="android.permission.INTERNET"
+        android:permissionGroup="android.permission-group.UNDEFINED"
         android:description="@string/permdesc_createNetworkSockets"
         android:label="@string/permlab_createNetworkSockets"
         android:protectionLevel="dangerous|instant" />
 
     <!-- Allows applications to access information about networks.
          <p>Protection level: normal
     -->
     <permission android:name="android.permission.ACCESS_NETWORK_STATE"
         android:description="@string/permdesc_accessNetworkState"
         android:label="@string/permlab_accessNetworkState"
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index b58638cc3adedb0672c75a066be21311aba35468..d3d97ee9286f63b1b4a6b79f9891562d04c6cc39 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -830,20 +830,25 @@
     <string name="permgrouplab_phone">Phone</string>
     <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgroupdesc_phone">make and manage phone calls</string>
     <!-- Message shown to the user when the apps requests permission from this group. If ever possible this should stay below 80 characters (assuming the parameters takes 20 characters). Don't abbreviate until the message reaches 120 characters though. [CHAR LIMIT=120] -->
 
     <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgrouplab_sensors">Body sensors</string>
     <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgroupdesc_sensors">access sensor data about your vital signs</string>
 
+    <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_network">Network</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_network">access the network</string>
+
     <!-- Title for the capability of an accessibility service to retrieve window content. -->
     <string name="capability_title_canRetrieveWindowContent">Retrieve window content</string>
     <!-- Description for the capability of an accessibility service to retrieve window content. -->
     <string name="capability_desc_canRetrieveWindowContent">Inspect the content of a window you\'re
         interacting with.</string>
 
     <!-- Title for the capability of an accessibility service to request touch exploration. -->
     <string name="capability_title_canRequestTouchExploration">Turn on Explore by Touch</string>
     <!-- Description for the capability of an accessibility service to request touch exploration. -->
     <string name="capability_desc_canRequestTouchExploration">Tapped items will be spoken aloud

commit 7681d5d003c404b5f41f0ed588abeb1284a0fbad
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2017-10-07 15:54:42-0400

    add special runtime permission for other sensors
    
    This covers sensors not included in the existing runtime permission for
    body sensors.
    
    Ported from 10: 9ec9f7f521323552fa658b46862c8408f1a7b41b
    
    Changes from 10:
    - Needed to run `m api-stubs-docs-non-updatable-update-current-api`
    to fix the "You have tried to change the API from what has been
    previously approved" errors.
---
 core/api/current.txt                                         |  1 +
 core/java/android/content/pm/PackageParser.java              |  2 ++
 core/res/AndroidManifest.xml                                 | 12 ++++++++++++
 core/res/res/values/strings.xml                              | 12 ++++++++++++
 .../server/pm/permission/PermissionManagerService.java       |  2 +-
 5 files changed, 28 insertions(+), 1 deletion(-)

diff --git a/core/api/current.txt b/core/api/current.txt
index b4ef39a9e5571f3e281e719246d96016e3ee3991..36ab6b1de52764b49994df4fe5b2e1d3bc000809 100644
--- a/core/api/current.txt
+++ b/core/api/current.txt
@@ -108,20 +108,21 @@ package android {
     field public static final String MANAGE_OWN_CALLS = "android.permission.MANAGE_OWN_CALLS";
     field public static final String MASTER_CLEAR = "android.permission.MASTER_CLEAR";
     field public static final String MEDIA_CONTENT_CONTROL = "android.permission.MEDIA_CONTENT_CONTROL";
     field public static final String MODIFY_AUDIO_SETTINGS = "android.permission.MODIFY_AUDIO_SETTINGS";
     field public static final String MODIFY_PHONE_STATE = "android.permission.MODIFY_PHONE_STATE";
     field public static final String MOUNT_FORMAT_FILESYSTEMS = "android.permission.MOUNT_FORMAT_FILESYSTEMS";
     field public static final String MOUNT_UNMOUNT_FILESYSTEMS = "android.permission.MOUNT_UNMOUNT_FILESYSTEMS";
     field public static final String NFC = "android.permission.NFC";
     field public static final String NFC_PREFERRED_PAYMENT_INFO = "android.permission.NFC_PREFERRED_PAYMENT_INFO";
     field public static final String NFC_TRANSACTION_EVENT = "android.permission.NFC_TRANSACTION_EVENT";
+    field public static final String OTHER_SENSORS = "android.permission.OTHER_SENSORS";
     field public static final String PACKAGE_USAGE_STATS = "android.permission.PACKAGE_USAGE_STATS";
     field @Deprecated public static final String PERSISTENT_ACTIVITY = "android.permission.PERSISTENT_ACTIVITY";
     field @Deprecated public static final String PROCESS_OUTGOING_CALLS = "android.permission.PROCESS_OUTGOING_CALLS";
     field public static final String QUERY_ALL_PACKAGES = "android.permission.QUERY_ALL_PACKAGES";
     field public static final String READ_CALENDAR = "android.permission.READ_CALENDAR";
     field public static final String READ_CALL_LOG = "android.permission.READ_CALL_LOG";
     field public static final String READ_CONTACTS = "android.permission.READ_CONTACTS";
     field public static final String READ_EXTERNAL_STORAGE = "android.permission.READ_EXTERNAL_STORAGE";
     field @Deprecated public static final String READ_INPUT_STATE = "android.permission.READ_INPUT_STATE";
     field public static final String READ_LOGS = "android.permission.READ_LOGS";
diff --git a/core/java/android/content/pm/PackageParser.java b/core/java/android/content/pm/PackageParser.java
index 4ff26242dab2beae2e6e77964c7bf1172c75b685..bd273f3001f9bfb7f19e7fe4606297e641604e3a 100644
--- a/core/java/android/content/pm/PackageParser.java
+++ b/core/java/android/content/pm/PackageParser.java
@@ -274,20 +274,22 @@ public class PackageParser {
      * NOTE: These must be declared in SDK version order, with permissions
      * added to older SDKs appearing before those added to newer SDKs.
      * If sdkVersion is 0, then this is not a permission that we want to
      * automatically add to older apps, but we do want to allow it to be
      * granted during a platform update.
      * @hide
      */
     @UnsupportedAppUsage
     public static final PackageParser.NewPermissionInfo NEW_PERMISSIONS[] =
         new PackageParser.NewPermissionInfo[] {
+            new PackageParser.NewPermissionInfo(android.Manifest.permission.OTHER_SENSORS,
+                    android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.WRITE_EXTERNAL_STORAGE,
                     android.os.Build.VERSION_CODES.DONUT, 0),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.READ_PHONE_STATE,
                     android.os.Build.VERSION_CODES.DONUT, 0)
     };
 
     /**
      * @deprecated callers should move to explicitly passing around source path.
      */
     @Deprecated
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index 5b7bcf7e9b35116d38242be91da9b87e6b8aedd0..1910909d1617dd3b9f4db0e93274649a9a391fdb 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -1478,20 +1478,32 @@
 
     <!-- Allows an app to use device supported biometric modalities.
          <p>Protection level: normal
     -->
     <permission android:name="android.permission.USE_BIOMETRIC"
         android:permissionGroup="android.permission-group.SENSORS"
         android:label="@string/permlab_useBiometric"
         android:description="@string/permdesc_useBiometric"
         android:protectionLevel="normal" />
 
+    <permission-group android:name="android.permission-group.OTHER_SENSORS"
+        android:icon="@drawable/perm_group_location"
+        android:label="@string/permgrouplab_otherSensors"
+        android:description="@string/permgroupdesc_otherSensors"
+        android:priority="1000" />
+
+    <permission android:name="android.permission.OTHER_SENSORS"
+        android:permissionGroup="android.permission-group.UNDEFINED"
+        android:label="@string/permlab_otherSensors"
+        android:description="@string/permdesc_otherSensors"
+        android:protectionLevel="dangerous" />
+
     <!-- ====================================================================== -->
     <!-- REMOVED PERMISSIONS                                                    -->
     <!-- ====================================================================== -->
 
     <!-- @hide We need to keep this around for backwards compatibility -->
     <permission android:name="android.permission.READ_PROFILE"
         android:protectionLevel="normal"
         android:permissionFlags="removed"/>
 
     <!-- @hide We need to keep this around for backwards compatibility -->
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index d3d97ee9286f63b1b4a6b79f9891562d04c6cc39..b27df17e19109575e61c169e414d6df33ba6308a 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -830,20 +830,25 @@
     <string name="permgrouplab_phone">Phone</string>
     <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgroupdesc_phone">make and manage phone calls</string>
     <!-- Message shown to the user when the apps requests permission from this group. If ever possible this should stay below 80 characters (assuming the parameters takes 20 characters). Don't abbreviate until the message reaches 120 characters though. [CHAR LIMIT=120] -->
 
     <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgrouplab_sensors">Body sensors</string>
     <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgroupdesc_sensors">access sensor data about your vital signs</string>
 
+    <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_otherSensors">Sensors</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_otherSensors">access sensor data about orientation, movement, etc.</string>
+
     <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgrouplab_network">Network</string>
     <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgroupdesc_network">access the network</string>
 
     <!-- Title for the capability of an accessibility service to retrieve window content. -->
     <string name="capability_title_canRetrieveWindowContent">Retrieve window content</string>
     <!-- Description for the capability of an accessibility service to retrieve window content. -->
     <string name="capability_desc_canRetrieveWindowContent">Inspect the content of a window you\'re
         interacting with.</string>
@@ -1158,20 +1163,27 @@
     <string name="permdesc_writeCallLog" product="default">Allows the app to modify your phone\'s call log, including data about incoming and outgoing calls.
         Malicious apps may use this to erase or modify your call log.</string>
 
     <!-- Title of the body sensors permission, listed so the user can decide whether to allow the application to access body sensor data. [CHAR LIMIT=80] -->
     <string name="permlab_bodySensors">access body sensors (like heart rate monitors)
     </string>
     <!-- Description of the body sensors permission, listed so the user can decide whether to allow the application to access data from body sensors. [CHAR LIMIT=NONE] -->
     <string name="permdesc_bodySensors" product="default">Allows the app to access data from sensors
     that monitor your physical condition, such as your heart rate.</string>
 
+    <!-- Title of the sensors permission, listed so the user can decide whether to allow the application to access sensor data. [CHAR LIMIT=80] -->
+    <string name="permlab_otherSensors">access sensors (like the compass)
+    </string>
+    <!-- Description of the sensors permission, listed so the user can decide whether to allow the application to access data from sensors. [CHAR LIMIT=NONE] -->
+    <string name="permdesc_otherSensors" product="default">Allows the app to access data from sensors
+    monitoring orientation, movement, vibration (including low frequency sound) and environmental data</string>
+
     <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permlab_readCalendar">Read calendar events and details</string>
     <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permdesc_readCalendar" product="tablet">This app can read all calendar events stored on your tablet and share or save your calendar data.</string>
     <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permdesc_readCalendar" product="tv">This app can read all calendar events stored on your Android TV device and share or save your calendar data.</string>
     <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permdesc_readCalendar" product="default">This app can read all calendar events stored on your phone and share or save your calendar data.</string>
 
     <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
diff --git a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
index 22d3fd41ea64b152a1fe56c333b8cd5d0c503542..60dc0a0277254b6cf1cd2539e1cca36c58305499 100644
--- a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
+++ b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
@@ -2585,21 +2585,21 @@ public class PermissionManagerService extends IPermissionManager.Stub {
         synchronized (mLock) {
             Permission permission = mRegistry.getPermission(permissionName);
             if (permission == null) {
                 return EmptyArray.INT;
             }
             return permission.computeGids(userId);
         }
     }
 
     public static boolean isSpecialRuntimePermission(final String permission) {
-        return Manifest.permission.INTERNET.equals(permission);
+        return Manifest.permission.INTERNET.equals(permission) || Manifest.permission.OTHER_SENSORS.equals(permission);
     }
 
     /**
      * Restore the permission state for a package.
      *
      * <ul>
      *     <li>During boot the state gets restored from the disk</li>
      *     <li>During app update the state gets restored from the last version of the app</li>
      * </ul>
      *

commit dd9bedffb547d80923f48bf71cdcc00ba551af50
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Tue 2021-10-05 16:27:43-0700

    net: Notify ConnectivityService of runtime permission changes
    
    ConnectivityService needs permission change events in order to enforce
    INTERNET permission updates correctly at runtime.
    
    Change-Id: I74b0b8a5aa70f0794b4f3d72c70167dbe2aae88d
---
 .../com/android/server/net/NetworkPolicyManagerService.java  | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/services/core/java/com/android/server/net/NetworkPolicyManagerService.java b/services/core/java/com/android/server/net/NetworkPolicyManagerService.java
index 84be7f5809e60524b3da88b80f9d58a726f1bb56..4d2f2f876a32c757e1dd7613f49161165a19849d 100644
--- a/services/core/java/com/android/server/net/NetworkPolicyManagerService.java
+++ b/services/core/java/com/android/server/net/NetworkPolicyManagerService.java
@@ -166,22 +166,24 @@ import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.usage.UsageStatsManagerInternal;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageManager;
+import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.PackageManagerInternal;
 import android.content.pm.UserInfo;
 import android.content.res.Resources;
 import android.database.ContentObserver;
 import android.net.ConnectivityManager;
 import android.net.ConnectivityManager.NetworkCallback;
 import android.net.INetworkManagementEventObserver;
 import android.net.INetworkPolicyListener;
 import android.net.INetworkPolicyManager;
 import android.net.INetworkStatsService;
 import android.net.Network;
@@ -267,20 +269,21 @@ import com.android.internal.util.DumpUtils;
 import com.android.internal.util.IndentingPrintWriter;
 import com.android.internal.util.StatLogger;
 import com.android.internal.util.XmlUtils;
 import com.android.net.module.util.NetworkIdentityUtils;
 import com.android.net.module.util.PermissionUtils;
 import com.android.server.EventLogTags;
 import com.android.server.LocalServices;
 import com.android.server.ServiceThread;
 import com.android.server.SystemConfig;
 import com.android.server.connectivity.MultipathPolicyTracker;
+import com.android.server.pm.permission.PermissionManagerServiceInternal;
 import com.android.server.usage.AppStandbyInternal;
 import com.android.server.usage.AppStandbyInternal.AppIdleStateChangeListener;
 
 import libcore.io.IoUtils;
 
 import org.xmlpull.v1.XmlPullParserException;
 
 import java.io.File;
 import java.io.FileDescriptor;
 import java.io.FileInputStream;
@@ -757,20 +760,29 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         mAppOps = context.getSystemService(AppOpsManager.class);
         mMultipathPolicyTracker = new MultipathPolicyTracker(mContext, mHandler);
         // Expose private service for system components to use.
         LocalServices.addService(NetworkPolicyManagerInternal.class,
                 new NetworkPolicyManagerInternalImpl());
     }
 
     public void bindConnectivityManager() {
         mConnManager = Objects.requireNonNull(mContext.getSystemService(ConnectivityManager.class),
                 "missing ConnectivityManager");
+
+        // Listen for permission changes and forward to ConnectivityService
+        PermissionManagerServiceInternal pm = LocalServices.getService(
+                PermissionManagerServiceInternal.class);
+        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);
+        pm.addOnRuntimePermissionStateChangedListener((packageName, userId) -> {
+            int uid = pmi.getPackageUid(packageName, PackageManager.GET_PERMISSIONS, userId);
+            mConnManager.onPackagePermissionChanged(uid);
+        });
     }
 
     @GuardedBy("mUidRulesFirstLock")
     private void updatePowerSaveWhitelistUL() {
         int[] whitelist = mPowerWhitelistManager.getWhitelistedAppIds(/* includingIdle */ false);
         mPowerSaveWhitelistExceptIdleAppIds.clear();
         for (int uid : whitelist) {
             mPowerSaveWhitelistExceptIdleAppIds.put(uid, true);
         }
 

commit 11c81683a2cb57a943091b9af0f720624a2c4dc0
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Sun 2021-10-10 22:20:11-0700

    gmscompat: Add compatibility layer for unprivileged Google Play services
    
    This is a compatibility layer that allows installing Google Play
    services, Google Play Store, and Google Services Framework as regular,
    unprivileged apps in the standard app sandbox. Most functionality works
    without giving Google Play Services any special privileges, permissions,
    or security exceptions, including:
    
    - Account login (including two-factor authentication with NFC security keys)
    - Play Store
    - Firebase Cloud Messaging notifications (tested with Signal, Discord, Slack, and Gmail)
    - Firebase database API (tested with Swift Backup)
    - Firebase app indexing
    - Google Play Games
    - Account settings
    - Google My Account
    - Autofill
    - SMS verification receiver (tested with Signal)
    - Play license verification (both in-app purchases and paid apps)
    - Play Store app purchases
    - Play Store app installation (buggy)
    - SafetyNet (basic integrity passes, but not CTS profile checks)
    - Dynamite modules (e.g. Maps API v2 and Cronet)
    - Play geolocation API (buggy)
    
    The Google Play services family of apps can also be installed in a
    secondary user profile for isolation, and all of the above functionality
    will still work.
    
    NB: The DropBoxManager and DeviceConfig shims are not functionally
    meaningful, but they help reduce log spam that could obscure fatal
    errors.
    
    Change-Id: Ib6f6b36946dab2f6bb51650c1b6aabb628af46be
---
 core/api/module-lib-current.txt                    |   8 +
 core/java/android/app/ActivityManager.java         |   6 +
 core/java/android/app/ActivityThread.java          |   2 +
 core/java/android/app/AppOpsManager.java           |  21 ++
 .../android/app/ApplicationPackageManager.java     |  14 ++
 core/java/android/app/ContextImpl.java             |  14 ++
 core/java/android/app/Instrumentation.java         |   4 +
 core/java/android/app/LoadedApk.java               |   5 +
 core/java/android/app/NotificationManager.java     |   6 +
 core/java/android/app/SystemServiceRegistry.java   |   5 +
 .../android/app/admin/DevicePolicyManager.java     |  17 ++
 .../android/app/compat/gms/GmsCompat.java (new)    | 230 ++++++++++++++++++
 .../content/integrity/AppIntegrityManager.java     |  13 ++
 core/java/android/content/pm/PackageParser.java    |  11 +-
 .../content/pm/parsing/ParsingPackageUtils.java    |   3 +
 core/java/android/content/res/ApkAssets.java       |   9 +
 .../hardware/location/ContextHubManager.java       |  11 +
 core/java/android/net/NetworkScoreManager.java     |  13 ++
 core/java/android/os/Build.java                    |   7 +
 core/java/android/os/DropBoxManager.java           |   5 +
 core/java/android/os/UserManager.java              |  41 ++++
 core/java/android/provider/DeviceConfig.java       |  13 ++
 core/java/android/provider/Settings.java           |   5 +
 .../android/internal/gmscompat/GmsHooks.java (new) | 256 +++++++++++++++++++++
 .../android/internal/gmscompat/GmsInfo.java (new)  |  34 +++
 .../gmscompat/dynamite/GmsDynamiteHooks.java (new) | 197 ++++++++++++++++
 .../dynamite/client/DynamiteContext.java (new)     | 156 +++++++++++++
 .../dynamite/client/ModuleLoadState.java (new)     |  64 ++++++
 .../dynamite/server/FileProxyProvider.java (new)   |  87 +++++++
 .../dynamite/server/FileProxyService.java (new)    | 100 ++++++++
 .../dynamite/server/IFileProxyService.aidl (new)   |   7 +
 core/res/AndroidManifest.xml                       |   2 +-
 core/res/res/values/strings.xml                    |  14 ++
 core/res/res/values/symbols.xml                    |   5 +
 .../java/android/location/LocationManager.java     |   5 +
 .../android/server/am/ActivityManagerService.java  |   5 +
 .../com/android/server/compat/CompatChange.java    |   4 +
 .../java/com/android/server/pm/AppsFilter.java     |   7 +
 .../java/android/telephony/TelephonyManager.java   |  51 ++++
 39 files changed, 1455 insertions(+), 2 deletions(-)

diff --git a/core/api/module-lib-current.txt b/core/api/module-lib-current.txt
index e48a1da7b6a7e1aadf492309927a7b32d84e88b4..c04ec72ba9f7c5b1b83f520e189a5c1223f4dfeb 100644
--- a/core/api/module-lib-current.txt
+++ b/core/api/module-lib-current.txt
@@ -38,20 +38,28 @@ package android.app {
     method @RequiresPermission(android.Manifest.permission.GET_INTENT_SENDER_INTENT) public boolean intentFilterEquals(@Nullable android.app.PendingIntent);
     method @NonNull @RequiresPermission(android.Manifest.permission.GET_INTENT_SENDER_INTENT) public java.util.List<android.content.pm.ResolveInfo> queryIntentComponents(int);
   }
 
   public class StatusBarManager {
     method @RequiresPermission(android.Manifest.permission.STATUS_BAR) public void setExpansionDisabledForSimNetworkLock(boolean);
   }
 
 }
 
+package android.app.compat.gms {
+
+  public final class GmsCompat {
+    method public static boolean isEnabled();
+  }
+
+}
+
 package android.app.usage {
 
   public class NetworkStatsManager {
     method @RequiresPermission(anyOf={android.net.NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK, android.Manifest.permission.NETWORK_STACK}) public void notifyNetworkStatus(@NonNull java.util.List<android.net.Network>, @NonNull java.util.List<android.net.NetworkStateSnapshot>, @Nullable String, @NonNull java.util.List<android.net.UnderlyingNetworkInfo>);
   }
 
 }
 
 package android.content {
 
diff --git a/core/java/android/app/ActivityManager.java b/core/java/android/app/ActivityManager.java
index f53c5b6c974824d2a6152457de586ec748b22605..30f1cc88affc57f3136ab23fe19534e05eb82914 100644
--- a/core/java/android/app/ActivityManager.java
+++ b/core/java/android/app/ActivityManager.java
@@ -25,20 +25,21 @@ import android.Manifest;
 import android.annotation.DrawableRes;
 import android.annotation.IntDef;
 import android.annotation.IntRange;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.annotation.UserIdInt;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.ConfigurationInfo;
 import android.content.pm.IPackageDataObserver;
@@ -76,20 +77,21 @@ import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.DisplayMetrics;
 import android.util.Singleton;
 import android.util.Size;
 import android.util.TypedXmlPullParser;
 import android.util.TypedXmlSerializer;
 import android.window.TaskSnapshot;
 
 import com.android.internal.app.LocalePicker;
 import com.android.internal.app.procstats.ProcessStats;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.RoSystemProperties;
 import com.android.internal.os.TransferPipe;
 import com.android.internal.util.FastPrintWriter;
 import com.android.internal.util.MemInfoReader;
 import com.android.internal.util.Preconditions;
 import com.android.server.LocalServices;
 
 import java.io.FileDescriptor;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -4030,20 +4032,24 @@ public class ActivityManager {
     /**
      * Gets the userId of the current foreground user. Requires system permissions.
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {
             "android.permission.INTERACT_ACROSS_USERS",
             "android.permission.INTERACT_ACROSS_USERS_FULL"
     })
     public static int getCurrentUser() {
+        if (GmsCompat.isEnabled()) {
+            return GmsHooks.getCurrentUser();
+        }
+
         try {
             return getService().getCurrentUserId();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * @param userid the user's id. Zero indicates the default user.
      * @hide
diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index fc4bb1a00da5fd9d41dd97e248abe4a2a904923d..29f1c906c5db315cd3b88dfd295f04d42fb42b7c 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -181,20 +181,21 @@ import android.view.translation.TranslationSpec;
 import android.view.translation.UiTranslationSpec;
 import android.webkit.WebView;
 import android.window.SizeConfigurationBuckets;
 import android.window.SplashScreen;
 import android.window.SplashScreenView;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.app.IVoiceInteractor;
 import com.android.internal.content.ReferrerIntent;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.BinderInternal;
 import com.android.internal.os.RuntimeInit;
 import com.android.internal.os.SomeArgs;
 import com.android.internal.policy.DecorView;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.FastPrintWriter;
 import com.android.internal.util.Preconditions;
 import com.android.internal.util.function.pooled.PooledLambda;
 import com.android.org.conscrypt.OpenSSLSocketImpl;
 import com.android.org.conscrypt.TrustedCertificateStore;
@@ -4477,20 +4478,21 @@ public final class ActivityThread extends ClientTransactionHandler
                 context = (ContextImpl) context.createAttributionContext(attributionTag);
             }
             // Service resources must be initialized with the same loaders as the application
             // context.
             context.getResources().addLoaders(
                     app.getResources().getLoaders().toArray(new ResourcesLoader[0]));
 
             context.setOuterContext(service);
             service.attach(context, this, data.info.name, data.token, app,
                     ActivityManager.getService());
+            GmsHooks.attachService(service);
             service.onCreate();
             mServicesData.put(data.token, data);
             mServices.put(data.token, service);
             try {
                 ActivityManager.getService().serviceDoneExecuting(
                         data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
             } catch (RemoteException e) {
                 throw e.rethrowFromSystemServer();
             }
         } catch (Exception e) {
diff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java
index d932a29beca616c5115ccb18ed871fd18dd6865e..f0b749c40a5ff65cf14e394795cd3fea4d1723b8 100644
--- a/core/java/android/app/AppOpsManager.java
+++ b/core/java/android/app/AppOpsManager.java
@@ -21,20 +21,21 @@ import static java.lang.Long.max;
 import android.Manifest;
 import android.annotation.CallbackExecutor;
 import android.annotation.IntDef;
 import android.annotation.IntRange;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
+import android.app.compat.gms.GmsCompat;
 import android.app.usage.UsageStatsManager;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.AttributionSource;
 import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
@@ -8256,20 +8257,24 @@ public class AppOpsManager {
         return noteOpNoThrow(strOpToOp(op), uid, packageName, attributionTag, message);
     }
 
     /**
      * @see #noteOpNoThrow(String, int, String, String, String)
      *
      * @hide
      */
     public int noteOpNoThrow(int op, int uid, @Nullable String packageName,
             @Nullable String attributionTag, @Nullable String message) {
+        if (GmsCompat.isEnabled() && uid != Process.myUid()) {
+            return noteProxyOpNoThrow(op, packageName, uid, attributionTag, message);
+        }
+
         try {
             collectNoteOpCallsForValidation(op);
             int collectionMode = getNotedOpCollectionMode(uid, packageName, op);
             boolean shouldCollectMessage = Process.myUid() == Process.SYSTEM_UID;
             if (collectionMode == COLLECT_ASYNC) {
                 if (message == null) {
                     // Set stack trace as default message
                     message = getFormattedStackTrace();
                     shouldCollectMessage = true;
                 }
@@ -8405,20 +8410,28 @@ public class AppOpsManager {
      * @see #noteOpNoThrow(String, int, String, String, String)
      */
     public int noteProxyOpNoThrow(@NonNull String op, @Nullable String proxiedPackageName,
             int proxiedUid, @Nullable String proxiedAttributionTag, @Nullable String message) {
         return noteProxyOpNoThrow(strOpToOp(op), new AttributionSource(
                 mContext.getAttributionSource(), new AttributionSource(proxiedUid,
                         proxiedPackageName, proxiedAttributionTag, mContext.getAttributionSource()
                         .getToken())), message,/*skipProxyOperation*/ false);
     }
 
+    private int noteProxyOpNoThrow(int op, @Nullable String proxiedPackageName,
+            int proxiedUid, @Nullable String proxiedAttributionTag, @Nullable String message) {
+        return noteProxyOpNoThrow(op, new AttributionSource(
+                mContext.getAttributionSource(), new AttributionSource(proxiedUid,
+                proxiedPackageName, proxiedAttributionTag, mContext.getAttributionSource()
+                .getToken())), message,/*skipProxyOperation*/ false);
+    }
+
     /**
      * Make note of an application performing an operation on behalf of another application(s).
      *
      * @param op The operation to note. One of the OPSTR_* constants.
      * @param attributionSource The permission identity for which to note.
      * @param message A message describing the reason the op was noted
      * @param skipProxyOperation Whether to note op for the proxy
      *
      * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or {@link #MODE_IGNORED}
      * if it is not allowed and should be silently ignored (without causing the app to crash).
@@ -8761,20 +8774,24 @@ public class AppOpsManager {
     }
 
     /**
      * @see #startOpNoThrow(String, int, String, String, String)
      *
      * @hide
      */
     public int startOpNoThrow(@NonNull IBinder token, int op, int uid, @NonNull String packageName,
             boolean startIfModeDefault, @Nullable String attributionTag, @Nullable String message,
             @AttributionFlags int attributionFlags, int attributionChainId) {
+        if (GmsCompat.isEnabled() && uid != Process.myUid()) {
+            return noteProxyOpNoThrow(op, packageName, uid, attributionTag, message);
+        }
+
         try {
             collectNoteOpCallsForValidation(op);
             int collectionMode = getNotedOpCollectionMode(uid, packageName, op);
             boolean shouldCollectMessage = Process.myUid() == Process.SYSTEM_UID;
             if (collectionMode == COLLECT_ASYNC) {
                 if (message == null) {
                     // Set stack trace as default message
                     message = getFormattedStackTrace();
                     shouldCollectMessage = true;
                 }
@@ -8984,20 +9001,24 @@ public class AppOpsManager {
         finishOp(mContext.getAttributionSource().getToken(), op, uid, packageName, attributionTag);
     }
 
     /**
      * @see #finishOp(String, int, String, String)
      *
      * @hide
      */
     public void finishOp(IBinder token, int op, int uid, @NonNull String packageName,
             @Nullable String attributionTag) {
+        if (GmsCompat.isEnabled() && uid != Process.myUid()) {
+            return;
+        }
+
         try {
             mService.finishOperation(token, op, uid, packageName, attributionTag);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Report that an application is no longer performing an operation that had previously
      * been started with {@link #startProxyOp(String, int, String, String, String)}. There is no
diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index cd2c12cb4b6f221872ffdcf78dc70f9f957ba636..4dabe78f2f737c12314bd4697a839b9f44f39d7b 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -24,20 +24,21 @@ import static android.content.pm.Checksum.TYPE_WHOLE_SHA1;
 import static android.content.pm.Checksum.TYPE_WHOLE_SHA256;
 import static android.content.pm.Checksum.TYPE_WHOLE_SHA512;
 
 import android.annotation.CallbackExecutor;
 import android.annotation.DrawableRes;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.StringRes;
 import android.annotation.UserIdInt;
 import android.annotation.XmlRes;
+import android.app.compat.gms.GmsCompat;
 import android.app.role.RoleManager;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.IntentSender;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApkChecksum;
@@ -113,20 +114,21 @@ import android.system.OsConstants;
 import android.system.StructStat;
 import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.LauncherIcons;
 import android.util.Log;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.Immutable;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.SomeArgs;
 import com.android.internal.util.UserIcons;
 
 import dalvik.system.VMRuntime;
 
 import libcore.util.EmptyArray;
 
 import java.io.File;
 import java.lang.ref.WeakReference;
 import java.security.cert.Certificate;
@@ -209,36 +211,40 @@ public class ApplicationPackageManager extends PackageManager {
 
     @Override
     public PackageInfo getPackageInfo(String packageName, int flags)
             throws NameNotFoundException {
         return getPackageInfoAsUser(packageName, flags, getUserId());
     }
 
     @Override
     public PackageInfo getPackageInfo(VersionedPackage versionedPackage, int flags)
             throws NameNotFoundException {
+        flags = GmsHooks.getPackageInfoFlags(flags);
+
         final int userId = getUserId();
         try {
             PackageInfo pi = mPM.getPackageInfoVersioned(versionedPackage,
                     updateFlagsForPackage(flags, userId), userId);
             if (pi != null) {
                 return pi;
             }
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
         throw new NameNotFoundException(versionedPackage.toString());
     }
 
     @Override
     public PackageInfo getPackageInfoAsUser(String packageName, int flags, int userId)
             throws NameNotFoundException {
+        flags = GmsHooks.getPackageInfoFlags(flags);
+
         PackageInfo pi =
                 getPackageInfoAsUserCached(
                         packageName,
                         updateFlagsForPackage(flags, userId),
                         userId);
         if (pi == null) {
             throw new NameNotFoundException(packageName);
         }
         return pi;
     }
@@ -572,20 +578,24 @@ public class ApplicationPackageManager extends PackageManager {
     /** @hide */
     @Override
     public @NonNull List<SharedLibraryInfo> getSharedLibraries(int flags) {
         return getSharedLibrariesAsUser(flags, getUserId());
     }
 
     /** @hide */
     @Override
     @SuppressWarnings("unchecked")
     public @NonNull List<SharedLibraryInfo> getSharedLibrariesAsUser(int flags, int userId) {
+        if (GmsCompat.isEnabled()) {
+            return GmsHooks.getSharedLibrariesAsUser();
+        }
+
         try {
             ParceledListSlice<SharedLibraryInfo> sharedLibs = mPM.getSharedLibraries(
                     mContext.getOpPackageName(), flags, userId);
             if (sharedLibs == null) {
                 return Collections.emptyList();
             }
             return sharedLibs.getList();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
@@ -1797,20 +1807,24 @@ public class ApplicationPackageManager extends PackageManager {
                 mCachedSafeMode = mPM.isSafeMode() ? 1 : 0;
             }
             return mCachedSafeMode != 0;
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public void addOnPermissionsChangeListener(OnPermissionsChangedListener listener) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         getPermissionManager().addOnPermissionsChangeListener(listener);
     }
 
     @Override
     public void removeOnPermissionsChangeListener(OnPermissionsChangedListener listener) {
         getPermissionManager().removeOnPermissionsChangeListener(listener);
     }
 
     @UnsupportedAppUsage
     static void configurationChanged() {
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 1397f5ea10dc7caa4dbd815b23841e128e58bf45..e4115456d1d852a556980e19035c53a29cac1d38 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -18,20 +18,21 @@ package android.app;
 
 import static android.content.pm.PackageManager.PERMISSION_DENIED;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.os.StrictMode.vmIncorrectContextUseEnabled;
 import static android.view.WindowManager.LayoutParams.WindowType;
 
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.UiContext;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.AttributionSource;
 import android.content.AutofillOptions;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.ContentCaptureOptions;
 import android.content.ContentProvider;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.ContextParams;
@@ -87,20 +88,21 @@ import android.util.AndroidRuntimeException;
 import android.util.ArrayMap;
 import android.util.Log;
 import android.util.Slog;
 import android.view.Display;
 import android.view.DisplayAdjustments;
 import android.view.autofill.AutofillManager.AutofillClient;
 import android.window.WindowContext;
 import android.window.WindowTokenClient;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.util.Preconditions;
 
 import dalvik.system.BlockGuard;
 
 import libcore.io.Memory;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
@@ -1377,20 +1379,22 @@ class ContextImpl extends Context {
                     mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType,
                     rd, initialCode, initialData, initialExtras, receiverPermissions,
                     null /*excludedPermissions=*/, appOp, options, true, false, getUserId());
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user) {
+        user = GmsHooks.getUserHandle(user);
+
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         try {
             intent.prepareToLeaveProcess(this);
             ActivityManager.getService().broadcastIntentWithFeature(
                     mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType,
                     null, Activity.RESULT_OK, null, null, null, null /*excludedPermissions=*/,
                     AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
@@ -1398,38 +1402,42 @@ class ContextImpl extends Context {
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user,
             String receiverPermission) {
         sendBroadcastAsUser(intent, user, receiverPermission, AppOpsManager.OP_NONE);
     }
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission,
             Bundle options) {
+        user = GmsHooks.getUserHandle(user);
+
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         String[] receiverPermissions = receiverPermission == null ? null
                 : new String[] {receiverPermission};
         try {
             intent.prepareToLeaveProcess(this);
             ActivityManager.getService().broadcastIntentWithFeature(
                     mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType,
                     null, Activity.RESULT_OK, null, null, receiverPermissions,
                     null /*excludedPermissions=*/, AppOpsManager.OP_NONE, options, false, false,
                     user.getIdentifier());
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user,
             String receiverPermission, int appOp) {
+        user = GmsHooks.getUserHandle(user);
+
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         String[] receiverPermissions = receiverPermission == null ? null
                 : new String[] {receiverPermission};
         try {
             intent.prepareToLeaveProcess(this);
             ActivityManager.getService().broadcastIntentWithFeature(
                     mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType,
                     null, Activity.RESULT_OK, null, null, receiverPermissions,
                     null /*excludedPermissions=*/, appOp, null, false, false, user.getIdentifier());
         } catch (RemoteException e) {
@@ -1450,20 +1458,22 @@ class ContextImpl extends Context {
             String receiverPermission, int appOp, BroadcastReceiver resultReceiver,
             Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
         sendOrderedBroadcastAsUser(intent, user, receiverPermission, appOp,
                 null, resultReceiver, scheduler, initialCode, initialData, initialExtras);
     }
 
     @Override
     public void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
             String receiverPermission, int appOp, Bundle options, BroadcastReceiver resultReceiver,
             Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
+        user = GmsHooks.getUserHandle(user);
+
         IIntentReceiver rd = null;
         if (resultReceiver != null) {
             if (mPackageInfo != null) {
                 if (scheduler == null) {
                     scheduler = mMainThread.getHandler();
                 }
                 rd = mPackageInfo.getReceiverDispatcher(
                     resultReceiver, getOuterContext(), scheduler,
                     mMainThread.getInstrumentation(), false);
             } else {
@@ -1806,20 +1816,24 @@ class ContextImpl extends Context {
                 throw ex;
             } else {
                 Log.w(TAG, "Implicit intents with startService are not safe: " + service
                         + " " + Debug.getCallers(2, 3));
             }
         }
     }
 
     @Override
     public ComponentName startService(Intent service) {
+        if (GmsCompat.isEnabled()) {
+            return GmsHooks.startService(this, service);
+        }
+
         warnIfCallingFromSystemProcess();
         return startServiceCommon(service, false, mUser);
     }
 
     @Override
     public ComponentName startForegroundService(Intent service) {
         warnIfCallingFromSystemProcess();
         return startServiceCommon(service, true, mUser);
     }
 
diff --git a/core/java/android/app/Instrumentation.java b/core/java/android/app/Instrumentation.java
index b2184fe65887c59ccab5c2df625f93c884d4d184..bf066564fc94137b6ed84188a0bf0ab75366cf09 100644
--- a/core/java/android/app/Instrumentation.java
+++ b/core/java/android/app/Instrumentation.java
@@ -50,20 +50,22 @@ import android.view.InputDevice;
 import android.view.KeyCharacterMap;
 import android.view.KeyEvent;
 import android.view.MotionEvent;
 import android.view.SurfaceControl;
 import android.view.ViewConfiguration;
 import android.view.Window;
 import android.view.WindowManagerGlobal;
 
 import com.android.internal.content.ReferrerIntent;
 
+import com.android.internal.gmscompat.GmsHooks;
+
 import java.io.File;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeoutException;
 
 /**
  * Base class for implementing application instrumentation code.  When running
  * with instrumentation turned on, this class will be instantiated for you
@@ -1169,37 +1171,39 @@ public class Instrumentation {
      * @param context The context to initialize the application with
      * 
      * @return The newly instantiated Application object.
      */
     public Application newApplication(ClassLoader cl, String className, Context context)
             throws InstantiationException, IllegalAccessException, 
             ClassNotFoundException {
         Application app = getFactory(context.getPackageName())
                 .instantiateApplication(cl, className);
         app.attach(context);
+        GmsHooks.initApplicationBeforeOnCreate(app);
         return app;
     }
     
     /**
      * Perform instantiation of the process's {@link Application} object.  The
      * default implementation provides the normal system behavior.
      * 
      * @param clazz The class used to create an Application object from.
      * @param context The context to initialize the application with
      * 
      * @return The newly instantiated Application object.
      */
     static public Application newApplication(Class<?> clazz, Context context)
             throws InstantiationException, IllegalAccessException, 
             ClassNotFoundException {
         Application app = (Application)clazz.newInstance();
         app.attach(context);
+        GmsHooks.initApplicationBeforeOnCreate(app);
         return app;
     }
 
     /**
      * Perform calling of the application's {@link Application#onCreate}
      * method.  The default implementation simply calls through to that method.
      *
      * <p>Note: This method will be called immediately after {@link #onCreate(Bundle)}.
      * Often instrumentation tests start their test thread in onCreate(); you
      * need to be careful of races between these.  (Well between it and
diff --git a/core/java/android/app/LoadedApk.java b/core/java/android/app/LoadedApk.java
index a2c9795204ada00646c046e5341d771d53f292f6..5a2533115b46e5d04d66346b48c682dad39a2ff9 100644
--- a/core/java/android/app/LoadedApk.java
+++ b/core/java/android/app/LoadedApk.java
@@ -52,20 +52,21 @@ import android.security.net.config.NetworkSecurityConfigProvider;
 import android.sysprop.VndkProperties;
 import android.text.TextUtils;
 import android.util.AndroidRuntimeException;
 import android.util.ArrayMap;
 import android.util.Log;
 import android.util.Slog;
 import android.util.SparseArray;
 import android.view.DisplayAdjustments;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.util.ArrayUtils;
 
 import dalvik.system.BaseDexClassLoader;
 import dalvik.system.VMRuntime;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.InvocationTargetException;
@@ -1565,20 +1566,24 @@ public final class LoadedApk {
             final LoadedApk.ReceiverDispatcher mStrongRef;
 
             InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) {
                 mDispatcher = new WeakReference<LoadedApk.ReceiverDispatcher>(rd);
                 mStrongRef = strong ? rd : null;
             }
 
             @Override
             public void performReceive(Intent intent, int resultCode, String data,
                     Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
+                if (GmsHooks.performReceive(intent)) {
+                    return;
+                }
+
                 final LoadedApk.ReceiverDispatcher rd;
                 if (intent == null) {
                     Log.wtf(TAG, "Null intent received");
                     rd = null;
                 } else {
                     rd = mDispatcher.get();
                 }
                 if (ActivityThread.DEBUG_BROADCAST) {
                     int seq = intent.getIntExtra("seq", -1);
                     Slog.i(ActivityThread.TAG, "Receiving broadcast " + intent.getAction()
diff --git a/core/java/android/app/NotificationManager.java b/core/java/android/app/NotificationManager.java
index ccf1edb3fecc06502d683af58faa2a2c6ad92545..66b47a6edeaa4b32bcd6a16f0c6199540f529c3d 100644
--- a/core/java/android/app/NotificationManager.java
+++ b/core/java/android/app/NotificationManager.java
@@ -47,20 +47,22 @@ import android.os.StrictMode;
 import android.os.UserHandle;
 import android.provider.Settings.Global;
 import android.service.notification.Adjustment;
 import android.service.notification.Condition;
 import android.service.notification.StatusBarNotification;
 import android.service.notification.ZenModeConfig;
 import android.service.notification.ZenPolicy;
 import android.util.Log;
 import android.util.proto.ProtoOutputStream;
 
+import com.android.internal.gmscompat.GmsHooks;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 
 /**
@@ -990,20 +992,24 @@ public class NotificationManager {
     }
 
     /**
      * Deletes the given notification channel.
      *
      * <p>If you {@link #createNotificationChannel(NotificationChannel) create} a new channel with
      * this same id, the deleted channel will be un-deleted with all of the same settings it
      * had before it was deleted.
      */
     public void deleteNotificationChannel(String channelId) {
+        if (GmsHooks.skipDeleteNotificationChannel(channelId)) {
+            return;
+        }
+
         INotificationManager service = getService();
         try {
             service.deleteNotificationChannel(mContext.getPackageName(), channelId);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Returns the notification channel group settings for a given channel group id.
diff --git a/core/java/android/app/SystemServiceRegistry.java b/core/java/android/app/SystemServiceRegistry.java
index 32ea41b2c75f553bb7546e290a3b386d8db93aae..5cc2f5e63393aedf859049501475abcbb611141f 100644
--- a/core/java/android/app/SystemServiceRegistry.java
+++ b/core/java/android/app/SystemServiceRegistry.java
@@ -19,20 +19,21 @@ package android.app;
 import android.accounts.AccountManager;
 import android.accounts.IAccountManager;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SystemApi;
 import android.app.ContextImpl.ServiceInitializationState;
 import android.app.admin.DevicePolicyManager;
 import android.app.admin.IDevicePolicyManager;
 import android.app.appsearch.AppSearchManagerFrameworkInitializer;
 import android.app.blob.BlobStoreManagerFrameworkInitializer;
+import android.app.compat.gms.GmsCompat;
 import android.app.contentsuggestions.ContentSuggestionsManager;
 import android.app.contentsuggestions.IContentSuggestionsManager;
 import android.app.job.JobSchedulerFrameworkInitializer;
 import android.app.people.PeopleManager;
 import android.app.prediction.AppPredictionManager;
 import android.app.role.RoleFrameworkInitializer;
 import android.app.search.SearchUiManager;
 import android.app.slice.SliceManager;
 import android.app.smartspace.SmartspaceManager;
 import android.app.time.TimeManager;
@@ -1397,20 +1398,24 @@ public final class SystemServiceRegistry {
                                 Context.FILE_INTEGRITY_SERVICE);
                         return new FileIntegrityManager(ctx.getOuterContext(),
                                 IFileIntegrityService.Stub.asInterface(b));
                     }});
         //CHECKSTYLE:ON IndentationCheck
         registerService(Context.APP_INTEGRITY_SERVICE, AppIntegrityManager.class,
                 new CachedServiceFetcher<AppIntegrityManager>() {
                     @Override
                     public AppIntegrityManager createService(ContextImpl ctx)
                             throws ServiceNotFoundException {
+                        if (GmsCompat.isEnabled()) {
+                            return new AppIntegrityManager(null);
+                        }
+
                         IBinder b = ServiceManager.getServiceOrThrow(Context.APP_INTEGRITY_SERVICE);
                         return new AppIntegrityManager(IAppIntegrityManager.Stub.asInterface(b));
                     }});
         registerService(Context.APP_HIBERNATION_SERVICE, AppHibernationManager.class,
                 new CachedServiceFetcher<AppHibernationManager>() {
                     @Override
                     public AppHibernationManager createService(ContextImpl ctx) {
                         IBinder b = ServiceManager.getService(Context.APP_HIBERNATION_SERVICE);
                         return b == null ? null : new AppHibernationManager(ctx);
                     }});
diff --git a/core/java/android/app/admin/DevicePolicyManager.java b/core/java/android/app/admin/DevicePolicyManager.java
index d7ace96010d9a35940462c1f3e23176e52daeeed..c972c372e1066cae827b450ce9539d6fa9d40e5c 100644
--- a/core/java/android/app/admin/DevicePolicyManager.java
+++ b/core/java/android/app/admin/DevicePolicyManager.java
@@ -33,20 +33,21 @@ import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.annotation.UserHandleAware;
 import android.annotation.UserIdInt;
 import android.annotation.WorkerThread;
 import android.app.Activity;
 import android.app.IServiceConnection;
 import android.app.KeyguardManager;
 import android.app.admin.SecurityLog.SecurityEvent;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.ServiceConnection;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageDataObserver;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
@@ -7808,20 +7809,24 @@ public class DevicePolicyManager {
      * @return device owner component name, even if it's running on a different user.
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS,
     })
     public ComponentName getDeviceOwnerComponentOnAnyUser() {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         return getDeviceOwnerComponentInner(/* callingUserOnly =*/ false);
     }
 
     private boolean isDeviceOwnerAppOnAnyUserInner(String packageName, boolean callingUserOnly) {
         if (packageName == null) {
             return false;
         }
         final ComponentName deviceOwner = getDeviceOwnerComponentInner(callingUserOnly);
         if (deviceOwner == null) {
             return false;
@@ -7942,20 +7947,24 @@ public class DevicePolicyManager {
 
     /**
      * Returns the device owner name.  Note this method *will* return the device owner
      * name when it's running on a different user.
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(android.Manifest.permission.MANAGE_USERS)
     public String getDeviceOwnerNameOnAnyUser() {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         throwIfParentInstance("getDeviceOwnerNameOnAnyUser");
         if (mService != null) {
             try {
                 return mService.getDeviceOwnerName();
             } catch (RemoteException re) {
                 throw re.rethrowFromSystemServer();
             }
         }
         return null;
     }
@@ -8332,20 +8341,24 @@ public class DevicePolicyManager {
     /**
      * @hide
      * @param userId The user for whom to fetch the profile owner name, if any.
      * @return the human readable name of the organisation associated with this profile owner or
      *         null if one is not set.
      * @throws IllegalArgumentException if the userId is invalid.
      */
     @SystemApi
     @RequiresPermission(android.Manifest.permission.MANAGE_USERS)
     public @Nullable String getProfileOwnerNameAsUser(int userId) throws IllegalArgumentException {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         throwIfParentInstance("getProfileOwnerNameAsUser");
         if (mService != null) {
             try {
                 return mService.getProfileOwnerName(userId);
             } catch (RemoteException re) {
                 throw re.rethrowFromSystemServer();
             }
         }
         return null;
     }
@@ -11991,20 +12004,24 @@ public class DevicePolicyManager {
     /**
      * Returns whether the device has been provisioned.
      *
      * <p>Not for use by third-party applications.
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(android.Manifest.permission.MANAGE_USERS)
     public boolean isDeviceProvisioned() {
+        if (GmsCompat.isEnabled()) {
+            return true;
+        }
+
         try {
             return mService.isDeviceProvisioned();
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
     }
 
     /**
       * Writes that the provisioning configuration has been applied.
       *
diff --git a/core/java/android/app/compat/gms/GmsCompat.java b/core/java/android/app/compat/gms/GmsCompat.java
new file mode 100644
index 0000000000000000000000000000000000000000..15ee23822299bee53065b4e2267a9db8df8819d2
--- /dev/null
+++ b/core/java/android/app/compat/gms/GmsCompat.java
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.compat.gms;
+
+import android.annotation.SystemApi;
+import android.app.ActivityThread;
+import android.compat.Compatibility;
+import android.compat.annotation.ChangeId;
+import android.compat.annotation.Disabled;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.Signature;
+import android.os.Binder;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.UserHandle;
+import android.util.Log;
+
+import com.android.internal.compat.CompatibilityChangeInfo;
+import com.android.internal.gmscompat.GmsInfo;
+
+/**
+ * This class provides helpers for Google Play Services compatibility. It allows the following apps
+ * to work as regular, unprivileged user apps:
+ *     - Google Play Services (Google Mobile Services, aka "GMS")
+ *     - Google Services Framework
+ *     - Google Play Store
+ *     - All apps depending on Google Play Services
+ *
+ * All GMS compatibility hooks should call methods on GmsCompat. Hooks that are more complicated
+ * than returning a simple constant value should also be implemented in GmsHooks to reduce
+ * maintenance overhead.
+ *
+ * @hide
+ */
+@SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)
+public final class GmsCompat {
+    private static final String TAG = "GmsCompat/Core";
+    private static final boolean DEBUG_VERBOSE = false;
+
+    /**
+     * Whether to enable Google Play Services compatibility for this app.
+     *
+     * This compatibility change is special because the system enables it automatically for certain
+     * apps, but it still needs to be declared with a change ID.
+     *
+     * We don't have a bug for this in Google's issue tracker, so the change ID is a
+     * randomly-generated long.
+     */
+    @ChangeId
+    @Disabled // Overridden as a special case in CompatChange
+    private static final long GMS_UNPRIVILEGED_COMPAT = 1531297613045645771L;
+
+    /**
+     * Whether to enable hooks for this app to load Dynamite modules from unprivileged GMS.
+     * This is for CLIENT apps, not GMS itself.
+     */
+    @ChangeId
+    @Disabled // Overridden as a special case in CompatChange
+    private static final long GMS_UNPRIVILEGED_DYNAMITE_CLIENT = 7528921493777479941L;
+
+    // Some hooks are in (potentially) hot paths, so cache the change enable states.
+    private static volatile boolean isGmsCompatEnabled = false;
+    private static volatile boolean isDynamiteClientEnabled = false;
+
+    // Static only
+    private GmsCompat() { }
+
+    public static boolean isEnabled() {
+        return isGmsCompatEnabled;
+    }
+
+    /** @hide */
+    public static boolean isDynamiteClient() {
+        return isDynamiteClientEnabled;
+    }
+
+    private static void logEnabled(String changeName, boolean enabled) {
+        if (!DEBUG_VERBOSE) {
+            return;
+        }
+
+        String pkg = ActivityThread.currentPackageName();
+        if (pkg == null) {
+            pkg = (Process.myUid() == Process.SYSTEM_UID) ? "system_server" : "[unknown]";
+        }
+
+        Log.d(TAG, changeName + " enabled for " + pkg + " (" + Process.myPid() + ") = " + enabled);
+    }
+
+    private static boolean isChangeEnabled(String changeName, long changeId) {
+        boolean enabled = Compatibility.isChangeEnabled(changeId);
+
+        // Compatibility changes aren't available in the system process, but this should never be
+        // enabled for it or other core "android" system processes (such as the android:ui process
+        // used for chooser and resolver activities).
+        if (UserHandle.getAppId(Process.myUid()) == Process.SYSTEM_UID) {
+            enabled = false;
+        }
+
+        logEnabled(changeName, enabled);
+        return enabled;
+    }
+
+    /**
+     * Must be called to initialize the compatibility change enable states before any hooks run.
+     *
+     * @hide
+     */
+    public static void initChangeEnableStates() {
+        isGmsCompatEnabled = isChangeEnabled("GMS_UNPRIVILEGED_COMPAT", GMS_UNPRIVILEGED_COMPAT);
+        isDynamiteClientEnabled = isChangeEnabled("GMS_UNPRIVILEGED_DYNAMITE_CLIENT", GMS_UNPRIVILEGED_DYNAMITE_CLIENT);
+    }
+
+    private static boolean validateCerts(Signature[] signatures) {
+        for (Signature signature : signatures) {
+            if (signature.toCharsString().equals(GmsInfo.SIGNING_CERT)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Check whether the given app is unprivileged and part of the Google Play Services family.
+     *
+     * @hide
+     */
+    public static boolean isGmsApp(String packageName, Signature[] signatures,
+            Signature[] signatures2, boolean isPrivileged, String sharedUserId) {
+        // Privileged GMS doesn't need any compatibility changes
+        if (isPrivileged) {
+            return false;
+        }
+
+        if (GmsInfo.PACKAGE_GMS.equals(packageName) || GmsInfo.PACKAGE_GSF.equals(packageName)) {
+            // Check the shared user ID to avoid affecting microG with a spoofed signature. This is a
+            // reliable indicator because apps can't change their shared user ID after shipping with it.
+            if (!GmsInfo.SHARED_USER_ID.equals(sharedUserId)) {
+                return false;
+            }
+        } else if (!GmsInfo.PACKAGE_PLAY_STORE.equals(packageName)) {
+            return false;
+        }
+
+        // Validate signature to avoid affecting apps like microG and Gcam Services Provider.
+        // This isn't actually necessary from a security perspective because GMS doesn't get any
+        // special privileges, but it's a failsafe to avoid unintentional compatibility issues.
+        boolean validCert = validateCerts(signatures);
+
+        // Try past signing certificates if necessary. We iterate through two separate arrays here
+        // instead of concatenating them beforehand because this method gets called for every
+        // package installed in the system.
+        if (!validCert && signatures2 != null) {
+            validCert = validateCerts(signatures2);
+        }
+
+        return validCert;
+    }
+
+    /** @hide */
+    public static boolean isGmsApp(ApplicationInfo app) {
+        int userId = UserHandle.getUserId(app.uid);
+        IPackageManager pm = ActivityThread.getPackageManager();
+
+        // Fetch PackageInfo to get signing certificates
+        PackageInfo pkg;
+        long token = Binder.clearCallingIdentity();
+        try {
+            pkg = pm.getPackageInfo(app.packageName, PackageManager.GET_SIGNING_CERTIFICATES, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        } finally {
+            Binder.restoreCallingIdentity(token);
+        }
+
+        // Get all applicable certificates, even if GMS switches to multiple signing certificates
+        // in the future
+        Signature[] signatures = pkg.signingInfo.hasMultipleSigners() ?
+                pkg.signingInfo.getApkContentsSigners() :
+                pkg.signingInfo.getSigningCertificateHistory();
+        return isGmsApp(app.packageName, signatures, null, app.isPrivilegedApp(), pkg.sharedUserId);
+    }
+
+    private static boolean isGmsInstalled(ApplicationInfo relatedApp) {
+        int userId = UserHandle.getUserId(relatedApp.uid);
+        IPackageManager pm = ActivityThread.getPackageManager();
+
+        ApplicationInfo gmsApp;
+        try {
+            gmsApp = pm.getApplicationInfo(GmsInfo.PACKAGE_GMS, 0, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        // Check signature to avoid breaking microG's implementation of Dynamite
+        return gmsApp != null && isGmsApp(gmsApp);
+    }
+
+    /** @hide */
+    // CompatChange#isEnabled(ApplicationInfo)
+    public static boolean isChangeEnabled(CompatibilityChangeInfo change, ApplicationInfo app) {
+        if (change.getId() == GMS_UNPRIVILEGED_COMPAT) {
+            return isGmsApp(app);
+        } else if (change.getId() == GMS_UNPRIVILEGED_DYNAMITE_CLIENT) {
+            // Client apps can't be GMS itself, but GMS must be installed in the same user
+            return !(GmsInfo.PACKAGE_GMS.equals(app.packageName) && isGmsApp(app)) &&
+                    isGmsInstalled(app);
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/core/java/android/content/integrity/AppIntegrityManager.java b/core/java/android/content/integrity/AppIntegrityManager.java
index 1196064768e8d3ed7d15e4c84adac82652971021..52f3c2aaa6d57656a67c5191784d3b59cc58a036 100644
--- a/core/java/android/content/integrity/AppIntegrityManager.java
+++ b/core/java/android/content/integrity/AppIntegrityManager.java
@@ -13,20 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package android.content.integrity;
 
 import android.annotation.NonNull;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
+import android.app.compat.gms.GmsCompat;
 import android.content.Context;
 import android.content.IntentSender;
 import android.content.pm.ParceledListSlice;
 import android.os.RemoteException;
 
 import java.util.List;
 
 /**
  * Class for pushing rules used to check the integrity of app installs.
  *
@@ -67,43 +68,55 @@ public class AppIntegrityManager {
     /**
      * Update the rules to evaluate during install time.
      *
      * @param updateRequest request containing the data of the rule set update
      * @param statusReceiver Called when the state of the session changes. Intents sent to this
      *     receiver contain {@link #EXTRA_STATUS}. Refer to the individual status codes on how to
      *     handle them.
      */
     public void updateRuleSet(
             @NonNull RuleSet updateRequest, @NonNull IntentSender statusReceiver) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         try {
             mManager.updateRuleSet(
                     updateRequest.getVersion(),
                     new ParceledListSlice<>(updateRequest.getRules()),
                     statusReceiver);
         } catch (RemoteException e) {
             throw e.rethrowAsRuntimeException();
         }
     }
 
     /** Get the current version of the rule set. */
     @NonNull
     public String getCurrentRuleSetVersion() {
+        if (GmsCompat.isEnabled()) {
+            return "";
+        }
+
         try {
             return mManager.getCurrentRuleSetVersion();
         } catch (RemoteException e) {
             throw e.rethrowAsRuntimeException();
         }
     }
 
     /** Get the name of the package that provided the current rule set. */
     @NonNull
     public String getCurrentRuleSetProvider() {
+        if (GmsCompat.isEnabled()) {
+            return "";
+        }
+
         try {
             return mManager.getCurrentRuleSetProvider();
         } catch (RemoteException e) {
             throw e.rethrowAsRuntimeException();
         }
     }
 
     /**
      * Get current RuleSet on device.
      *
diff --git a/core/java/android/content/pm/PackageParser.java b/core/java/android/content/pm/PackageParser.java
index bd273f3001f9bfb7f19e7fe4606297e641604e3a..1eca93ab2886f534afb2a294df4c6a97f2210818 100644
--- a/core/java/android/content/pm/PackageParser.java
+++ b/core/java/android/content/pm/PackageParser.java
@@ -85,20 +85,21 @@ import android.util.Log;
 import android.util.PackageUtils;
 import android.util.Pair;
 import android.util.Slog;
 import android.util.SparseArray;
 import android.util.TypedValue;
 import android.util.apk.ApkSignatureVerifier;
 import android.view.Gravity;
 
 import com.android.internal.R;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.gmscompat.GmsInfo;
 import com.android.internal.os.ClassLoaderFactory;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.XmlUtils;
 
 import libcore.io.IoUtils;
 import libcore.util.EmptyArray;
 import libcore.util.HexEncoding;
 
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
@@ -254,40 +255,48 @@ public class PackageParser {
     /** @hide */
     public static final String APEX_FILE_EXTENSION = ".apex";
 
     /** @hide */
     public static class NewPermissionInfo {
         @UnsupportedAppUsage
         public final String name;
         @UnsupportedAppUsage
         public final int sdkVersion;
         public final int fileVersion;
+        public final String targetPackage;
 
-        public NewPermissionInfo(String name, int sdkVersion, int fileVersion) {
+        public NewPermissionInfo(String name, int sdkVersion, int fileVersion, String targetPackage) {
             this.name = name;
             this.sdkVersion = sdkVersion;
             this.fileVersion = fileVersion;
+            this.targetPackage = targetPackage;
+        }
+
+        public NewPermissionInfo(String name, int sdkVersion, int fileVersion) {
+            this(name, sdkVersion, fileVersion, null);
         }
     }
 
     /**
      * List of new permissions that have been added since 1.0.
      * NOTE: These must be declared in SDK version order, with permissions
      * added to older SDKs appearing before those added to newer SDKs.
      * If sdkVersion is 0, then this is not a permission that we want to
      * automatically add to older apps, but we do want to allow it to be
      * granted during a platform update.
      * @hide
      */
     @UnsupportedAppUsage
     public static final PackageParser.NewPermissionInfo NEW_PERMISSIONS[] =
         new PackageParser.NewPermissionInfo[] {
+            new PackageParser.NewPermissionInfo(android.Manifest.permission.REQUEST_INSTALL_PACKAGES,
+                    android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0, GmsInfo.PACKAGE_PLAY_STORE),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.OTHER_SENSORS,
                     android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.WRITE_EXTERNAL_STORAGE,
                     android.os.Build.VERSION_CODES.DONUT, 0),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.READ_PHONE_STATE,
                     android.os.Build.VERSION_CODES.DONUT, 0)
     };
 
     /**
      * @deprecated callers should move to explicitly passing around source path.
diff --git a/core/java/android/content/pm/parsing/ParsingPackageUtils.java b/core/java/android/content/pm/parsing/ParsingPackageUtils.java
index dce242c9d87c5ab024ca729c0b7d7ecbb7e3e7ca..27198fd0113fa2ef7218183a5554ae03c00b0b5c 100644
--- a/core/java/android/content/pm/parsing/ParsingPackageUtils.java
+++ b/core/java/android/content/pm/parsing/ParsingPackageUtils.java
@@ -2793,20 +2793,23 @@ public class ParsingPackageUtils {
 
     private static void convertNewPermissions(ParsingPackage pkg) {
         final int NP = PackageParser.NEW_PERMISSIONS.length;
         StringBuilder newPermsMsg = null;
         for (int ip = 0; ip < NP; ip++) {
             final PackageParser.NewPermissionInfo npi
                     = PackageParser.NEW_PERMISSIONS[ip];
             if (pkg.getTargetSdkVersion() >= npi.sdkVersion) {
                 break;
             }
+            if (npi.targetPackage != null && !pkg.getPackageName().equals(npi.targetPackage)) {
+                continue;
+            }
             if (!pkg.getRequestedPermissions().contains(npi.name)) {
                 if (newPermsMsg == null) {
                     newPermsMsg = new StringBuilder(128);
                     newPermsMsg.append(pkg.getPackageName());
                     newPermsMsg.append(": compat added ");
                 } else {
                     newPermsMsg.append(' ');
                 }
                 newPermsMsg.append(npi.name);
                 pkg.addUsesPermission(new ParsedUsesPermission(npi.name, 0))
diff --git a/core/java/android/content/res/ApkAssets.java b/core/java/android/content/res/ApkAssets.java
index 6fd2d05ad13572649121dc6d0a1dc49232552809..0bf5b0ea5489c1a1b34afd50e2fcf2814cd8a941 100644
--- a/core/java/android/content/res/ApkAssets.java
+++ b/core/java/android/content/res/ApkAssets.java
@@ -11,27 +11,29 @@
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package android.content.res;
 
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.om.OverlayableInfo;
 import android.content.res.loader.AssetsProvider;
 import android.content.res.loader.ResourcesProvider;
 import android.text.TextUtils;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.dynamite.GmsDynamiteHooks;
 
 import java.io.FileDescriptor;
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Objects;
 
 /**
  * The loaded, immutable, in-memory representation of an APK.
  *
@@ -134,20 +136,27 @@ public final class ApkAssets {
     /**
      * Creates a new ApkAssets instance from the given path on disk.
      *
      * @param path The path to an APK on disk.
      * @param flags flags that change the behavior of loaded apk assets
      * @return a new instance of ApkAssets.
      * @throws IOException if a disk I/O error or parsing error occurred.
      */
     public static @NonNull ApkAssets loadFromPath(@NonNull String path, @PropertyFlags int flags)
             throws IOException {
+        if (GmsCompat.isDynamiteClient()) {
+            ApkAssets assets = GmsDynamiteHooks.loadAssetsFromPath(path, flags);
+            if (assets != null) {
+                return assets;
+            }
+        }
+
         return new ApkAssets(FORMAT_APK, path, flags, null /* assets */);
     }
 
     /**
      * Creates a new ApkAssets instance from the given path on disk.
      *
      * @param path The path to an APK on disk.
      * @param flags flags that change the behavior of loaded apk assets
      * @param assets The assets provider that overrides the loading of file-based resources
      * @return a new instance of ApkAssets.
diff --git a/core/java/android/hardware/location/ContextHubManager.java b/core/java/android/hardware/location/ContextHubManager.java
index 9af0e09ee97ad010768c16176f83f1a26149af94..271f24c4f127efac9bd79abccda53f844aaa6f53 100644
--- a/core/java/android/hardware/location/ContextHubManager.java
+++ b/core/java/android/hardware/location/ContextHubManager.java
@@ -19,33 +19,35 @@ import android.annotation.CallbackExecutor;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresFeature;
 import android.annotation.RequiresPermission;
 import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.app.ActivityThread;
 import android.app.PendingIntent;
+import android.app.compat.gms.GmsCompat;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.os.Handler;
 import android.os.HandlerExecutor;
 import android.os.Looper;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.ServiceManager.ServiceNotFoundException;
 import android.util.Log;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.Executor;
 
 /**
  * A class that exposes the Context hubs on a device to applications.
  *
  * Please note that this class is not expected to be used by unbundled applications. Also, calling
  * applications are expected to have LOCATION_HARDWARE or ACCESS_CONTEXT_HUB permissions to use this
  * class. Use of LOCATION_HARDWARE to enable access to these APIs is deprecated and may be removed
@@ -465,20 +467,24 @@ public final class ContextHubManager {
      *
      * @return the list of ContextHubInfo objects
      *
      * @see ContextHubInfo
      */
     @RequiresPermission(anyOf = {
             android.Manifest.permission.LOCATION_HARDWARE,
             android.Manifest.permission.ACCESS_CONTEXT_HUB
     })
     @NonNull public List<ContextHubInfo> getContextHubs() {
+        if (GmsCompat.isEnabled()) {
+            return Collections.emptyList();
+        }
+
         try {
             return mService.getContextHubs();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Helper function to generate a stub for a non-query transaction callback.
      *
@@ -1055,17 +1061,22 @@ public final class ContextHubManager {
             }
         }
     };
 
     /** @throws ServiceNotFoundException
      * @hide */
     public ContextHubManager(Context context, Looper mainLooper) throws ServiceNotFoundException {
         mMainLooper = mainLooper;
         mService = IContextHubService.Stub.asInterface(
                 ServiceManager.getServiceOrThrow(Context.CONTEXTHUB_SERVICE));
+
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         try {
             mService.registerCallback(mClientCallback);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 }
diff --git a/core/java/android/net/NetworkScoreManager.java b/core/java/android/net/NetworkScoreManager.java
index 0ba266345a601181147b5764dcf96788b0ec5c66..6367926c22179aaeaadadab428f1e7f086a34170 100644
--- a/core/java/android/net/NetworkScoreManager.java
+++ b/core/java/android/net/NetworkScoreManager.java
@@ -19,20 +19,21 @@ package android.net;
 import android.Manifest.permission;
 import android.annotation.CallbackExecutor;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
+import android.app.compat.gms.GmsCompat;
 import android.content.Context;
 import android.os.Binder;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.ServiceManager.ServiceNotFoundException;
 import android.util.Log;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collection;
@@ -240,20 +241,24 @@ public class NetworkScoreManager {
      * determine the current scorer and offer the user the ability to select a different scorer via
      * the {@link #ACTION_CHANGE_ACTIVE} intent.
      * @return the full package name of the current active scorer, or null if there is no active
      *         scorer.
      * @throws SecurityException if the caller doesn't hold either {@link permission#SCORE_NETWORKS}
      *                           or {@link permission#REQUEST_NETWORK_SCORES} permissions.
      */
     @RequiresPermission(anyOf = {android.Manifest.permission.SCORE_NETWORKS,
                                  android.Manifest.permission.REQUEST_NETWORK_SCORES})
     public String getActiveScorerPackage() {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             return mService.getActiveScorerPackage();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Returns metadata about the active scorer or <code>null</code> if there is no active scorer.
      *
@@ -441,39 +446,47 @@ public class NetworkScoreManager {
      * @param scoreCache implementation of {@link INetworkScoreCache} to store the scores
      * @param filterType the {@link ScoreUpdateFilter} to apply
      * @throws SecurityException if the caller does not hold the
      *         {@link permission#REQUEST_NETWORK_SCORES} permission.
      * @throws IllegalArgumentException if a score cache is already registered for this type.
      * @hide
      */
     @RequiresPermission(android.Manifest.permission.REQUEST_NETWORK_SCORES)
     public void registerNetworkScoreCache(int networkType, INetworkScoreCache scoreCache,
             @ScoreUpdateFilter int filterType) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         try {
             mService.registerNetworkScoreCache(networkType, scoreCache, filterType);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Unregister a network score cache.
      *
      * @param networkType the type of network this cache can handle. See {@link NetworkKey#type}.
      * @param scoreCache implementation of {@link INetworkScoreCache} to store the scores.
      * @throws SecurityException if the caller does not hold the
      *         {@link permission#REQUEST_NETWORK_SCORES} permission.
      * @throws IllegalArgumentException if a score cache is already registered for this type.
      * @hide
      */
     @RequiresPermission(android.Manifest.permission.REQUEST_NETWORK_SCORES)
     public void unregisterNetworkScoreCache(int networkType, INetworkScoreCache scoreCache) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         try {
             mService.unregisterNetworkScoreCache(networkType, scoreCache);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Base class for network score cache callback. Should be extended by applications and set
      * when calling {@link #registerNetworkScoreCallback(int, int, Executor, NetworkScoreCallback)}.
diff --git a/core/java/android/os/Build.java b/core/java/android/os/Build.java
index c4f5fa37977d30649f9194a66e9e74ea8feafdfa..659f72f4f8c001600b6fba30363f2d87f342cf0c 100755
--- a/core/java/android/os/Build.java
+++ b/core/java/android/os/Build.java
@@ -18,29 +18,32 @@ package android.os;
 
 import android.Manifest;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SuppressAutoDoc;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.app.ActivityThread;
 import android.app.Application;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Context;
 import android.sysprop.DeviceProperties;
 import android.sysprop.SocProperties;
 import android.sysprop.TelephonyProperties;
 import android.text.TextUtils;
 import android.util.Slog;
 import android.view.View;
 
+import com.android.internal.gmscompat.GmsHooks;
+
 import dalvik.system.VMRuntime;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
 import java.util.stream.Collectors;
 
 /**
  * Information about the current build, extracted from system properties.
  */
@@ -192,20 +195,24 @@ public class Build {
      *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have
      *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or
      *     higher, then a SecurityException is thrown.</li>
      * </ul>
      *
      * @return The serial number if specified.
      */
     @SuppressAutoDoc // No support for device / profile owner.
     @RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public static String getSerial() {
+        if (GmsCompat.isEnabled()) {
+            return GmsHooks.getSerial();
+        }
+
         IDeviceIdentifiersPolicyService service = IDeviceIdentifiersPolicyService.Stub
                 .asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE));
         try {
             Application application = ActivityThread.currentApplication();
             String callingPackage = application != null ? application.getPackageName() : null;
             return service.getSerialForPackage(callingPackage, null);
         } catch (RemoteException e) {
             e.rethrowFromSystemServer();
         }
         return UNKNOWN;
diff --git a/core/java/android/os/DropBoxManager.java b/core/java/android/os/DropBoxManager.java
index f38271aad867ae410d2cb36095afa9a1ec29bfb6..3bc1e8a72b34c35677c17a3ac14f4c775d5bff7d 100644
--- a/core/java/android/os/DropBoxManager.java
+++ b/core/java/android/os/DropBoxManager.java
@@ -21,20 +21,21 @@ import static android.Manifest.permission.READ_LOGS;
 
 import android.annotation.BytesLong;
 import android.annotation.CurrentTimeMillisLong;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SystemService;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Context;
 import android.util.Log;
 
 import com.android.internal.os.IDropBoxManagerService;
 
 import java.io.ByteArrayInputStream;
 import java.io.Closeable;
 import java.io.File;
 import java.io.IOException;
@@ -380,20 +381,24 @@ public class DropBoxManager {
     /**
      * Gets the next entry from the drop box <em>after</em> the specified time.
      * You must always call {@link Entry#close()} on the return value!
      *
      * @param tag of entry to look for, null for all tags
      * @param msec time of the last entry seen
      * @return the next entry, or null if there are no more entries
      */
     @RequiresPermission(allOf = { READ_LOGS, PACKAGE_USAGE_STATS })
     public @Nullable Entry getNextEntry(String tag, long msec) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             return mService.getNextEntryWithAttribution(tag, msec, mContext.getOpPackageName(),
                     mContext.getAttributionTag());
         } catch (SecurityException e) {
             if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.P) {
                 throw e;
             } else {
                 Log.w(TAG, e.getMessage());
                 return null;
             }
diff --git a/core/java/android/os/UserManager.java b/core/java/android/os/UserManager.java
index 8709f071f222d59fca2e398ea77e8bb969810874..d1f0d12e039a98fc7430b5c1869245e58ce8c710 100644
--- a/core/java/android/os/UserManager.java
+++ b/core/java/android/os/UserManager.java
@@ -30,20 +30,21 @@ import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.annotation.UserHandleAware;
 import android.annotation.UserIdInt;
 import android.annotation.WorkerThread;
 import android.app.Activity;
 import android.app.ActivityManager;
 import android.app.PropertyInvalidatedCache;
 import android.app.admin.DevicePolicyManager;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.IntentSender;
 import android.content.pm.UserInfo;
 import android.content.pm.UserInfo.UserInfoFlag;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -51,20 +52,21 @@ import android.graphics.BitmapFactory;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.location.LocationManager;
 import android.provider.Settings;
 import android.telephony.TelephonyManager;
 import android.util.AndroidException;
 import android.util.ArraySet;
 import android.view.WindowManager.LayoutParams;
 
 import com.android.internal.R;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.RoSystemProperties;
 import com.android.internal.util.FrameworkStatsLog;
 
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
@@ -1963,20 +1965,25 @@ public class UserManager {
     }
 
     /**
      * Used to check if this process is running under the system user. The system user
      * is the initial user that is implicitly created on first boot and hosts most of the
      * system services.
      *
      * @return whether this process is running under the system user.
      */
     public boolean isSystemUser() {
+        if (GmsCompat.isEnabled()) {
+            // com.android.vending: java.lang.IllegalStateException: This method must be called in primary profile
+            return true;
+        }
+
         return UserHandle.myUserId() == UserHandle.USER_SYSTEM;
     }
 
     /**
      * Used to check if this process is running as an admin user. An admin user is allowed to
      * modify or configure certain settings that aren't available to non-admin users,
      * create and delete additional users, etc. There can be more than one admin users.
      *
      * @return whether this process is running under an admin user.
      * @hide
@@ -2191,34 +2198,42 @@ public class UserManager {
 
     /**
      * Checks if a user is a guest user.
      * @return whether user is a guest user.
      * @hide
      */
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     @RequiresPermission(anyOf = {Manifest.permission.MANAGE_USERS,
             Manifest.permission.CREATE_USERS})
     public boolean isGuestUser(@UserIdInt int userId) {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
+
         UserInfo user = getUserInfo(userId);
         return user != null && user.isGuest();
     }
 
     /**
      * Used to check if this process is running under a guest user. A guest user may be transient.
      *
      * @return whether this process is running under a guest user.
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {Manifest.permission.MANAGE_USERS,
             Manifest.permission.CREATE_USERS})
     public boolean isGuestUser() {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
+
         UserInfo user = getUserInfo(UserHandle.myUserId());
         return user != null && user.isGuest();
     }
 
 
     /**
      * Checks if the calling app is running in a demo user. When running in a demo user,
      * apps can be more helpful to the user, or explain their features in more detail.
      *
      * @return whether the caller is a demo user.
@@ -2684,20 +2699,25 @@ public class UserManager {
      * restrictions set by device policy.
      * @param restrictionKey the string key representing the restriction
      * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.
      */
     @TestApi
     @UnsupportedAppUsage
     @RequiresPermission(anyOf = {Manifest.permission.MANAGE_USERS,
             Manifest.permission.CREATE_USERS})
     public boolean hasBaseUserRestriction(@UserRestrictionKey @NonNull String restrictionKey,
             @NonNull UserHandle userHandle) {
+        if (GmsCompat.isEnabled()) {
+            // Can't ignore device policy restrictions without permission
+            return hasUserRestriction(restrictionKey, userHandle);
+        }
+
         try {
             return mService.hasBaseUserRestriction(restrictionKey, userHandle.getIdentifier());
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
     }
 
     /**
      * This will no longer work.  Device owners and profile owners should use
      * {@link DevicePolicyManager#addUserRestriction(ComponentName, String)} instead.
@@ -3401,20 +3421,24 @@ public class UserManager {
     }
 
     /**
      * Return the number of users currently created on the device.
      */
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.CREATE_USERS
     })
     public int getUserCount() {
+        if (GmsCompat.isEnabled()) {
+            return 1;
+        }
+
         List<UserInfo> users = getUsers();
         return users != null ? users.size() : 1;
     }
 
     /**
      * Returns information for all fully-created users on this device, including ones marked for
      * deletion.
      *
      * <p>To retrieve only users that are not marked for deletion, use {@link #getAliveUsers()}.
      *
@@ -3523,20 +3547,24 @@ public class UserManager {
      * @param excludeDying specify if the list should exclude users being removed.
      * @return the list of serial numbers of users that exist on the device.
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.CREATE_USERS
     })
     public long[] getSerialNumbersOfUsers(boolean excludeDying) {
+        if (GmsCompat.isEnabled()) {
+            return GmsHooks.getSerialNumbersOfUsers(this);
+        }
+
         List<UserInfo> users = getUsers(/* excludePartial= */ true, excludeDying,
                 /* excludePreCreated= */ true);
         long[] result = new long[users.size()];
         for (int i = 0; i < result.length; i++) {
             result[i] = users.get(i).serialNumber;
         }
         return result;
     }
 
     /**
@@ -3850,20 +3878,24 @@ public class UserManager {
      * or null if called from a user that is not a profile.
      *
      * @hide
      */
     @UnsupportedAppUsage
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.INTERACT_ACROSS_USERS
     })
     public UserInfo getProfileParent(@UserIdInt int userId) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             return mService.getProfileParent(userId);
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
     }
 
     /**
      * Get the parent of a user profile.
      *
@@ -3872,20 +3904,24 @@ public class UserManager {
      * @return the parent of the user or {@code null} if the user is not profile
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.INTERACT_ACROSS_USERS
     })
     public @Nullable UserHandle getProfileParent(@NonNull UserHandle user) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         UserInfo info = getProfileParent(user.getIdentifier());
 
         if (info == null) {
             return null;
         }
 
         return UserHandle.of(info.id);
     }
 
     /**
@@ -4489,20 +4525,25 @@ public class UserManager {
 
     /**
      * Returns a serial number on this device for a given userId. User handles can be recycled
      * when deleting and creating users, but serial numbers are not reused until the device is wiped.
      * @param userId
      * @return a serial number associated with that user, or -1 if the userId is not valid.
      * @hide
      */
     @UnsupportedAppUsage
     public int getUserSerialNumber(@UserIdInt int userId) {
+        if (GmsCompat.isEnabled()) {
+            // com.google.android.gms.persistent: java.lang.IllegalStateException - com.google.android.gms.gcm.GcmProxyIntentOperation.b
+            return 0;
+        }
+
         try {
             return mService.getUserSerialNumber(userId);
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
     }
 
     /**
      * Returns a userId on this device for a given user serial number. User handles can be
      * recycled when deleting and creating users, but serial numbers are not reused until the device
diff --git a/core/java/android/provider/DeviceConfig.java b/core/java/android/provider/DeviceConfig.java
index 217e17ddd7b426c62cffd54b630297b359a23098..7680d117c9d97ec7e260d771e6af437051df0e38 100644
--- a/core/java/android/provider/DeviceConfig.java
+++ b/core/java/android/provider/DeviceConfig.java
@@ -19,20 +19,21 @@ package android.provider;
 import static android.Manifest.permission.READ_DEVICE_CONFIG;
 import static android.Manifest.permission.WRITE_DEVICE_CONFIG;
 
 import android.annotation.CallbackExecutor;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.app.ActivityThread;
+import android.app.compat.gms.GmsCompat;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.database.ContentObserver;
 import android.net.Uri;
 import android.provider.Settings.Config.SyncDisabledMode;
 import android.provider.Settings.ResetMode;
 import android.util.ArrayMap;
 import android.util.Log;
 import android.util.Pair;
@@ -789,20 +790,24 @@ public final class DeviceConfig {
      * @param value       The value to store for the property.
      * @param makeDefault Whether to make the new value the default one.
      * @return True if the value was set, false if the storage implementation throws errors.
      * @hide
      * @see #resetToDefaults(int, String).
      */
     @SystemApi
     @RequiresPermission(WRITE_DEVICE_CONFIG)
     public static boolean setProperty(@NonNull String namespace, @NonNull String name,
             @Nullable String value, boolean makeDefault) {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
+
         ContentResolver contentResolver = ActivityThread.currentApplication().getContentResolver();
         return Settings.Config.putString(contentResolver, namespace, name, value, makeDefault);
     }
 
     /**
      * Set all of the properties for a specific namespace. Pre-existing properties will be updated
      * and new properties will be added if necessary. Any pre-existing properties for the specific
      * namespace which are not part of the provided {@link Properties} object will be deleted from
      * the namespace. These changes are all applied atomically, such that no calls to read or reset
      * these properties can happen in the middle of this update.
@@ -811,20 +816,24 @@ public final class DeviceConfig {
      * none or all of this update is picked up, but never only part of it.
      *
      * @param properties the complete set of properties to set for a specific namespace.
      * @throws BadConfigException if the provided properties are banned by RescueParty.
      * @return True if the values were set, false otherwise.
      * @hide
      */
     @SystemApi
     @RequiresPermission(WRITE_DEVICE_CONFIG)
     public static boolean setProperties(@NonNull Properties properties) throws BadConfigException {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
+
         ContentResolver contentResolver = ActivityThread.currentApplication().getContentResolver();
         return Settings.Config.setStrings(contentResolver, properties.getNamespace(),
                 properties.mMap);
     }
 
     /**
      * Reset properties to their default values by removing the underlying values.
      * <p>
      * The method accepts an optional namespace parameter. If provided, only properties set within
      * that namespace will be reset. Otherwise, all properties will be reset.
@@ -844,20 +853,24 @@ public final class DeviceConfig {
      * to using {@link #setProperties(Properties)} as outlined above.
      *
      * @param resetMode The reset mode to use.
      * @param namespace Optionally, the specific namespace which resets will be limited to.
      * @hide
      * @see #setProperty(String, String, String, boolean)
      */
     @SystemApi
     @RequiresPermission(WRITE_DEVICE_CONFIG)
     public static void resetToDefaults(@ResetMode int resetMode, @Nullable String namespace) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         ContentResolver contentResolver = ActivityThread.currentApplication().getContentResolver();
         Settings.Config.resetToDefaults(contentResolver, resetMode, namespace);
     }
 
     /**
      * Disables or re-enables bulk modifications ({@link #setProperties(Properties)}) to device
      * config values. This is intended for use during tests to prevent a sync operation clearing
      * config values, which could influence the outcome of the tests, i.e. by changing behavior.
      *
      * @param syncDisabledMode the mode to use, see {@link Settings.Config#SYNC_DISABLED_MODE_NONE},
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 00abc759278f7ee361c4e3902d1c143072630606..0247c54e42c025e4bebbb473b03b62430d78103e 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -29,20 +29,21 @@ import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.annotation.UserIdInt;
 import android.app.ActivityThread;
 import android.app.AppOpsManager;
 import android.app.Application;
 import android.app.AutomaticZenRule;
 import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.SearchManager;
 import android.app.WallpaperManager;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.IContentProvider;
 import android.content.Intent;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
@@ -2811,20 +2812,24 @@ public final class Settings {
             mReadableFields = new ArraySet<>();
             mAllFields = new ArraySet<>();
             mReadableFieldsWithMaxTargetSdk = new ArrayMap<>();
             getPublicSettingsForClass(callerClass, mAllFields, mReadableFields,
                     mReadableFieldsWithMaxTargetSdk);
         }
 
         public boolean putStringForUser(ContentResolver cr, String name, String value,
                 String tag, boolean makeDefault, final int userHandle,
                 boolean overrideableByRestore) {
+            if (GmsCompat.isEnabled()) {
+                return true;
+            }
+
             try {
                 Bundle arg = new Bundle();
                 arg.putString(Settings.NameValueTable.VALUE, value);
                 arg.putInt(CALL_METHOD_USER_KEY, userHandle);
                 if (tag != null) {
                     arg.putString(CALL_METHOD_TAG_KEY, tag);
                 }
                 if (makeDefault) {
                     arg.putBoolean(CALL_METHOD_MAKE_DEFAULT_KEY, true);
                 }
diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
new file mode 100644
index 0000000000000000000000000000000000000000..620bb7e46fa0a065692dbf6082ae1c6af02578a0
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+import android.annotation.SuppressLint;
+import android.app.ActivityThread;
+import android.app.Application;
+import android.app.Notification;
+import android.app.NotificationChannel;
+import android.app.NotificationChannelGroup;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.app.compat.gms.GmsCompat;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInstaller;
+import android.content.pm.PackageManager;
+import android.content.pm.SharedLibraryInfo;
+import android.os.Build;
+import android.os.Process;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.Settings;
+import android.util.Log;
+import android.webkit.WebView;
+
+import com.android.internal.R;
+import com.android.internal.gmscompat.dynamite.GmsDynamiteHooks;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * API shims for Google Play Services compatibility. Hooks that are more complicated than a simple
+ * constant return value should be delegated to this class for easier maintenance.
+ *
+ * @hide
+ */
+public final class GmsHooks {
+    private static final String TAG = "GmsCompat/Hooks";
+
+    // Foreground service notifications
+    private static final String FGS_GROUP_ID = "gmscompat_fgs_group";
+    private static final String FGS_CHANNEL_ID = "gmscompat_fgs_channel";
+    private static final int FGS_NOTIFICATION_ID = 529977835;
+    private static boolean fgsChannelCreated = false;
+
+    // Static only
+    private GmsHooks() { }
+
+
+    /*
+     * Foreground service notifications to keep GMS services alive
+     */
+
+    // Make all services foreground to keep them alive
+    // ContextImpl#startService(Intent)
+    public static ComponentName startService(Context context, Intent service) {
+        return context.startForegroundService(service);
+    }
+
+    private static void createFgsChannel(Context context) {
+        if (fgsChannelCreated) {
+            return;
+        }
+
+        NotificationManager notificationManager = (NotificationManager)
+                context.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        NotificationChannelGroup group = new NotificationChannelGroup(FGS_GROUP_ID,
+                context.getText(R.string.foreground_service_gmscompat_group));
+        notificationManager.createNotificationChannelGroup(group);
+
+        CharSequence name = context.getText(R.string.foreground_service_gmscompat_channel);
+        NotificationChannel channel = new NotificationChannel(FGS_CHANNEL_ID, name,
+                NotificationManager.IMPORTANCE_LOW);
+        channel.setGroup(FGS_GROUP_ID);
+        channel.setDescription(context.getString(R.string.foreground_service_gmscompat_channel_desc));
+        channel.setShowBadge(false);
+        notificationManager.createNotificationChannel(channel);
+
+        fgsChannelCreated = true;
+    }
+
+    // Post notification on foreground service start
+    // ActivityThread#handleCreateService(CreateServiceData)
+    public static void attachService(Service service) {
+        // Isolated processes (e.g. WebView) don't have access to NotificationManager. They don't
+        // need a foreground notification anyway, so bail out early.
+        if (!GmsCompat.isEnabled() || Process.isIsolated()) {
+            return;
+        }
+
+        // Channel
+        createFgsChannel(service);
+
+        // Intent: notification channel settings
+        Intent intent = new Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);
+        intent.putExtra(Settings.EXTRA_APP_PACKAGE, service.getPackageName());
+        intent.putExtra(Settings.EXTRA_CHANNEL_ID, FGS_CHANNEL_ID);
+        PendingIntent pi = PendingIntent.getActivity(service, 0, intent, PendingIntent.FLAG_IMMUTABLE);
+
+        // Notification
+        CharSequence appName = service.getApplicationInfo().loadLabel(service.getPackageManager());
+        Notification notification = new Notification.Builder(service, FGS_CHANNEL_ID)
+                .setSmallIcon(service.getApplicationInfo().icon)
+                .setContentTitle(service.getString(R.string.app_running_notification_title, appName))
+                .setContentText(service.getText(R.string.foreground_service_gmscompat_notif_desc))
+                .setContentIntent(pi)
+                .build();
+
+        Log.d(TAG, "Posting notification for service: " + service.getClass().getName());
+        service.startForeground(FGS_NOTIFICATION_ID, notification);
+    }
+
+    // GMS tries to clean up its own notification channels periodically.
+    // Don't let it delete the FGS shim channel because that throws an exception and crashes GMS.
+    // NotificationManager#deleteNotificationChannel(String)
+    public static boolean skipDeleteNotificationChannel(String channelId) {
+        return GmsCompat.isEnabled() && FGS_CHANNEL_ID.equals(channelId);
+    }
+
+
+    /**
+     * API shims
+     */
+
+    // Report a single user on the system
+    // UserManager#getSerialNumbersOfUsers(boolean)
+    public static long[] getSerialNumbersOfUsers(UserManager userManager) {
+        return new long[] { userManager.getSerialNumberForUser(Process.myUserHandle()) };
+    }
+
+    // Current user is always active
+    // ActivityManager#getCurrentUser()
+    public static int getCurrentUser() {
+        return Process.myUserHandle().getIdentifier();
+    }
+
+    /**
+     * Use the per-app SSAID as a random serial number for SafetyNet. This doesn't necessarily make
+     * pass, but at least it retusn a valid "failed" response and stops spamming device key
+     * requests.
+     *
+     * This isn't a privacy risk because all unprivileged apps already have access to random SSAIDs.
+     */
+    // Build#getSerial()
+    @SuppressLint("HardwareIds")
+    public static String getSerial() {
+        Application app = ActivityThread.currentApplication();
+        if (app == null) {
+            return Build.UNKNOWN;
+        }
+
+        String ssaid = Settings.Secure.getString(app.getContentResolver(),
+                Settings.Secure.ANDROID_ID);
+        String serial = ssaid.toUpperCase();
+        Log.d(TAG, "Generating serial number from SSAID: " + serial);
+        return serial;
+    }
+
+    // Report no shared libraries
+    // ApplicationPackageManager#getSharedLibrariesAsUser(int, int)
+    public static List<SharedLibraryInfo> getSharedLibrariesAsUser() {
+        // TODO: Report standard Pixel libraries?
+        return Collections.emptyList();
+    }
+
+    // Only get package info for current user
+    // ApplicationPackageManager#getPackageInfo(VersionedPackage, int)
+    // ApplicationPackageManager#getPackageInfoAsUser(String, int, int)
+    public static int getPackageInfoFlags(int flags) {
+        if (!GmsCompat.isEnabled()) {
+            return flags;
+        }
+
+        // Remove MATCH_ANY_USER flag to avoid permission denial
+        return flags & ~PackageManager.MATCH_ANY_USER;
+    }
+
+    // Fix RuntimeException: Using WebView from more than one process at once with the same data
+    // directory is not supported. https://crbug.com/558377
+    // Instrumentation#newApplication(ClassLoader, String, Context)
+    public static void initApplicationBeforeOnCreate(Application app) {
+        GmsCompat.initChangeEnableStates();
+
+        if (GmsCompat.isEnabled()) {
+            String processName = Application.getProcessName();
+            if (!app.getPackageName().equals(processName)) {
+                WebView.setDataDirectorySuffix("process-shim--" + processName);
+            }
+
+            GmsDynamiteHooks.initGmsServerApp(app);
+        } else if (GmsCompat.isDynamiteClient()) {
+            GmsDynamiteHooks.initClientApp();
+        }
+    }
+
+    // Request user action for package install sessions
+    // LoadedApk.ReceiverDispatcher.InnerReceiver#performReceive(Intent, int, String, Bundle, boolean, boolean, int)
+    public static boolean performReceive(Intent intent) {
+        if (!GmsCompat.isEnabled()) {
+            return false;
+        }
+
+        // Validate - we only want to handle user action requests
+        if (!(intent.hasExtra(PackageInstaller.EXTRA_SESSION_ID) &&
+                intent.hasExtra(PackageInstaller.EXTRA_STATUS) &&
+                intent.hasExtra(Intent.EXTRA_INTENT))) {
+            return false;
+        }
+        if (intent.getIntExtra(PackageInstaller.EXTRA_STATUS, 0) !=
+                PackageInstaller.STATUS_PENDING_USER_ACTION) {
+            return false;
+        }
+
+        Application app = ActivityThread.currentApplication();
+        if (app == null) {
+            return false;
+        }
+
+        // Use the intent
+        Log.i(TAG, "Requesting user confirmation for package install session");
+        Intent confirmIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
+        // Make it work with the Application context
+        confirmIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        // TODO: post notification if app is in the background
+        app.startActivity(confirmIntent);
+
+        // Don't dispatch it, otherwise Play Store abandons the session
+        return true;
+    }
+
+    // Redirect cross-user interactions to current user
+    // ContextImpl#sendOrderedBroadcastAsUser
+    // ContextImpl#sendBroadcastAsUser
+    public static UserHandle getUserHandle(UserHandle user) {
+        return GmsCompat.isEnabled() ? Process.myUserHandle() : user;
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/GmsInfo.java b/core/java/com/android/internal/gmscompat/GmsInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..15e6560930ba9c917b1789754f0323e6c2dc2551
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmsInfo.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+/** @hide */
+public final class GmsInfo {
+    // Package names for GMS apps
+    public static final String PACKAGE_GMS = "com.google.android.gms";
+    public static final String PACKAGE_GSF = "com.google.android.gsf";
+    public static final String PACKAGE_PLAY_STORE = "com.android.vending";
+
+    // Shared user ID for GMS and GSF
+    public static final String SHARED_USER_ID = "com.google.uid.shared";
+
+    // Signing certificate for GMS apps, used to check package eligibility.
+    // This is Google's 2008 MD5 certificate because Play Store doesn't use the new SHA-256 one yet.
+    public static final String SIGNING_CERT = "308204433082032ba003020102020900c2e08746644a308d300d06092a864886f70d01010405003074310b3009060355040613025553311330110603550408130a43616c69666f726e6961311630140603550407130d4d6f756e7461696e205669657731143012060355040a130b476f6f676c6520496e632e3110300e060355040b1307416e64726f69643110300e06035504031307416e64726f6964301e170d3038303832313233313333345a170d3336303130373233313333345a3074310b3009060355040613025553311330110603550408130a43616c69666f726e6961311630140603550407130d4d6f756e7461696e205669657731143012060355040a130b476f6f676c6520496e632e3110300e060355040b1307416e64726f69643110300e06035504031307416e64726f696430820120300d06092a864886f70d01010105000382010d00308201080282010100ab562e00d83ba208ae0a966f124e29da11f2ab56d08f58e2cca91303e9b754d372f640a71b1dcb130967624e4656a7776a92193db2e5bfb724a91e77188b0e6a47a43b33d9609b77183145ccdf7b2e586674c9e1565b1f4c6a5955bff251a63dabf9c55c27222252e875e4f8154a645f897168c0b1bfc612eabf785769bb34aa7984dc7e2ea2764cae8307d8c17154d7ee5f64a51a44a602c249054157dc02cd5f5c0e55fbef8519fbe327f0b1511692c5a06f19d18385f5c4dbc2d6b93f68cc2979c70e18ab93866b3bd5db8999552a0e3b4c99df58fb918bedc182ba35e003c1b4b10dd244a8ee24fffd333872ab5221985edab0fc0d0b145b6aa192858e79020103a381d93081d6301d0603551d0e04160414c77d8cc2211756259a7fd382df6be398e4d786a53081a60603551d2304819e30819b8014c77d8cc2211756259a7fd382df6be398e4d786a5a178a4763074310b3009060355040613025553311330110603550408130a43616c69666f726e6961311630140603550407130d4d6f756e7461696e205669657731143012060355040a130b476f6f676c6520496e632e3110300e060355040b1307416e64726f69643110300e06035504031307416e64726f6964820900c2e08746644a308d300c0603551d13040530030101ff300d06092a864886f70d010104050003820101006dd252ceef85302c360aaace939bcff2cca904bb5d7a1661f8ae46b2994204d0ff4a68c7ed1a531ec4595a623ce60763b167297a7ae35712c407f208f0cb109429124d7b106219c084ca3eb3f9ad5fb871ef92269a8be28bf16d44c8d9a08e6cb2f005bb3fe2cb96447e868e731076ad45b33f6009ea19c161e62641aa99271dfd5228c5c587875ddb7f452758d661f6cc0cccb7352e424cc4365c523532f7325137593c4ae341f4db41edda0d0b1071a7c440f0fe9ea01cb627ca674369d084bd2fd911ff06cdbf2cfa10dc0f893ae35762919048c7efc64c7144178342f70581c9de573af55b390dd7fdb9418631895d5f759f30112687ff621410c069308a";
+
+    private GmsInfo() { }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java b/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java
new file mode 100644
index 0000000000000000000000000000000000000000..937613790d770f23006f50be35eee1d9f4e78397
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.dynamite;
+
+import android.app.ActivityThread;
+import android.app.Application;
+import android.app.compat.gms.GmsCompat;
+import android.content.Context;
+import android.content.res.ApkAssets;
+import android.os.ParcelFileDescriptor;
+import android.os.Process;
+import android.os.RemoteException;
+import android.util.Log;
+
+import com.android.internal.gmscompat.GmsInfo;
+import com.android.internal.gmscompat.dynamite.client.ModuleLoadState;
+import com.android.internal.gmscompat.dynamite.client.DynamiteContext;
+import com.android.internal.gmscompat.dynamite.server.FileProxyProvider;
+
+import dalvik.system.DelegateLastClassLoader;
+import dalvik.system.DexPathList;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * Hooks specific to Dynamite module compatibility.
+ *
+ * @hide
+ */
+public final class GmsDynamiteHooks {
+    // Created lazily because most apps don't use Dynamite modules
+    private static DynamiteContext clientContext = null;
+
+    private GmsDynamiteHooks() { }
+
+    private static DynamiteContext getClientContext() {
+        if (clientContext != null) {
+            return clientContext;
+        }
+
+        Context context = Objects.requireNonNull(ActivityThread.currentApplication());
+        clientContext = new DynamiteContext(context);
+        return clientContext;
+    }
+
+    public static void initClientApp() {
+        // Install hooks (requires libcore changes)
+        DexPathList.postConstructorBufferHook = GmsDynamiteHooks::getDexPathListBuffers;
+        File.lastModifiedHook = GmsDynamiteHooks::getFileLastModified;
+        DelegateLastClassLoader.librarySearchPathHook = GmsDynamiteHooks::mapRemoteLibraryPaths;
+    }
+
+    public static void initGmsServerApp(Application app) {
+        // Main GMS process only, to avoid serving proxy requests multiple times.
+        // This is specifically the main process, not persistent, because
+        // com.google.android.gms.chimera.container.FileApkIntentOperation$ExternalFileApkService
+        // is in the main process and thus the process is guaranteed to start before
+        // DelegateLastClassLoader requests the file proxy service.
+        if (!Process.isIsolated() && GmsInfo.PACKAGE_GMS.equals(Application.getProcessName())) {
+            FileProxyProvider.register(app);
+        }
+    }
+
+    // For Android assets and resources
+    // ApkAssets#loadFromPath(String, int)
+    public static ApkAssets loadAssetsFromPath(String path, int flags) throws IOException {
+        if (!GmsCompat.isDynamiteClient()) {
+            return null;
+        }
+
+        ModuleLoadState state = getClientContext().getState();
+        if (state == null || !state.modulePath.equals(path)) {
+            return null;
+        }
+
+        Log.d(DynamiteContext.TAG, "Replacing " + path + " -> fd " + state.moduleFd.getInt$());
+        return ApkAssets.loadFromFd(state.moduleFd, path, flags, null);
+    }
+
+    // For Java code
+    // DexPathList(ClassLoader, String, String, File, boolean)
+    private static ByteBuffer[] getDexPathListBuffers(DexPathList pathList) {
+        if (!GmsCompat.isDynamiteClient()) {
+            return null;
+        }
+
+        ModuleLoadState state = getClientContext().getState();
+        if (state == null) {
+            return null;
+        }
+
+        ByteBuffer[] buffers;
+        try {
+            buffers = state.mapDexBuffers();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+
+        Log.d(DynamiteContext.TAG, "Creating class loader with " + buffers.length + " dex buffer(s)");
+
+        // Undo path init and re-initialize with the ByteBuffers
+        return buffers;
+    }
+
+    // To fix false-positive "Module APK has been modified" check
+    // File#lastModified()
+    private static Long getFileLastModified(File file) {
+        if (!GmsCompat.isDynamiteClient()) {
+            return null;
+        }
+
+        ModuleLoadState state = getClientContext().getState();
+        if (state == null || !state.modulePath.equals(file.getPath())) {
+            return null;
+        }
+
+        long lastModified;
+        try {
+            lastModified = getClientContext().getService().getLastModified(file.getPath());
+        } catch (RemoteException e) {
+            throw e.rethrowAsRuntimeException();
+        }
+        Log.d(DynamiteContext.TAG, "File " + file.getPath() + " lastModified=" + lastModified);
+
+        // This is the final hook in the module loading process, so clear the state.
+        getClientContext().setState(null);
+
+        Log.d(DynamiteContext.TAG, "Finished loading module " + state.modulePath);
+        return lastModified;
+    }
+
+    // To start the module loading process and map native library paths to fd from remote
+    public static String mapRemoteLibraryPaths(String librarySearchPath) {
+        if (!GmsCompat.isDynamiteClient() || librarySearchPath == null) {
+            return librarySearchPath;
+        }
+
+        String[] searchPaths = librarySearchPath.split(Pattern.quote(File.pathSeparator));
+
+        List<String> newPaths = Arrays.stream(searchPaths).map(libPath -> {
+            if (!libPath.startsWith(getClientContext().gmsDataPrefix)) {
+                return libPath;
+            }
+
+            Log.d(DynamiteContext.TAG, "Loading module: " + libPath);
+            String[] libComponents = libPath.split("!");
+            String path = libComponents[0];
+
+            // Ask GMS to open the file and return a PFD. Be careful with ownership.
+            ParcelFileDescriptor srcPfd;
+            try {
+                srcPfd = getClientContext().getService().openFile(path);
+            } catch (RemoteException e) {
+                throw e.rethrowAsRuntimeException();
+            }
+            if (srcPfd == null) {
+                throw new RuntimeException(new FileNotFoundException(path));
+            }
+
+            // For ApkAssets, DexPathList, File#lastModified()
+            Log.d(DynamiteContext.TAG, "Received remote fd: " + path + " -> " + srcPfd.getFd());
+            ModuleLoadState state = new ModuleLoadState(path, srcPfd.getFileDescriptor());
+            getClientContext().setState(state);
+
+            // Native code dups the fd each time it loads a lib
+            String fdPath = "/proc/self/fd/" + srcPfd.getFd();
+            libComponents[0] = fdPath;
+
+            // Re-combine the path with native library components
+            return String.join("!", libComponents);
+        }).collect(Collectors.toList());
+
+        return String.join(File.pathSeparator, newPaths);
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/client/DynamiteContext.java b/core/java/com/android/internal/gmscompat/dynamite/client/DynamiteContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..4fd3e06f996ed2fcd2cf08c35a6f223adff8f289
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/client/DynamiteContext.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.dynamite.client;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Log;
+
+import com.android.internal.gmscompat.GmsInfo;
+import com.android.internal.gmscompat.dynamite.server.FileProxyProvider;
+import com.android.internal.gmscompat.dynamite.server.IFileProxyService;
+
+import java.io.File;
+
+/** @hide */
+public final class DynamiteContext {
+    public static final String TAG = "GmsCompat/DynamiteClient";
+
+    // Permission that only GMS holds
+    private static final String GMS_PERM = "com.google.android.gms.permission.INTERNAL_BROADCAST";
+
+    // Make sure we don't block the main thread for too long if GMS isn't available
+    private static final long GET_SERVICE_TIMEOUT = 250L;
+
+    private final Context context;
+    public final String gmsDataPrefix;
+
+    // Manage state for loading one module at a time per thread
+    private final ThreadLocal<ModuleLoadState> threadLocalState = new ThreadLocal<>();
+
+    // The remote GMS process can die at any time, so this needs to be managed carefully.
+    private IFileProxyService serviceBinder = null;
+
+    public DynamiteContext(Context context) {
+        this.context = context;
+
+        // Get data directory path without using package context or current data dir, since not all
+        // packages have data directories and package context causes recursion in ApkAssets
+        File userDe = Environment.getDataUserDeDirectory(null, context.getUserId());
+        gmsDataPrefix = userDe.getPath() + '/' + GmsInfo.PACKAGE_GMS + '/';
+    }
+
+    public ModuleLoadState getState() {
+        return threadLocalState.get();
+    }
+    public void setState(ModuleLoadState state) {
+        threadLocalState.set(state);
+    }
+
+    public IFileProxyService getService() {
+        return serviceBinder == null ? getNewBinder() : serviceBinder;
+    }
+
+    private IFileProxyService getNewBinder() {
+        // Request a fresh service unconditionally
+        IFileProxyService binder = requestGmsService();
+
+        // Register before saving to avoid race condition if GMS dies *now*
+        try {
+            binder.asBinder().linkToDeath(() -> {
+                Log.d(DynamiteContext.TAG, "File proxy service has died");
+                serviceBinder = null;
+            }, 0);
+
+            serviceBinder = binder;
+            return binder;
+        } catch (RemoteException e) {
+            serviceBinder = null;
+            return null;
+        }
+    }
+
+    private IFileProxyService requestGmsService() {
+        // Create a dedicated thread to avoid deadlocks, since this might be called on the main thread
+        HandlerThread thread = new HandlerThread(FileProxyProvider.THREAD_NAME);
+        thread.start();
+        Handler handler = new Handler(thread.getLooper());
+
+        // Potential return values
+        final IFileProxyService[] service = {null};
+        final RuntimeException[] receiverException = {null};
+        BroadcastReceiver replyReceiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                if (!intent.getAction().equals(FileProxyProvider.ACTION_RESPONSE)) {
+                    return;
+                }
+
+                try {
+                    Bundle bundle = intent.getBundleExtra(FileProxyProvider.EXTRA_BUNDLE);
+                    IBinder binder = bundle.getBinder(FileProxyProvider.EXTRA_BINDER);
+                    service[0] = IFileProxyService.Stub.asInterface(binder);
+                } catch (RuntimeException e) {
+                    receiverException[0] = e;
+                } finally {
+                    thread.quitSafely();
+                }
+            }
+        };
+
+        // Register receiver first
+        IntentFilter filter = new IntentFilter(FileProxyProvider.ACTION_RESPONSE);
+        // For security, we require the reply to come from GMS (by permission) so other apps
+        // can't inject code into our process by replying with a fake proxy service that returns
+        // malicious APKs.
+        context.registerReceiver(replyReceiver, filter, GMS_PERM, handler);
+
+        // Now, send the broadcast and wait...
+        try {
+            Log.d(TAG, "Requesting file proxy service from GMS");
+
+            Intent intent = new Intent(FileProxyProvider.ACTION_REQUEST);
+            intent.setPackage(GmsInfo.PACKAGE_GMS);
+            intent.putExtra(FileProxyProvider.EXTRA_PACKAGE, context.getPackageName());
+            context.sendBroadcast(intent, GMS_PERM);
+            thread.join(GET_SERVICE_TIMEOUT);
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        } finally {
+            context.unregisterReceiver(replyReceiver);
+            // Attempt to stop the thread if join() timed out
+            thread.quit();
+        }
+
+        // Rethrow exception or return value
+        if (receiverException[0] != null) {
+            throw receiverException[0];
+        } else if (service[0] != null) {
+            return service[0];
+        } else {
+            throw new IllegalStateException("Dynamite file proxy request timed out");
+        }
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/client/ModuleLoadState.java b/core/java/com/android/internal/gmscompat/dynamite/client/ModuleLoadState.java
new file mode 100644
index 0000000000000000000000000000000000000000..29b39679b75d6fb524ee2e452c8eda05e5d5ca58
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/client/ModuleLoadState.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.dynamite.client;
+
+import android.util.jar.StrictJarFile;
+
+import java.io.FileDescriptor;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.util.ArrayList;
+import java.util.regex.Pattern;
+import java.util.zip.ZipEntry;
+
+/** @hide */
+public final class ModuleLoadState {
+    private static final Pattern CLASSES_DEX_PATTERN = Pattern.compile("^classes\\d*\\.dex$");
+
+    public String modulePath;
+    public FileDescriptor moduleFd;
+
+    public ModuleLoadState(String modulePath, FileDescriptor moduleFd) {
+        this.modulePath = modulePath;
+        // Do NOT close the original fd. The Bionic linker could dup it for library loading
+        // at any time. Unfortunately, this results in CloseGuard warnings, but it's more efficient
+        // to just ignore them.
+        this.moduleFd = moduleFd;
+    }
+
+    public ByteBuffer[] mapDexBuffers() throws IOException {
+        // Native code doesn't assume ownership, so we can safely use the original fd temporarily
+        FileChannel channel = new FileInputStream(moduleFd).getChannel();
+        // Dynamite modules don't seem to have proper v2 signatures, so don't verify them
+        StrictJarFile jar = new StrictJarFile(moduleFd, false, false);
+
+        ArrayList<ByteBuffer> buffers = new ArrayList<>(1);
+        jar.iterator().forEachRemaining(entry -> {
+            if (entry.getMethod() == ZipEntry.STORED && CLASSES_DEX_PATTERN.matcher(entry.getName()).matches()) {
+                try {
+                    buffers.add(channel.map(FileChannel.MapMode.READ_ONLY, entry.getDataOffset(), entry.getSize()));
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        });
+
+        return buffers.toArray(new ByteBuffer[0]);
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyProvider.java b/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..b7eae2bbc289abccb5b5ae05496bb5b4640291a0
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyProvider.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.dynamite.server;
+
+import android.app.Application;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.util.Log;
+
+/** @hide */
+public final class FileProxyProvider extends BroadcastReceiver {
+    public static final String EXTRA_BUNDLE = "service_bundle";
+    public static final String EXTRA_BINDER = "service_binder";
+    public static final String EXTRA_PACKAGE = "service_client_package";
+
+    public static final String ACTION_REQUEST = "com.android.internal.gmscompat.REQUEST_DYNAMITE_FILE_PROXY";
+    public static final String ACTION_RESPONSE = "com.android.internal.gmscompat.DYNAMITE_FILE_PROXY";
+
+    public static final String THREAD_NAME = "DynamiteFileProxy";
+
+    private FileProxyService service;
+
+    private FileProxyProvider() { }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        if (!intent.getAction().equals(ACTION_REQUEST)) {
+            return;
+        }
+
+        if (service == null) {
+            // The service is a singleton, so use the application context to prevent memory leaks.
+            service = new FileProxyService(context.getApplicationContext());
+        }
+
+        Intent reply = new Intent(ACTION_RESPONSE);
+
+        // Use an explicit intent to avoid sending multiple replies to clients that
+        // request the file proxy binder at the same time. Security doesn't matter because
+        // this is a public service, and we can't use PendingIntents due to permission checks
+        // on the client side.
+        String clientPackage = intent.getStringExtra(EXTRA_PACKAGE);
+        if (clientPackage == null) {
+            return;
+        }
+        reply.setPackage(clientPackage);
+
+        // New bundle is required because Intent doesn't expose IBinder extras
+        Bundle bundle = new Bundle();
+        bundle.putBinder(EXTRA_BINDER, service.asBinder());
+        reply.putExtra(EXTRA_BUNDLE, bundle);
+
+        Log.d(FileProxyService.TAG, "Sending file proxy binder to " + clientPackage);
+        context.sendBroadcast(reply);
+    }
+
+    public static void register(Context context) {
+        Log.d(FileProxyService.TAG, "Registering file proxy provider from " + Application.getProcessName());
+
+        // Create a dedicated thread to avoid blocking clients for too long
+        HandlerThread thread = new HandlerThread(THREAD_NAME);
+        thread.start();
+        Handler handler = new Handler(thread.getLooper());
+
+        IntentFilter filter = new IntentFilter(ACTION_REQUEST);
+        context.registerReceiver(new FileProxyProvider(), filter, null, handler);
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyService.java b/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyService.java
new file mode 100644
index 0000000000000000000000000000000000000000..8656f0767d6167eaa6532c2c427765d7cd720dd4
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyService.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.dynamite.server;
+
+import android.content.Context;
+import android.os.ParcelFileDescriptor;
+import android.system.ErrnoException;
+import android.system.Os;
+import android.system.OsConstants;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+/** @hide */
+public final class FileProxyService extends IFileProxyService.Stub {
+    public static final String TAG = "GmsCompat/DynamiteServer";
+    private static final String CHIMERA_REL_PATH = "app_chimera/m/";
+
+    private final File deDataRoot;
+    private final String chimeraRoot;
+
+    public FileProxyService(Context context) {
+        deDataRoot = context.createDeviceProtectedStorageContext().getDataDir();
+        chimeraRoot = deDataRoot.getPath() + "/" + CHIMERA_REL_PATH;
+    }
+
+    private String sanitizeModulePath(String rawPath) {
+        // Normalize path for security checks
+        String path;
+        try {
+            path = new File(rawPath).getCanonicalPath();
+        } catch (IOException e) {
+            throw new SecurityException("Invalid path " + rawPath + ": " + e.getMessage());
+        }
+
+        // Modules can only be in DE Chimera storage
+        if (!path.startsWith(chimeraRoot)) {
+            throw new SecurityException("Path " + rawPath + " is not in " + chimeraRoot);
+        }
+
+        // Check permissions recursively
+        String relPath = path.substring(deDataRoot.getPath().length() + 1); // already checked prefix above
+        List<String> relParts = Arrays.asList(relPath.split("/"));
+        for (int i = 0; i < relParts.size(); i++) {
+            List<String> leadingParts = relParts.subList(0, i + 1);
+            String nodePath = deDataRoot + "/" + String.join("/", leadingParts);
+            int mode;
+            try {
+                mode = Os.stat(nodePath).st_mode;
+            } catch (ErrnoException e) {
+                throw new SecurityException("Failed to stat " + rawPath + ": " + e.getMessage());
+            }
+
+            // World-readable or world-executable, depending on type
+            int permBit = OsConstants.S_ISDIR(mode) ? OsConstants.S_IXOTH : OsConstants.S_IROTH;
+            if ((mode & permBit) == 0) {
+                throw new SecurityException("Node " + nodePath + " in path " + rawPath + " is not world-readable");
+            }
+        }
+
+        return path;
+    }
+
+    private ParcelFileDescriptor getFilePfd(String path) {
+        Log.d(TAG, "Opening " + path + " for remote");
+        try {
+            return ParcelFileDescriptor.open(new File(path), ParcelFileDescriptor.MODE_READ_ONLY);
+        } catch (FileNotFoundException e) {
+            return null;
+        }
+    }
+
+    @Override
+    public ParcelFileDescriptor openFile(String rawPath) {
+        return getFilePfd(sanitizeModulePath(rawPath));
+    }
+
+    @Override
+    public long getLastModified(String rawPath) {
+        return new File(sanitizeModulePath(rawPath)).lastModified();
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/server/IFileProxyService.aidl b/core/java/com/android/internal/gmscompat/dynamite/server/IFileProxyService.aidl
new file mode 100644
index 0000000000000000000000000000000000000000..15e5c4195715e9cf93bf6bf89023063c589ae24d
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/server/IFileProxyService.aidl
@@ -0,0 +1,7 @@
+package com.android.internal.gmscompat.dynamite.server;
+
+/** @hide */
+interface IFileProxyService {
+    ParcelFileDescriptor openFile(String path);
+    long getLastModified(String path);
+}
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index 1910909d1617dd3b9f4db0e93274649a9a391fdb..362d707083f8f74418c1126837fa3949462e4e37 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -5772,21 +5772,21 @@
 
     <!-- @hide @SystemApi Allows an application to retrieve whether shortcut is backed by a
          Conversation.
          TODO(b/180412052): STOPSHIP: Define a role so it can be granted to Shell and AiAi. -->
     <permission android:name="android.permission.READ_PEOPLE_DATA"
                 android:protectionLevel="signature|recents|role"/>
 
     <!-- @hide @SystemApi Allows a logical component within an application to
          temporarily renounce a set of otherwise granted permissions. -->
     <permission android:name="android.permission.RENOUNCE_PERMISSIONS"
-                android:protectionLevel="signature|privileged" />
+                android:protectionLevel="normal" />
 
     <!-- Allows an application to read nearby streaming policy. The policy allows the device
          to stream its notifications and apps to nearby devices.
          @hide -->
     <permission android:name="android.permission.READ_NEARBY_STREAMING_POLICY"
         android:protectionLevel="signature|privileged" />
 
     <!-- @SystemApi Allows the holder to set the source of the data when setting a clip on the
          clipboard.
          @hide -->
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index b27df17e19109575e61c169e414d6df33ba6308a..43cba7b85e2cfd5c510f9fed50dbd3b2639e7a9b 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -757,20 +757,34 @@
         data usage</string>
 
     <!-- Separator for foreground service notification content listing all apps when there
         are multiple apps running.  The left and right side may both already be compound
         (constructed using this separator).  Should be kept as short as possible, this is
         for summary text in the notification where there is not a lot of space.
         [CHAR LIMIT=NONE] -->
     <string name="foreground_service_multiple_separator"><xliff:g id="left_side">%1$s</xliff:g>,
         <xliff:g id="right_side">%2$s</xliff:g></string>
 
+    <!-- Name for foreground service notification channel group created by GmsCompat  -->
+    <string name="foreground_service_gmscompat_group">Compatibility</string>
+
+    <!-- Name for foreground service notification channel created by GmsCompat  -->
+    <string name="foreground_service_gmscompat_channel">Services</string>
+
+    <!-- Description for foreground service notification channel created by GmsCompat  -->
+    <string name="foreground_service_gmscompat_channel_desc">These notifications are created by the
+        Google Play Services compatibility layer in order to keep services running in the
+        background.\n\nDisable this category to hide the unnecessary notifications.</string>
+
+    <!-- Description for foreground service notifications created by GmsCompat  -->
+    <string name="foreground_service_gmscompat_notif_desc">Tap to hide</string>
+
     <!-- Displayed to the user to tell them that they have started up the phone in "safe mode" -->
     <string name="safeMode">Safe mode</string>
 
     <!-- Label for the Android system components when they are shown to the user. -->
     <string name="android_system_label">Android System</string>
 
     <!-- "Switch" is a verb; it means to change user profile by tapping another user profile name. -->
     <string name="user_owner_label">Switch to personal profile</string>
 
     <!-- "Switch" is a verb; it means to change user profile by tapping another user profile name. -->
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 0a98601969af2ffc56955090034d69192e660e9c..df167a8ee71e5bf3083ea02649fe9bfb9a7ca466 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -3615,20 +3615,25 @@
   <java-symbol type="string" name="config_defaultSystemCaptionsManagerService" />
   <java-symbol type="string" name="config_retailDemoPackage" />
   <java-symbol type="string" name="config_retailDemoPackageSignature" />
 
   <java-symbol type="string" name="notification_channel_foreground_service" />
   <java-symbol type="string" name="foreground_service_app_in_background" />
   <java-symbol type="string" name="foreground_service_apps_in_background" />
   <java-symbol type="string" name="foreground_service_tap_for_details" />
   <java-symbol type="string" name="foreground_service_multiple_separator" />
 
+  <java-symbol type="string" name="foreground_service_gmscompat_group" />
+  <java-symbol type="string" name="foreground_service_gmscompat_channel" />
+  <java-symbol type="string" name="foreground_service_gmscompat_channel_desc" />
+  <java-symbol type="string" name="foreground_service_gmscompat_notif_desc" />
+
   <java-symbol type="bool" name="config_enableCredentialFactoryResetProtection" />
 
   <!-- ETWS primary messages -->
   <java-symbol type="string" name="etws_primary_default_message_earthquake" />
   <java-symbol type="string" name="etws_primary_default_message_tsunami" />
   <java-symbol type="string" name="etws_primary_default_message_earthquake_and_tsunami" />
   <java-symbol type="string" name="etws_primary_default_message_test" />
   <java-symbol type="string" name="etws_primary_default_message_others" />
 
   <java-symbol type="bool" name="config_quickSettingsSupported" />
diff --git a/location/java/android/location/LocationManager.java b/location/java/android/location/LocationManager.java
index 526b84e85e383d2e17097f831f0a41baf6d7502c..c427a9dec87c4ededfd6f37e9305a43c97667573 100644
--- a/location/java/android/location/LocationManager.java
+++ b/location/java/android/location/LocationManager.java
@@ -33,20 +33,21 @@ import android.annotation.RequiresFeature;
 import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.app.AppOpsManager;
 import android.app.PendingIntent;
 import android.app.PropertyInvalidatedCache;
+import android.app.compat.gms.GmsCompat;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.location.provider.IProviderRequestListener;
 import android.location.provider.ProviderProperties;
 import android.location.provider.ProviderRequest;
 import android.location.provider.ProviderRequest.ChangedListener;
@@ -527,20 +528,24 @@ public class LocationManager {
     }
 
     /**
      * Set whether the extra location controller package is currently enabled on the device.
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(Manifest.permission.LOCATION_HARDWARE)
     public void setExtraLocationControllerPackageEnabled(boolean enabled) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         try {
             mService.setExtraLocationControllerPackageEnabled(enabled);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Returns whether extra location controller package is currently enabled on the device.
      *
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index 6a84b3ae42a85d0dfa8357e189e92de0716a1f72..732c4447117970652c92f3de51c8e3daa9be2113 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -180,20 +180,21 @@ import android.app.Notification;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.ProcessMemoryState;
 import android.app.ProfilerInfo;
 import android.app.PropertyInvalidatedCache;
 import android.app.RemoteServiceException;
 import android.app.SyncNotedAppOp;
 import android.app.WaitResult;
 import android.app.backup.BackupManager.OperationType;
 import android.app.backup.IBackupManager;
+import android.app.compat.gms.GmsCompat;
 import android.app.job.JobParameters;
 import android.app.usage.UsageEvents;
 import android.app.usage.UsageEvents.Event;
 import android.app.usage.UsageStatsManager;
 import android.app.usage.UsageStatsManagerInternal;
 import android.appwidget.AppWidgetManager;
 import android.appwidget.AppWidgetManagerInternal;
 import android.content.AttributionSource;
 import android.content.AutofillOptions;
 import android.content.BroadcastReceiver;
@@ -11930,20 +11931,24 @@ public class ActivityManagerService extends IActivityManager.Stub
 
     @Override
     public int handleIncomingUser(int callingPid, int callingUid, int userId, boolean allowAll,
             boolean requireFull, String name, String callerPackage) {
         return mUserController.handleIncomingUser(callingPid, callingUid, userId, allowAll,
                 requireFull ? ALLOW_FULL_ONLY : ALLOW_NON_FULL, name, callerPackage);
     }
 
     boolean isSingleton(String componentProcessName, ApplicationInfo aInfo,
             String className, int flags) {
+        if (GmsCompat.isGmsApp(aInfo)) {
+            return false;
+        }
+
         boolean result = false;
         // For apps that don't have pre-defined UIDs, check for permission
         if (UserHandle.getAppId(aInfo.uid) >= FIRST_APPLICATION_UID) {
             if ((flags & ServiceInfo.FLAG_SINGLE_USER) != 0) {
                 if (ActivityManager.checkUidPermission(
                         INTERACT_ACROSS_USERS,
                         aInfo.uid) != PackageManager.PERMISSION_GRANTED) {
                     ComponentName comp = new ComponentName(aInfo.packageName, className);
                     String msg = "Permission Denial: Component " + comp.flattenToShortString()
                             + " requests FLAG_SINGLE_USER, but app does not hold "
diff --git a/services/core/java/com/android/server/compat/CompatChange.java b/services/core/java/com/android/server/compat/CompatChange.java
index 0f97b9042ebefc3cf3940a914ea5c9f54c14c710..c2c6ae86ed597beca73d65d0a284605c8f5f9659 100644
--- a/services/core/java/com/android/server/compat/CompatChange.java
+++ b/services/core/java/com/android/server/compat/CompatChange.java
@@ -15,20 +15,21 @@
  */
 
 package com.android.server.compat;
 
 import static android.app.compat.PackageOverride.VALUE_DISABLED;
 import static android.app.compat.PackageOverride.VALUE_ENABLED;
 import static android.app.compat.PackageOverride.VALUE_UNDEFINED;
 
 import android.annotation.Nullable;
 import android.app.compat.PackageOverride;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.Disabled;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.Overridable;
 import android.content.pm.ApplicationInfo;
 
 import com.android.internal.compat.AndroidBuildClassifier;
 import com.android.internal.compat.CompatibilityChangeInfo;
 import com.android.internal.compat.OverrideAllowedState;
 import com.android.server.compat.config.Change;
@@ -240,20 +241,23 @@ public final class CompatChange extends CompatibilityChangeInfo {
      * @param app Info about the app in question
      * @return {@code true} if the change should be enabled for the package.
      */
     boolean isEnabled(ApplicationInfo app, AndroidBuildClassifier buildClassifier) {
         if (app == null) {
             return defaultValue();
         }
         if (mEvaluatedOverrides.containsKey(app.packageName)) {
             return mEvaluatedOverrides.get(app.packageName);
         }
+        if (GmsCompat.isChangeEnabled(this, app)) {
+            return true;
+        }
         if (getDisabled()) {
             return false;
         }
         if (getEnableSinceTargetSdk() != -1) {
             // If the change is gated by a platform version newer than the one currently installed
             // on the device, disregard the app's target sdk version.
             int compareSdk = Math.min(app.targetSdkVersion, buildClassifier.platformTargetSdk());
             if (compareSdk != app.targetSdkVersion) {
                 compareSdk = app.targetSdkVersion;
             }
diff --git a/services/core/java/com/android/server/pm/AppsFilter.java b/services/core/java/com/android/server/pm/AppsFilter.java
index ed9b539c05df239ff5d0a6bd1e7fd69775122a36..7d1d1224348d6647298ae5604837e9dd446511e6 100644
--- a/services/core/java/com/android/server/pm/AppsFilter.java
+++ b/services/core/java/com/android/server/pm/AppsFilter.java
@@ -17,20 +17,21 @@
 package com.android.server.pm;
 
 import static android.os.Trace.TRACE_TAG_PACKAGE_MANAGER;
 import static android.provider.DeviceConfig.NAMESPACE_PACKAGE_MANAGER_SERVICE;
 
 import static com.android.internal.annotations.VisibleForTesting.Visibility.PRIVATE;
 
 import android.Manifest;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManagerInternal;
 import android.content.pm.PackageParser;
 import android.content.pm.UserInfo;
 import android.content.pm.parsing.component.ParsedComponent;
 import android.content.pm.parsing.component.ParsedInstrumentation;
 import android.content.pm.parsing.component.ParsedIntentInfo;
 import android.content.pm.parsing.component.ParsedMainComponent;
@@ -733,24 +734,30 @@ public class AppsFilter implements Watchable, Snappable {
 
         final AndroidPackage newPkg = newPkgSetting.pkg;
         if (newPkg == null) {
             return null;
         }
 
         if (mProtectedBroadcasts.addAll(newPkg.getProtectedBroadcasts())) {
             mQueriesViaComponentRequireRecompute = true;
         }
 
+        final boolean isGmsApp = GmsCompat.isGmsApp(newPkg.getPackageName(),
+                newPkg.getSigningDetails().signatures,
+                newPkg.getSigningDetails().pastSigningCertificates,
+                newPkg.isPrivileged(),
+                newPkgSetting.sharedUser != null ? newPkgSetting.sharedUser.name : null);
         final boolean newIsForceQueryable =
                 mForceQueryable.contains(newPkgSetting.appId)
                         /* shared user that is already force queryable */
                         || newPkgSetting.forceQueryableOverride /* adb override */
+                        || isGmsApp
                         || (newPkgSetting.isSystem() && (mSystemAppsQueryable
                         || newPkg.isForceQueryable()
                         || ArrayUtils.contains(mForceQueryableByDevicePackageNames,
                         newPkg.getPackageName())));
         if (newIsForceQueryable
                 || (mSystemSigningDetails != null
                 && isSystemSigned(mSystemSigningDetails, newPkgSetting))) {
             mForceQueryable.add(newPkgSetting.appId);
         }
 
diff --git a/telephony/java/android/telephony/TelephonyManager.java b/telephony/java/android/telephony/TelephonyManager.java
index 989663406a6b347e8784dae5f7d8f615cbf6a08d..7b3d281eefe30bab8edaeaa1b5deed0c73097398 100644
--- a/telephony/java/android/telephony/TelephonyManager.java
+++ b/telephony/java/android/telephony/TelephonyManager.java
@@ -34,20 +34,21 @@ import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.StringDef;
 import android.annotation.SuppressAutoDoc;
 import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.annotation.WorkerThread;
 import android.app.PendingIntent;
+import android.app.compat.gms.GmsCompat;
 import android.app.role.RoleManager;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
 import android.net.ConnectivityManager;
@@ -1956,20 +1957,24 @@ public class TelephonyManager {
      *     higher, then a SecurityException is thrown.</li>
      * </ul>
      *
      * @deprecated Use {@link #getImei} which returns IMEI for GSM or {@link #getMeid} which returns
      * MEID for CDMA.
      */
     @Deprecated
     @SuppressAutoDoc // No support for device / profile owner or carrier privileges (b/72967236).
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public String getDeviceId() {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             ITelephony telephony = getITelephony();
             if (telephony == null)
                 return null;
             return telephony.getDeviceIdWithFeature(mContext.getOpPackageName(),
                     mContext.getAttributionTag());
         } catch (RemoteException ex) {
             return null;
         } catch (NullPointerException ex) {
             return null;
@@ -2009,20 +2014,24 @@ public class TelephonyManager {
      *
      * @param slotIndex of which deviceID is returned
      *
      * @deprecated Use {@link #getImei} which returns IMEI for GSM or {@link #getMeid} which returns
      * MEID for CDMA.
      */
     @Deprecated
     @SuppressAutoDoc // No support for device / profile owner or carrier privileges (b/72967236).
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public String getDeviceId(int slotIndex) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         // FIXME this assumes phoneId == slotIndex
         try {
             IPhoneSubInfo info = getSubscriberInfoService();
             if (info == null)
                 return null;
             return info.getDeviceIdForPhone(slotIndex, mContext.getOpPackageName(),
                     mContext.getAttributionTag());
         } catch (RemoteException ex) {
             return null;
         } catch (NullPointerException ex) {
@@ -2074,20 +2083,24 @@ public class TelephonyManager {
      *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have
      *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or
      *     higher, then a SecurityException is thrown.</li>
      * </ul>
      *
      * @param slotIndex of which IMEI is returned
      */
     @SuppressAutoDoc // No support for device / profile owner or carrier privileges (b/72967236).
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public String getImei(int slotIndex) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         ITelephony telephony = getITelephony();
         if (telephony == null) return null;
 
         try {
             return telephony.getImeiForSlot(slotIndex, getOpPackageName(), getAttributionTag());
         } catch (RemoteException ex) {
             return null;
         } catch (NullPointerException ex) {
             return null;
         }
@@ -2186,20 +2199,24 @@ public class TelephonyManager {
      *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have
      *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or
      *     higher, then a SecurityException is thrown.</li>
      * </ul>
      *
      * @param slotIndex of which MEID is returned
      */
     @SuppressAutoDoc // No support for device / profile owner or carrier privileges (b/72967236).
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public String getMeid(int slotIndex) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         ITelephony telephony = getITelephony();
         if (telephony == null) return null;
 
         try {
             String meid = telephony.getMeidForSlot(slotIndex, getOpPackageName(),
                     getAttributionTag());
             if (TextUtils.isEmpty(meid)) {
                 Log.d(TAG, "getMeid: return null because MEID is not available");
                 return null;
             }
@@ -2915,20 +2932,24 @@ public class TelephonyManager {
      * @see #NETWORK_TYPE_LTE
      * @see #NETWORK_TYPE_EHRPD
      * @see #NETWORK_TYPE_HSPAP
      * @see #NETWORK_TYPE_NR
      *
      * @hide
      */
     @RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)
     public int getNetworkType(int subId) {
+        if (GmsCompat.isEnabled()) {
+            return NETWORK_TYPE_UNKNOWN;
+        }
+
         try {
             ITelephony telephony = getITelephony();
             if (telephony != null) {
                 return telephony.getNetworkTypeForSubscriber(subId, getOpPackageName(),
                         getAttributionTag());
             } else {
                 // This can happen when the ITelephony interface is not up yet.
                 return NETWORK_TYPE_UNKNOWN;
             }
         } catch (RemoteException ex) {
@@ -3824,20 +3845,24 @@ public class TelephonyManager {
      *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or
      *     higher, then a SecurityException is thrown.</li>
      * </ul>
      *
      * @param subId for which Sim Serial number is returned
      * @hide
      */
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     @UnsupportedAppUsage
     public String getSimSerialNumber(int subId) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             IPhoneSubInfo info = getSubscriberInfoService();
             if (info == null)
                 return null;
             return info.getIccSerialNumberForSubscriber(subId, mContext.getOpPackageName(),
                     mContext.getAttributionTag());
         } catch (RemoteException ex) {
             return null;
         } catch (NullPointerException ex) {
             // This could happen before phone restarts due to crashing
@@ -3953,20 +3978,24 @@ public class TelephonyManager {
      * Gets all the UICC slots. The objects in the array can be null if the slot info is not
      * available, which is possible between phone process starting and getting slot info from modem.
      *
      * @return UiccSlotInfo array.
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public UiccSlotInfo[] getUiccSlotsInfo() {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             ITelephony telephony = getITelephony();
             if (telephony == null) {
                 return null;
             }
             return telephony.getUiccSlotsInfo();
         } catch (RemoteException e) {
             return null;
         }
     }
@@ -4092,20 +4121,24 @@ public class TelephonyManager {
      *
      * See {@link #getSubscriberId()} for details on the required permissions and behavior
      * when the caller does not hold sufficient permissions.
      *
      * @param subId whose subscriber id is returned
      * @hide
      */
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)
     public String getSubscriberId(int subId) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             IPhoneSubInfo info = getSubscriberInfoService();
             if (info == null)
                 return null;
             return info.getSubscriberIdForSubscriber(subId, mContext.getOpPackageName(),
                     mContext.getAttributionTag());
         } catch (RemoteException ex) {
             return null;
         } catch (NullPointerException ex) {
             // This could happen before phone restarts due to crashing
@@ -4706,20 +4739,28 @@ public class TelephonyManager {
     @UnsupportedAppUsage
     public String getLine1Number(int subId) {
         String number = null;
         try {
             ITelephony telephony = getITelephony();
             if (telephony != null)
                 number = telephony.getLine1NumberForDisplay(subId, mContext.getOpPackageName(),
                          mContext.getAttributionTag());
         } catch (RemoteException ex) {
         } catch (NullPointerException ex) {
+        } catch (SecurityException ex) {
+            if (GmsCompat.isEnabled()) {
+                // Google Play Services settings -> Account services -> Google Pay -> Add a payment method
+                // com.google.android.gms: java.lang.SecurityException: getLine1NumberForDisplay: Neither user 1010142 nor current process has android.permission.READ_PHONE_STATE, android.permission.READ_SMS, or android.permission.READ_PHONE_NUMBERS
+                return null;
+            } else {
+                throw ex;
+            }
         }
         if (number != null) {
             return number;
         }
         try {
             IPhoneSubInfo info = getSubscriberInfoService();
             if (info == null)
                 return null;
             return info.getLine1NumberForSubscriber(subId, mContext.getOpPackageName(),
                     mContext.getAttributionTag());
@@ -6376,20 +6417,26 @@ public class TelephonyManager {
      * @param workSource the requestor to whom the power consumption for this should be attributed.
      * @param executor the executor on which callback will be invoked.
      * @param callback a callback to receive CellInfo.
      * @hide
      */
     @SystemApi
     @RequiresPermission(allOf = {android.Manifest.permission.ACCESS_FINE_LOCATION,
             android.Manifest.permission.MODIFY_PHONE_STATE})
     public void requestCellInfoUpdate(@NonNull WorkSource workSource,
             @NonNull @CallbackExecutor Executor executor, @NonNull CellInfoCallback callback) {
+        if (GmsCompat.isEnabled()) {
+            // Attribute the work to GMS instead of the client
+            requestCellInfoUpdate(executor, callback);
+            return;
+        }
+
         try {
             ITelephony telephony = getITelephony();
             if (telephony == null) {
                 if (Compatibility.isChangeEnabled(NULL_TELEPHONY_THROW_NO_CB)) {
                     throw new IllegalStateException("Telephony is null");
                 } else {
                     return;
                 }
             }
 
@@ -14578,20 +14625,24 @@ public class TelephonyManager {
      * <p>Requires Permission:
      * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}
      * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).
      *
      * @hide
      */
     @WorkerThread
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     @SystemApi
     public boolean isIccLockEnabled() {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
+
         try {
             ITelephony telephony = getITelephony();
             if (telephony != null) {
                 return telephony.isIccLockEnabled(getSubId());
             } else {
                 throw new IllegalStateException("telephony service is null.");
             }
         } catch (RemoteException e) {
             Log.e(TAG, "isIccLockEnabled RemoteException", e);
             e.rethrowFromSystemServer();

commit 7693fdea691f53079477d92b29634b7912450127
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2021-03-16 02:54:57-0400

    enable app compaction by default
---
 services/core/java/com/android/server/am/CachedAppOptimizer.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/services/core/java/com/android/server/am/CachedAppOptimizer.java b/services/core/java/com/android/server/am/CachedAppOptimizer.java
index 9da6d528a9670fbd77a11524bfde98e7a67a9df4..8c74158ac4891f55df96121174a8818181e668e7 100644
--- a/services/core/java/com/android/server/am/CachedAppOptimizer.java
+++ b/services/core/java/com/android/server/am/CachedAppOptimizer.java
@@ -93,21 +93,21 @@ public final class CachedAppOptimizer {
     private static final int COMPACT_ACTION_ANON = 2;
     private static final int COMPACT_ACTION_FULL = 3;
 
     private static final String COMPACT_ACTION_STRING[] = {"", "file", "anon", "all"};
 
     // Keeps these flags in sync with services/core/jni/com_android_server_am_CachedAppOptimizer.cpp
     private static final int COMPACT_ACTION_FILE_FLAG = 1;
     private static final int COMPACT_ACTION_ANON_FLAG = 2;
 
     // Defaults for phenotype flags.
-    @VisibleForTesting static final Boolean DEFAULT_USE_COMPACTION = false;
+    @VisibleForTesting static final Boolean DEFAULT_USE_COMPACTION = true;
     @VisibleForTesting static final Boolean DEFAULT_USE_FREEZER = true;
     @VisibleForTesting static final int DEFAULT_COMPACT_ACTION_1 = COMPACT_ACTION_FILE;
     @VisibleForTesting static final int DEFAULT_COMPACT_ACTION_2 = COMPACT_ACTION_FULL;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_1 = 5_000;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_2 = 10_000;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_3 = 500;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_4 = 10_000;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_5 = 10 * 60 * 1000;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_6 = 10 * 60 * 1000;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_MIN_OOM_ADJ =

commit fc34f773cd23b63da198617a91bf1129923275ac
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Mon 2021-10-11 15:03:59-0700

    SystemUI: Use new privacy indicators for location
    
    Android has had location indicators for a while, but let's use the new
    privacy indicator infrastructure for displaying them. This makes them
    integrate better with the new camera and microphone indicators.
    
    Change-Id: Ie457bb2dad17bddbf9dc3a818e3ec586023ce918
---
 core/java/android/permission/PermissionUsageHelper.java               | 2 +-
 .../src/com/android/systemui/privacy/PrivacyItemController.kt         | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/core/java/android/permission/PermissionUsageHelper.java b/core/java/android/permission/PermissionUsageHelper.java
index 19f204b377c8e61a55916d0976b8b4fefa74c553..1d55673d77ec0e83cdfe24544c1f219b0a46f88e 100644
--- a/core/java/android/permission/PermissionUsageHelper.java
+++ b/core/java/android/permission/PermissionUsageHelper.java
@@ -94,21 +94,21 @@ public class PermissionUsageHelper implements AppOpsManager.OnOpActiveChangedLis
                 PROPERTY_PERMISSIONS_HUB_2_ENABLED, false);
     }
 
     private static boolean shouldShowIndicators() {
         return DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_PRIVACY,
                 PROPERTY_CAMERA_MIC_ICONS_ENABLED, true) || shouldShowPermissionsHub();
     }
 
     private static boolean shouldShowLocationIndicator() {
         return DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_PRIVACY,
-                PROPERTY_LOCATION_INDICATORS_ENABLED, false);
+                PROPERTY_LOCATION_INDICATORS_ENABLED, true);
     }
 
     private static long getRecentThreshold(Long now) {
         return now - DeviceConfig.getLong(DeviceConfig.NAMESPACE_PRIVACY,
                 RECENT_ACCESS_TIME_MS, DEFAULT_RECENT_TIME_MS);
     }
 
     private static long getRunningThreshold(Long now) {
         return now - DeviceConfig.getLong(DeviceConfig.NAMESPACE_PRIVACY,
                 RUNNING_ACCESS_TIME_MS, DEFAULT_RUNNING_TIME_MS);
diff --git a/packages/SystemUI/src/com/android/systemui/privacy/PrivacyItemController.kt b/packages/SystemUI/src/com/android/systemui/privacy/PrivacyItemController.kt
index e072b4a3646c992ebe5da076ed96e2885cb1d0f7..f7bf1c3af7a24b720299e01597ecaa5ce0da2f4c 100644
--- a/packages/SystemUI/src/com/android/systemui/privacy/PrivacyItemController.kt
+++ b/packages/SystemUI/src/com/android/systemui/privacy/PrivacyItemController.kt
@@ -66,21 +66,21 @@ class PrivacyItemController @Inject constructor(
         val OPS = OPS_MIC_CAMERA + OPS_LOCATION
         val intentFilter = IntentFilter().apply {
             addAction(Intent.ACTION_USER_SWITCHED)
             addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE)
             addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE)
         }
         const val TAG = "PrivacyItemController"
         private const val MIC_CAMERA = SystemUiDeviceConfigFlags.PROPERTY_MIC_CAMERA_ENABLED
         private const val LOCATION = SystemUiDeviceConfigFlags.PROPERTY_LOCATION_INDICATORS_ENABLED
         private const val DEFAULT_MIC_CAMERA = true
-        private const val DEFAULT_LOCATION = false
+        private const val DEFAULT_LOCATION = true
         @VisibleForTesting const val TIME_TO_HOLD_INDICATORS = 5000L
     }
 
     @VisibleForTesting
     internal var privacyList = emptyList<PrivacyItem>()
         @Synchronized get() = field.toList() // Returns a shallow copy of the list
         @Synchronized set
 
     private fun isMicCameraEnabled(): Boolean {
         return deviceConfigProxy.getBoolean(DeviceConfig.NAMESPACE_PRIVACY,
@@ -374,11 +374,11 @@ class PrivacyItemController @Inject constructor(
 
         override fun execute(command: Runnable) {
             delegate.execute(command)
         }
 
         fun updateListeningState() {
             listeningCanceller?.run()
             listeningCanceller = delegate.executeDelayed({ setListeningState() }, 0L)
         }
     }
-}
\ No newline at end of file
+}

commit 7755ab6e320ba3cd5d8428d78da942ac8b5e881e
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Mon 2021-10-11 15:04:50-0700

    appop: Keep up to 7 days of permission usage history
    
    Keeping 7 days of discrete app op history allows us to show a 7-day
    permission usage timeline in the privacy dashboard.
    
    Change-Id: Ia4683e9a8dddb944d56465ce8a3829281556e723
---
 services/core/java/com/android/server/appop/DiscreteRegistry.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/services/core/java/com/android/server/appop/DiscreteRegistry.java b/services/core/java/com/android/server/appop/DiscreteRegistry.java
index b9cc992b438eea501fbb6934e1e9f2a9e6619ccf..8de515d4d3e522e13b10ebf775f701cd545f1aeb 100644
--- a/services/core/java/com/android/server/appop/DiscreteRegistry.java
+++ b/services/core/java/com/android/server/appop/DiscreteRegistry.java
@@ -127,21 +127,21 @@ final class DiscreteRegistry {
     private static final String TAG = DiscreteRegistry.class.getSimpleName();
 
     private static final String PROPERTY_DISCRETE_HISTORY_CUTOFF = "discrete_history_cutoff_millis";
     private static final String PROPERTY_DISCRETE_HISTORY_QUANTIZATION =
             "discrete_history_quantization_millis";
     private static final String PROPERTY_DISCRETE_FLAGS = "discrete_history_op_flags";
     private static final String PROPERTY_DISCRETE_OPS_LIST = "discrete_history_ops_cslist";
     private static final String DEFAULT_DISCRETE_OPS = OP_FINE_LOCATION + "," + OP_COARSE_LOCATION
             + "," + OP_CAMERA + "," + OP_RECORD_AUDIO + "," + OP_PHONE_CALL_MICROPHONE + ","
             + OP_PHONE_CALL_CAMERA;
-    private static final long DEFAULT_DISCRETE_HISTORY_CUTOFF = Duration.ofHours(24).toMillis();
+    private static final long DEFAULT_DISCRETE_HISTORY_CUTOFF = Duration.ofDays(7).toMillis();
     private static final long MAXIMUM_DISCRETE_HISTORY_CUTOFF = Duration.ofDays(30).toMillis();
     private static final long DEFAULT_DISCRETE_HISTORY_QUANTIZATION =
             Duration.ofMinutes(1).toMillis();
 
     private static long sDiscreteHistoryCutoff;
     private static long sDiscreteHistoryQuantization;
     private static int[] sDiscreteOps;
     private static int sDiscreteFlags;
 
     private static final String TAG_HISTORY = "h";

commit e4c7c02f3cfe00a366193c46cee97990b6600b09
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Mon 2021-10-11 15:15:40-0700

    appop: Save discrete app op history for more permissions
    
    Android 12's privacy dashboard shows permission usage timelines for
    location, camera, and microphone. However, there's no reason to limit it
    to those specific permissions; all the infrastructure is in place for
    other permissions.
    
    To enable the usage timeline for more permissions, keep discrete app op
    history for all permission groups shown in the privacy dashboard. The
    list of permission group -> app op mappings was obtained from
    AppOpsManager.RUNTIME_AND_APPOP_PERMISSION_OPS with a few additional ops
    from PrivacyItemController, and each op was resolved to its respective
    enum ordinal from frameworks/proto_logging/stats/enums/app/enums.proto.
    
    Change-Id: I6b1c476ea4c0edbc0b3fdf2e3e5cfcb11da77e33
---
 .../com/android/server/appop/DiscreteRegistry.java | 67 +++++++++++++++++++++-
 1 file changed, 64 insertions(+), 3 deletions(-)

diff --git a/services/core/java/com/android/server/appop/DiscreteRegistry.java b/services/core/java/com/android/server/appop/DiscreteRegistry.java
index 8de515d4d3e522e13b10ebf775f701cd545f1aeb..49fbc1cc1181938c01d767b4a4b49ee78a3c388b 100644
--- a/services/core/java/com/android/server/appop/DiscreteRegistry.java
+++ b/services/core/java/com/android/server/appop/DiscreteRegistry.java
@@ -17,31 +17,60 @@
 package com.android.server.appop;
 
 import static android.app.AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE;
 import static android.app.AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR;
 import static android.app.AppOpsManager.ATTRIBUTION_FLAG_RECEIVER;
 import static android.app.AppOpsManager.ATTRIBUTION_FLAG_TRUSTED;
 import static android.app.AppOpsManager.FILTER_BY_ATTRIBUTION_TAG;
 import static android.app.AppOpsManager.FILTER_BY_OP_NAMES;
 import static android.app.AppOpsManager.FILTER_BY_PACKAGE_NAME;
 import static android.app.AppOpsManager.FILTER_BY_UID;
+import static android.app.AppOpsManager.OP_ACCEPT_HANDOVER;
+import static android.app.AppOpsManager.OP_ACCESS_MEDIA_LOCATION;
+import static android.app.AppOpsManager.OP_ACTIVITY_RECOGNITION;
+import static android.app.AppOpsManager.OP_ADD_VOICEMAIL;
+import static android.app.AppOpsManager.OP_ANSWER_PHONE_CALLS;
+import static android.app.AppOpsManager.OP_BLUETOOTH_ADVERTISE;
+import static android.app.AppOpsManager.OP_BLUETOOTH_CONNECT;
+import static android.app.AppOpsManager.OP_BLUETOOTH_SCAN;
+import static android.app.AppOpsManager.OP_CALL_PHONE;
 import static android.app.AppOpsManager.OP_CAMERA;
 import static android.app.AppOpsManager.OP_COARSE_LOCATION;
 import static android.app.AppOpsManager.OP_FINE_LOCATION;
 import static android.app.AppOpsManager.OP_FLAGS_ALL;
 import static android.app.AppOpsManager.OP_FLAG_SELF;
 import static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED;
 import static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXY;
+import static android.app.AppOpsManager.OP_GET_ACCOUNTS;
 import static android.app.AppOpsManager.OP_NONE;
 import static android.app.AppOpsManager.OP_PHONE_CALL_CAMERA;
 import static android.app.AppOpsManager.OP_PHONE_CALL_MICROPHONE;
+import static android.app.AppOpsManager.OP_PROCESS_OUTGOING_CALLS;
+import static android.app.AppOpsManager.OP_READ_CALENDAR;
+import static android.app.AppOpsManager.OP_READ_CALL_LOG;
+import static android.app.AppOpsManager.OP_READ_CELL_BROADCASTS;
+import static android.app.AppOpsManager.OP_READ_CONTACTS;
+import static android.app.AppOpsManager.OP_READ_EXTERNAL_STORAGE;
+import static android.app.AppOpsManager.OP_READ_PHONE_NUMBERS;
+import static android.app.AppOpsManager.OP_READ_PHONE_STATE;
+import static android.app.AppOpsManager.OP_READ_SMS;
+import static android.app.AppOpsManager.OP_RECEIVE_MMS;
+import static android.app.AppOpsManager.OP_RECEIVE_SMS;
+import static android.app.AppOpsManager.OP_RECEIVE_WAP_PUSH;
 import static android.app.AppOpsManager.OP_RECORD_AUDIO;
+import static android.app.AppOpsManager.OP_SEND_SMS;
+import static android.app.AppOpsManager.OP_USE_SIP;
+import static android.app.AppOpsManager.OP_UWB_RANGING;
+import static android.app.AppOpsManager.OP_WRITE_CALENDAR;
+import static android.app.AppOpsManager.OP_WRITE_CALL_LOG;
+import static android.app.AppOpsManager.OP_WRITE_CONTACTS;
+import static android.app.AppOpsManager.OP_WRITE_EXTERNAL_STORAGE;
 import static android.app.AppOpsManager.flagsToString;
 import static android.app.AppOpsManager.getUidStateName;
 
 import static java.lang.Long.min;
 import static java.lang.Math.max;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.AppOpsManager;
 import android.os.AsyncTask;
@@ -124,23 +153,55 @@ import java.util.Set;
 
 final class DiscreteRegistry {
     static final String DISCRETE_HISTORY_FILE_SUFFIX = "tl";
     private static final String TAG = DiscreteRegistry.class.getSimpleName();
 
     private static final String PROPERTY_DISCRETE_HISTORY_CUTOFF = "discrete_history_cutoff_millis";
     private static final String PROPERTY_DISCRETE_HISTORY_QUANTIZATION =
             "discrete_history_quantization_millis";
     private static final String PROPERTY_DISCRETE_FLAGS = "discrete_history_op_flags";
     private static final String PROPERTY_DISCRETE_OPS_LIST = "discrete_history_ops_cslist";
-    private static final String DEFAULT_DISCRETE_OPS = OP_FINE_LOCATION + "," + OP_COARSE_LOCATION
-            + "," + OP_CAMERA + "," + OP_RECORD_AUDIO + "," + OP_PHONE_CALL_MICROPHONE + ","
-            + OP_PHONE_CALL_CAMERA;
+
+    /**
+     * Keep track of more app ops for privacy dashboard display.
+     *
+     * From AppOpsManager.RUNTIME_AND_APPOP_PERMISSIONS_OPS:
+     * Location: COARSE_LOCATION, FINE_LOCATION
+     * Camera: CAMERA
+     * Microphone: RECORD_AUDIO
+     * Calendar: READ_CALENDAR, WRITE_CALENDAR
+     * Call logs: READ_CALL_LOG, WRITE_CALL_LOG
+     * Contacts: READ_CONTACTS, WRITE_CONTACTS, GET_ACCOUNTS
+     * Files and media: READ_EXTERNAL_STORAGE, WRITE_EXTERNAL_STORAGE, ACCESS_MEDIA_LOCATION
+     * Nearby devices: BLUETOOTH_SCAN, BLUETOOTH_CONNECT, BLUETOOTH_ADVERTISE, UWB_RANGING
+     * Phone: READ_PHONE_STATE, READ_PHONE_NUMBERS, CALL_PHONE, READ_CALL_LOG, WRITE_CALL_LOG, ADD_VOICEMAIL, USE_SIP, PROCESS_OUTGOING_CALLS, ANSWER_PHONE_CALLS, ACCEPT_HANDOVER
+     * Body sensors: ACTIVITY_RECOGNITION
+     * SMS: SEND_SMS, RECEIVE_SMS, READ_SMS, RECEIVE_WAP_PUSH, RECEIVE_MMS, READ_CELL_BROADCASTS
+     *
+     * From PrivacyItemController:
+     * Camera: PHONE_CALL_CAMERA
+     * Microphone: PHONE_CALL_MICROPHONE
+     */
+    private static final String DEFAULT_DISCRETE_OPS = OP_COARSE_LOCATION + "," + OP_FINE_LOCATION +
+            "," + OP_CAMERA + "," + OP_RECORD_AUDIO + "," + OP_READ_CALENDAR + "," +
+            OP_WRITE_CALENDAR + "," + OP_READ_CALL_LOG + "," + OP_WRITE_CALL_LOG + "," +
+            OP_READ_CONTACTS + "," + OP_WRITE_CONTACTS + "," + OP_GET_ACCOUNTS + "," +
+            OP_READ_EXTERNAL_STORAGE + "," + OP_WRITE_EXTERNAL_STORAGE + "," +
+            OP_ACCESS_MEDIA_LOCATION + "," + OP_BLUETOOTH_SCAN + "," + OP_BLUETOOTH_CONNECT + "," +
+            OP_BLUETOOTH_ADVERTISE + "," + OP_UWB_RANGING + "," + OP_READ_PHONE_STATE + "," +
+            OP_READ_PHONE_NUMBERS + "," + OP_CALL_PHONE + "," + OP_READ_CALL_LOG + "," +
+            OP_WRITE_CALL_LOG + "," + OP_ADD_VOICEMAIL + "," + OP_USE_SIP + "," +
+            OP_PROCESS_OUTGOING_CALLS + "," + OP_ANSWER_PHONE_CALLS + "," + OP_ACCEPT_HANDOVER +
+            "," + OP_ACTIVITY_RECOGNITION + "," + OP_SEND_SMS + "," + OP_RECEIVE_SMS + "," +
+            OP_READ_SMS + "," + OP_RECEIVE_WAP_PUSH + "," + OP_RECEIVE_MMS + "," +
+            OP_READ_CELL_BROADCASTS + "," + OP_PHONE_CALL_CAMERA + "," + OP_PHONE_CALL_MICROPHONE;
+
     private static final long DEFAULT_DISCRETE_HISTORY_CUTOFF = Duration.ofDays(7).toMillis();
     private static final long MAXIMUM_DISCRETE_HISTORY_CUTOFF = Duration.ofDays(30).toMillis();
     private static final long DEFAULT_DISCRETE_HISTORY_QUANTIZATION =
             Duration.ofMinutes(1).toMillis();
 
     private static long sDiscreteHistoryCutoff;
     private static long sDiscreteHistoryQuantization;
     private static int[] sDiscreteOps;
     private static int sDiscreteFlags;
 

commit 0ff885faa9b829ea99a11101e8266f8e10131d29
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2021-10-14 22:10:58-0400

    enable backup support via seedvault
---
 packages/SettingsProvider/res/values/defaults.xml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/packages/SettingsProvider/res/values/defaults.xml b/packages/SettingsProvider/res/values/defaults.xml
index 53324ba4d9664dc170a81c39dcf77d1affe7812a..93efe5060a2f642841b4d662225d30935e9b48b7 100644
--- a/packages/SettingsProvider/res/values/defaults.xml
+++ b/packages/SettingsProvider/res/values/defaults.xml
@@ -43,22 +43,22 @@
     <integer name="def_location_mode">3</integer>
     <bool name="assisted_gps_enabled">true</bool>
     <bool name="def_netstats_enabled">true</bool>
     <bool name="def_usb_mass_storage_enabled">true</bool>
     <bool name="def_wifi_on">false</bool>
     <!-- 0 == never, 1 == only when plugged in, 2 == always -->
     <integer name="def_wifi_sleep_policy">2</integer>
     <bool name="def_wifi_wakeup_enabled">true</bool>
     <bool name="def_networks_available_notification_on">true</bool>
 
-    <bool name="def_backup_enabled">false</bool>
-    <string name="def_backup_transport" translatable="false">com.android.localtransport/.LocalTransport</string>
+    <bool name="def_backup_enabled">true</bool>
+    <string name="def_backup_transport" translatable="false">com.stevesoltys.seedvault.transport.ConfigurableBackupTransport</string>
 
     <!-- Default value for whether or not to pulse the notification LED when there is a
          pending notification -->
     <bool name="def_notification_pulse">true</bool>
 
     <bool name="def_mount_play_notification_snd">true</bool>
     <bool name="def_mount_ums_autostart">false</bool>
     <bool name="def_mount_ums_prompt">true</bool>
     <bool name="def_mount_ums_notify_enabled">true</bool>
 

commit 94e93f2b8726f23b27543b168b6e61db72a4f5be
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Fri 2021-10-15 17:18:57-0700

    gmscompat: Fix crash with SDK 31 Google Services Framework
    
    Change-Id: I0cd34f32ccb59922bf85a220f485765bc34dbaf1
---
 core/java/android/provider/DeviceConfig.java | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/core/java/android/provider/DeviceConfig.java b/core/java/android/provider/DeviceConfig.java
index 7680d117c9d97ec7e260d771e6af437051df0e38..04195fac2b44c421ced786a3a855139473d4eb57 100644
--- a/core/java/android/provider/DeviceConfig.java
+++ b/core/java/android/provider/DeviceConfig.java
@@ -621,20 +621,24 @@ public final class DeviceConfig {
      * Look up the value of a property for a particular namespace.
      *
      * @param namespace The namespace containing the property to look up.
      * @param name      The name of the property to look up.
      * @return the corresponding value, or null if not present.
      * @hide
      */
     @SystemApi
     @RequiresPermission(READ_DEVICE_CONFIG)
     public static String getProperty(@NonNull String namespace, @NonNull String name) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         // Fetch all properties for the namespace at once and cache them in the local process, so we
         // incur the cost of the IPC less often. Lookups happen much more frequently than updates,
         // and we want to optimize the former.
         return getProperties(namespace, name).getString(name, null);
     }
 
     /**
      * Look up the values of multiple properties for a particular namespace. The lookup is atomic,
      * such that the values of these properties cannot change between the time when the first is
      * fetched and the time when the last is fetched.

commit 1ee907c3310f4550ebf8ece4c671b147c9667b88
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Fri 2021-10-15 17:55:04-0700

    gmscompat: Fall back to batched alarms when necessary
    
    Exact alarms are only available if the app is set to unrestricted
    battery usage.
    
    Change-Id: Id8e45726e9bc63cbfa70e873f56f375240209b70
---
 apex/jobscheduler/framework/java/android/app/AlarmManager.java | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/apex/jobscheduler/framework/java/android/app/AlarmManager.java b/apex/jobscheduler/framework/java/android/app/AlarmManager.java
index 9c0c3657bff33c5d8209c309fd4e6afd57a61fa0..f1483d23f9824d78e0c44cca5034ee60852d80f5 100644
--- a/apex/jobscheduler/framework/java/android/app/AlarmManager.java
+++ b/apex/jobscheduler/framework/java/android/app/AlarmManager.java
@@ -19,20 +19,21 @@ package android.app;
 import android.Manifest;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Context;
 import android.content.Intent;
 import android.os.Build;
 import android.os.Handler;
 import android.os.HandlerExecutor;
 import android.os.Parcel;
 import android.os.Parcelable;
@@ -1165,20 +1166,25 @@ public class AlarmManager {
      * @see android.content.Intent#filterEquals
      * @see #ELAPSED_REALTIME
      * @see #ELAPSED_REALTIME_WAKEUP
      * @see #RTC
      * @see #RTC_WAKEUP
      * @see Manifest.permission#SCHEDULE_EXACT_ALARM SCHEDULE_EXACT_ALARM
      */
     @RequiresPermission(value = Manifest.permission.SCHEDULE_EXACT_ALARM, conditional = true)
     public void setExactAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis,
             PendingIntent operation) {
+        if (GmsCompat.isEnabled() && !canScheduleExactAlarms()) {
+            setAndAllowWhileIdle(type, triggerAtMillis, operation);
+            return;
+        }
+
         setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, FLAG_ALLOW_WHILE_IDLE, operation,
                 null, null, (Handler) null, null, null);
     }
 
     /**
      * Remove any alarms with a matching {@link Intent}.
      * Any alarm, of any type, whose Intent matches this one (as defined by
      * {@link Intent#filterEquals}), will be canceled.
      *
      * @param operation IntentSender which matches a previously added

commit 0563acb8ed2bf5083b3a5916f02879f7b2e68d4c
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Wed 2021-10-20 16:06:40-0700

    gmscompat: Handle all exact alarm denials
    
    java.lang.SecurityException: Caller com.google.android.gms needs to hold android.permission.SCHEDULE_EXACT_ALARM to set exact alarms.
            at android.os.Parcel.createExceptionOrNull(Parcel.java:2425)
            at android.os.Parcel.createException(Parcel.java:2409)
            at android.os.Parcel.readException(Parcel.java:2392)
            at android.os.Parcel.readException(Parcel.java:2334)
            at android.app.IAlarmManager$Stub$Proxy.set(IAlarmManager.java:359)
            at android.app.AlarmManager.setImpl(AlarmManager.java:948)
            at android.app.AlarmManager.setImpl(AlarmManager.java:908)
            at android.app.AlarmManager.set(AlarmManager.java:818)
            at usv.k(:com.google.android.gms@213314046@21.33.14 (150400-395723304):1)
            at usv.o(:com.google.android.gms@213314046@21.33.14 (150400-395723304):0)
            at usv.e(:com.google.android.gms@213314046@21.33.14 (150400-395723304):2)
            at com.google.android.contextmanager.controller.EventHandler$AlarmSetter.c(:com.google.android.gms@213314046@21.33.14 (150400-395723304):8)
            at exr.d(:com.google.android.gms@213314046@21.33.14 (150400-395723304):3)
            at ext.l(:com.google.android.gms@213314046@21.33.14 (150400-395723304):0)
            at evr.a(:com.google.android.gms@213314046@21.33.14 (150400-395723304):143)
            at ext.run(:com.google.android.gms@213314046@21.33.14 (150400-395723304):2)
            at exp.handleMessage(:com.google.android.gms@213314046@21.33.14 (150400-395723304):3)
            at uwe.run(:com.google.android.gms@213314046@21.33.14 (150400-395723304):2)
            at uwo.c(:com.google.android.gms@213314046@21.33.14 (150400-395723304):6)
            at uwo.run(:com.google.android.gms@213314046@21.33.14 (150400-395723304):8)
            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
            at vcm.run(:com.google.android.gms@213314046@21.33.14 (150400-395723304):0)
            at java.lang.Thread.run(Thread.java:920)
    
    Change-Id: I6a179661a3da33cba54cbc07c48adcebcaf008a8
---
 apex/jobscheduler/framework/java/android/app/AlarmManager.java | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/apex/jobscheduler/framework/java/android/app/AlarmManager.java b/apex/jobscheduler/framework/java/android/app/AlarmManager.java
index f1483d23f9824d78e0c44cca5034ee60852d80f5..d6f3f42d10ab488b1c947a694e9d76a721bf4ec6 100644
--- a/apex/jobscheduler/framework/java/android/app/AlarmManager.java
+++ b/apex/jobscheduler/framework/java/android/app/AlarmManager.java
@@ -906,20 +906,25 @@ public class AlarmManager {
             AlarmClockInfo alarmClock) {
         final Handler handlerToUse = (targetHandler != null) ? targetHandler : mMainThreadHandler;
         setImpl(type, triggerAtMillis, windowMillis, intervalMillis, flags, operation, listener,
                 listenerTag, new HandlerExecutor(handlerToUse), workSource, alarmClock);
     }
 
     private void setImpl(@AlarmType int type, long triggerAtMillis, long windowMillis,
             long intervalMillis, int flags, PendingIntent operation, final OnAlarmListener listener,
             String listenerTag, Executor targetExecutor, WorkSource workSource,
             AlarmClockInfo alarmClock) {
+        if (GmsCompat.isEnabled() && windowMillis == WINDOW_EXACT &&
+                !canScheduleExactAlarms()) {
+            windowMillis = WINDOW_HEURISTIC;
+        }
+
         if (triggerAtMillis < 0) {
             /* NOTYET
             if (mAlwaysExact) {
                 // Fatal error for KLP+ apps to use negative trigger times
                 throw new IllegalArgumentException("Invalid alarm trigger time "
                         + triggerAtMillis);
             }
             */
             triggerAtMillis = 0;
         }
@@ -1166,25 +1171,20 @@ public class AlarmManager {
      * @see android.content.Intent#filterEquals
      * @see #ELAPSED_REALTIME
      * @see #ELAPSED_REALTIME_WAKEUP
      * @see #RTC
      * @see #RTC_WAKEUP
      * @see Manifest.permission#SCHEDULE_EXACT_ALARM SCHEDULE_EXACT_ALARM
      */
     @RequiresPermission(value = Manifest.permission.SCHEDULE_EXACT_ALARM, conditional = true)
     public void setExactAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis,
             PendingIntent operation) {
-        if (GmsCompat.isEnabled() && !canScheduleExactAlarms()) {
-            setAndAllowWhileIdle(type, triggerAtMillis, operation);
-            return;
-        }
-
         setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, FLAG_ALLOW_WHILE_IDLE, operation,
                 null, null, (Handler) null, null, null);
     }
 
     /**
      * Remove any alarms with a matching {@link Intent}.
      * Any alarm, of any type, whose Intent matches this one (as defined by
      * {@link Intent#filterEquals}), will be canceled.
      *
      * @param operation IntentSender which matches a previously added

commit 5527c12d1564c7c864964740b2254232bb06e8c1
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2015-03-14 18:10:20-0400

    add exec-based spawning support
---
 .../com/android/internal/os/ExecInit.java (new)    | 115 +++++++++++++++++++++
 core/java/com/android/internal/os/WrapperInit.java |   2 +-
 .../com/android/internal/os/ZygoteConnection.java  |  10 +-
 3 files changed, 125 insertions(+), 2 deletions(-)

diff --git a/core/java/com/android/internal/os/ExecInit.java b/core/java/com/android/internal/os/ExecInit.java
new file mode 100644
index 0000000000000000000000000000000000000000..2adcab7fdbe687f72143491b5e9a87c936431abb
--- /dev/null
+++ b/core/java/com/android/internal/os/ExecInit.java
@@ -0,0 +1,115 @@
+package com.android.internal.os;
+
+import android.os.Trace;
+import android.system.ErrnoException;
+import android.system.Os;
+import android.util.Slog;
+import android.util.TimingsTraceLog;
+import dalvik.system.VMRuntime;
+
+/**
+ * Startup class for the process.
+ * @hide
+ */
+public class ExecInit {
+    /**
+     * Class not instantiable.
+     */
+    private ExecInit() {
+    }
+
+    /**
+     * The main function called when starting a runtime application.
+     *
+     * The first argument is the target SDK version for the app.
+     *
+     * The remaining arguments are passed to the runtime.
+     *
+     * @param args The command-line arguments.
+     */
+    public static void main(String[] args) {
+        // Parse our mandatory argument.
+        int targetSdkVersion = Integer.parseInt(args[0], 10);
+
+        // Mimic system Zygote preloading.
+        ZygoteInit.preload(new TimingsTraceLog("ExecInitTiming",
+                Trace.TRACE_TAG_DALVIK));
+
+        // Launch the application.
+        String[] runtimeArgs = new String[args.length - 1];
+        System.arraycopy(args, 1, runtimeArgs, 0, runtimeArgs.length);
+        Runnable r = execInit(targetSdkVersion, runtimeArgs);
+
+        r.run();
+    }
+
+    /**
+     * Executes a runtime application with exec-based spawning.
+     * This method never returns.
+     *
+     * @param niceName The nice name for the application, or null if none.
+     * @param targetSdkVersion The target SDK version for the app.
+     * @param args Arguments for {@link RuntimeInit#main}.
+     */
+    public static void execApplication(String niceName, int targetSdkVersion,
+            String instructionSet, String[] args) {
+        int niceArgs = niceName == null ? 0 : 1;
+        int baseArgs = 5 + niceArgs;
+        String[] argv = new String[baseArgs + args.length];
+        if (VMRuntime.is64BitInstructionSet(instructionSet)) {
+            argv[0] = "/system/bin/app_process64";
+        } else {
+            argv[0] = "/system/bin/app_process32";
+        }
+        argv[1] = "/system/bin";
+        argv[2] = "--application";
+        if (niceName != null) {
+            argv[3] = "--nice-name=" + niceName;
+        }
+        argv[3 + niceArgs] = "com.android.internal.os.ExecInit";
+        argv[4 + niceArgs] = Integer.toString(targetSdkVersion);
+        System.arraycopy(args, 0, argv, baseArgs, args.length);
+
+        WrapperInit.preserveCapabilities();
+        try {
+            Os.execv(argv[0], argv);
+        } catch (ErrnoException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * The main function called when an application is started with exec-based spawning.
+     *
+     * When the app starts, the runtime starts {@link RuntimeInit#main}
+     * which calls {@link main} which then calls this method.
+     * So we don't need to call commonInit() here.
+     *
+     * @param targetSdkVersion target SDK version
+     * @param argv arg strings
+     */
+    private static Runnable execInit(int targetSdkVersion, String[] argv) {
+        if (RuntimeInit.DEBUG) {
+            Slog.d(RuntimeInit.TAG, "RuntimeInit: Starting application from exec");
+        }
+
+        // Check whether the first argument is a "-cp" in argv, and assume the next argument is the
+        // classpath. If found, create a PathClassLoader and use it for applicationInit.
+        ClassLoader classLoader = null;
+        if (argv != null && argv.length > 2 && argv[0].equals("-cp")) {
+            classLoader = ZygoteInit.createPathClassLoader(argv[1], targetSdkVersion);
+
+            // Install this classloader as the context classloader, too.
+            Thread.currentThread().setContextClassLoader(classLoader);
+
+            // Remove the classpath from the arguments.
+            String removedArgs[] = new String[argv.length - 2];
+            System.arraycopy(argv, 2, removedArgs, 0, argv.length - 2);
+            argv = removedArgs;
+        }
+
+        // Perform the same initialization that would happen after the Zygote forks.
+        Zygote.nativePreApplicationInit();
+        return RuntimeInit.applicationInit(targetSdkVersion, /*disabledCompatChanges*/ null, argv, classLoader);
+    }
+}
diff --git a/core/java/com/android/internal/os/WrapperInit.java b/core/java/com/android/internal/os/WrapperInit.java
index 6860759eea8aeaacbc40fc45720790a1f979b5ce..a2eef62f80be2485233cba817b995bc9beb1f338 100644
--- a/core/java/com/android/internal/os/WrapperInit.java
+++ b/core/java/com/android/internal/os/WrapperInit.java
@@ -179,21 +179,21 @@ public class WrapperInit {
      * Copy current capabilities to ambient capabilities. This is required for apps using
      * capabilities, as execv will re-evaluate the capability set, and the set of sh is
      * empty. Ambient capabilities have to be set to inherit them effectively.
      *
      * Note: This is BEST EFFORT ONLY. In case capabilities can't be raised, this function
      *       will silently return. In THIS CASE ONLY, as this is a development feature, it
      *       is better to return and try to run anyways, instead of blocking the wrapped app.
      *       This is acceptable here as failure will leave the wrapped app with strictly less
      *       capabilities, which may make it crash, but not exceed its allowances.
      */
-    private static void preserveCapabilities() {
+    public static void preserveCapabilities() {
         StructCapUserHeader header = new StructCapUserHeader(
                 OsConstants._LINUX_CAPABILITY_VERSION_3, 0);
         StructCapUserData[] data;
         try {
             data = Os.capget(header);
         } catch (ErrnoException e) {
             Slog.e(RuntimeInit.TAG, "RuntimeInit: Failed capget", e);
             return;
         }
 
diff --git a/core/java/com/android/internal/os/ZygoteConnection.java b/core/java/com/android/internal/os/ZygoteConnection.java
index 993e4e7b4b3d0bb39f0afe8e60947fd3d03baded..756547706f60812a32f2057f6c3b4a3406ec7c37 100644
--- a/core/java/com/android/internal/os/ZygoteConnection.java
+++ b/core/java/com/android/internal/os/ZygoteConnection.java
@@ -22,20 +22,21 @@ import static android.system.OsConstants.POLLIN;
 
 import static com.android.internal.os.ZygoteConnectionConstants.CONNECTION_TIMEOUT_MILLIS;
 import static com.android.internal.os.ZygoteConnectionConstants.WRAPPED_PID_TIMEOUT_MILLIS;
 
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.pm.ApplicationInfo;
 import android.net.Credentials;
 import android.net.LocalSocket;
 import android.os.Parcel;
 import android.os.Process;
+import android.os.SystemProperties;
 import android.os.Trace;
 import android.system.ErrnoException;
 import android.system.Os;
 import android.system.StructPollfd;
 import android.util.Log;
 
 import dalvik.system.VMRuntime;
 import dalvik.system.ZygoteHooks;
 
 import libcore.io.IoUtils;
@@ -240,21 +241,21 @@ class ZygoteConnection {
                 if (fd != null) {
                     fdsToClose[0] = fd.getInt$();
                 }
 
                 FileDescriptor zygoteFd = zygoteServer.getZygoteSocketFileDescriptor();
 
                 if (zygoteFd != null) {
                     fdsToClose[1] = zygoteFd.getInt$();
                 }
 
-                if (parsedArgs.mInvokeWith != null || parsedArgs.mStartChildZygote
+                if (parsedArgs.mInvokeWith != null || SystemProperties.getBoolean("sys.spawn.exec", true) || parsedArgs.mStartChildZygote
                         || !multipleOK || peer.getUid() != Process.SYSTEM_UID) {
                     // Continue using old code for now. TODO: Handle these cases in the other path.
                     pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid,
                             parsedArgs.mGids, parsedArgs.mRuntimeFlags, rlimits,
                             parsedArgs.mMountExternal, parsedArgs.mSeInfo, parsedArgs.mNiceName,
                             fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote,
                             parsedArgs.mInstructionSet, parsedArgs.mAppDataDir,
                             parsedArgs.mIsTopApp, parsedArgs.mPkgDataInfoList,
                             parsedArgs.mAllowlistedDataInfoList, parsedArgs.mBindMountAppDataDirs,
                             parsedArgs.mBindMountAppStorageDirs);
@@ -528,20 +529,27 @@ class ZygoteConnection {
         if (parsedArgs.mInvokeWith != null) {
             WrapperInit.execApplication(parsedArgs.mInvokeWith,
                     parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,
                     VMRuntime.getCurrentInstructionSet(),
                     pipeFd, parsedArgs.mRemainingArgs);
 
             // Should not get here.
             throw new IllegalStateException("WrapperInit.execApplication unexpectedly returned");
         } else {
             if (!isZygote) {
+                if (SystemProperties.getBoolean("sys.spawn.exec", true)) {
+                    ExecInit.execApplication(parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,
+                            VMRuntime.getCurrentInstructionSet(), parsedArgs.mRemainingArgs);
+
+                    // Should not get here.
+                    throw new IllegalStateException("ExecInit.execApplication unexpectedly returned");
+                }
                 return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,
                         parsedArgs.mDisabledCompatChanges,
                         parsedArgs.mRemainingArgs, null /* classLoader */);
             } else {
                 return ZygoteInit.childZygoteInit(
                         parsedArgs.mRemainingArgs  /* classLoader */);
             }
         }
     }
 

commit 6c6b093e5a3fa5d5786cbfe749ae9e8d0132f829
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-21 23:54:20-0400

    disable exec spawning when using debugging options
    
    The debugging options are not yet supported probably, so disable exec
    spawning when doing debugging.
---
 core/java/com/android/internal/os/ZygoteConnection.java | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/core/java/com/android/internal/os/ZygoteConnection.java b/core/java/com/android/internal/os/ZygoteConnection.java
index 756547706f60812a32f2057f6c3b4a3406ec7c37..27518dd4cdce45c6b54f3deb5d018a6706a061d8 100644
--- a/core/java/com/android/internal/os/ZygoteConnection.java
+++ b/core/java/com/android/internal/os/ZygoteConnection.java
@@ -529,21 +529,22 @@ class ZygoteConnection {
         if (parsedArgs.mInvokeWith != null) {
             WrapperInit.execApplication(parsedArgs.mInvokeWith,
                     parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,
                     VMRuntime.getCurrentInstructionSet(),
                     pipeFd, parsedArgs.mRemainingArgs);
 
             // Should not get here.
             throw new IllegalStateException("WrapperInit.execApplication unexpectedly returned");
         } else {
             if (!isZygote) {
-                if (SystemProperties.getBoolean("sys.spawn.exec", true)) {
+                if (SystemProperties.getBoolean("sys.spawn.exec", true) &&
+                        (parsedArgs.mRuntimeFlags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
                     ExecInit.execApplication(parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,
                             VMRuntime.getCurrentInstructionSet(), parsedArgs.mRemainingArgs);
 
                     // Should not get here.
                     throw new IllegalStateException("ExecInit.execApplication unexpectedly returned");
                 }
                 return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,
                         parsedArgs.mDisabledCompatChanges,
                         parsedArgs.mRemainingArgs, null /* classLoader */);
             } else {

commit a51dc3d24af7b7ddcdb0731a654e5101a0d81137
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-14 14:24:21-0400

    add parameter for avoiding full preload with exec
---
 core/java/com/android/internal/os/ExecInit.java   | 2 +-
 core/java/com/android/internal/os/ZygoteInit.java | 6 +++++-
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/core/java/com/android/internal/os/ExecInit.java b/core/java/com/android/internal/os/ExecInit.java
index 2adcab7fdbe687f72143491b5e9a87c936431abb..830e5b562a919bf599784358f3e4a267168e7fb1 100644
--- a/core/java/com/android/internal/os/ExecInit.java
+++ b/core/java/com/android/internal/os/ExecInit.java
@@ -26,21 +26,21 @@ public class ExecInit {
      * The remaining arguments are passed to the runtime.
      *
      * @param args The command-line arguments.
      */
     public static void main(String[] args) {
         // Parse our mandatory argument.
         int targetSdkVersion = Integer.parseInt(args[0], 10);
 
         // Mimic system Zygote preloading.
         ZygoteInit.preload(new TimingsTraceLog("ExecInitTiming",
-                Trace.TRACE_TAG_DALVIK));
+                Trace.TRACE_TAG_DALVIK), false);
 
         // Launch the application.
         String[] runtimeArgs = new String[args.length - 1];
         System.arraycopy(args, 1, runtimeArgs, 0, runtimeArgs.length);
         Runnable r = execInit(targetSdkVersion, runtimeArgs);
 
         r.run();
     }
 
     /**
diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index 0f26f57e21559d9efbf650587842680ddd480f0f..809ac8b4dfd497443fdd7da3af824724255a1caf 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -126,21 +126,21 @@ public class ZygoteInit {
     private static final int ROOT_GID = 0;
 
     private static boolean sPreloadComplete;
 
     /**
      * Cached classloader to use for the system server. Will only be populated in the system
      * server process.
      */
     private static ClassLoader sCachedSystemServerClassLoader = null;
 
-    static void preload(TimingsTraceLog bootTimingsTraceLog) {
+    static void preload(TimingsTraceLog bootTimingsTraceLog, boolean fullPreload) {
         Log.d(TAG, "begin preload");
         bootTimingsTraceLog.traceBegin("BeginPreload");
         beginPreload();
         bootTimingsTraceLog.traceEnd(); // BeginPreload
         bootTimingsTraceLog.traceBegin("PreloadClasses");
         preloadClasses();
         bootTimingsTraceLog.traceEnd(); // PreloadClasses
         bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
         cacheNonBootClasspathClassLoaders();
         bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
@@ -158,20 +158,24 @@ public class ZygoteInit {
         // Ask the WebViewFactory to do any initialization that must run in the zygote process,
         // for memory sharing purposes.
         WebViewFactory.prepareWebViewInZygote();
         endPreload();
         warmUpJcaProviders();
         Log.d(TAG, "end preload");
 
         sPreloadComplete = true;
     }
 
+    static void preload(TimingsTraceLog bootTimingsTraceLog) {
+        preload(bootTimingsTraceLog, true);
+    }
+
     static void lazyPreload() {
         Preconditions.checkState(!sPreloadComplete);
         Log.i(TAG, "Lazily preloading resources.");
 
         preload(new TimingsTraceLog("ZygoteInitTiming_lazy", Trace.TRACE_TAG_DALVIK));
     }
 
     private static void beginPreload() {
         Log.i(TAG, "Calling ZygoteHooks.beginPreload()");
 

commit d4661d94a9f1fa5fd85f88ef04c305dbc6fa5866
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2019-09-11 06:43:55-0400

    pass through fullPreload to libcore
---
 core/java/com/android/internal/os/ZygoteInit.java | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index 809ac8b4dfd497443fdd7da3af824724255a1caf..e8e35ab70cbe91698aa8d97cab57163b6e8f4d5c 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -129,21 +129,21 @@ public class ZygoteInit {
 
     /**
      * Cached classloader to use for the system server. Will only be populated in the system
      * server process.
      */
     private static ClassLoader sCachedSystemServerClassLoader = null;
 
     static void preload(TimingsTraceLog bootTimingsTraceLog, boolean fullPreload) {
         Log.d(TAG, "begin preload");
         bootTimingsTraceLog.traceBegin("BeginPreload");
-        beginPreload();
+        beginPreload(fullPreload);
         bootTimingsTraceLog.traceEnd(); // BeginPreload
         bootTimingsTraceLog.traceBegin("PreloadClasses");
         preloadClasses();
         bootTimingsTraceLog.traceEnd(); // PreloadClasses
         bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
         cacheNonBootClasspathClassLoaders();
         bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
         bootTimingsTraceLog.traceBegin("PreloadResources");
         preloadResources();
         bootTimingsTraceLog.traceEnd(); // PreloadResources
@@ -151,46 +151,46 @@ public class ZygoteInit {
         nativePreloadAppProcessHALs();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
         maybePreloadGraphicsDriver();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         preloadSharedLibraries();
         preloadTextResources();
         // Ask the WebViewFactory to do any initialization that must run in the zygote process,
         // for memory sharing purposes.
         WebViewFactory.prepareWebViewInZygote();
-        endPreload();
+        endPreload(fullPreload);
         warmUpJcaProviders();
         Log.d(TAG, "end preload");
 
         sPreloadComplete = true;
     }
 
     static void preload(TimingsTraceLog bootTimingsTraceLog) {
         preload(bootTimingsTraceLog, true);
     }
 
     static void lazyPreload() {
         Preconditions.checkState(!sPreloadComplete);
         Log.i(TAG, "Lazily preloading resources.");
 
         preload(new TimingsTraceLog("ZygoteInitTiming_lazy", Trace.TRACE_TAG_DALVIK));
     }
 
-    private static void beginPreload() {
+    private static void beginPreload(boolean fullPreload) {
         Log.i(TAG, "Calling ZygoteHooks.beginPreload()");
 
-        ZygoteHooks.onBeginPreload();
+        ZygoteHooks.onBeginPreload(fullPreload);
     }
 
-    private static void endPreload() {
-        ZygoteHooks.onEndPreload();
+    private static void endPreload(boolean fullPreload) {
+        ZygoteHooks.onEndPreload(fullPreload);
 
         Log.i(TAG, "Called ZygoteHooks.endPreload()");
     }
 
     private static void preloadSharedLibraries() {
         Log.i(TAG, "Preloading shared libraries...");
         System.loadLibrary("android");
         System.loadLibrary("compiler_rt");
         System.loadLibrary("jnigraphics");
     }

commit 428707ee76036f933e9f6e87af6874287880c00a
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-14 14:28:27-0400

    disable OpenGL preloading for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index e8e35ab70cbe91698aa8d97cab57163b6e8f4d5c..cdd14501e8ac528b650a14bf5be2a0eb9f6f409b 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -143,23 +143,25 @@ public class ZygoteInit {
         bootTimingsTraceLog.traceEnd(); // PreloadClasses
         bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
         cacheNonBootClasspathClassLoaders();
         bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
         bootTimingsTraceLog.traceBegin("PreloadResources");
         preloadResources();
         bootTimingsTraceLog.traceEnd(); // PreloadResources
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
         nativePreloadAppProcessHALs();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
-        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
-        maybePreloadGraphicsDriver();
-        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
+        if (fullPreload) {
+            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
+            maybePreloadGraphicsDriver();
+            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
+        }
         preloadSharedLibraries();
         preloadTextResources();
         // Ask the WebViewFactory to do any initialization that must run in the zygote process,
         // for memory sharing purposes.
         WebViewFactory.prepareWebViewInZygote();
         endPreload(fullPreload);
         warmUpJcaProviders();
         Log.d(TAG, "end preload");
 
         sPreloadComplete = true;

commit 8f8d28bbb44f3e15720e69a704d5dc5727be42a9
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2021-10-16 18:41:25-0400

    Revert "disable OpenGL preloading for exec spawning"
    
    This reverts commit 5a8d91b5fac0a1ae597de359128e0706776ce3a7.
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index cdd14501e8ac528b650a14bf5be2a0eb9f6f409b..e8e35ab70cbe91698aa8d97cab57163b6e8f4d5c 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -143,25 +143,23 @@ public class ZygoteInit {
         bootTimingsTraceLog.traceEnd(); // PreloadClasses
         bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
         cacheNonBootClasspathClassLoaders();
         bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
         bootTimingsTraceLog.traceBegin("PreloadResources");
         preloadResources();
         bootTimingsTraceLog.traceEnd(); // PreloadResources
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
         nativePreloadAppProcessHALs();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
-        if (fullPreload) {
-            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
-            maybePreloadGraphicsDriver();
-            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
-        }
+        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
+        maybePreloadGraphicsDriver();
+        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         preloadSharedLibraries();
         preloadTextResources();
         // Ask the WebViewFactory to do any initialization that must run in the zygote process,
         // for memory sharing purposes.
         WebViewFactory.prepareWebViewInZygote();
         endPreload(fullPreload);
         warmUpJcaProviders();
         Log.d(TAG, "end preload");
 
         sPreloadComplete = true;

commit 092a71ef3cca2f7c528dfe0216637d06d45ca951
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-14 14:28:52-0400

    disable resource preloading for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index e8e35ab70cbe91698aa8d97cab57163b6e8f4d5c..4742522bcaf447c2209275830230829850a9630b 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -137,23 +137,25 @@ public class ZygoteInit {
         Log.d(TAG, "begin preload");
         bootTimingsTraceLog.traceBegin("BeginPreload");
         beginPreload(fullPreload);
         bootTimingsTraceLog.traceEnd(); // BeginPreload
         bootTimingsTraceLog.traceBegin("PreloadClasses");
         preloadClasses();
         bootTimingsTraceLog.traceEnd(); // PreloadClasses
         bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
         cacheNonBootClasspathClassLoaders();
         bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
-        bootTimingsTraceLog.traceBegin("PreloadResources");
-        preloadResources();
-        bootTimingsTraceLog.traceEnd(); // PreloadResources
+        if (fullPreload) {
+            bootTimingsTraceLog.traceBegin("PreloadResources");
+            preloadResources();
+            bootTimingsTraceLog.traceEnd(); // PreloadResources
+        }
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
         nativePreloadAppProcessHALs();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
         maybePreloadGraphicsDriver();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         preloadSharedLibraries();
         preloadTextResources();
         // Ask the WebViewFactory to do any initialization that must run in the zygote process,
         // for memory sharing purposes.

commit df5fabadacfa25da9b78065ac232459545737a8c
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-14 14:30:59-0400

    disable class preloading for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index 4742522bcaf447c2209275830230829850a9630b..af243c44c829dd03965aee5b8dde985f1b4093fa 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -131,23 +131,25 @@ public class ZygoteInit {
      * Cached classloader to use for the system server. Will only be populated in the system
      * server process.
      */
     private static ClassLoader sCachedSystemServerClassLoader = null;
 
     static void preload(TimingsTraceLog bootTimingsTraceLog, boolean fullPreload) {
         Log.d(TAG, "begin preload");
         bootTimingsTraceLog.traceBegin("BeginPreload");
         beginPreload(fullPreload);
         bootTimingsTraceLog.traceEnd(); // BeginPreload
-        bootTimingsTraceLog.traceBegin("PreloadClasses");
-        preloadClasses();
-        bootTimingsTraceLog.traceEnd(); // PreloadClasses
+        if (fullPreload) {
+            bootTimingsTraceLog.traceBegin("PreloadClasses");
+            preloadClasses();
+            bootTimingsTraceLog.traceEnd(); // PreloadClasses
+        }
         bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
         cacheNonBootClasspathClassLoaders();
         bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
         if (fullPreload) {
             bootTimingsTraceLog.traceBegin("PreloadResources");
             preloadResources();
             bootTimingsTraceLog.traceEnd(); // PreloadResources
         }
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
         nativePreloadAppProcessHALs();

commit bc81a705a8e17aff112fc0d16f91d765977508e0
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-14 14:31:29-0400

    disable WebView reservation for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index af243c44c829dd03965aee5b8dde985f1b4093fa..d98f14b414a5825d0372f574f185480e39b6b769 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -152,23 +152,25 @@ public class ZygoteInit {
             bootTimingsTraceLog.traceEnd(); // PreloadResources
         }
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
         nativePreloadAppProcessHALs();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
         maybePreloadGraphicsDriver();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         preloadSharedLibraries();
         preloadTextResources();
-        // Ask the WebViewFactory to do any initialization that must run in the zygote process,
-        // for memory sharing purposes.
-        WebViewFactory.prepareWebViewInZygote();
+        if (fullPreload) {
+            // Ask the WebViewFactory to do any initialization that must run in the zygote process,
+            // for memory sharing purposes.
+            WebViewFactory.prepareWebViewInZygote();
+        }
         endPreload(fullPreload);
         warmUpJcaProviders();
         Log.d(TAG, "end preload");
 
         sPreloadComplete = true;
     }
 
     static void preload(TimingsTraceLog bootTimingsTraceLog) {
         preload(bootTimingsTraceLog, true);
     }

commit b5544391680cc91600b8f34b4191b214a87ee2b2
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-14 14:34:32-0400

    disable JCA provider warm up for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 22 ++++++++++++----------
 1 file changed, 12 insertions(+), 10 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index d98f14b414a5825d0372f574f185480e39b6b769..145b52f2c143fc97d44fc6823fc70d6a7f588458 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -158,21 +158,21 @@ public class ZygoteInit {
         maybePreloadGraphicsDriver();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         preloadSharedLibraries();
         preloadTextResources();
         if (fullPreload) {
             // Ask the WebViewFactory to do any initialization that must run in the zygote process,
             // for memory sharing purposes.
             WebViewFactory.prepareWebViewInZygote();
         }
         endPreload(fullPreload);
-        warmUpJcaProviders();
+        warmUpJcaProviders(fullPreload);
         Log.d(TAG, "end preload");
 
         sPreloadComplete = true;
     }
 
     static void preload(TimingsTraceLog bootTimingsTraceLog) {
         preload(bootTimingsTraceLog, true);
     }
 
     static void lazyPreload() {
@@ -222,39 +222,41 @@ public class ZygoteInit {
         Hyphenator.init();
         TextView.preloadFontCache();
     }
 
     /**
      * Register AndroidKeyStoreProvider and warm up the providers that are already registered.
      *
      * By doing it here we avoid that each app does it when requesting a service from the provider
      * for the first time.
      */
-    private static void warmUpJcaProviders() {
+    private static void warmUpJcaProviders(boolean fullPreload) {
         long startTime = SystemClock.uptimeMillis();
         Trace.traceBegin(
                 Trace.TRACE_TAG_DALVIK, "Starting installation of AndroidKeyStoreProvider");
 
         AndroidKeyStoreProvider.install();
         Log.i(TAG, "Installed AndroidKeyStoreProvider in "
                 + (SystemClock.uptimeMillis() - startTime) + "ms.");
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
 
-        startTime = SystemClock.uptimeMillis();
-        Trace.traceBegin(
-                Trace.TRACE_TAG_DALVIK, "Starting warm up of JCA providers");
-        for (Provider p : Security.getProviders()) {
-            p.warmUpServiceProvision();
+        if (fullPreload) {
+            startTime = SystemClock.uptimeMillis();
+            Trace.traceBegin(
+                    Trace.TRACE_TAG_DALVIK, "Starting warm up of JCA providers");
+            for (Provider p : Security.getProviders()) {
+                p.warmUpServiceProvision();
+            }
+            Log.i(TAG, "Warmed up JCA providers in "
+                    + (SystemClock.uptimeMillis() - startTime) + "ms.");
+            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         }
-        Log.i(TAG, "Warmed up JCA providers in "
-                + (SystemClock.uptimeMillis() - startTime) + "ms.");
-        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
     }
 
     /**
      * Performs Zygote process initialization. Loads and initializes commonly used classes.
      *
      * Most classes only cause a few hundred bytes to be allocated, but a few will allocate a dozen
      * Kbytes (in one case, 500+K).
      */
     private static void preloadClasses() {
         final VMRuntime runtime = VMRuntime.getRuntime();

commit 82d6d167abde7052d0fea92af45545093c3eee30
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2019-09-11 06:57:24-0400

    disable preloading classloaders for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index 145b52f2c143fc97d44fc6823fc70d6a7f588458..0fb0d4a97d826f1bd62bf252e01cebad3e3b0979 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -136,23 +136,25 @@ public class ZygoteInit {
     static void preload(TimingsTraceLog bootTimingsTraceLog, boolean fullPreload) {
         Log.d(TAG, "begin preload");
         bootTimingsTraceLog.traceBegin("BeginPreload");
         beginPreload(fullPreload);
         bootTimingsTraceLog.traceEnd(); // BeginPreload
         if (fullPreload) {
             bootTimingsTraceLog.traceBegin("PreloadClasses");
             preloadClasses();
             bootTimingsTraceLog.traceEnd(); // PreloadClasses
         }
-        bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
-        cacheNonBootClasspathClassLoaders();
-        bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
+        if (fullPreload) {
+            bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
+            cacheNonBootClasspathClassLoaders();
+            bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
+        }
         if (fullPreload) {
             bootTimingsTraceLog.traceBegin("PreloadResources");
             preloadResources();
             bootTimingsTraceLog.traceEnd(); // PreloadResources
         }
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
         nativePreloadAppProcessHALs();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
         maybePreloadGraphicsDriver();

commit 99e6d0dd4e225db13bc147cda95146f55cc625ec
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2019-09-11 06:58:51-0400

    disable preloading HALs for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index 0fb0d4a97d826f1bd62bf252e01cebad3e3b0979..ea199914b11e17586cadd9bdadf5694c8d052c0e 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -146,23 +146,25 @@ public class ZygoteInit {
         if (fullPreload) {
             bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
             cacheNonBootClasspathClassLoaders();
             bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
         }
         if (fullPreload) {
             bootTimingsTraceLog.traceBegin("PreloadResources");
             preloadResources();
             bootTimingsTraceLog.traceEnd(); // PreloadResources
         }
-        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
-        nativePreloadAppProcessHALs();
-        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
+        if (fullPreload) {
+            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
+            nativePreloadAppProcessHALs();
+            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
+        }
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
         maybePreloadGraphicsDriver();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         preloadSharedLibraries();
         preloadTextResources();
         if (fullPreload) {
             // Ask the WebViewFactory to do any initialization that must run in the zygote process,
             // for memory sharing purposes.
             WebViewFactory.prepareWebViewInZygote();
         }

commit 3a6d43feeaaacfe866f1f51291adb9ea7c88d3c4
Author: anupritaisno1 <www.anuprita804@gmail.com>
Date:   Fri 2020-10-30 22:26:09+0000

    pass through runtime flags for exec spawning and implement them in the child
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 core/java/com/android/internal/os/ExecInit.java    |  14 ++-
 core/java/com/android/internal/os/Zygote.java      |   9 ++
 .../com/android/internal/os/ZygoteConnection.java  |   2 +-
 core/jni/com_android_internal_os_Zygote.cpp        | 129 +++++++++++----------
 4 files changed, 89 insertions(+), 65 deletions(-)

diff --git a/core/java/com/android/internal/os/ExecInit.java b/core/java/com/android/internal/os/ExecInit.java
index 830e5b562a919bf599784358f3e4a267168e7fb1..749c67abf389dfd684972fab5b8e5b967c2634a0 100644
--- a/core/java/com/android/internal/os/ExecInit.java
+++ b/core/java/com/android/internal/os/ExecInit.java
@@ -24,57 +24,63 @@ public class ExecInit {
      * The first argument is the target SDK version for the app.
      *
      * The remaining arguments are passed to the runtime.
      *
      * @param args The command-line arguments.
      */
     public static void main(String[] args) {
         // Parse our mandatory argument.
         int targetSdkVersion = Integer.parseInt(args[0], 10);
 
+        // Parse the runtime_flags.
+        int runtimeFlags = Integer.parseInt(args[1], 10);
+
         // Mimic system Zygote preloading.
         ZygoteInit.preload(new TimingsTraceLog("ExecInitTiming",
                 Trace.TRACE_TAG_DALVIK), false);
 
         // Launch the application.
-        String[] runtimeArgs = new String[args.length - 1];
-        System.arraycopy(args, 1, runtimeArgs, 0, runtimeArgs.length);
+        String[] runtimeArgs = new String[args.length - 2];
+        System.arraycopy(args, 2, runtimeArgs, 0, runtimeArgs.length);
         Runnable r = execInit(targetSdkVersion, runtimeArgs);
 
+        Zygote.nativeHandleRuntimeFlags(runtimeFlags);
+
         r.run();
     }
 
     /**
      * Executes a runtime application with exec-based spawning.
      * This method never returns.
      *
      * @param niceName The nice name for the application, or null if none.
      * @param targetSdkVersion The target SDK version for the app.
      * @param args Arguments for {@link RuntimeInit#main}.
      */
     public static void execApplication(String niceName, int targetSdkVersion,
-            String instructionSet, String[] args) {
+            String instructionSet, int runtimeFlags, String[] args) {
         int niceArgs = niceName == null ? 0 : 1;
-        int baseArgs = 5 + niceArgs;
+        int baseArgs = 6 + niceArgs;
         String[] argv = new String[baseArgs + args.length];
         if (VMRuntime.is64BitInstructionSet(instructionSet)) {
             argv[0] = "/system/bin/app_process64";
         } else {
             argv[0] = "/system/bin/app_process32";
         }
         argv[1] = "/system/bin";
         argv[2] = "--application";
         if (niceName != null) {
             argv[3] = "--nice-name=" + niceName;
         }
         argv[3 + niceArgs] = "com.android.internal.os.ExecInit";
         argv[4 + niceArgs] = Integer.toString(targetSdkVersion);
+        argv[5 + niceArgs] = Integer.toString(runtimeFlags);
         System.arraycopy(args, 0, argv, baseArgs, args.length);
 
         WrapperInit.preserveCapabilities();
         try {
             Os.execv(argv[0], argv);
         } catch (ErrnoException e) {
             throw new RuntimeException(e);
         }
     }
 
diff --git a/core/java/com/android/internal/os/Zygote.java b/core/java/com/android/internal/os/Zygote.java
index e4e28a926ed6d03df12981eff2a5ab518a149423..42242c3d5481b4da61ab8839c42a777d935fdd61 100644
--- a/core/java/com/android/internal/os/Zygote.java
+++ b/core/java/com/android/internal/os/Zygote.java
@@ -1161,11 +1161,20 @@ public final class Zygote {
      * fully-feature Memory Tagging, rather than the static Tagged Pointers.
      */
     public static native boolean nativeSupportsTaggedPointers();
 
     /**
      * Returns the current native tagging level, as one of the
      * MEMORY_TAG_LEVEL_* constants. Returns zero if no tagging is present, or
      * we failed to determine the level.
      */
     public static native int nativeCurrentTaggingLevel();
+
+    /**
+     * Used on GrapheneOS to set up runtime flags
+     *
+     * @param runtimeFlags flags to be passed to the native method
+     *
+     * @hide
+     */
+    public static native void nativeHandleRuntimeFlags(int runtimeFlags);
 }
diff --git a/core/java/com/android/internal/os/ZygoteConnection.java b/core/java/com/android/internal/os/ZygoteConnection.java
index 27518dd4cdce45c6b54f3deb5d018a6706a061d8..a8d9400c79923848f82e4b2371638584977d8d0b 100644
--- a/core/java/com/android/internal/os/ZygoteConnection.java
+++ b/core/java/com/android/internal/os/ZygoteConnection.java
@@ -532,21 +532,21 @@ class ZygoteConnection {
                     VMRuntime.getCurrentInstructionSet(),
                     pipeFd, parsedArgs.mRemainingArgs);
 
             // Should not get here.
             throw new IllegalStateException("WrapperInit.execApplication unexpectedly returned");
         } else {
             if (!isZygote) {
                 if (SystemProperties.getBoolean("sys.spawn.exec", true) &&
                         (parsedArgs.mRuntimeFlags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
                     ExecInit.execApplication(parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,
-                            VMRuntime.getCurrentInstructionSet(), parsedArgs.mRemainingArgs);
+                            VMRuntime.getCurrentInstructionSet(), parsedArgs.mRuntimeFlags, parsedArgs.mRemainingArgs);
 
                     // Should not get here.
                     throw new IllegalStateException("ExecInit.execApplication unexpectedly returned");
                 }
                 return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,
                         parsedArgs.mDisabledCompatChanges,
                         parsedArgs.mRemainingArgs, null /* classLoader */);
             } else {
                 return ZygoteInit.childZygoteInit(
                         parsedArgs.mRemainingArgs  /* classLoader */);
diff --git a/core/jni/com_android_internal_os_Zygote.cpp b/core/jni/com_android_internal_os_Zygote.cpp
index bed0aae074a4c274bea18d4491322cd77d22639f..69f615a8e0f4d680279e456d4dcab4136cc29edb 100644
--- a/core/jni/com_android_internal_os_Zygote.cpp
+++ b/core/jni/com_android_internal_os_Zygote.cpp
@@ -1545,20 +1545,83 @@ static void BindMountStorageDirs(JNIEnv* env, jobjectArray pkg_data_info_list,
 
   // Bind mount each package obb directory
   for (int i = 0; i < size; i += 3) {
     jstring package_str = (jstring) (env->GetObjectArrayElement(pkg_data_info_list, i));
     std::string packageName = extract_fn(package_str).value();
     BindMountStorageToLowerFs(user_id, uid, "Android/obb", packageName.c_str(), fail_fn);
     BindMountStorageToLowerFs(user_id, uid, "Android/data", packageName.c_str(), fail_fn);
   }
 }
 
+static void HandleRuntimeFlags(JNIEnv* env, jint& runtime_flags) {
+    // Set process properties to enable debugging if required.
+    if ((runtime_flags & RuntimeFlags::DEBUG_ENABLE_JDWP) != 0) {
+        EnableDebugger();
+    }
+    if ((runtime_flags & RuntimeFlags::PROFILE_FROM_SHELL) != 0) {
+        // simpleperf needs the process to be dumpable to profile it.
+        if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) == -1) {
+            ALOGE("prctl(PR_SET_DUMPABLE) failed: %s", strerror(errno));
+            RuntimeAbort(env, __LINE__, "prctl(PR_SET_DUMPABLE, 1) failed");
+        }
+    }
+
+    HeapTaggingLevel heap_tagging_level;
+    switch (runtime_flags & RuntimeFlags::MEMORY_TAG_LEVEL_MASK) {
+        case RuntimeFlags::MEMORY_TAG_LEVEL_TBI:
+            heap_tagging_level = M_HEAP_TAGGING_LEVEL_TBI;
+            break;
+        case RuntimeFlags::MEMORY_TAG_LEVEL_ASYNC:
+            heap_tagging_level = M_HEAP_TAGGING_LEVEL_ASYNC;
+            break;
+        case RuntimeFlags::MEMORY_TAG_LEVEL_SYNC:
+            heap_tagging_level = M_HEAP_TAGGING_LEVEL_SYNC;
+            break;
+        default:
+            heap_tagging_level = M_HEAP_TAGGING_LEVEL_NONE;
+            break;
+    }
+    mallopt(M_BIONIC_SET_HEAP_TAGGING_LEVEL, heap_tagging_level);
+
+    // Now that we've used the flag, clear it so that we don't pass unknown flags to the ART
+    // runtime.
+    runtime_flags &= ~RuntimeFlags::MEMORY_TAG_LEVEL_MASK;
+
+    // Avoid heap zero initialization for applications without MTE. Zero init may
+    // cause app compat problems, use more memory, or reduce performance. While it
+    // would be nice to have them for apps, we will have to wait until they are
+    // proven out, have more efficient hardware, and/or apply them only to new
+    // applications.
+    if (!(runtime_flags & RuntimeFlags::NATIVE_HEAP_ZERO_INIT)) {
+        mallopt(M_BIONIC_ZERO_INIT, 0);
+    }
+
+    // Now that we've used the flag, clear it so that we don't pass unknown flags to the ART
+    // runtime.
+    runtime_flags &= ~RuntimeFlags::NATIVE_HEAP_ZERO_INIT;
+
+    bool forceEnableGwpAsan = false;
+    switch (runtime_flags & RuntimeFlags::GWP_ASAN_LEVEL_MASK) {
+        default:
+        case RuntimeFlags::GWP_ASAN_LEVEL_NEVER:
+            break;
+        case RuntimeFlags::GWP_ASAN_LEVEL_ALWAYS:
+            forceEnableGwpAsan = true;
+            [[fallthrough]];
+        case RuntimeFlags::GWP_ASAN_LEVEL_LOTTERY:
+            android_mallopt(M_INITIALIZE_GWP_ASAN, &forceEnableGwpAsan, sizeof(forceEnableGwpAsan));
+    }
+    // Now that we've used the flag, clear it so that we don't pass unknown flags to the ART
+    // runtime.
+    runtime_flags &= ~RuntimeFlags::GWP_ASAN_LEVEL_MASK;
+}
+
 // Utility routine to specialize a zygote child process.
 static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags,
                              jobjectArray rlimits, jlong permitted_capabilities,
                              jlong effective_capabilities, jint mount_external,
                              jstring managed_se_info, jstring managed_nice_name,
                              bool is_system_server, bool is_child_zygote,
                              jstring managed_instruction_set, jstring managed_app_data_dir,
                              bool is_top_app, jobjectArray pkg_data_info_list,
                              jobjectArray allowlisted_data_info_list, bool mount_data_dirs,
                              bool mount_storage_dirs) {
@@ -1672,80 +1735,21 @@ static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids,
         RuntimeAbort(env, __LINE__, "prctl(PR_GET_DUMPABLE) failed");
     }
 
     if (dumpable == 2 && uid >= AID_APP) {
         if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) == -1) {
             ALOGE("prctl(PR_SET_DUMPABLE, 0) failed: %s", strerror(errno));
             RuntimeAbort(env, __LINE__, "prctl(PR_SET_DUMPABLE, 0) failed");
         }
     }
 
-    // Set process properties to enable debugging if required.
-    if ((runtime_flags & RuntimeFlags::DEBUG_ENABLE_JDWP) != 0) {
-        EnableDebugger();
-    }
-    if ((runtime_flags & RuntimeFlags::PROFILE_FROM_SHELL) != 0) {
-        // simpleperf needs the process to be dumpable to profile it.
-        if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) == -1) {
-            ALOGE("prctl(PR_SET_DUMPABLE) failed: %s", strerror(errno));
-            RuntimeAbort(env, __LINE__, "prctl(PR_SET_DUMPABLE, 1) failed");
-        }
-    }
-
-    HeapTaggingLevel heap_tagging_level;
-    switch (runtime_flags & RuntimeFlags::MEMORY_TAG_LEVEL_MASK) {
-        case RuntimeFlags::MEMORY_TAG_LEVEL_TBI:
-            heap_tagging_level = M_HEAP_TAGGING_LEVEL_TBI;
-            break;
-        case RuntimeFlags::MEMORY_TAG_LEVEL_ASYNC:
-            heap_tagging_level = M_HEAP_TAGGING_LEVEL_ASYNC;
-            break;
-        case RuntimeFlags::MEMORY_TAG_LEVEL_SYNC:
-            heap_tagging_level = M_HEAP_TAGGING_LEVEL_SYNC;
-            break;
-        default:
-            heap_tagging_level = M_HEAP_TAGGING_LEVEL_NONE;
-            break;
-    }
-    mallopt(M_BIONIC_SET_HEAP_TAGGING_LEVEL, heap_tagging_level);
-
-    // Now that we've used the flag, clear it so that we don't pass unknown flags to the ART
-    // runtime.
-    runtime_flags &= ~RuntimeFlags::MEMORY_TAG_LEVEL_MASK;
-
-    // Avoid heap zero initialization for applications without MTE. Zero init may
-    // cause app compat problems, use more memory, or reduce performance. While it
-    // would be nice to have them for apps, we will have to wait until they are
-    // proven out, have more efficient hardware, and/or apply them only to new
-    // applications.
-    if (!(runtime_flags & RuntimeFlags::NATIVE_HEAP_ZERO_INIT)) {
-        mallopt(M_BIONIC_ZERO_INIT, 0);
-    }
-
-    // Now that we've used the flag, clear it so that we don't pass unknown flags to the ART
-    // runtime.
-    runtime_flags &= ~RuntimeFlags::NATIVE_HEAP_ZERO_INIT;
-
-    bool forceEnableGwpAsan = false;
-    switch (runtime_flags & RuntimeFlags::GWP_ASAN_LEVEL_MASK) {
-        default:
-        case RuntimeFlags::GWP_ASAN_LEVEL_NEVER:
-            break;
-        case RuntimeFlags::GWP_ASAN_LEVEL_ALWAYS:
-            forceEnableGwpAsan = true;
-            [[fallthrough]];
-        case RuntimeFlags::GWP_ASAN_LEVEL_LOTTERY:
-            android_mallopt(M_INITIALIZE_GWP_ASAN, &forceEnableGwpAsan, sizeof(forceEnableGwpAsan));
-    }
-    // Now that we've used the flag, clear it so that we don't pass unknown flags to the ART
-    // runtime.
-    runtime_flags &= ~RuntimeFlags::GWP_ASAN_LEVEL_MASK;
+    HandleRuntimeFlags(env, runtime_flags);
 
     if (NeedsNoRandomizeWorkaround()) {
         // Work around ARM kernel ASLR lossage (http://b/5817320).
         int old_personality = personality(0xffffffff);
         int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);
         if (new_personality == -1) {
             ALOGW("personality(%d) failed: %s", new_personality, strerror(errno));
         }
     }
 
@@ -2635,20 +2639,24 @@ static void com_android_internal_os_Zygote_nativeAllowFilesOpenedByPreload(JNIEn
     auto fail_fn = std::bind(zygote::ZygoteFailure, env, "zygote", nullptr, _1);
     std::unique_ptr<std::set<int>> current_fds = GetOpenFds(fail_fn);
     auto difference = std::make_unique<std::set<int>>();
     std::set_difference(current_fds->begin(), current_fds->end(), gPreloadFds->begin(),
                         gPreloadFds->end(), std::inserter(*difference, difference->end()));
     delete gPreloadFds;
     gPreloadFds = difference.release();
     gPreloadFdsExtracted = true;
 }
 
+static void nativeHandleRuntimeFlagsWrapper(JNIEnv* env, jclass, jint runtime_flags) {
+    HandleRuntimeFlags(env, runtime_flags);
+}
+
 static const JNINativeMethod gMethods[] = {
         {"nativeForkAndSpecialize",
          "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/"
          "String;Z[Ljava/lang/String;[Ljava/lang/String;ZZ)I",
          (void*)com_android_internal_os_Zygote_nativeForkAndSpecialize},
         {"nativeForkSystemServer", "(II[II[[IJJ)I",
          (void*)com_android_internal_os_Zygote_nativeForkSystemServer},
         {"nativeAllowFileAcrossFork", "(Ljava/lang/String;)V",
          (void*)com_android_internal_os_Zygote_nativeAllowFileAcrossFork},
         {"nativePreApplicationInit", "()V",
@@ -2687,20 +2695,21 @@ static const JNINativeMethod gMethods[] = {
         {"nativeSupportsMemoryTagging", "()Z",
          (void*)com_android_internal_os_Zygote_nativeSupportsMemoryTagging},
         {"nativeSupportsTaggedPointers", "()Z",
          (void*)com_android_internal_os_Zygote_nativeSupportsTaggedPointers},
         {"nativeCurrentTaggingLevel", "()I",
          (void*)com_android_internal_os_Zygote_nativeCurrentTaggingLevel},
         {"nativeMarkOpenedFilesBeforePreload", "()V",
          (void*)com_android_internal_os_Zygote_nativeMarkOpenedFilesBeforePreload},
         {"nativeAllowFilesOpenedByPreload", "()V",
          (void*)com_android_internal_os_Zygote_nativeAllowFilesOpenedByPreload},
+        {"nativeHandleRuntimeFlags", "(I)V", (void*)nativeHandleRuntimeFlagsWrapper},
 };
 
 int register_com_android_internal_os_Zygote(JNIEnv* env) {
   gZygoteClass = MakeGlobalRefOrDie(env, FindClassOrDie(env, kZygoteClassName));
   gCallPostForkSystemServerHooks = GetStaticMethodIDOrDie(env, gZygoteClass,
                                                           "callPostForkSystemServerHooks",
                                                           "(I)V");
   gCallPostForkChildHooks = GetStaticMethodIDOrDie(env, gZygoteClass, "callPostForkChildHooks",
                                                    "(IZZLjava/lang/String;)V");
 

commit e1232193344c9e198a8d9050287ee0a47d29ac8b
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2017-01-15 18:18:09-0500

    add option to scramble PIN
    
    Originally adapted from work by Adnan <adnan@cyngn.com> for CyanogenMod
    but it has substantially diverged from the original code.
    
    Change-Id: I416895210128cc0fc174201c29dc1e4dc9d14eb6
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 core/java/android/provider/Settings.java           |  7 +++++
 .../src/com/android/keyguard/KeyguardPINView.java  | 29 +++++++++++++++++++++
 .../src/com/android/keyguard/NumPadKey.java        | 30 +++++++++++++++-------
 3 files changed, 57 insertions(+), 9 deletions(-)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 0247c54e42c025e4bebbb473b03b62430d78103e..38b2db67b0fb809a9c385ca56a4c8584402d073d 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -4186,20 +4186,27 @@ public final class Settings {
 
         /**
          * @deprecated Use
          * {@link android.provider.Settings.Secure#LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED}
          * instead
          */
         @Deprecated
         public static final String LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED =
             "lock_pattern_tactile_feedback_enabled";
 
+        /**
+         * Whether to scramble a pin unlock layout
+         * @hide
+         */
+        public static final String SCRAMBLE_PIN_LAYOUT =
+            "lockscreen_scramble_pin_layout";
+
         /**
          * A formatted string of the next alarm that is set, or the empty string
          * if there is no alarm set.
          *
          * @deprecated Use {@link android.app.AlarmManager#getNextAlarmClock()}.
          */
         @Deprecated
         @Readable
         public static final String NEXT_ALARM_FORMATTED = "next_alarm_formatted";
 
diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java b/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
index 8fc4240e1054dcba2d0166b945e46a1b466d3b50..65f8de8a6825a1c69cddb4889bc01fb08d63ac65 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
@@ -11,26 +11,32 @@
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.android.keyguard;
 
 import android.content.Context;
 import android.content.res.Configuration;
+import android.provider.Settings;
 import android.util.AttributeSet;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.animation.AnimationUtils;
 import android.widget.LinearLayout;
 
+import java.security.SecureRandom;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
 import com.android.internal.jank.InteractionJankMonitor;
 import com.android.settingslib.animation.AppearAnimationUtils;
 import com.android.settingslib.animation.DisappearAnimationUtils;
 import com.android.systemui.R;
 
 import java.util.List;
 
 /**
  * Displays a PIN pad for unlocking.
  */
@@ -133,20 +139,43 @@ public class KeyguardPINView extends KeyguardPinBasedInputView {
                         findViewById(R.id.key7), findViewById(R.id.key8),
                         findViewById(R.id.key9)
                 },
                 new View[]{
                         findViewById(R.id.delete_button), findViewById(R.id.key0),
                         findViewById(R.id.key_enter)
                 },
                 new View[]{
                         null, mEcaView, null
                 }};
+
+        boolean scramblePin = Settings.System.getInt(getContext().getContentResolver(),
+                Settings.System.SCRAMBLE_PIN_LAYOUT, 0) == 1;
+
+        if (scramblePin) {
+            List<Integer> digits = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0);
+            Collections.shuffle(digits, new SecureRandom());
+            LinearLayout container = (LinearLayout) findViewById(R.id.pin_container);
+            int finished = 0;
+            for (int i = 0; i < container.getChildCount(); i++) {
+                if (container.getChildAt(i) instanceof LinearLayout) {
+                    LinearLayout nestedLayout = ((LinearLayout) container.getChildAt(i));
+                    for (int j = 0; j < nestedLayout.getChildCount(); j++){
+                        View view = nestedLayout.getChildAt(j);
+                        if (view.getClass() == NumPadKey.class) {
+                            NumPadKey key = (NumPadKey) view;
+                            key.setDigit(digits.get(finished));
+                            finished++;
+                        }
+                    }
+                }
+            }
+        }
     }
 
     @Override
     public int getWrongPasswordStringId() {
         return R.string.kg_wrong_pin;
     }
 
     @Override
     public void startAppearAnimation() {
         enableClipping(false);
diff --git a/packages/SystemUI/src/com/android/keyguard/NumPadKey.java b/packages/SystemUI/src/com/android/keyguard/NumPadKey.java
index 232c6fc9906818a2b7aba07075bc999a1d839cf1..07715f8ad9c25bc735f6a42564aa4ac947410c44 100644
--- a/packages/SystemUI/src/com/android/keyguard/NumPadKey.java
+++ b/packages/SystemUI/src/com/android/keyguard/NumPadKey.java
@@ -15,20 +15,21 @@
  */
 package com.android.keyguard;
 
 import android.content.Context;
 import android.content.res.Configuration;
 import android.content.res.TypedArray;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.RippleDrawable;
 import android.os.PowerManager;
 import android.os.SystemClock;
+import android.provider.Settings;
 import android.util.AttributeSet;
 import android.view.HapticFeedbackConstants;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.accessibility.AccessibilityManager;
 import android.widget.TextView;
 
 import androidx.annotation.Nullable;
@@ -107,44 +108,55 @@ public class NumPadKey extends ViewGroup {
         mLockPatternUtils = new LockPatternUtils(context);
         mPM = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
         LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(
                 Context.LAYOUT_INFLATER_SERVICE);
         inflater.inflate(contentResource, this, true);
 
         mDigitText = (TextView) findViewById(R.id.digit_text);
         mDigitText.setText(Integer.toString(mDigit));
         mKlondikeText = (TextView) findViewById(R.id.klondike_text);
 
+        updateText();
+
+        Drawable background = getBackground();
+        if (background instanceof RippleDrawable) {
+            mAnimator = new NumPadAnimator(context, (RippleDrawable) background,
+                    R.style.NumPadKey);
+        } else {
+            mAnimator = null;
+        }
+    }
+
+    private void updateText() {
+        boolean scramblePin = Settings.System.getInt(getContext().getContentResolver(),
+                Settings.System.SCRAMBLE_PIN_LAYOUT, 0) == 1;
         if (mDigit >= 0) {
+            mDigitText.setText(Integer.toString(mDigit));
             if (sKlondike == null) {
                 sKlondike = getResources().getStringArray(R.array.lockscreen_num_pad_klondike);
             }
             if (sKlondike != null && sKlondike.length > mDigit) {
                 String klondike = sKlondike[mDigit];
                 final int len = klondike.length();
-                if (len > 0) {
+                if (len > 0 || scramblePin) {
                     mKlondikeText.setText(klondike);
                 } else if (mKlondikeText.getVisibility() != View.GONE) {
                     mKlondikeText.setVisibility(View.INVISIBLE);
                 }
             }
         }
-
         setContentDescription(mDigitText.getText().toString());
+    }
 
-        Drawable background = getBackground();
-        if (background instanceof RippleDrawable) {
-            mAnimator = new NumPadAnimator(context, (RippleDrawable) background,
-                    R.style.NumPadKey);
-        } else {
-            mAnimator = null;
-        }
+    public void setDigit(int digit) {
+        mDigit = digit;
+        updateText();
     }
 
     @Override
     protected void onConfigurationChanged(Configuration newConfig) {
         mOrientation = newConfig.orientation;
     }
 
     /**
      * Reload colors from resources.
      **/

commit 7606b43a94614adea7b3a7ebcb82a69cdb664ccd
Author: Renlord <me@renlord.com>
Date:   Tue 2020-03-03 22:55:39+1100

    use per-user settings secure table for lockscreen pin scrambling layout option
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
    Change-Id: I484405a4f2f30d23f4143597cb944e515ce6eb43
---
 core/java/android/provider/Settings.java                   | 14 +++++++-------
 .../SystemUI/src/com/android/keyguard/KeyguardPINView.java |  6 ++++--
 packages/SystemUI/src/com/android/keyguard/NumPadKey.java  |  5 +++--
 3 files changed, 14 insertions(+), 11 deletions(-)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 38b2db67b0fb809a9c385ca56a4c8584402d073d..048b6e937495846238b3eae803e13e8d26f8c8a2 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -4186,27 +4186,20 @@ public final class Settings {
 
         /**
          * @deprecated Use
          * {@link android.provider.Settings.Secure#LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED}
          * instead
          */
         @Deprecated
         public static final String LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED =
             "lock_pattern_tactile_feedback_enabled";
 
-        /**
-         * Whether to scramble a pin unlock layout
-         * @hide
-         */
-        public static final String SCRAMBLE_PIN_LAYOUT =
-            "lockscreen_scramble_pin_layout";
-
         /**
          * A formatted string of the next alarm that is set, or the empty string
          * if there is no alarm set.
          *
          * @deprecated Use {@link android.app.AlarmManager#getNextAlarmClock()}.
          */
         @Deprecated
         @Readable
         public static final String NEXT_ALARM_FORMATTED = "next_alarm_formatted";
 
@@ -9902,20 +9895,27 @@ public final class Settings {
         @Readable
         public static final String TAP_GESTURE = "tap_gesture";
 
         /**
          * Controls whether the people strip is enabled.
          * @hide
          */
         @Readable
         public static final String PEOPLE_STRIP = "people_strip";
 
+        /**
+         * Whether to scramble a pin unlock layout
+         * @hide
+         */
+        public static final String SCRAMBLE_PIN_LAYOUT =
+            "lockscreen_scramble_pin_layout";
+
         /**
          * Whether or not to enable media resumption
          * When enabled, media controls in quick settings will populate on boot and persist if
          * resumable via a MediaBrowserService.
          * @see Settings.Global#SHOW_MEDIA_ON_QUICK_SETTINGS
          * @hide
          */
         @Readable
         public static final String MEDIA_CONTROLS_RESUME = "qs_media_resumption";
 
diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java b/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
index 65f8de8a6825a1c69cddb4889bc01fb08d63ac65..fdc44584e4a11daef58f4b0f8291b61c21de52e1 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
@@ -30,20 +30,22 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 import com.android.internal.jank.InteractionJankMonitor;
 import com.android.settingslib.animation.AppearAnimationUtils;
 import com.android.settingslib.animation.DisappearAnimationUtils;
 import com.android.systemui.R;
 
 import java.util.List;
 
+import android.app.ActivityManager;
+
 /**
  * Displays a PIN pad for unlocking.
  */
 public class KeyguardPINView extends KeyguardPinBasedInputView {
 
     private final AppearAnimationUtils mAppearAnimationUtils;
     private final DisappearAnimationUtils mDisappearAnimationUtils;
     private final DisappearAnimationUtils mDisappearAnimationUtilsLocked;
     private ViewGroup mContainer;
     private ViewGroup mRow0;
@@ -140,22 +142,22 @@ public class KeyguardPINView extends KeyguardPinBasedInputView {
                         findViewById(R.id.key9)
                 },
                 new View[]{
                         findViewById(R.id.delete_button), findViewById(R.id.key0),
                         findViewById(R.id.key_enter)
                 },
                 new View[]{
                         null, mEcaView, null
                 }};
 
-        boolean scramblePin = Settings.System.getInt(getContext().getContentResolver(),
-                Settings.System.SCRAMBLE_PIN_LAYOUT, 0) == 1;
+        boolean scramblePin = Settings.Secure.getIntForUser(mContext.getContentResolver(),
+                Settings.Secure.SCRAMBLE_PIN_LAYOUT, 0, ActivityManager.getCurrentUser()) == 1;
 
         if (scramblePin) {
             List<Integer> digits = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0);
             Collections.shuffle(digits, new SecureRandom());
             LinearLayout container = (LinearLayout) findViewById(R.id.pin_container);
             int finished = 0;
             for (int i = 0; i < container.getChildCount(); i++) {
                 if (container.getChildAt(i) instanceof LinearLayout) {
                     LinearLayout nestedLayout = ((LinearLayout) container.getChildAt(i));
                     for (int j = 0; j < nestedLayout.getChildCount(); j++){
diff --git a/packages/SystemUI/src/com/android/keyguard/NumPadKey.java b/packages/SystemUI/src/com/android/keyguard/NumPadKey.java
index 07715f8ad9c25bc735f6a42564aa4ac947410c44..c388b4de30ca87bfbd1e4a5a195d8c81baaa5291 100644
--- a/packages/SystemUI/src/com/android/keyguard/NumPadKey.java
+++ b/packages/SystemUI/src/com/android/keyguard/NumPadKey.java
@@ -8,20 +8,21 @@
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.android.keyguard;
 
+import android.app.ActivityManager;
 import android.content.Context;
 import android.content.res.Configuration;
 import android.content.res.TypedArray;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.RippleDrawable;
 import android.os.PowerManager;
 import android.os.SystemClock;
 import android.provider.Settings;
 import android.util.AttributeSet;
 import android.view.HapticFeedbackConstants;
@@ -120,22 +121,22 @@ public class NumPadKey extends ViewGroup {
         Drawable background = getBackground();
         if (background instanceof RippleDrawable) {
             mAnimator = new NumPadAnimator(context, (RippleDrawable) background,
                     R.style.NumPadKey);
         } else {
             mAnimator = null;
         }
     }
 
     private void updateText() {
-        boolean scramblePin = Settings.System.getInt(getContext().getContentResolver(),
-                Settings.System.SCRAMBLE_PIN_LAYOUT, 0) == 1;
+        boolean scramblePin = Settings.Secure. getIntForUser(mContext.getContentResolver(),
+                Settings.Secure.SCRAMBLE_PIN_LAYOUT, 0, ActivityManager.getCurrentUser()) == 1;
         if (mDigit >= 0) {
             mDigitText.setText(Integer.toString(mDigit));
             if (sKlondike == null) {
                 sKlondike = getResources().getStringArray(R.array.lockscreen_num_pad_klondike);
             }
             if (sKlondike != null && sKlondike.length > mDigit) {
                 String klondike = sKlondike[mDigit];
                 final int len = klondike.length();
                 if (len > 0 || scramblePin) {
                     mKlondikeText.setText(klondike);

commit 099be049bd50cf324a2bde4d5567dc518d4b689e
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2021-10-16 19:44:59-0400

    constify JNINativeMethod tables
---
 cmds/hid/jni/com_android_commands_hid_Device.cpp           | 2 +-
 cmds/uinput/jni/com_android_commands_uinput_Device.cpp     | 2 +-
 core/jni/android_app_ActivityThread.cpp                    | 2 +-
 core/jni/android_os_HidlMemory.cpp                         | 2 +-
 core/jni/android_os_HwBinder.cpp                           | 2 +-
 core/jni/android_os_HwBlob.cpp                             | 2 +-
 core/jni/android_os_HwParcel.cpp                           | 2 +-
 core/jni/android_os_HwRemoteBinder.cpp                     | 2 +-
 libs/hwui/jni/android_graphics_DisplayListCanvas.cpp       | 2 +-
 media/jni/android_media_ImageWriter.cpp                    | 4 ++--
 media/jni/android_media_MediaSync.cpp                      | 2 +-
 media/jni/soundpool/android_media_SoundPool.cpp            | 2 +-
 services/core/jni/com_android_server_UsbMidiDevice.cpp     | 2 +-
 services/core/jni/com_android_server_tv_TvUinputBridge.cpp | 2 +-
 14 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/cmds/hid/jni/com_android_commands_hid_Device.cpp b/cmds/hid/jni/com_android_commands_hid_Device.cpp
index 2cda57dd67e9875c03ae5de7be3412a3363592a6..7613651e75c43a2650d4d45974e17e15b288c04a 100644
--- a/cmds/hid/jni/com_android_commands_hid_Device.cpp
+++ b/cmds/hid/jni/com_android_commands_hid_Device.cpp
@@ -347,21 +347,21 @@ static void sendGetFeatureReportReply(JNIEnv* env, jclass /* clazz */, jlong ptr
     }
 }
 
 static void closeDevice(JNIEnv* /* env */, jclass /* clazz */, jlong ptr) {
     uhid::Device* d = reinterpret_cast<uhid::Device*>(ptr);
     if (d) {
         delete d;
     }
 }
 
-static JNINativeMethod sMethods[] = {
+static const JNINativeMethod sMethods[] = {
         {"nativeOpenDevice",
          "(Ljava/lang/String;IIII[B"
          "Lcom/android/commands/hid/Device$DeviceCallback;)J",
          reinterpret_cast<void*>(openDevice)},
         {"nativeSendReport", "(J[B)V", reinterpret_cast<void*>(sendReport)},
         {"nativeSendGetFeatureReportReply", "(JI[B)V",
          reinterpret_cast<void*>(sendGetFeatureReportReply)},
         {"nativeCloseDevice", "(J)V", reinterpret_cast<void*>(closeDevice)},
 };
 
diff --git a/cmds/uinput/jni/com_android_commands_uinput_Device.cpp b/cmds/uinput/jni/com_android_commands_uinput_Device.cpp
index 06fa2aac2c7e551faad40d341bf0dbf5465fb957..4c20055020a4e1cd8a260c958b6fb285b92e2ece 100644
--- a/cmds/uinput/jni/com_android_commands_uinput_Device.cpp
+++ b/cmds/uinput/jni/com_android_commands_uinput_Device.cpp
@@ -294,21 +294,21 @@ static void setAbsInfo(JNIEnv* env, jclass /* clazz */, jint handle, jint axisCo
     absSetup.absinfo.maximum = info.maximum;
     absSetup.absinfo.minimum = info.minimum;
     absSetup.absinfo.value = info.value;
     absSetup.absinfo.fuzz = info.fuzz;
     absSetup.absinfo.flat = info.flat;
     absSetup.absinfo.resolution = info.resolution;
 
     ::ioctl(static_cast<int>(handle), UI_ABS_SETUP, &absSetup);
 }
 
-static JNINativeMethod sMethods[] = {
+static const JNINativeMethod sMethods[] = {
         {"nativeOpenUinputDevice",
          "(Ljava/lang/String;IIIII"
          "Lcom/android/commands/uinput/Device$DeviceCallback;)J",
          reinterpret_cast<void*>(openUinputDevice)},
         {"nativeInjectEvent", "(JIII)V", reinterpret_cast<void*>(injectEvent)},
         {"nativeConfigure", "(II[I)V", reinterpret_cast<void*>(configure)},
         {"nativeSetAbsInfo", "(IILandroid/os/Parcel;)V", reinterpret_cast<void*>(setAbsInfo)},
         {"nativeCloseUinputDevice", "(J)V", reinterpret_cast<void*>(closeUinputDevice)},
 };
 
diff --git a/core/jni/android_app_ActivityThread.cpp b/core/jni/android_app_ActivityThread.cpp
index e9d9a20c7538fabbd748d8b6768b8031da864b3d..cd285238d6e2e1e0d38d7196050745c21ff5e792 100644
--- a/core/jni/android_app_ActivityThread.cpp
+++ b/core/jni/android_app_ActivityThread.cpp
@@ -33,21 +33,21 @@ static void android_app_ActivityThread_purgePendingResources(JNIEnv* env, jobjec
 static void
 android_app_ActivityThread_dumpGraphics(JNIEnv* env, jobject clazz, jobject javaFileDescriptor) {
     int fd = jniGetFDFromFileDescriptor(env, javaFileDescriptor);
     ARenderThread_dumpGraphicsMemory(fd);
 }
 
 static void android_app_ActivityThread_initZygoteChildHeapProfiling(JNIEnv* env, jobject clazz) {
     android_mallopt(M_INIT_ZYGOTE_CHILD_PROFILING, nullptr, 0);
 }
 
-static JNINativeMethod gActivityThreadMethods[] = {
+static const JNINativeMethod gActivityThreadMethods[] = {
     // ------------ Regular JNI ------------------
     { "nPurgePendingResources",        "()V",
       (void*) android_app_ActivityThread_purgePendingResources },
     { "nDumpGraphicsInfo",        "(Ljava/io/FileDescriptor;)V",
       (void*) android_app_ActivityThread_dumpGraphics },
     { "nInitZygoteChildHeapProfiling",        "()V",
       (void*) android_app_ActivityThread_initZygoteChildHeapProfiling }
 };
 
 int register_android_app_ActivityThread(JNIEnv* env) {
diff --git a/core/jni/android_os_HidlMemory.cpp b/core/jni/android_os_HidlMemory.cpp
index 69e48184c0ad3a4fe144383d799d2d406ab3ea11..612fc95776a568bb65ba6b2170a05d8086ad2733 100644
--- a/core/jni/android_os_HidlMemory.cpp
+++ b/core/jni/android_os_HidlMemory.cpp
@@ -43,21 +43,21 @@ std::string stringFromJava(JNIEnv* env, jstring jstr) {
 jstring stringToJava(JNIEnv* env, const std::string& cstr) {
     return env->NewStringUTF(cstr.c_str());
 }
 
 static void nativeFinalize(JNIEnv* env, jobject jobj) {
     jlong jNativeContext = env->GetLongField(jobj, gFields.nativeContext);
     JHidlMemory* native = reinterpret_cast<JHidlMemory*>(jNativeContext);
     delete native;
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
         {"nativeFinalize", "()V", (void*) nativeFinalize},
 };
 
 }  // namespace
 
 JHidlMemory::~JHidlMemory() {
     if (mObj) {
         // Must manually delete the underlying handle - hidl_memory doesn't own
         // it.
         native_handle_delete(const_cast<native_handle_t*>(mObj->handle()));
diff --git a/core/jni/android_os_HwBinder.cpp b/core/jni/android_os_HwBinder.cpp
index 781895eeeabaf021e0a966538b78cfec27a1c38d..cbec79144826648e67804fd58e693b784c0b4ad1 100644
--- a/core/jni/android_os_HwBinder.cpp
+++ b/core/jni/android_os_HwBinder.cpp
@@ -345,21 +345,21 @@ void JHwBinder_native_configureRpcThreadpool(JNIEnv *, jclass,
 
 void JHwBinder_native_joinRpcThreadpool() {
     IPCThreadState::self()->joinThreadPool();
 }
 
 static void JHwBinder_report_sysprop_change(JNIEnv * /*env*/, jclass /*clazz*/)
 {
     report_sysprop_change();
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     { "native_init", "()J", (void *)JHwBinder_native_init },
     { "native_setup", "()V", (void *)JHwBinder_native_setup },
 
     { "transact",
         "(IL" PACKAGE_PATH "/HwParcel;L" PACKAGE_PATH "/HwParcel;I)V",
         (void *)JHwBinder_native_transact },
 
     { "registerService", "(Ljava/lang/String;)V",
         (void *)JHwBinder_native_registerService },
 
diff --git a/core/jni/android_os_HwBlob.cpp b/core/jni/android_os_HwBlob.cpp
index a9db91be1d5b04c352018abf83209199243ec576..ba4cf610144931c787a73932f0cf0be1fc681018 100644
--- a/core/jni/android_os_HwBlob.cpp
+++ b/core/jni/android_os_HwBlob.cpp
@@ -592,21 +592,21 @@ static jlong JHwBlob_native_handle(JNIEnv *env, jobject thiz) {
     status_t err = JHwBlob::GetNativeContext(env, thiz)->getHandle(&handle);
 
     if (err != OK) {
         signalExceptionForError(env, err);
         return 0;
     }
 
     return handle;
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     { "native_init", "()J", (void *)JHwBlob_native_init },
     { "native_setup", "(I)V", (void *)JHwBlob_native_setup },
 
     { "getBool", "(J)Z", (void *)JHwBlob_native_getBool },
     { "getInt8", "(J)B", (void *)JHwBlob_native_getInt8 },
     { "getInt16", "(J)S", (void *)JHwBlob_native_getInt16 },
     { "getInt32", "(J)I", (void *)JHwBlob_native_getInt32 },
     { "getInt64", "(J)J", (void *)JHwBlob_native_getInt64 },
     { "getFloat", "(J)F", (void *)JHwBlob_native_getFloat },
     { "getDouble", "(J)D", (void *)JHwBlob_native_getDouble },
diff --git a/core/jni/android_os_HwParcel.cpp b/core/jni/android_os_HwParcel.cpp
index 4c4443fc29c3d0bca0b378d006f17e4d9faa821e..78fd6d90691ba812af0803f023afab97534b0bf9 100644
--- a/core/jni/android_os_HwParcel.cpp
+++ b/core/jni/android_os_HwParcel.cpp
@@ -1061,21 +1061,21 @@ static void JHwParcel_native_writeBuffer(
         JHwParcel::GetNativeContext(env, thiz)->getParcel();
 
     sp<JHwBlob> blob = JHwBlob::GetNativeContext(env, blobObj);
     status_t err = blob->writeToParcel(parcel);
 
     if (err != OK) {
         signalExceptionForError(env, err);
     }
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     { "native_init", "()J", (void *)JHwParcel_native_init },
     { "native_setup", "(Z)V", (void *)JHwParcel_native_setup },
 
     { "writeInterfaceToken", "(Ljava/lang/String;)V",
         (void *)JHwParcel_native_writeInterfaceToken },
 
     { "writeBool", "(Z)V", (void *)JHwParcel_native_writeBool },
     { "writeInt8", "(B)V", (void *)JHwParcel_native_writeInt8 },
     { "writeInt16", "(S)V", (void *)JHwParcel_native_writeInt16 },
     { "writeInt32", "(I)V", (void *)JHwParcel_native_writeInt32 },
diff --git a/core/jni/android_os_HwRemoteBinder.cpp b/core/jni/android_os_HwRemoteBinder.cpp
index 3af55fe810fc6025dea93082f277053d403ed71b..feabd6a60fbfc1908f1420060f665f282d509237 100644
--- a/core/jni/android_os_HwRemoteBinder.cpp
+++ b/core/jni/android_os_HwRemoteBinder.cpp
@@ -435,21 +435,21 @@ static jboolean JHwRemoteBinder_equals(JNIEnv* env, jobject thiz, jobject other)
 
     return hardware::interfacesEqual(toIBase(env, clazz.get(), thiz), toIBase(env, clazz.get(), other));
 }
 
 static jint JHwRemoteBinder_hashCode(JNIEnv* env, jobject thiz) {
     jlong longHash = reinterpret_cast<jlong>(
             JHwRemoteBinder::GetNativeContext(env, thiz)->getBinder().get());
     return static_cast<jint>(longHash ^ (longHash >> 32)); // See Long.hashCode()
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     { "native_init", "()J", (void *)JHwRemoteBinder_native_init },
 
     { "native_setup_empty", "()V",
         (void *)JHwRemoteBinder_native_setup_empty },
 
     { "transact",
         "(IL" PACKAGE_PATH "/HwParcel;L" PACKAGE_PATH "/HwParcel;I)V",
         (void *)JHwRemoteBinder_native_transact },
 
     {"linkToDeath",
diff --git a/libs/hwui/jni/android_graphics_DisplayListCanvas.cpp b/libs/hwui/jni/android_graphics_DisplayListCanvas.cpp
index f060bb32031aa512580737f5c13d4e54d9d4f481..3ebb3553ce209281b0f6739ca2a108630d09d1e8 100644
--- a/libs/hwui/jni/android_graphics_DisplayListCanvas.cpp
+++ b/libs/hwui/jni/android_graphics_DisplayListCanvas.cpp
@@ -167,21 +167,21 @@ static void android_view_DisplayListCanvas_drawWebViewFunctor(CRITICAL_JNI_PARAM
     Canvas* canvas = reinterpret_cast<Canvas*>(canvasPtr);
     canvas->drawWebViewFunctor(functor);
 }
 
 // ----------------------------------------------------------------------------
 // JNI Glue
 // ----------------------------------------------------------------------------
 
 const char* const kClassPathName = "android/graphics/RecordingCanvas";
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
         // ------------ @CriticalNative --------------
         {"nCreateDisplayListCanvas", "(JII)J",
          (void*)android_view_DisplayListCanvas_createDisplayListCanvas},
         {"nResetDisplayListCanvas", "(JJII)V",
          (void*)android_view_DisplayListCanvas_resetDisplayListCanvas},
         {"nGetMaximumTextureWidth", "()I", (void*)android_view_DisplayListCanvas_getMaxTextureSize},
         {"nGetMaximumTextureHeight", "()I",
          (void*)android_view_DisplayListCanvas_getMaxTextureSize},
         {"nEnableZ", "(JZ)V", (void*)android_view_DisplayListCanvas_enableZ},
         {"nFinishRecording", "(JJ)V", (void*)android_view_DisplayListCanvas_finishRecording},
diff --git a/media/jni/android_media_ImageWriter.cpp b/media/jni/android_media_ImageWriter.cpp
index b291ac95bf4f56b458cb425380937c0b1b024c41..1ee25c4f6421cd7ce413d44a7bd4711047948487 100644
--- a/media/jni/android_media_ImageWriter.cpp
+++ b/media/jni/android_media_ImageWriter.cpp
@@ -1054,35 +1054,35 @@ static jobjectArray Image_createSurfacePlanes(JNIEnv* env, jobject thiz,
         env->SetObjectArrayElement(surfacePlanes, i, surfacePlane);
     }
 
     return surfacePlanes;
 }
 
 } // extern "C"
 
 // ----------------------------------------------------------------------------
 
-static JNINativeMethod gImageWriterMethods[] = {
+static const JNINativeMethod gImageWriterMethods[] = {
     {"nativeClassInit",         "()V",                        (void*)ImageWriter_classInit },
     {"nativeInit",              "(Ljava/lang/Object;Landroid/view/Surface;IIII)J",
                                                               (void*)ImageWriter_init },
     {"nativeClose",              "(J)V",                      (void*)ImageWriter_close },
     {"nativeAttachAndQueueImage", "(JJIJIIIIII)I",          (void*)ImageWriter_attachAndQueueImage },
     {"nativeAttachAndQueueGraphicBuffer",
         "(JLandroid/graphics/GraphicBuffer;IJIIIIII)I",
         (void*)ImageWriter_attachAndQueueGraphicBuffer },
     {"nativeDequeueInputImage", "(JLandroid/media/Image;)V",  (void*)ImageWriter_dequeueImage },
     {"nativeQueueInputImage",   "(JLandroid/media/Image;JIIIIII)V",  (void*)ImageWriter_queueImage },
     {"cancelImage",             "(JLandroid/media/Image;)V",   (void*)ImageWriter_cancelImage },
 };
 
-static JNINativeMethod gImageMethods[] = {
+static const JNINativeMethod gImageMethods[] = {
     {"nativeCreatePlanes",      "(II)[Landroid/media/ImageWriter$WriterSurfaceImage$SurfacePlane;",
                                                                (void*)Image_createSurfacePlanes },
     {"nativeGetWidth",          "()I",                         (void*)Image_getWidth },
     {"nativeGetHeight",         "()I",                         (void*)Image_getHeight },
     {"nativeGetFormat",         "()I",                         (void*)Image_getFormat },
     {"nativeGetHardwareBuffer", "()Landroid/hardware/HardwareBuffer;",
                                                                (void*)Image_getHardwareBuffer },
 };
 
 int register_android_media_ImageWriter(JNIEnv *env) {
diff --git a/media/jni/android_media_MediaSync.cpp b/media/jni/android_media_MediaSync.cpp
index d1ce30a3e8278b5935ad23f0ccc793aa102bc40a..d93bda166c441263766911d31058e3b5019d93b5 100644
--- a/media/jni/android_media_MediaSync.cpp
+++ b/media/jni/android_media_MediaSync.cpp
@@ -507,21 +507,21 @@ static void android_media_MediaSync_native_init(JNIEnv *env) {
 static void android_media_MediaSync_native_setup(JNIEnv *env, jobject thiz) {
     sp<JMediaSync> sync = new JMediaSync();
 
     setMediaSync(env, thiz, sync);
 }
 
 static void android_media_MediaSync_native_finalize(JNIEnv *env, jobject thiz) {
     android_media_MediaSync_release(env, thiz);
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     { "native_setSurface",
       "(Landroid/view/Surface;)V",
       (void *)android_media_MediaSync_native_setSurface },
 
     { "native_setAudioTrack",
       "(Landroid/media/AudioTrack;)V",
       (void *)android_media_MediaSync_native_setAudioTrack },
 
     { "createInputSurface", "()Landroid/view/Surface;",
       (void *)android_media_MediaSync_createInputSurface },
diff --git a/media/jni/soundpool/android_media_SoundPool.cpp b/media/jni/soundpool/android_media_SoundPool.cpp
index a66d99fbd9f44ab94b8c1e65fa8a073bff3c267a..1665421aacd44672bc3ce3c636b21b3a9d7f0a6d 100644
--- a/media/jni/soundpool/android_media_SoundPool.cpp
+++ b/media/jni/soundpool/android_media_SoundPool.cpp
@@ -240,21 +240,21 @@ android_media_SoundPool_release(JNIEnv *env, jobject thiz)
 
         // clear native context
         env->SetLongField(thiz, fields.mNativeContext, 0);
         delete ap;
     }
 }
 
 // ----------------------------------------------------------------------------
 
 // Dalvik VM type signatures
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     {   "_load",
         "(Ljava/io/FileDescriptor;JJI)I",
         (void *)android_media_SoundPool_load_FD
     },
     {   "unload",
         "(I)Z",
         (void *)android_media_SoundPool_unload
     },
     {   "_play",
         "(IFFIIF)I",
diff --git a/services/core/jni/com_android_server_UsbMidiDevice.cpp b/services/core/jni/com_android_server_UsbMidiDevice.cpp
index d6b5bed173ebe59a413cbaacbfa6d97f71bbf54e..564f71daedac80d17ba8caad65ad84155981b32e 100644
--- a/services/core/jni/com_android_server_UsbMidiDevice.cpp
+++ b/services/core/jni/com_android_server_UsbMidiDevice.cpp
@@ -150,21 +150,21 @@ android_server_UsbMidiDevice_close(JNIEnv *env, jobject thiz, jobjectArray fds)
     close(pipeFD);
     env->SetIntField(thiz, sPipeFDField, -1);
 
     int count = env->GetArrayLength(fds);
     for (int i = 0; i < count; i++) {
         jobject fd = env->GetObjectArrayElement(fds, i);
         close(jniGetFDFromFileDescriptor(env, fd));
     }
 }
 
-static JNINativeMethod method_table[] = {
+static const JNINativeMethod method_table[] = {
     { "nativeGetSubdeviceCount", "(II)I", (void*)android_server_UsbMidiDevice_get_subdevice_count },
     { "nativeOpen", "(III)[Ljava/io/FileDescriptor;", (void*)android_server_UsbMidiDevice_open },
     { "nativeClose", "([Ljava/io/FileDescriptor;)V", (void*)android_server_UsbMidiDevice_close },
 };
 
 int register_android_server_UsbMidiDevice(JNIEnv *env)
 {
     jclass clazz = env->FindClass("java/io/FileDescriptor");
     if (clazz == NULL) {
         ALOGE("Can't find java/io/FileDescriptor");
diff --git a/services/core/jni/com_android_server_tv_TvUinputBridge.cpp b/services/core/jni/com_android_server_tv_TvUinputBridge.cpp
index 99deab4fd652cf45e02889a096aa66b1cf3a3a46..2cb1aaef13fa141816f90d53dea985a79ec35a5f 100644
--- a/services/core/jni/com_android_server_tv_TvUinputBridge.cpp
+++ b/services/core/jni/com_android_server_tv_TvUinputBridge.cpp
@@ -527,21 +527,21 @@ static void nativeClear(JNIEnv* env, jclass clazz, jlong ptr) {
     }
 
     // Sync pointer events
     connection->sendEvent(EV_SYN, SYN_REPORT, 0);
 }
 
 /*
  * JNI registration
  */
 
-static JNINativeMethod gUinputBridgeMethods[] = {
+static const JNINativeMethod gUinputBridgeMethods[] = {
         {"nativeOpen", "(Ljava/lang/String;Ljava/lang/String;III)J", (void*)nativeOpen},
         {"nativeGamepadOpen", "(Ljava/lang/String;Ljava/lang/String;)J", (void*)nativeGamepadOpen},
         {"nativeClose", "(J)V", (void*)nativeClose},
         {"nativeSendKey", "(JIZ)V", (void*)nativeSendKey},
         {"nativeSendPointerDown", "(JIII)V", (void*)nativeSendPointerDown},
         {"nativeSendPointerUp", "(JI)V", (void*)nativeSendPointerUp},
         {"nativeClear", "(J)V", (void*)nativeClear},
         {"nativeSendPointerSync", "(J)V", (void*)nativeSendPointerSync},
         {"nativeSendGamepadKey", "(JIZ)V", (void*)nativeSendGamepadKey},
         {"nativeSendGamepadAxisValue", "(JIF)V", (void*)nativeSendGamepadAxisValue},

commit abb0d53682a9431d252421a5bac9fd4f9f8787f2
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2021-10-16 22:32:37-0400

    disable long press on power assistant setting
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index e2edb28e13b58d1d2af1e1a6181be468ad956372..e165ee97c50c096ffb74cd5fdfcb95748644235b 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -967,21 +967,21 @@
         <item>250</item>
         <item>350</item>
         <item>500</item>
         <item>650</item>
         <item>750</item>
     </integer-array>
 
     <!-- Whether the setting to change long press on power behaviour from default to assistant (5)
          is available in Settings.
      -->
-    <bool name="config_longPressOnPowerForAssistantSettingAvailable">true</bool>
+    <bool name="config_longPressOnPowerForAssistantSettingAvailable">false</bool>
 
     <!-- Control the behavior when the user long presses the power button for a long time.
             0 - Nothing
             1 - Global actions menu
     -->
     <integer name="config_veryLongPressOnPowerBehavior">0</integer>
 
     <!-- Control the behavior when the user presses the power and volume up buttons together.
             0 - Nothing
             1 - Mute toggle

commit c34b211fef9bb60ec7b06f971cd39327e009a029
Author: Renlord <me@renlord.com>
Date:   Thu 2019-11-14 23:13:15+1100

    imprecise authenticated timestamps using https
    
    added custom trust manager to bypass certificate time validation
    
    implemented a custom eternalcertificate class that ignores certification
    time checks.
    
    Signed-off-by: Renlord <me@renlord.com>
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
    Change-Id: I2befbe7023e1f9bcb929dbd59241ae5823111427
---
 core/java/android/net/SntpClient.java      | 315 ++++++++++++++++++++++++++++-
 core/java/android/provider/Settings.java   |   4 +
 core/java/android/util/NtpTrustedTime.java |  49 ++++-
 core/res/res/values/config.xml             |   5 +
 core/res/res/values/symbols.xml            |   2 +
 5 files changed, 361 insertions(+), 14 deletions(-)

diff --git a/core/java/android/net/SntpClient.java b/core/java/android/net/SntpClient.java
index f6852e6814393efe4312ced89bc89a3969d6ca46..3eec5adfa628f3ec516d60b7b0ca2424e115a3f6 100644
--- a/core/java/android/net/SntpClient.java
+++ b/core/java/android/net/SntpClient.java
@@ -15,26 +15,54 @@
  */
 
 package android.net;
 
 import android.compat.annotation.UnsupportedAppUsage;
 import android.os.SystemClock;
 import android.util.Log;
 
 import com.android.internal.util.TrafficStatsConstants;
 
+import java.net.URL;
+import java.net.URLConnection;
 import java.net.DatagramPacket;
 import java.net.DatagramSocket;
 import java.net.InetAddress;
+import java.net.MalformedURLException;
 import java.net.UnknownHostException;
 import java.util.Arrays;
 
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.HttpsURLConnection;
+
+import java.security.cert.X509Certificate;
+
+import java.util.Date;
+import java.util.Set;
+import java.math.BigInteger;
+import java.security.KeyStore;
+import java.security.Principal;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.SignatureException;
+import java.security.NoSuchProviderException;
+import java.security.InvalidKeyException;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateExpiredException;
+import java.security.cert.CertificateNotYetValidException;
+
+import static android.os.Build.TIME;
+
 /**
  * {@hide}
  *
  * Simple SNTP client class for retrieving network time.
  *
  * Sample usage:
  * <pre>SntpClient client = new SntpClient();
  * if (client.requestTime("time.foo.com")) {
  *     long now = client.getNtpTime() + SystemClock.elapsedRealtime() - client.getNtpTimeReference();
  * }
@@ -66,20 +94,23 @@ public class SntpClient {
 
     // system time computed from NTP server response
     private long mNtpTime;
 
     // value of SystemClock.elapsedRealtime() corresponding to mNtpTime
     private long mNtpTimeReference;
 
     // round trip time in milliseconds
     private long mRoundTripTime;
 
+    // SntpClient mode (http/ntp)
+    private String mNtpMode = "ntp";
+
     private static class InvalidServerReplyException extends Exception {
         public InvalidServerReplyException(String message) {
             super(message);
         }
     }
 
     @UnsupportedAppUsage
     public SntpClient() {
     }
 
@@ -89,28 +120,38 @@ public class SntpClient {
      * @param host host name of the server.
      * @param timeout network timeout in milliseconds. the timeout doesn't include the DNS lookup
      *                time, and it applies to each individual query to the resolved addresses of
      *                the NTP server.
      * @param network network over which to send the request.
      * @return true if the transaction was successful.
      */
     public boolean requestTime(String host, int timeout, Network network) {
         final Network networkForResolv = network.getPrivateDnsBypassingCopy();
         try {
-            final InetAddress[] addresses = networkForResolv.getAllByName(host);
-            for (int i = 0; i < addresses.length; i++) {
-                if (requestTime(addresses[i], NTP_PORT, timeout, networkForResolv)) return true;
+            switch (mNtpMode) {
+                case "https":
+                    URL url = new URL(host);
+                    return requestHttpTime(url, timeout, network);
+                case "ntp":
+                    final InetAddress[] addresses = networkForResolv.getAllByName(host);
+                    for (int i = 0; i < addresses.length; i++) {
+                        if (requestTime(addresses[i], NTP_PORT, timeout, networkForResolv)) return true;
+                    }
+                default:
+                    EventLogTags.writeNtpFailure(host, "unknown protocol " + mNtpMode + " provided");
+                    if (DBG) Log.d(TAG, "request time failed, wrong protocol");
+                    return false;
             }
         } catch (UnknownHostException e) {
             Log.w(TAG, "Unknown host: " + host);
             EventLogTags.writeNtpFailure(host, e.toString());
-        }
+        } catch (MalformedURLException e) {} // exception should never be reached
 
         if (DBG) Log.d(TAG, "request time failed");
         return false;
     }
 
     public boolean requestTime(InetAddress address, int port, int timeout, Network network) {
         DatagramSocket socket = null;
         final int oldTag = TrafficStats.getAndSetThreadStatsTag(
                 TrafficStatsConstants.TAG_SYSTEM_NTP);
         try {
@@ -156,21 +197,21 @@ public class SntpClient {
             // responseTime = transmitTime + transit - skew
             // clockOffset = ((receiveTime - originateTime) + (transmitTime - responseTime))/2
             //             = ((originateTime + transit + skew - originateTime) +
             //                (transmitTime - (transmitTime + transit - skew)))/2
             //             = ((transit + skew) + (transmitTime - transmitTime - transit + skew))/2
             //             = (transit + skew - transit + skew)/2
             //             = (2 * skew)/2 = skew
             long clockOffset = ((receiveTime - originateTime) + (transmitTime - responseTime))/2;
             EventLogTags.writeNtpSuccess(address.toString(), roundTripTime, clockOffset);
             if (DBG) {
-                Log.d(TAG, "round trip: " + roundTripTime + "ms, " +
+                Log.d(TAG, "default method -- round trip: " + roundTripTime + "ms, " +
                         "clock offset: " + clockOffset + "ms");
             }
 
             // save our results - use the times on this side of the network latency
             // (response rather than request time)
             mNtpTime = responseTime + clockOffset;
             mNtpTimeReference = responseTicks;
             mRoundTripTime = roundTripTime;
         } catch (Exception e) {
             EventLogTags.writeNtpFailure(address.toString(), e.toString());
@@ -179,20 +220,276 @@ public class SntpClient {
         } finally {
             if (socket != null) {
                 socket.close();
             }
             TrafficStats.setThreadStatsTag(oldTag);
         }
 
         return true;
     }
 
+    private boolean requestHttpTime(URL url, int timeout, Network network) {
+        final int oldTag = TrafficStats.getAndSetThreadStatsTag(
+                TrafficStatsConstants.TAG_SYSTEM_NTP);
+        final Network networkForResolv = network.getPrivateDnsBypassingCopy();
+        if (DBG) Log.d(TAG, "requestHttpTime() getting time using https");
+        try {
+            TrustManagerFactory tmf = TrustManagerFactory
+                .getInstance(TrustManagerFactory.getDefaultAlgorithm());
+            tmf.init((KeyStore) null);
+
+            X509TrustManager x509Tm = null;
+            for (TrustManager tm : tmf.getTrustManagers()) {
+                if (tm instanceof X509TrustManager) {
+                    x509Tm = (X509TrustManager) tm;
+                    break;
+                }
+            }
+
+            final X509TrustManager finalTm = x509Tm;
+            X509TrustManager customTm = new X509TrustManager() {
+
+                // custom eternal certificate class that ignores expired SSL certificates
+                // adapted from https://gist.github.com/divergentdave/9a68d820e3610513bd4fcdc4ae5f91a1
+                class TimeLeewayCertificate extends X509Certificate {
+                    private final X509Certificate originalCertificate;
+
+                    public TimeLeewayCertificate(X509Certificate originalCertificate) {
+                        this.originalCertificate = originalCertificate;
+                    }
+
+                    @Override
+                    public void checkValidity() throws CertificateExpiredException, CertificateNotYetValidException {
+                        // Ignore notBefore/notAfter
+                        checkValidity(new Date());
+                    }
+
+                    @Override
+                    public void checkValidity(Date date) throws CertificateExpiredException, CertificateNotYetValidException {
+                        // expiration must be set after OS build date
+                        if (getNotAfter().compareTo(new Date(TIME)) < 0) {
+                            throw new CertificateExpiredException("Certificate expired at "
+                                    + getNotAfter().toString() + " (compared to " + date.toString() + ")");
+                        }
+                    }
+
+                    @Override
+                    public int getVersion() {
+                        return originalCertificate.getVersion();
+                    }
+
+                    @Override
+                    public BigInteger getSerialNumber() {
+                        return originalCertificate.getSerialNumber();
+                    }
+
+                    @Override
+                    public Principal getIssuerDN() {
+                        return originalCertificate.getIssuerDN();
+                    }
+
+                    @Override
+                    public Principal getSubjectDN() {
+                        return originalCertificate.getSubjectDN();
+                    }
+
+                    @Override
+                    public Date getNotBefore() {
+                        return originalCertificate.getNotBefore();
+                    }
+
+                    @Override
+                    public Date getNotAfter() {
+                        return originalCertificate.getNotAfter();
+                    }
+
+                    @Override
+                    public byte[] getTBSCertificate() throws CertificateEncodingException {
+                        return originalCertificate.getTBSCertificate();
+                    }
+
+                    @Override
+                    public byte[] getSignature() {
+                        return originalCertificate.getSignature();
+                    }
+
+                    @Override
+                    public String getSigAlgName() {
+                        return originalCertificate.getSigAlgName();
+                    }
+
+                    @Override
+                    public String getSigAlgOID() {
+                        return originalCertificate.getSigAlgOID();
+                    }
+
+                    @Override
+                    public byte[] getSigAlgParams() {
+                        return originalCertificate.getSigAlgParams();
+                    }
+
+                    @Override
+                    public boolean[] getIssuerUniqueID() {
+                        return originalCertificate.getIssuerUniqueID();
+                    }
+
+                    @Override
+                    public boolean[] getSubjectUniqueID() {
+                        return originalCertificate.getSubjectUniqueID();
+                    }
+
+                    @Override
+                    public boolean[] getKeyUsage() {
+                        return originalCertificate.getKeyUsage();
+                    }
+
+                    @Override
+                    public int getBasicConstraints() {
+                        return originalCertificate.getBasicConstraints();
+                    }
+
+                    @Override
+                    public byte[] getEncoded() throws CertificateEncodingException {
+                        return originalCertificate.getEncoded();
+                    }
+
+                    @Override
+                    public void verify(PublicKey key) throws CertificateException,
+                           NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException
+                    {
+                        originalCertificate.verify(key);
+                    }
+
+                    @Override
+                    public void verify(PublicKey key, String sigProvider) throws CertificateException,
+                           NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException
+                    {
+                        originalCertificate.verify(key, sigProvider);
+                    }
+
+                    @Override
+                    public String toString() {
+                        return originalCertificate.toString();
+                    }
+
+                    @Override
+                    public PublicKey getPublicKey() {
+                        return originalCertificate.getPublicKey();
+                    }
+
+                    @Override
+                    public Set<String> getCriticalExtensionOIDs() {
+                        return originalCertificate.getCriticalExtensionOIDs();
+                    }
+
+                    @Override
+                    public byte[] getExtensionValue(String oid) {
+                        return originalCertificate.getExtensionValue(oid);
+                    }
+
+                    @Override
+                    public Set<String> getNonCriticalExtensionOIDs() {
+                        return originalCertificate.getNonCriticalExtensionOIDs();
+                    }
+
+                    @Override
+                    public boolean hasUnsupportedCriticalExtension() {
+                        return originalCertificate.hasUnsupportedCriticalExtension();
+                    }
+                }
+
+                @Override
+                public X509Certificate[] getAcceptedIssuers() {
+                    return finalTm.getAcceptedIssuers();
+                }
+
+                @Override
+                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+                        // replace the top-level certificate with a certificate validation routine that
+                        // ignores expired certificates due to clock drift.
+                        X509Certificate[] timeLeewayChain = new X509Certificate[chain.length];
+                        for (int i = 0; i < chain.length; i++) {
+                            timeLeewayChain[i] = new TimeLeewayCertificate(chain[i]);
+                        }
+                        finalTm.checkServerTrusted(timeLeewayChain, authType);
+                }
+
+                @Override
+                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+                    // never gets used, so default to stock.
+                    finalTm.checkClientTrusted(chain, authType);
+                }
+            };
+
+            if (DBG) Log.d(TAG, "requestHttpTime() setting up URL connection");
+            URLConnection urlConnection = networkForResolv.openConnection(url);
+            SSLContext sslContext = SSLContext.getInstance("SSL");
+            sslContext.init(null, new TrustManager[] { customTm }, null);
+
+            if (urlConnection instanceof HttpsURLConnection) {
+                HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) urlConnection;
+                try {
+                    // change the SSLSocketFactory to use custom trust manager
+                    httpsUrlConnection.setSSLSocketFactory(sslContext.getSocketFactory());
+                    httpsUrlConnection.setConnectTimeout(timeout);
+                    httpsUrlConnection.setReadTimeout(timeout);
+                    httpsUrlConnection.setRequestProperty("Connection", "close");
+                    final long requestTime = System.currentTimeMillis();
+                    final long requestTicks = SystemClock.elapsedRealtime();
+                    // implicitly fires GET request.
+                    httpsUrlConnection.getInputStream();
+                    long transmitTime = urlConnection.getDate();
+                    // http servers dont log originate/receive time (imprecise offset).
+                    long receiveTime = urlConnection.getDate();
+                    final long responseTicks = SystemClock.elapsedRealtime();
+                    final long responseTime = requestTime + (responseTicks - requestTicks);
+                    long roundTripTime = responseTicks - requestTicks - (transmitTime - receiveTime);
+                    long clockOffset = ((receiveTime - requestTime) + (transmitTime - responseTime))/2;
+                    if (DBG) {
+                        Log.d(TAG, "https method -- round trip: " + roundTripTime + "ms, " +
+                                "clock offset: " + clockOffset + "ms");
+                    }
+                    if (receiveTime < TIME) {
+                        Log.w(TAG, "https method received timestamp before BUILD unix time, rejecting");
+                        return false;
+                    }
+                    EventLogTags.writeNtpSuccess(url.toString(), roundTripTime, clockOffset);
+                    // save our results - use the times on this side of the network latency
+                    // (response rather than request time)
+                    mNtpTime = responseTime + clockOffset;
+                    mNtpTimeReference = responseTicks;
+                    mRoundTripTime = roundTripTime;
+                } catch (Exception e) {
+                    Log.e(TAG, "request https time failed: " + e.toString());
+                    if (DBG) e.printStackTrace();
+                    return false;
+                } finally {
+                    httpsUrlConnection.disconnect();
+                }
+            } else {
+                EventLogTags.writeNtpFailure(url.toString(), "did not receive HttpsURLConnection from Android Network");
+                if (DBG) Log.d(TAG, "request time failed: did not receive HttpsURLConnection from Android Network");
+                return false;
+            }
+        } catch (Exception e) {
+            EventLogTags.writeNtpFailure(url.toString(), e.toString());
+            Log.e(TAG, "request time failed: " + e.toString());
+            if (DBG) {
+                e.printStackTrace();
+            }
+            return false;
+        } finally {
+            TrafficStats.setThreadStatsTag(oldTag);
+        }
+        return true;
+    }
+
     @Deprecated
     @UnsupportedAppUsage
     public boolean requestTime(String host, int timeout) {
         Log.w(TAG, "Shame on you for calling the hidden API requestTime()!");
         return false;
     }
 
     /**
      * Returns the time computed from the NTP transaction.
      *
@@ -217,20 +514,28 @@ public class SntpClient {
     /**
      * Returns the round trip time of the NTP transaction
      *
      * @return round trip time in milliseconds.
      */
     @UnsupportedAppUsage
     public long getRoundTripTime() {
         return mRoundTripTime;
     }
 
+    /**
+     * Sets the ntp mode
+     */
+    @UnsupportedAppUsage
+    public void setNtpMode(String mode) {
+        mNtpMode = mode;
+    }
+
     private static void checkValidServerReply(
             byte leap, byte mode, int stratum, long transmitTime, long referenceTime)
             throws InvalidServerReplyException {
         if (leap == NTP_LEAP_NOSYNC) {
             throw new InvalidServerReplyException("unsynchronized server");
         }
         if ((mode != NTP_MODE_SERVER) && (mode != NTP_MODE_BROADCAST)) {
             throw new InvalidServerReplyException("untrusted mode: " + mode);
         }
         if ((stratum == NTP_STRATUM_DEATH) || (stratum > NTP_STRATUM_MAX)) {
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 048b6e937495846238b3eae803e13e8d26f8c8a2..2f9796b21ca8f400f78d993bce330d27d629ed37 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -11260,20 +11260,24 @@ public final class Settings {
         */
         @Readable
         public static final String NITZ_UPDATE_SPACING = "nitz_update_spacing";
 
         /** Preferred NTP server. {@hide} */
         @Readable
         public static final String NTP_SERVER = "ntp_server";
         /** Timeout in milliseconds to wait for NTP server. {@hide} */
         @Readable
         public static final String NTP_TIMEOUT = "ntp_timeout";
+       /** Preferred HTTPS time server. {@hide} */
+       public static final String HTTPS_TIME_SERVER = "https_time_server";
+       /** Prefered method to get NTP. {@hide} */
+       public static final String NTP_MODE = "ntp_mode";
 
         /** {@hide} */
         @Readable
         public static final String STORAGE_BENCHMARK_INTERVAL = "storage_benchmark_interval";
 
         /**
          * Whether or not Settings should enable psd API.
          * {@hide}
          */
         @Readable
diff --git a/core/java/android/util/NtpTrustedTime.java b/core/java/android/util/NtpTrustedTime.java
index 4ac3178ecb4cf7e2d55ad63aea4daeeec8d7cd4b..9ebc9f4cea0b832d7f09131cae5839458362b183 100644
--- a/core/java/android/util/NtpTrustedTime.java
+++ b/core/java/android/util/NtpTrustedTime.java
@@ -102,21 +102,20 @@ public class NtpTrustedTime implements TrustedTime {
     @NonNull
     private final Context mContext;
 
     /**
      * A supplier that returns the ConnectivityManager. The Supplier can return null if
      * ConnectivityService isn't running yet.
      */
     private final Supplier<ConnectivityManager> mConnectivityManagerSupplier =
             new Supplier<ConnectivityManager>() {
         private ConnectivityManager mConnectivityManager;
-
         @Nullable
         @Override
         public synchronized ConnectivityManager get() {
             // We can't do this at initialization time: ConnectivityService might not be running
             // yet.
             if (mConnectivityManager == null) {
                 mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
             }
             return mConnectivityManager;
         }
@@ -153,23 +152,23 @@ public class NtpTrustedTime implements TrustedTime {
             if (connectivityManager == null) {
                 if (LOGD) Log.d(TAG, "forceRefresh: no ConnectivityManager");
                 return false;
             }
             final Network network = connectivityManager.getActiveNetwork();
             final NetworkInfo ni = connectivityManager.getNetworkInfo(network);
             if (ni == null || !ni.isConnected()) {
                 if (LOGD) Log.d(TAG, "forceRefresh: no connectivity");
                 return false;
             }
-
             if (LOGD) Log.d(TAG, "forceRefresh() from cache miss");
             final SntpClient client = new SntpClient();
+            client.setNtpMode(connectionInfo.getNtpMode());
             final String serverName = connectionInfo.getServer();
             final int timeoutMillis = connectionInfo.getTimeoutMillis();
             if (client.requestTime(serverName, timeoutMillis, network)) {
                 long ntpCertainty = client.getRoundTripTime() / 2;
                 mTimeResult = new TimeResult(
                         client.getNtpTime(), client.getNtpTimeReference(), ntpCertainty);
                 return true;
             } else {
                 return false;
             }
@@ -253,45 +252,77 @@ public class NtpTrustedTime implements TrustedTime {
      */
     @Nullable
     public TimeResult getCachedTimeResult() {
         return mTimeResult;
     }
 
     private static class NtpConnectionInfo {
 
         @NonNull private final String mServer;
         private final int mTimeoutMillis;
+        private final String mNtpMode;
 
         NtpConnectionInfo(@NonNull String server, int timeoutMillis) {
             mServer = Objects.requireNonNull(server);
             mTimeoutMillis = timeoutMillis;
+            mNtpMode = "ntp";
+        }
+
+        NtpConnectionInfo(@NonNull String server, int timeoutMillis, @NonNull String ntpMode) {
+            mServer = Objects.requireNonNull(server);
+            mTimeoutMillis = timeoutMillis;
+            mNtpMode = ntpMode;
         }
 
         @NonNull
         public String getServer() {
             return mServer;
         }
 
+        @NonNull
+        public String getNtpMode() {
+            return mNtpMode;
+        }
+
         int getTimeoutMillis() {
             return mTimeoutMillis;
         }
     }
 
     @GuardedBy("this")
     private NtpConnectionInfo getNtpConnectionInfo() {
         final ContentResolver resolver = mContext.getContentResolver();
 
         final Resources res = mContext.getResources();
-        final String defaultServer = res.getString(
-                com.android.internal.R.string.config_ntpServer);
-        final int defaultTimeoutMillis = res.getInteger(
-                com.android.internal.R.integer.config_ntpTimeout);
+        final String defaultNtpMode = res.getString(
+                com.android.internal.R.string.config_ntpMode);
+        final String ntpMode =
+                Settings.Global.getString(resolver, Settings.Global.NTP_MODE) != null ?
+                Settings.Global.getString(resolver, Settings.Global.NTP_MODE) :
+                defaultNtpMode;
 
-        final String secureServer = Settings.Global.getString(
-                resolver, Settings.Global.NTP_SERVER);
+        String defaultServer;
+        String secureServer;
+
+        int defaultTimeoutMillis = res.getInteger(
+                com.android.internal.R.integer.config_ntpTimeout);
         final int timeoutMillis = Settings.Global.getInt(
                 resolver, Settings.Global.NTP_TIMEOUT, defaultTimeoutMillis);
 
+        switch(ntpMode) {
+            case "https":
+                defaultServer = res.getString(
+                        com.android.internal.R.string.config_httpsTimeServer);
+                secureServer = Settings.Global.getString(
+                        resolver, Settings.Global.HTTPS_TIME_SERVER);
+                break;
+            default:
+                defaultServer = res.getString(
+                        com.android.internal.R.string.config_ntpServer);
+                secureServer = Settings.Global.getString(
+                        resolver, Settings.Global.NTP_SERVER);
+                break;
+        }
         final String server = secureServer != null ? secureServer : defaultServer;
-        return TextUtils.isEmpty(server) ? null : new NtpConnectionInfo(server, timeoutMillis);
+        return TextUtils.isEmpty(server) ? null : new NtpConnectionInfo(server, timeoutMillis, ntpMode);
     }
 }
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index e165ee97c50c096ffb74cd5fdfcb95748644235b..155b4eff86f4d87748a174f1b78aa6d2f7954503 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2208,22 +2208,27 @@
 
     <!-- Whether a software navigation bar should be shown. NOTE: in the future this may be
          autodetected from the Configuration. -->
     <bool name="config_showNavigationBar">false</bool>
 
     <!-- Whether action menu items should be displayed in ALLCAPS or not.
          Defaults to true. If this is not appropriate for specific locales
          it should be disabled in that locale's resources. -->
     <bool name="config_actionMenuItemAllCaps">true</bool>
 
+    <!-- Network derived time preferred protocol
+         Supports "ntp" or "https" only now -->
+    <string translatable="false" name="config_ntpMode">https</string>
     <!-- Remote server that can provide NTP responses. -->
     <string translatable="false" name="config_ntpServer">time.android.com</string>
+    <!-- Remote server that can provide HTTPS time responses -->
+    <string translatable="false" name="config_httpsTimeServer">https://time.grapheneos.org/generate_204</string>
     <!-- Normal polling frequency in milliseconds -->
     <integer name="config_ntpPollingInterval">86400000</integer>
     <!-- Try-again polling interval in milliseconds, in case the network request failed -->
     <integer name="config_ntpPollingIntervalShorter">60000</integer>
     <!-- Number of times to try again with the shorter interval, before backing
          off until the normal polling interval. A value < 0 indicates infinite. -->
     <integer name="config_ntpRetry">3</integer>
     <!-- Timeout to wait for NTP server response in milliseconds. -->
     <integer name="config_ntpTimeout">5000</integer>
 
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index df167a8ee71e5bf3083ea02649fe9bfb9a7ca466..f582b8a61158eb2b507220b282b44e4d8fbd397b 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -702,20 +702,22 @@
   <java-symbol type="array" name="config_companionDevicePackages" />
   <java-symbol type="array" name="config_companionDeviceCerts" />
   <java-symbol type="string" name="config_default_dns_server" />
   <java-symbol type="string" name="config_ethernet_iface_regex" />
   <java-symbol type="string" name="not_checked" />
   <java-symbol type="array" name="config_ethernet_interfaces" />
   <java-symbol type="bool" name="config_vehicleInternalNetworkAlwaysRequested" />
   <java-symbol type="string" name="config_forceVoiceInteractionServicePackage" />
   <java-symbol type="string" name="config_mms_user_agent" />
   <java-symbol type="string" name="config_mms_user_agent_profile_url" />
+  <java-symbol type="string" name="config_ntpMode" />
+  <java-symbol type="string" name="config_httpsTimeServer" />
   <java-symbol type="string" name="config_ntpServer" />
   <java-symbol type="string" name="config_useragentprofile_url" />
   <java-symbol type="string" name="config_appsNotReportingCrashes" />
   <java-symbol type="string" name="contentServiceSync" />
   <java-symbol type="string" name="contentServiceSyncNotificationTitle" />
   <java-symbol type="string" name="contentServiceTooManyDeletesNotificationDesc" />
   <java-symbol type="string" name="date_and_time" />
   <java-symbol type="string" name="date_picker_decrement_day_button" />
   <java-symbol type="string" name="date_picker_decrement_month_button" />
   <java-symbol type="string" name="date_picker_decrement_year_button" />

commit 4247de522dcc5052fcd9f1a9ad8ba5a24c38b0b0
Author: Renlord <me@renlord.com>
Date:   Tue 2020-09-29 10:58:40+1000

    reinstate toggle for disabling NITZ time updates to prefer network time updates instead
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
    Change-Id: Ia98f919e91d87af597940431c4aa83539850d540
---
 core/res/res/values/config.xml                            |  2 ++
 core/res/res/values/symbols.xml                           |  1 +
 .../com/android/server/timedetector/EnvironmentImpl.java  |  9 +++++++++
 .../server/timedetector/TimeDetectorStrategyImpl.java     | 15 ++++++++++++---
 4 files changed, 24 insertions(+), 3 deletions(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 155b4eff86f4d87748a174f1b78aa6d2f7954503..4ff333e6f27e6d4bed73836ea230899f4fc9efe9 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2219,20 +2219,22 @@
          Supports "ntp" or "https" only now -->
     <string translatable="false" name="config_ntpMode">https</string>
     <!-- Remote server that can provide NTP responses. -->
     <string translatable="false" name="config_ntpServer">time.android.com</string>
     <!-- Remote server that can provide HTTPS time responses -->
     <string translatable="false" name="config_httpsTimeServer">https://time.grapheneos.org/generate_204</string>
     <!-- Normal polling frequency in milliseconds -->
     <integer name="config_ntpPollingInterval">86400000</integer>
     <!-- Try-again polling interval in milliseconds, in case the network request failed -->
     <integer name="config_ntpPollingIntervalShorter">60000</integer>
+    <!-- Toggle to update timestamp using NITZ -->
+    <bool name="config_nitzTimeUpdate">false</bool>
     <!-- Number of times to try again with the shorter interval, before backing
          off until the normal polling interval. A value < 0 indicates infinite. -->
     <integer name="config_ntpRetry">3</integer>
     <!-- Timeout to wait for NTP server response in milliseconds. -->
     <integer name="config_ntpTimeout">5000</integer>
 
     <!-- Default network policy warning threshold, in megabytes. -->
     <integer name="config_networkPolicyDefaultWarning">2048</integer>
 
     <!-- Set and Unsets WiMAX -->
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index f582b8a61158eb2b507220b282b44e4d8fbd397b..f65dbc469e4a2f5cbcda553e4dcee8c81457e256 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -448,20 +448,21 @@
   <java-symbol type="bool" name="config_allowStartActivityForLongPressOnPowerInSetup" />
   <java-symbol type="integer" name="config_keyChordPowerVolumeUp" />
   <java-symbol type="integer" name="config_wakeUpToLastStateTimeoutMillis" />
   <java-symbol type="integer" name="config_lowMemoryKillerMinFreeKbytesAdjust" />
   <java-symbol type="integer" name="config_lowMemoryKillerMinFreeKbytesAbsolute" />
   <java-symbol type="integer" name="config_max_pan_devices" />
   <java-symbol type="integer" name="config_ntpPollingInterval" />
   <java-symbol type="integer" name="config_ntpPollingIntervalShorter" />
   <java-symbol type="integer" name="config_ntpRetry" />
   <java-symbol type="integer" name="config_ntpTimeout" />
+  <java-symbol type="bool" name="config_nitzTimeUpdate" />
   <java-symbol type="integer" name="config_shortPressOnPowerBehavior" />
   <java-symbol type="integer" name="config_toastDefaultGravity" />
   <java-symbol type="integer" name="config_triplePressOnPowerBehavior" />
   <java-symbol type="integer" name="config_shortPressOnSleepBehavior" />
   <java-symbol type="integer" name="config_windowOutsetBottom" />
   <java-symbol type="integer" name="db_connection_pool_size" />
   <java-symbol type="integer" name="db_journal_size_limit" />
   <java-symbol type="integer" name="db_wal_autocheckpoint" />
   <java-symbol type="integer" name="db_default_idle_connection_timeout" />
   <java-symbol type="integer" name="config_soundEffectVolumeDb" />
diff --git a/services/core/java/com/android/server/timedetector/EnvironmentImpl.java b/services/core/java/com/android/server/timedetector/EnvironmentImpl.java
index 7649958fe6c996298dba889265647ef1bec1dc00..205ade9ed82fe75b3318b950443367fc7a64fa2a 100644
--- a/services/core/java/com/android/server/timedetector/EnvironmentImpl.java
+++ b/services/core/java/com/android/server/timedetector/EnvironmentImpl.java
@@ -43,20 +43,21 @@ final class EnvironmentImpl implements TimeDetectorStrategyImpl.Environment {
 
     private static final String LOG_TAG = TimeDetectorService.TAG;
 
     @NonNull private final Context mContext;
     @NonNull private final Handler mHandler;
     @NonNull private final ServiceConfigAccessor mServiceConfigAccessor;
     @NonNull private final ContentResolver mContentResolver;
     @NonNull private final PowerManager.WakeLock mWakeLock;
     @NonNull private final AlarmManager mAlarmManager;
     @NonNull private final UserManager mUserManager;
+    @NonNull private final boolean mNitzTimeDetectionToggle;
 
     // @NonNull after setConfigChangeListener() is called.
     @GuardedBy("this")
     private ConfigurationChangeListener mConfigChangeListener;
 
     EnvironmentImpl(@NonNull Context context, @NonNull Handler handler,
             @NonNull ServiceConfigAccessor serviceConfigAccessor) {
         mContext = Objects.requireNonNull(context);
         mContentResolver = Objects.requireNonNull(context.getContentResolver());
         mHandler = Objects.requireNonNull(handler);
@@ -78,20 +79,23 @@ final class EnvironmentImpl implements TimeDetectorStrategyImpl.Environment {
                 Settings.Global.getUriFor(Settings.Global.AUTO_TIME), true,
                 new ContentObserver(mHandler) {
                     @Override
                     public void onChange(boolean selfChange) {
                         handleAutoTimeDetectionChangedOnHandlerThread();
                     }
                 });
         mServiceConfigAccessor.addListener(
                 () -> mHandler.post(
                         EnvironmentImpl.this::handleAutoTimeDetectionChangedOnHandlerThread));
+        mNitzTimeDetectionToggle =
+            mContext.getResources().getBoolean(
+                    com.android.internal.R.bool.config_nitzTimeUpdate);
     }
 
     /** Internal method for handling the auto time setting being changed. */
     private void handleAutoTimeDetectionChangedOnHandlerThread() {
         synchronized (this) {
             if (mConfigChangeListener == null) {
                 Slog.wtf(LOG_TAG, "mConfigChangeListener is unexpectedly null");
             }
             mConfigChangeListener.onChange();
         }
@@ -129,20 +133,25 @@ final class EnvironmentImpl implements TimeDetectorStrategyImpl.Environment {
     }
 
     @Override
     public ConfigurationInternal configurationInternal(@UserIdInt int userId) {
         return new ConfigurationInternal.Builder(userId)
                 .setUserConfigAllowed(isUserConfigAllowed(userId))
                 .setAutoDetectionEnabled(isAutoTimeDetectionEnabled())
                 .build();
     }
 
+    @Override
+    public boolean isNITZTimeDetectionEnabled() {
+        return mNitzTimeDetectionToggle;
+    }
+
     @Override
     public void acquireWakeLock() {
         if (mWakeLock.isHeld()) {
             Slog.wtf(LOG_TAG, "WakeLock " + mWakeLock + " already held");
         }
         mWakeLock.acquire();
     }
 
     @Override
     public long elapsedRealtimeMillis() {
diff --git a/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java b/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java
index 357c232226582f6d0a85f152b4fe3697a74307c7..5c95d02a34de3b810fa9e4ad4d0019ac134af1eb 100644
--- a/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java
+++ b/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java
@@ -48,21 +48,21 @@ import java.util.Objects;
 
 /**
  * An implementation of {@link TimeDetectorStrategy} that passes telephony and manual suggestions to
  * {@link AlarmManager}. When there are multiple telephony sources, the one with the lowest ID is
  * used unless the data becomes too stale.
  *
  * <p>Most public methods are marked synchronized to ensure thread safety around internal state.
  */
 public final class TimeDetectorStrategyImpl implements TimeDetectorStrategy {
 
-    private static final boolean DBG = false;
+    private static final boolean DBG = true;
     private static final String LOG_TAG = TimeDetectorService.TAG;
 
     /** A score value used to indicate "no score", either due to validation failure or age. */
     private static final int TELEPHONY_INVALID_SCORE = -1;
     /** The number of buckets telephony suggestions can be put in by age. */
     private static final int TELEPHONY_BUCKET_COUNT = 24;
     /** Each bucket is this size. All buckets are equally sized. */
     @VisibleForTesting
     static final int TELEPHONY_BUCKET_SIZE_MILLIS = 60 * 60 * 1000;
     /**
@@ -178,20 +178,24 @@ public final class TimeDetectorStrategyImpl implements TimeDetectorStrategy {
         long elapsedRealtimeMillis();
 
         /** Returns the system clock value. */
         long systemClockMillis();
 
         /** Sets the device system clock. The WakeLock must be held. */
         void setSystemClock(long newTimeMillis);
 
         /** Release the wake lock acquired by a call to {@link #acquireWakeLock()}. */
         void releaseWakeLock();
+
+        /** Returns true if NITZ time updates is enabled. */
+        boolean isNITZTimeDetectionEnabled();
+
     }
 
     static TimeDetectorStrategy create(
             @NonNull Context context, @NonNull Handler handler,
             @NonNull ServiceConfigAccessor serviceConfigAccessor) {
 
         TimeDetectorStrategyImpl.Environment environment =
                 new EnvironmentImpl(context, handler, serviceConfigAccessor);
         return new TimeDetectorStrategyImpl(environment);
     }
@@ -237,21 +241,21 @@ public final class TimeDetectorStrategyImpl implements TimeDetectorStrategy {
         if (!validateSuggestionTime(newUtcTime, suggestion)) {
             return false;
         }
 
         String cause = "Manual time suggestion received: suggestion=" + suggestion;
         return setSystemClockIfRequired(ORIGIN_MANUAL, newUtcTime, cause);
     }
 
     @Override
     public synchronized void suggestNetworkTime(@NonNull NetworkTimeSuggestion timeSuggestion) {
-        if (!validateAutoSuggestionTime(timeSuggestion.getUtcTime(), timeSuggestion)) {
+        if (timeSuggestion == null || !validateAutoSuggestionTime(timeSuggestion.getUtcTime(), timeSuggestion)) {
             return;
         }
 
         // The caller submits suggestions with the best available information when there are network
         // changes. The best available information may have been cached and if they were all stored
         // this would lead to duplicates showing up in the suggestion history. The suggestions may
         // be made for different reasons but there is not a significant benefit to storing the same
         // suggestion information again. doAutoTimeDetection() should still be called: this ensures
         // the suggestion and device state are always re-evaluated, which might produce a different
         // detected time if, for example, the age of all suggestions are considered.
@@ -261,20 +265,25 @@ public final class TimeDetectorStrategyImpl implements TimeDetectorStrategy {
         }
 
         // Now perform auto time detection. The new suggestion may be used to modify the system
         // clock.
         String reason = "New network time suggested. timeSuggestion=" + timeSuggestion;
         doAutoTimeDetection(reason);
     }
 
     @Override
     public synchronized void suggestTelephonyTime(@NonNull TelephonyTimeSuggestion timeSuggestion) {
+        // is config_nitzUpdate is set to false, we disallow telephony time suggestions.
+        if (!mEnvironment.isNITZTimeDetectionEnabled()) {
+            return;
+        }
+
         // Empty time suggestion means that telephony network connectivity has been lost.
         // The passage of time is relentless, and we don't expect our users to use a time machine,
         // so we can continue relying on previous suggestions when we lose connectivity. This is
         // unlike time zone, where a user may lose connectivity when boarding a flight and where we
         // do want to "forget" old signals. Suggestions that are too old are discarded later in the
         // detection algorithm.
         if (timeSuggestion.getUtcTime() == null) {
             return;
         }
 
@@ -441,21 +450,21 @@ public final class TimeDetectorStrategyImpl implements TimeDetectorStrategy {
         if (!mEnvironment.isAutoTimeDetectionEnabled()) {
             // Avoid doing unnecessary work with this (race-prone) check.
             return;
         }
 
         // Try the different origins one at a time.
         int[] originPriorities = mEnvironment.autoOriginPriorities();
         for (int origin : originPriorities) {
             TimestampedValue<Long> newUtcTime = null;
             String cause = null;
-            if (origin == ORIGIN_TELEPHONY) {
+            if (mEnvironment.isNITZTimeDetectionEnabled() && origin == ORIGIN_TELEPHONY) {
                 TelephonyTimeSuggestion bestTelephonySuggestion = findBestTelephonySuggestion();
                 if (bestTelephonySuggestion != null) {
                     newUtcTime = bestTelephonySuggestion.getUtcTime();
                     cause = "Found good telephony suggestion."
                             + ", bestTelephonySuggestion=" + bestTelephonySuggestion
                             + ", detectionReason=" + detectionReason;
                 }
             } else if (origin == ORIGIN_NETWORK) {
                 NetworkTimeSuggestion networkSuggestion = findLatestValidNetworkSuggestion();
                 if (networkSuggestion != null) {

commit c2288fc68f7289db24e5b69a3462ab2d2af574ea
Author: Renlord <me@renlord.com>
Date:   Tue 2020-06-30 11:52:43+1000

    dont ping server when nitz time update is toggled off
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 core/java/android/util/NtpTrustedTime.java | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/core/java/android/util/NtpTrustedTime.java b/core/java/android/util/NtpTrustedTime.java
index 9ebc9f4cea0b832d7f09131cae5839458362b183..be78084b7ea9c98d8b4c98976a6d7127110bd1b5 100644
--- a/core/java/android/util/NtpTrustedTime.java
+++ b/core/java/android/util/NtpTrustedTime.java
@@ -134,20 +134,29 @@ public class NtpTrustedTime implements TrustedTime {
         if (sSingleton == null) {
             Context appContext = context.getApplicationContext();
             sSingleton = new NtpTrustedTime(appContext);
         }
         return sSingleton;
     }
 
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     public boolean forceRefresh() {
         synchronized (this) {
+            final ContentResolver resolver = mContext.getContentResolver();
+
+            final boolean networkPollTime = Settings.Global.getInt(resolver,
+                    Settings.Global.AUTO_TIME, 1) != 0;
+            if (!networkPollTime) {
+                Log.d(TAG, "forceRefresh: nitzTimeUpdate disabled bailing early");
+                return false;
+            }
+
             NtpConnectionInfo connectionInfo = getNtpConnectionInfo();
             if (connectionInfo == null) {
                 // missing server config, so no trusted time available
                 if (LOGD) Log.d(TAG, "forceRefresh: invalid server config");
                 return false;
             }
 
             ConnectivityManager connectivityManager = mConnectivityManagerSupplier.get();
             if (connectivityManager == null) {
                 if (LOGD) Log.d(TAG, "forceRefresh: no ConnectivityManager");

commit 239d85b20af7fd32839013a91404831fabf99ad1
Author: anupritaisno1 <www.anuprita804@gmail.com>
Date:   Mon 2021-10-18 04:05:40+0530

    automatically reboot device after timeout if set
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
    Change-Id: If891bfbcc144c9336ba013260bad2b7c7a59c054
---
 core/java/android/provider/Settings.java           |  7 +++++
 data/etc/com.android.systemui.xml                  |  1 +
 packages/SystemUI/AndroidManifest.xml              |  3 ++
 .../systemui/keyguard/KeyguardViewMediator.java    | 35 ++++++++++++++++++++++
 4 files changed, 46 insertions(+)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 2f9796b21ca8f400f78d993bce330d27d629ed37..6c8d8aa379a84173f32eb4487ee6f98490fb1f5c 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -16191,20 +16191,27 @@ public final class Settings {
         /**
          * Used to enable / disable the Restricted Networking Mode in which network access is
          * restricted to apps holding the CONNECTIVITY_USE_RESTRICTED_NETWORKS permission.
          *
          * Values are:
          * 0: disabled
          * 1: enabled
          * @hide
          */
         public static final String RESTRICTED_NETWORKING_MODE = "restricted_networking_mode";
+
+        /**
+         * Whether to automatically reboot the device after a user defined timeout
+         *
+         * @hide
+         */
+        public static final String SETTINGS_REBOOT_AFTER_TIMEOUT = "settings_reboot_after_timeout";
     }
 
     /**
      * Configuration system settings, containing settings which are applied identically for all
      * defined users. Only Android can read these and only a specific configuration service can
      * write these.
      *
      * @hide
      */
     public static final class Config extends NameValueTable {
diff --git a/data/etc/com.android.systemui.xml b/data/etc/com.android.systemui.xml
index f2a33de008d6863d1996c85ab2f08be9853679e4..354fd82f3a0ddcaeec7af9e8c5b75484b98aa7d2 100644
--- a/data/etc/com.android.systemui.xml
+++ b/data/etc/com.android.systemui.xml
@@ -41,20 +41,21 @@
         <permission name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/>
         <permission name="android.permission.OBSERVE_NETWORK_POLICY"/>
         <permission name="android.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS" />
         <permission name="android.permission.OVERRIDE_WIFI_CONFIG"/>
         <permission name="android.permission.PACKAGE_USAGE_STATS" />
         <permission name="android.permission.READ_DREAM_STATE"/>
         <permission name="android.permission.READ_FRAME_BUFFER"/>
         <permission name="android.permission.READ_NETWORK_USAGE_HISTORY"/>
         <permission name="android.permission.READ_PRIVILEGED_PHONE_STATE"/>
         <permission name="android.permission.REAL_GET_TASKS"/>
+        <permission name="android.permission.REBOOT"/>
         <permission name="android.permission.REQUEST_NETWORK_SCORES"/>
         <permission name="android.permission.RECEIVE_MEDIA_RESOURCE_USAGE"/>
         <permission name="android.permission.START_ACTIVITIES_FROM_BACKGROUND" />
         <permission name="android.permission.START_ACTIVITY_AS_CALLER"/>
         <permission name="android.permission.START_TASKS_FROM_RECENTS"/>
         <permission name="android.permission.STATUS_BAR"/>
         <permission name="android.permission.STOP_APP_SWITCHES"/>
         <permission name="android.permission.SUBSTITUTE_NOTIFICATION_APP_NAME"/>
         <permission name="android.permission.TETHER_PRIVILEGED"/>
         <permission name="android.permission.UPDATE_APP_OPS_STATS"/>
diff --git a/packages/SystemUI/AndroidManifest.xml b/packages/SystemUI/AndroidManifest.xml
index 9de1c5ea1a3d4c68b67d4a1c39e993e25bc44c31..e508469086c9b43501b29a0f4dff3f08d12c69b0 100644
--- a/packages/SystemUI/AndroidManifest.xml
+++ b/packages/SystemUI/AndroidManifest.xml
@@ -279,20 +279,23 @@
     <uses-permission android:name="android.permission.MODIFY_SETTINGS_OVERRIDEABLE_BY_RESTORE" />
 
     <!-- Permission to make accessibility service access Bubbles -->
     <uses-permission android:name="android.permission.ADD_TRUSTED_DISPLAY" />
 
     <!-- Permission for Smartspace. -->
     <uses-permission android:name="android.permission.MANAGE_SMARTSPACE" />
 
     <uses-permission android:name="android.permission.READ_PEOPLE_DATA" />
 
+    <!-- Permission to allow rebooting the device after a user configurable amount of time -->
+    <uses-permission android:name="android.permission.REBOOT" />
+
     <protected-broadcast android:name="com.android.settingslib.action.REGISTER_SLICE_RECEIVER" />
     <protected-broadcast android:name="com.android.settingslib.action.UNREGISTER_SLICE_RECEIVER" />
     <protected-broadcast android:name="com.android.settings.flashlight.action.FLASHLIGHT_CHANGED" />
 
     <application
         android:name=".SystemUIApplication"
         android:persistent="true"
         android:allowClearUserData="false"
         android:backupAgent=".backup.BackupHelper"
         android:killAfterRestore="false"
diff --git a/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java b/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
index 1a8af3bb650b7da81b30f893f244316bc40e0fb8..45dbc12c7c166adf5a2df6d2a21e8e4cc2b1d2a0 100644
--- a/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
+++ b/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
@@ -173,20 +173,22 @@ import dagger.Lazy;
 public class KeyguardViewMediator extends SystemUI implements Dumpable,
         StatusBarStateController.StateListener {
     private static final int KEYGUARD_DISPLAY_TIMEOUT_DELAY_DEFAULT = 30000;
     private static final long KEYGUARD_DONE_PENDING_TIMEOUT_MS = 3000;
 
     private static final boolean DEBUG = KeyguardConstants.DEBUG;
     private static final boolean DEBUG_SIM_STATES = KeyguardConstants.DEBUG_SIM_STATES;
 
     private final static String TAG = "KeyguardViewMediator";
 
+    private static final String DELAYED_REBOOT_ACTION =
+        "com.android.internal.policy.impl.PhoneWindowManager.DELAYED_REBOOT";
     private static final String DELAYED_KEYGUARD_ACTION =
         "com.android.internal.policy.impl.PhoneWindowManager.DELAYED_KEYGUARD";
     private static final String DELAYED_LOCK_PROFILE_ACTION =
             "com.android.internal.policy.impl.PhoneWindowManager.DELAYED_LOCK";
 
     private static final String SYSTEMUI_PERMISSION = "com.android.systemui.permission.SELF";
 
     // used for handler messages
     private static final int SHOW = 1;
     private static final int HIDE = 2;
@@ -300,20 +302,25 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
      * Helps remember whether the screen has turned on since the last time
      * it turned off due to timeout. see {@link #onScreenTurnedOff(int)}
      */
     private int mDelayedShowingSequence;
 
     /**
      * Simiar to {@link #mDelayedProfileShowingSequence}, but it is for profile case.
      */
     private int mDelayedProfileShowingSequence;
 
+    /**
+     * Same as {@link #mDelayedProfileShowingSequence}, but used for our reboot implementation
+     */
+    private int mDelayedRebootSequence;
+
     /**
      * If the user has disabled the keyguard, then requests to exit, this is
      * how we'll ultimately let them know whether it was successful.  We use this
      * var being non-null as an indicator that there is an in progress request.
      */
     private IKeyguardExitCallback mExitSecureCallback;
     private final DismissCallbackRegistry mDismissCallbackRegistry;
 
     // the properties of the keyguard
 
@@ -892,20 +899,21 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
         mShowKeyguardWakeLock = mPM.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "show keyguard");
         mShowKeyguardWakeLock.setReferenceCounted(false);
 
         IntentFilter filter = new IntentFilter();
         filter.addAction(Intent.ACTION_SHUTDOWN);
         mBroadcastDispatcher.registerReceiver(mBroadcastReceiver, filter);
 
         final IntentFilter delayedActionFilter = new IntentFilter();
         delayedActionFilter.addAction(DELAYED_KEYGUARD_ACTION);
         delayedActionFilter.addAction(DELAYED_LOCK_PROFILE_ACTION);
+        delayedActionFilter.addAction(DELAYED_REBOOT_ACTION);
         mContext.registerReceiver(mDelayedLockBroadcastReceiver, delayedActionFilter,
                 SYSTEMUI_PERMISSION, null /* scheduler */);
 
         mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
 
         KeyguardUpdateMonitor.setCurrentUser(ActivityManager.getCurrentUser());
 
         // Assume keyguard is showing (unless it's disabled) until we know for sure, unless Keyguard
         // is disabled.
         if (isKeyguardServiceEnabled()) {
@@ -1190,37 +1198,53 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
                     lockIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
                     PendingIntent lockSender = PendingIntent.getBroadcast(
                             mContext, 0, lockIntent, PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_MUTABLE_UNAUDITED);
                     mAlarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP,
                             userWhen, lockSender);
                 }
             }
         }
     }
 
+    private void doRebootForOwnerAfterTimeoutIfEnabled(long rebootAfterTimeout) {
+        long when = SystemClock.elapsedRealtime() + rebootAfterTimeout;
+        Intent rebootIntent = new Intent(DELAYED_REBOOT_ACTION);
+        rebootIntent.putExtra("seq", mDelayedRebootSequence);
+        rebootIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+        PendingIntent sender = PendingIntent.getBroadcast(mContext,
+                0, rebootIntent, PendingIntent.FLAG_CANCEL_CURRENT |  PendingIntent.FLAG_IMMUTABLE);
+        mAlarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, when, sender);
+        if (DEBUG) Log.d(TAG, "setting alarm to reboot device, timeout = "
+                         + String.valueOf(rebootAfterTimeout));
+    }
+
     private void doKeyguardForChildProfilesLocked() {
         UserManager um = UserManager.get(mContext);
         for (int profileId : um.getEnabledProfileIds(UserHandle.myUserId())) {
             if (mLockPatternUtils.isSeparateProfileChallengeEnabled(profileId)) {
                 lockProfile(profileId);
             }
         }
     }
 
     private void cancelDoKeyguardLaterLocked() {
         mDelayedShowingSequence++;
     }
 
     private void cancelDoKeyguardForChildProfilesLocked() {
         mDelayedProfileShowingSequence++;
     }
 
+    private void cancelDoRebootForOwnerAfterTimeoutIfEnabled() {
+        mDelayedRebootSequence++;
+    }
+
     /**
      * Let's us know when the device is waking up.
      */
     public void onStartedWakingUp(boolean cameraGestureTriggered) {
         Trace.beginSection("KeyguardViewMediator#onStartedWakingUp");
 
         // TODO: Rename all screen off/on references to interactive/sleeping
         synchronized (this) {
             mDeviceInteractive = true;
             if (mPendingLock && !cameraGestureTriggered) {
@@ -1569,20 +1593,24 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
                 if (DEBUG) Log.d(TAG, "Not showing lock screen since just decrypted");
                 // Without this, settings is not enabled until the lock screen first appears
                 setShowingLocked(false);
                 hideLocked();
                 return;
             }
         }
 
         if (DEBUG) Log.d(TAG, "doKeyguard: showing the lock screen");
         showLocked(options);
+        final long rebootAfterTimeout = Settings.Global.getLong(mContext.getContentResolver(), Settings.Global.SETTINGS_REBOOT_AFTER_TIMEOUT, 0);
+        if (rebootAfterTimeout >= 1) {
+            doRebootForOwnerAfterTimeoutIfEnabled(rebootAfterTimeout);
+        }
     }
 
     private void lockProfile(int userId) {
         mTrustManager.setDeviceLockedForUser(userId, true);
     }
 
     private boolean shouldWaitForProvisioning() {
         return !mUpdateMonitor.isDeviceProvisioned() && !isSecure();
     }
 
@@ -1753,20 +1781,26 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
             } else if (DELAYED_LOCK_PROFILE_ACTION.equals(intent.getAction())) {
                 final int sequence = intent.getIntExtra("seq", 0);
                 int userId = intent.getIntExtra(Intent.EXTRA_USER_ID, 0);
                 if (userId != 0) {
                     synchronized (KeyguardViewMediator.this) {
                         if (mDelayedProfileShowingSequence == sequence) {
                             lockProfile(userId);
                         }
                     }
                 }
+            } else if (DELAYED_REBOOT_ACTION.equals(intent.getAction())) {
+                final int sequence = intent.getIntExtra("seq", 0);
+                if (sequence == mDelayedRebootSequence) {
+                    PowerManager pm = mContext.getSystemService(PowerManager.class);
+                    pm.reboot(null);
+                }
             }
         }
     };
 
     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
             if (Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
                 synchronized (KeyguardViewMediator.this){
                     mShuttingDown = true;
@@ -2339,20 +2373,21 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
             playSounds(false);
         }
 
         setShowingLocked(false);
         mWakeAndUnlocking = false;
         mDismissCallbackRegistry.notifyDismissSucceeded();
         resetKeyguardDonePendingLocked();
         mHideAnimationRun = false;
         adjustStatusBarLocked();
         sendUserPresentBroadcast();
+        cancelDoRebootForOwnerAfterTimeoutIfEnabled();
     }
 
     private Configuration.Builder createInteractionJankMonitorConf(String tag) {
         return new Configuration.Builder(CUJ_LOCKSCREEN_UNLOCK_ANIMATION)
                 .setView(mKeyguardViewControllerLazy.get().getViewRootImpl().getView())
                 .setTag(tag);
     }
 
     /**
      * Whether we're currently animating between the keyguard and the app/launcher surface behind

commit 20063ed4d2e2d8464150fce8744a47fe74899fd0
Author: flawedworld <flawedworld@flawed.world>
Date:   Tue 2021-09-28 15:25:03+0100

    Always show APN settings on CDMA carriers
---
 telephony/java/android/telephony/CarrierConfigManager.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/telephony/java/android/telephony/CarrierConfigManager.java b/telephony/java/android/telephony/CarrierConfigManager.java
index 45fd7a3467c407854acbad440303f6f7f9078ad6..92d6d9868da6c6252c01912a2cb66c527184ec75 100644
--- a/telephony/java/android/telephony/CarrierConfigManager.java
+++ b/telephony/java/android/telephony/CarrierConfigManager.java
@@ -5276,21 +5276,21 @@ public class CarrierConfigManager {
         sDefaults.putBoolean(KEY_CALL_FORWARDING_WHEN_UNREACHABLE_SUPPORTED_BOOL, true);
         sDefaults.putBoolean(KEY_CALL_FORWARDING_WHEN_UNANSWERED_SUPPORTED_BOOL, true);
         sDefaults.putBoolean(KEY_CALL_FORWARDING_WHEN_BUSY_SUPPORTED_BOOL, true);
         sDefaults.putBoolean(KEY_ADDITIONAL_SETTINGS_CALLER_ID_VISIBILITY_BOOL, true);
         sDefaults.putBoolean(KEY_ADDITIONAL_SETTINGS_CALL_WAITING_VISIBILITY_BOOL, true);
         sDefaults.putBoolean(KEY_DISABLE_SUPPLEMENTARY_SERVICES_IN_AIRPLANE_MODE_BOOL, false);
         sDefaults.putBoolean(KEY_IGNORE_SIM_NETWORK_LOCKED_EVENTS_BOOL, false);
         sDefaults.putBoolean(KEY_MDN_IS_ADDITIONAL_VOICEMAIL_NUMBER_BOOL, false);
         sDefaults.putBoolean(KEY_OPERATOR_SELECTION_EXPAND_BOOL, true);
         sDefaults.putBoolean(KEY_PREFER_2G_BOOL, true);
-        sDefaults.putBoolean(KEY_SHOW_APN_SETTING_CDMA_BOOL, false);
+        sDefaults.putBoolean(KEY_SHOW_APN_SETTING_CDMA_BOOL, true);
         sDefaults.putBoolean(KEY_SHOW_CDMA_CHOICES_BOOL, false);
         sDefaults.putBoolean(KEY_SMS_REQUIRES_DESTINATION_NUMBER_CONVERSION_BOOL, false);
         sDefaults.putBoolean(KEY_SUPPORT_EMERGENCY_SMS_OVER_IMS_BOOL, false);
         sDefaults.putBoolean(KEY_SHOW_ONSCREEN_DIAL_BUTTON_BOOL, true);
         sDefaults.putBoolean(KEY_SIM_NETWORK_UNLOCK_ALLOW_DISMISS_BOOL, true);
         sDefaults.putBoolean(KEY_SUPPORT_PAUSE_IMS_VIDEO_CALLS_BOOL, false);
         sDefaults.putBoolean(KEY_SUPPORT_SWAP_AFTER_MERGE_BOOL, true);
         sDefaults.putBoolean(KEY_USE_HFA_FOR_PROVISIONING_BOOL, false);
         sDefaults.putBoolean(KEY_EDITABLE_VOICEMAIL_NUMBER_SETTING_BOOL, true);
         sDefaults.putBoolean(KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL, false);

commit 99f1d4e21136dc942bc479f115cfb005b934ce5c
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2016-06-16 01:19:53-0400

    implement dynamic deny_new_usb toggle mode
---
 .../com/android/server/policy/keyguard/KeyguardStateMonitor.java     | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/services/core/java/com/android/server/policy/keyguard/KeyguardStateMonitor.java b/services/core/java/com/android/server/policy/keyguard/KeyguardStateMonitor.java
index add0b01f18799dc33079a30dd6eec9fe1ae4a752..1d68c37577e825f1c43a55dbbf64cd0ed1564ea0 100644
--- a/services/core/java/com/android/server/policy/keyguard/KeyguardStateMonitor.java
+++ b/services/core/java/com/android/server/policy/keyguard/KeyguardStateMonitor.java
@@ -12,20 +12,21 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.android.server.policy.keyguard;
 
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.RemoteException;
+import android.os.SystemProperties;
 import android.util.Slog;
 
 import com.android.internal.policy.IKeyguardService;
 import com.android.internal.policy.IKeyguardStateCallback;
 import com.android.internal.widget.LockPatternUtils;
 
 import java.io.PrintWriter;
 
 /**
  * Maintains a cached copy of Keyguard's state.
@@ -81,20 +82,24 @@ public class KeyguardStateMonitor extends IKeyguardStateCallback.Stub {
 
     public boolean hasLockscreenWallpaper() {
         return mHasLockscreenWallpaper;
     }
 
     @Override // Binder interface
     public void onShowingStateChanged(boolean showing) {
         mIsShowing = showing;
 
         mCallback.onShowingChanged();
+
+        if ("dynamic".equals(SystemProperties.get("persist.security.deny_new_usb"))) {
+            SystemProperties.set("security.deny_new_usb", showing ? "1" : "0");
+        }
     }
 
     @Override // Binder interface
     public void onSimSecureStateChanged(boolean simSecure) {
         mSimSecure = simSecure;
     }
 
     public synchronized void setCurrentUser(int userId) {
         mCurrentUserId = userId;
     }

commit 8afba165c79c1e9a44eaeea3d1c0c08921163b49
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2017-07-25 11:22:33-0400

    add system property for disabling keyguard camera
    
    Change-Id: I0b65cac3c3d2fc495b339c34add742bd698b107c
---
 .../android/systemui/statusbar/phone/KeyguardBottomAreaView.java  | 4 +++-
 services/core/java/com/android/server/GestureLauncherService.java | 8 ++++++++
 2 files changed, 11 insertions(+), 1 deletion(-)

diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java
index 4701d8b32ee639802e1e5d0c300e813ade636ce2..868edc404b7f63ccce975da3ad5c5379385f8fb6 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java
@@ -43,20 +43,21 @@ import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.content.res.ColorStateList;
 import android.content.res.Configuration;
 import android.graphics.drawable.Drawable;
 import android.os.AsyncTask;
 import android.os.Bundle;
 import android.os.IBinder;
 import android.os.Message;
 import android.os.Messenger;
 import android.os.RemoteException;
+import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.provider.MediaStore;
 import android.service.media.CameraPrewarmService;
 import android.service.quickaccesswallet.GetWalletCardsError;
 import android.service.quickaccesswallet.GetWalletCardsResponse;
 import android.service.quickaccesswallet.QuickAccessWalletClient;
 import android.telecom.TelecomManager;
 import android.text.TextUtils;
 import android.util.AttributeSet;
 import android.util.Log;
@@ -957,21 +958,22 @@ public class KeyguardBottomAreaView extends FrameLayout implements View.OnClickL
     private class DefaultRightButton implements IntentButton {
 
         private IconState mIconState = new IconState();
 
         @Override
         public IconState getIcon() {
             boolean isCameraDisabled = (mStatusBar != null) && !mStatusBar.isCameraAllowedByAdmin();
             mIconState.isVisible = !isCameraDisabled
                     && mShowCameraAffordance
                     && mUserSetupComplete
-                    && resolveCameraIntent() != null;
+                    && resolveCameraIntent() != null
+                    && SystemProperties.getBoolean("persist.keyguard.camera", true);
             mIconState.drawable = mContext.getDrawable(R.drawable.ic_camera_alt_24dp);
             mIconState.contentDescription =
                     mContext.getString(R.string.accessibility_camera_button);
             return mIconState;
         }
 
         @Override
         public Intent getIntent() {
             boolean canDismissLs = mKeyguardStateController.canDismissLockScreen();
             boolean secure = mKeyguardStateController.isMethodSecure();
diff --git a/services/core/java/com/android/server/GestureLauncherService.java b/services/core/java/com/android/server/GestureLauncherService.java
index d04698cb5aeb6d70d7457f2c691d30e348dd40a9..0ba4f550c5f400d1c04e8f48f594640bf24edc6f 100644
--- a/services/core/java/com/android/server/GestureLauncherService.java
+++ b/services/core/java/com/android/server/GestureLauncherService.java
@@ -10,20 +10,21 @@
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.android.server;
 
 import android.app.ActivityManager;
+import android.app.KeyguardManager;
 import android.app.StatusBarManager;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.res.Resources;
 import android.database.ContentObserver;
 import android.hardware.Sensor;
 import android.hardware.SensorEvent;
 import android.hardware.SensorEventListener;
@@ -519,20 +520,27 @@ public class GestureLauncherService extends SystemService {
         // user has completed setup.
         return intercept && isUserSetupComplete();
     }
     /**
      * @return true if camera was launched, false otherwise.
      */
     @VisibleForTesting
     boolean handleCameraGesture(boolean useWakelock, int source) {
         Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "GestureLauncher:handleCameraGesture");
         try {
+            if (!SystemProperties.getBoolean("persist.keyguard.camera", true)) {
+                final KeyguardManager manager = (KeyguardManager) getContext().getSystemService(
+                        Context.KEYGUARD_SERVICE);
+                if (manager.inKeyguardRestrictedInputMode()) {
+                    return false;
+                }
+            }
             boolean userSetupComplete = isUserSetupComplete();
             if (!userSetupComplete) {
                 if (DBG) {
                     Slog.d(TAG, String.format(
                             "userSetupComplete = %s, ignoring camera gesture.",
                             userSetupComplete));
                 }
                 return false;
             }
             if (DBG) {

commit 6c471abd6f42efdd5f0e2bc61aea1bfd308ea1f9
Author: Pratyush <39559233+empratyush@users.noreply.github.com>
Date:   Sun 2021-05-02 00:36:30+0000

    enable backup service for non-owner users
---
 .../server/backup/BackupManagerService.java        | 48 ++++++++++++++++++++++
 1 file changed, 48 insertions(+)

diff --git a/services/backup/java/com/android/server/backup/BackupManagerService.java b/services/backup/java/com/android/server/backup/BackupManagerService.java
index 38275f7cd34838b14f1e07999ff82ed2d56dcc06..1014f5dab3e723e37be43c3bcaaf94e755ea5659 100644
--- a/services/backup/java/com/android/server/backup/BackupManagerService.java
+++ b/services/backup/java/com/android/server/backup/BackupManagerService.java
@@ -35,32 +35,35 @@ import android.app.backup.ISelectBackupTransportCallback;
 import android.app.compat.CompatChanges;
 import android.app.job.JobParameters;
 import android.app.job.JobScheduler;
 import android.app.job.JobService;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
+import android.content.pm.UserInfo;
 import android.os.Binder;
 import android.os.FileUtils;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.IBinder;
 import android.os.ParcelFileDescriptor;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.SystemProperties;
 import android.os.Trace;
 import android.os.UserHandle;
 import android.os.UserManager;
+import android.provider.Settings;
+import android.util.Log;
 import android.util.Slog;
 import android.util.SparseArray;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.DumpUtils;
 import com.android.server.SystemConfig;
 import com.android.server.SystemService;
 import com.android.server.backup.utils.RandomAccessFileUtils;
 
@@ -148,41 +151,86 @@ public class BackupManagerService extends IBackupManager.Stub {
         public void onReceive(Context context, Intent intent) {
             if (Intent.ACTION_USER_REMOVED.equals(intent.getAction())) {
                 int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);
                 if (userId > 0) { // for only non system users
                     mHandler.post(() -> onRemovedNonSystemUser(userId));
                 }
             }
         }
     };
 
+    
+    private final BroadcastReceiver mUserAddedReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (Intent.ACTION_USER_ADDED.equals(intent.getAction())) {
+                int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);
+                Log.d(TAG, "new user added User ID : " + userId);
+                if (userId > 0) {
+                mHandler.post(() -> setBackupServiceActive(userId, true));
+                }
+            }
+        }
+    };
+    
     public BackupManagerService(Context context) {
         this(context, new SparseArray<>());
     }
 
     @VisibleForTesting
     BackupManagerService(Context context, SparseArray<UserBackupManagerService> userServices) {
         mContext = context;
         mGlobalDisable = isBackupDisabled();
         HandlerThread handlerThread =
                 new HandlerThread(BACKUP_THREAD, Process.THREAD_PRIORITY_BACKGROUND);
         handlerThread.start();
         mHandler = new Handler(handlerThread.getLooper());
         mUserManager = UserManager.get(context);
         mUserServices = userServices;
         Set<ComponentName> transportWhitelist =
                 SystemConfig.getInstance().getBackupTransportWhitelist();
         mTransportWhitelist = (transportWhitelist == null) ? emptySet() : transportWhitelist;
         mContext.registerReceiver(
                 mUserRemovedReceiver, new IntentFilter(Intent.ACTION_USER_REMOVED));
+        
+        
+        mContext.registerReceiver(
+                mUserAddedReceiver, new IntentFilter(Intent.ACTION_USER_ADDED));
+        
+        if (shouldMigrateExistingUser(context)) {
+            List<UserInfo> managerUsers = mUserManager.getUsers();
+                for (UserInfo userInfo : managerUsers) {
+                    setBackupServiceActive(
+                        userInfo.getUserHandle().getIdentifier(),
+                        true
+                    );
+            }
+
+            markExistingUserMigrated(context);
+        }
+        
     }
 
+    private static final String PROFILE_MIGRATION_COMPLETED = "graphene_existing_users_migration";
+    
+    private boolean markExistingUserMigrated(Context context) {
+        return Settings.Global.putInt(context.getContentResolver(), PROFILE_MIGRATION_COMPLETED, 1);
+    }
+    
+    private boolean shouldMigrateExistingUser(Context context) {
+        return Settings.Global.getInt(
+                context.getContentResolver(),
+                PROFILE_MIGRATION_COMPLETED,
+                0
+            ) != 1;
+    }
+    
     // TODO: Remove this when we implement DI by injecting in the construtor.
     @VisibleForTesting
     Handler getBackupHandler() {
         return mHandler;
     }
 
     protected boolean isBackupDisabled() {
         return SystemProperties.getBoolean(BACKUP_DISABLE_PROPERTY, false);
     }
 

commit 031b85368fb9baeb7fe5833ddc1e930255dd0e3f
Author: Rusty Bird <rustybird@net-c.com>
Date:   Wed 2020-04-22 18:28:33+0000

    disable safe volume everywhere, not just the US
    
    Safe Volume has many false alarms. And if overridden by the user, at
    every 20 hours of accumulated(!) audio playback it will intentionally
    reset - even while the audio is playing. This can ruin the listening
    experience, and ironically pose a safety hazard when e.g. the user is
    operating a vehicle...
    
    AOSP already opted out of Safe Volume in the overlays for Mobile Country
    Code 310-316 (= US). Make this universal.
    
    Signed-off-by: Rusty Bird <rustybird@net-c.com>
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 4ff333e6f27e6d4bed73836ea230899f4fc9efe9..52574384051bb3c741af75820c6b2089b1476216 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2604,21 +2604,21 @@
              0 - COLOR_MODE_DEFAULT
              7 - COLOR_MODE_SRGB
     -->
     <integer name="config_defaultDisplayDefaultColorMode">0</integer>
 
     <!-- When true use the linux /dev/input/event subsystem to detect the switch changes
          on the headphone/microphone jack. When false use the older uevent framework. -->
     <bool name="config_useDevInputEventForAudioJack">false</bool>
 
     <!-- Whether safe headphone volume is enabled or not (country specific). -->
-    <bool name="config_safe_media_volume_enabled">true</bool>
+    <bool name="config_safe_media_volume_enabled">false</bool>
 
     <!-- Whether safe headphone volume warning dialog is disabled on Vol+ (operator specific). -->
     <bool name="config_safe_media_disable_on_volume_up">true</bool>
 
     <!-- Set to true if the wifi display supports compositing content stored
          in gralloc protected buffers.  For this to be true, there must exist
          a protected hardware path for surface flinger to composite and send
          protected buffers to the wifi display video encoder.
 
          If this flag is false, we advise applications not to use protected

commit 7cd64a347d75bd7ba6ee43e3e4177a3b0fd7861c
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2019-03-17 19:11:12-0400

    SystemUI: enable NFC quick settings tile
---
 packages/SystemUI/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/packages/SystemUI/res/values/config.xml b/packages/SystemUI/res/values/config.xml
index d274c917c26df7869942c3d5af95aa57ebd26e30..8bd036b70d5f92ea5ea64cf4302dc8756b58d7bd 100644
--- a/packages/SystemUI/res/values/config.xml
+++ b/packages/SystemUI/res/values/config.xml
@@ -100,21 +100,21 @@
     <!-- The default tiles to display in QuickSettings -->
     <string name="quick_settings_tiles_default" translatable="false">
         internet,bt,flashlight,dnd,alarm,airplane,controls,wallet,rotation,battery,cast,screenrecord,mictoggle,cameratoggle
     </string>
 
     <!-- The minimum number of tiles to display in QuickSettings -->
     <integer name="quick_settings_min_num_tiles">6</integer>
 
     <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default" -->
     <string name="quick_settings_tiles_stock" translatable="false">
-        internet,bt,flashlight,dnd,alarm,airplane,controls,wallet,rotation,battery,cast,screenrecord,mictoggle,cameratoggle,location,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness
+        internet,bt,flashlight,dnd,alarm,airplane,controls,wallet,rotation,battery,cast,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness
     </string>
 
     <!-- The tiles to display in QuickSettings -->
     <string name="quick_settings_tiles" translatable="false">default</string>
 
     <!-- The tiles to display in QuickSettings in retail mode -->
     <string name="quick_settings_tiles_retail_mode" translatable="false">
         night,dark,dnd,flashlight,rotation,location
     </string>
 

commit 1729ecd7f10acf0164ef63f141eed6228412270e
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Mon 2017-01-02 18:51:57-0500

    hide sensitive information while locked by default
---
 packages/SettingsProvider/res/values/defaults.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/packages/SettingsProvider/res/values/defaults.xml b/packages/SettingsProvider/res/values/defaults.xml
index 93efe5060a2f642841b4d662225d30935e9b48b7..26ae277751730765f7ecdd688b9d824b00bccbe4 100644
--- a/packages/SettingsProvider/res/values/defaults.xml
+++ b/packages/SettingsProvider/res/values/defaults.xml
@@ -156,21 +156,21 @@
          Override to disable immersive mode confirmation for certain packages. -->
     <string name="def_immersive_mode_confirmations" translatable="false"></string>
 
     <!-- Default for Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE -->
     <integer name="def_wifi_scan_always_available">0</integer>
 
     <!-- Default for Settings.Secure.LOCK_SCREEN_SHOW_NOTIFICATIONS, 1==on -->
     <integer name="def_lock_screen_show_notifications">1</integer>
 
     <!-- Default for Settings.Secure.LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS -->
-    <bool name="def_lock_screen_allow_private_notifications">true</bool>
+    <bool name="def_lock_screen_allow_private_notifications">false</bool>
 
     <!-- Default for Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED, 1==on -->
     <integer name="def_heads_up_enabled">1</integer>
 
     <!-- Default for Settings.Global.DEVICE_NAME $1=MANUFACTURER $2=MODEL-->
     <string name="def_device_name">%1$s %2$s</string>
 
     <!-- Default for Settings.Global.DEVICE_NAME $1=MODEL-->
     <string name="def_device_name_simple">%1$s</string>
 

commit c7d89e9835bbfe2505343a7b17f1b6eac45446d8
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2017-02-03 06:53:00-0500

    set TEXT_SHOW_PASSWORD to false by default
---
 packages/SettingsProvider/res/values/defaults.xml                      | 2 ++
 .../src/com/android/providers/settings/DatabaseHelper.java             | 3 +++
 2 files changed, 5 insertions(+)

diff --git a/packages/SettingsProvider/res/values/defaults.xml b/packages/SettingsProvider/res/values/defaults.xml
index 26ae277751730765f7ecdd688b9d824b00bccbe4..5eea681b8566f9268fad65428c50e05fc46925f7 100644
--- a/packages/SettingsProvider/res/values/defaults.xml
+++ b/packages/SettingsProvider/res/values/defaults.xml
@@ -252,11 +252,13 @@
 
     <!-- Default for Settings.Global.DEVELOPMENT_ENABLE_NON_RESIZABLE_MULTI_WINDOW -->
     <bool name="def_enable_non_resizable_multi_window">false</bool>
 
     <!-- Default for Settings.Secure.ACCESSIBILITY_BUTTON_MODE -->
     <integer name="def_accessibility_button_mode">1</integer>
 
     <!-- Default for Settings.Secure.ONE_HANDED_MODE_ACTIVATED -->
     <bool name="def_one_handed_mode_activated">false</bool>
 
+    <bool name="def_text_show_password">false</bool>
+
 </resources>
diff --git a/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java b/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
index 268603fa8b0d71d87aca4527ecd807fef82bae59..537090b83e94b58fa35e28d795b9b9335a52c023 100644
--- a/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
+++ b/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
@@ -2270,20 +2270,23 @@ class DatabaseHelper extends SQLiteOpenHelper {
             loadDefaultHapticSettings(stmt);
 
             loadBooleanSetting(stmt, Settings.System.NOTIFICATION_LIGHT_PULSE,
                     R.bool.def_notification_pulse);
 
             loadUISoundEffectsSettings(stmt);
 
             loadIntegerSetting(stmt, Settings.System.POINTER_SPEED,
                     R.integer.def_pointer_speed);
 
+            loadBooleanSetting(stmt, Settings.System.TEXT_SHOW_PASSWORD,
+                    R.bool.def_text_show_password);
+
             /*
              * IMPORTANT: Do not add any more upgrade steps here as the global,
              * secure, and system settings are no longer stored in a database
              * but are kept in memory and persisted to XML.
              *
              * See: SettingsProvider.UpgradeController#onUpgradeLocked
              */
         } finally {
             if (stmt != null) stmt.close();
         }

commit 9698e11c2288cb91fc5c851ca52278e85b6bdcf2
Author: inthewaves <inthewaves@pm.me>
Date:   Sun 2020-09-20 14:59:10-0700

    have NfcTile get an NfcAdapter directly
    
    This changes the NfcTile to not be dependent on an NfcManager giving the
    NfcTile an NfcAdapter.
    
    The problem with NfcTile is that the NfcService doesn't start until the
    device is unlocked after a reboot, but NfcTile can be created and have
    its state updated before the device is unlocked.
    
    The state of NfcTile depends on an NfcAdapter. The tile gets an
    NfcAdapter from a call to NfcAdapter#getDefaultAdapter, which gets an
    adapter from an NfcManager via Context#getSystemService, and NfcManager
    tries to get an adapter in its constructor via NfcAdapter#getNfcAdapter.
    
    If this is done before unlock, NfcService isn't started, so the
    constructor of NfcManager fails to get an adapter, opting to just store
    null. This means that the NfcManager that's _cached_ by the NfcTile's
    application context holds a null NfcAdapter, so subsequent calls in
    NfcTile to get the NfcAdapter will keep returning null.
    
    We can just have NfcTile get the NfcAdapter directly via
    NfcAdapter#getNfcAdapter instead of relying on an NfcManager to call the
    same method for us to get its default adapter. We just have to make sure
    we use the application context for NfcAdapter#getNfcAdapter, as per the
    doc comments for getNfcAdapter. This means that there's no longer an
    NfcManager associated with the NfcTile's application context.
    
    It doesn't look like NfcManager does anything special with the
    NfcAdapter anyway. It seems to just be some middle man for NfcAdapters:
    * The NfcAdapter field in NfcManager is final, and it doesn't do
    anything else with it besides have a getter method for returning it. The
    NfcManager seems to be a way to force third-party apps that want to get
    an NfcAdapter to use the application context.
    * NfcAdapter#getNfcAdapter manages the caching of NfcAdapters by
    application context in a static HashMap. NfcManager doesn't manage
    caching; it just calls NfcAdapter#getNfcAdapter.
---
 packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java
index 590215101fb368eec81536fd4f19e1e5bb8287e0..1bd913ea9496b0b08274c338583bbc7457e6c269 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java
@@ -158,21 +158,21 @@ public class NfcTile extends SecureQSTile<BooleanState> {
         if (mState.value) {
             return mContext.getString(R.string.quick_settings_nfc_on);
         } else {
             return mContext.getString(R.string.quick_settings_nfc_off);
         }
     }
 
     private NfcAdapter getAdapter() {
         if (mAdapter == null) {
             try {
-                mAdapter = NfcAdapter.getDefaultAdapter(mContext);
+                mAdapter = NfcAdapter.getNfcAdapter(mContext.getApplicationContext());
             } catch (UnsupportedOperationException e) {
                 mAdapter = null;
             }
         }
         return mAdapter;
     }
 
     private BroadcastReceiver mNfcReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {

commit 0d7a596fa75e04011d6c6e25de3d79b50b10a1b5
Author: flawedworld <flawedworld@flawed.world>
Date:   Fri 2021-10-15 17:07:13+0100

    enable secondary user logout support by default
    
    Ported from 11, 12 moved the isLogoutEnabled boolean to ActiveAdmin.java
---
 .../java/com/android/server/devicepolicy/ActiveAdmin.java             | 2 +-
 .../com/android/server/devicepolicy/DevicePolicyManagerService.java   | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/services/devicepolicy/java/com/android/server/devicepolicy/ActiveAdmin.java b/services/devicepolicy/java/com/android/server/devicepolicy/ActiveAdmin.java
index 37a84f3698c13d880cbdd37e9486a54633c3d856..0ae88276ebda6b13e890a219cfa9067e66f7b3fd 100644
--- a/services/devicepolicy/java/com/android/server/devicepolicy/ActiveAdmin.java
+++ b/services/devicepolicy/java/com/android/server/devicepolicy/ActiveAdmin.java
@@ -190,21 +190,21 @@ class ActiveAdmin {
     boolean encryptionRequested = false;
     boolean testOnlyAdmin = false;
     boolean disableCamera = false;
     boolean disableCallerId = false;
     boolean disableContactsSearch = false;
     boolean disableBluetoothContactSharing = true;
     boolean disableScreenCapture = false;
     boolean requireAutoTime = false;
     boolean forceEphemeralUsers = false;
     boolean isNetworkLoggingEnabled = false;
-    boolean isLogoutEnabled = false;
+    boolean isLogoutEnabled = true;
 
     // one notification after enabling + one more after reboots
     static final int DEF_MAXIMUM_NETWORK_LOGGING_NOTIFICATIONS_SHOWN = 2;
     int numNetworkLoggingNotifications = 0;
     long lastNetworkLoggingNotificationTimeMs = 0; // Time in milliseconds since epoch
 
     ActiveAdmin parentAdmin;
     final boolean isParent;
 
     static class TrustAgentInfo {
diff --git a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java
index d48c9ea4831c78c0686a4bbeded829e47cd49928..f77df5c81f577f4ea1005c2210a49a5c08f01527 100644
--- a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java
+++ b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java
@@ -15533,25 +15533,25 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
                 return;
             }
             deviceOwner.isLogoutEnabled = enabled;
             saveSettingsLocked(caller.getUserId());
         }
     }
 
     @Override
     public boolean isLogoutEnabled() {
         if (!mHasFeature) {
-            return false;
+            return true;
         }
         synchronized (getLockObject()) {
             ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();
-            return (deviceOwner != null) && deviceOwner.isLogoutEnabled;
+            return (deviceOwner == null) || deviceOwner.isLogoutEnabled;
         }
     }
 
     @Override
     public List<String> getDisallowedSystemApps(ComponentName admin, int userId,
             String provisioningAction) throws RemoteException {
         Preconditions.checkCallAuthorization(
                 hasCallingOrSelfPermission(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS));
 
         return new ArrayList<>(

commit 71684f370781e7a31bb2a47a364bbb620fd838f8
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2020-12-20 15:53:52-0500

    add check for empty TTS engine name
---
 core/java/android/speech/tts/TtsEngines.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/java/android/speech/tts/TtsEngines.java b/core/java/android/speech/tts/TtsEngines.java
index a8aea7c1eb599bcf8d66f0ef25099691c32eb8a2..3697b9494949d93a83c6fe1136140f465d3b3863 100644
--- a/core/java/android/speech/tts/TtsEngines.java
+++ b/core/java/android/speech/tts/TtsEngines.java
@@ -491,21 +491,21 @@ public class TtsEngines {
         }
     }
 
     /**
      * Parses a comma separated list of engine locale preferences. The list is of the
      * form {@code "engine_name_1:locale_1,engine_name_2:locale2"} and so on and
      * so forth. Returns null if the list is empty, malformed or if there is no engine
      * specific preference in the list.
      */
     private static String parseEnginePrefFromList(String prefValue, String engineName) {
-        if (TextUtils.isEmpty(prefValue)) {
+        if (TextUtils.isEmpty(prefValue) || TextUtils.isEmpty(engineName)) {
             return null;
         }
 
         String[] prefValues = prefValue.split(",");
 
         for (String value : prefValues) {
             final int delimiter = value.indexOf(':');
             if (delimiter > 0) {
                 if (engineName.equals(value.substring(0, delimiter))) {
                     return value.substring(delimiter + 1);

commit d00c372e34f5a88bb4f381c3ecc05ebcff75408a
Author: inthewaves <inthewaves@pm.me>
Date:   Thu 2021-05-06 20:42:26-0700

    use more loadDrawableAsUser in MediaDataManager
---
 packages/SystemUI/src/com/android/systemui/media/MediaDataManager.kt | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/packages/SystemUI/src/com/android/systemui/media/MediaDataManager.kt b/packages/SystemUI/src/com/android/systemui/media/MediaDataManager.kt
index eacdab6e537da03add1f2c5567619d1b95569dfb..873987deaa0794a7846c644be34041be3b78b6c7 100644
--- a/packages/SystemUI/src/com/android/systemui/media/MediaDataManager.kt
+++ b/packages/SystemUI/src/com/android/systemui/media/MediaDataManager.kt
@@ -540,21 +540,22 @@ class MediaDataManager(
         } else {
             Icon.createWithBitmap(artworkBitmap)
         }
         if (artWorkIcon != null) {
             // If we have art, get colors from that
             if (artworkBitmap == null) {
                 if (artWorkIcon.type == Icon.TYPE_BITMAP ||
                         artWorkIcon.type == Icon.TYPE_ADAPTIVE_BITMAP) {
                     artworkBitmap = artWorkIcon.bitmap
                 } else {
-                    val drawable: Drawable = artWorkIcon.loadDrawable(context)
+                    val drawable: Drawable = artWorkIcon.loadDrawableAsUser(context,
+                            sbn.user.identifier)
                     artworkBitmap = Bitmap.createBitmap(
                             drawable.intrinsicWidth,
                             drawable.intrinsicHeight,
                             Bitmap.Config.ARGB_8888)
                     val canvas = Canvas(artworkBitmap)
                     drawable.setBounds(0, 0, drawable.intrinsicWidth, drawable.intrinsicHeight)
                     drawable.draw(canvas)
                 }
             }
         }

commit df6c3b06db535f6c2d61c40835e1d6b7d886a52a
Author: pratyush <codelab@pratyush.dev>
Date:   Thu 2021-07-01 12:26:49+0530

    Bluetooth auto turn off
---
 core/java/android/provider/Settings.java           |  6 ++
 .../android/server/BluetoothManagerService.java    | 76 ++++++++++++++++++++++
 2 files changed, 82 insertions(+)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 6c8d8aa379a84173f32eb4487ee6f98490fb1f5c..30b39c6e6bb61a7f4902cba948101957c23f7391 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -16198,20 +16198,26 @@ public final class Settings {
          * @hide
          */
         public static final String RESTRICTED_NETWORKING_MODE = "restricted_networking_mode";
 
         /**
          * Whether to automatically reboot the device after a user defined timeout
          *
          * @hide
          */
         public static final String SETTINGS_REBOOT_AFTER_TIMEOUT = "settings_reboot_after_timeout";
+        
+        /**
+         * The amount of time in milliseconds before bluetooth is turned off
+         * @hide
+         */
+        public static final String BLUETOOTH_OFF_TIMEOUT = "bluetooth_off_timeout";
     }
 
     /**
      * Configuration system settings, containing settings which are applied identically for all
      * defined users. Only Android can read these and only a specific configuration service can
      * write these.
      *
      * @hide
      */
     public static final class Config extends NameValueTable {
diff --git a/services/core/java/com/android/server/BluetoothManagerService.java b/services/core/java/com/android/server/BluetoothManagerService.java
index 51066dd837e2692b8e8d99470c6189bf21034611..76fb570ddf71d53707d9b8b5d50e7602c6cdcd41 100644
--- a/services/core/java/com/android/server/BluetoothManagerService.java
+++ b/services/core/java/com/android/server/BluetoothManagerService.java
@@ -22,20 +22,21 @@ import static android.content.PermissionChecker.PID_UNKNOWN;
 import static android.content.pm.PackageManager.MATCH_SYSTEM_ONLY;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.os.PowerExemptionManager.TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_ALLOWED;
 import static android.os.UserHandle.USER_SYSTEM;
 
 import android.Manifest;
 import android.annotation.NonNull;
 import android.annotation.RequiresPermission;
 import android.annotation.SuppressLint;
 import android.app.ActivityManager;
+import android.app.AlarmManager;
 import android.app.AppGlobals;
 import android.app.AppOpsManager;
 import android.app.BroadcastOptions;
 import android.bluetooth.BluetoothA2dp;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothHearingAid;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.BluetoothProtoEnums;
 import android.bluetooth.IBluetooth;
 import android.bluetooth.IBluetoothCallback;
@@ -546,20 +547,95 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
             systemUiUid = pm.getPackageUid(pm.getSystemUiServiceComponent().getPackageName(),
                     MATCH_SYSTEM_ONLY, USER_SYSTEM);
         }
         if (systemUiUid >= 0) {
             Slog.d(TAG, "Detected SystemUiUid: " + Integer.toString(systemUiUid));
         } else {
             // Some platforms, such as wearables do not have a system ui.
             Slog.w(TAG, "Unable to resolve SystemUI's UID.");
         }
         mSystemUiUid = systemUiUid;
+
+        /*
+        * System sends ACTION_STATE_CHANGED broadcast soon as any state
+        * changes. what it means in action is we don't have to take care if
+        * device reboot while BT has not been turned off automatically.
+        *
+        * A word of warning though it does not check if device as been
+        * unlocked or not what it means in real life is if you have sometime
+        * like tile ble tracker configured it will turn off BT. As result tile
+        * tracking will fail because of auto timeout. this behaviour can be
+        * changed with UserManager.isUnlocked()
+        * */
+        IntentFilter btFilter = new IntentFilter();
+        btFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
+        btFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
+        btFilter.addAction(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
+        context.registerReceiver(new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context broadcastContext, Intent intent) {
+                reconfigureBtTimeoutListener();
+            }
+        }, btFilter);
+
+        context.getContentResolver().registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.BLUETOOTH_OFF_TIMEOUT),
+                false,
+                new ContentObserver(new Handler(context.getMainLooper())) {
+                    @Override
+                    public void onChange(boolean selfChange) {
+                        super.onChange(selfChange);
+                        reconfigureBtTimeoutListener();
+                    }
+                });
+    }
+
+    private static final AlarmManager.OnAlarmListener listener = () -> {
+        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+        if (isBtOnAndDisconnected() && bluetoothAdapter != null) {
+            bluetoothAdapter.disable();
+        }
+    };
+
+    // If device is still connected cancel timeout for now and wait for disconnected signal
+    private void reconfigureBtTimeoutListener() {
+        AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
+        if (isTimeoutEnabled(mContext) && isBtOnAndDisconnected()) {
+            final long timeout = SystemClock.elapsedRealtime() + btTimeoutDurationInMilli(mContext);
+            alarmManager.cancel(listener);
+            alarmManager.setExact(
+                    AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                    timeout,
+                    "BT Idle Timeout",
+                    listener,
+                    new Handler(mContext.getMainLooper())
+            );
+        } else {
+            alarmManager.cancel(listener);
+        }
+    }
+
+    private static boolean isBtOnAndDisconnected() {
+        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+        return bluetoothAdapter != null && bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON
+                && bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON &&
+                bluetoothAdapter.getConnectionState() == BluetoothAdapter.STATE_DISCONNECTED;
+    }
+
+    private static long btTimeoutDurationInMilli(Context context) {
+        return Settings.Global.getLong(context.getContentResolver(),
+                Settings.Global.BLUETOOTH_OFF_TIMEOUT, 0);
+    }
+
+    /** Zero is default and means disabled */
+    private static boolean isTimeoutEnabled(Context context) {
+        return 0 != btTimeoutDurationInMilli(context);
     }
 
     /**
      *  Returns true if airplane mode is currently on
      */
     private boolean isAirplaneModeOn() {
         return Settings.Global.getInt(mContext.getContentResolver(),
                 Settings.Global.AIRPLANE_MODE_ON, 0) == 1;
     }
 

commit 48b44d9d517b96bae23778f9120861d9ccef7720
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Mon 2018-04-02 12:59:51-0400

    use Cloudflare DNS as the default fallback
    
    Cloudflare DNS has a better privacy policy than Google Public DNS while
    still supporting DNS over TLS.
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 52574384051bb3c741af75820c6b2089b1476216..4f792cf2fc911096a1a7d17c3b3f6474ec1ec044 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2004,21 +2004,21 @@
     <string name="config_systemTelevisionRemoteService" translatable="false">@string/config_tvRemoteServicePackage</string>
 
     <!-- The name of the package that will be allowed to change its components' label/icon. -->
     <string name="config_overrideComponentUiPackage" translatable="false">com.android.stk</string>
 
     <!-- Enable/disable default bluetooth profiles:
         HSP_AG, ObexObjectPush, Audio, NAP -->
     <bool name="config_bluetooth_default_profiles">true</bool>
 
     <!-- IP address of the dns server to use if nobody else suggests one -->
-    <string name="config_default_dns_server" translatable="false">8.8.8.8</string>
+    <string name="config_default_dns_server" translatable="false">1.0.0.1</string>
 
     <!-- The default mobile provisioning apn. Empty by default, maybe overridden by
          an mcc/mnc specific config.xml -->
     <string name="mobile_provisioning_apn" translatable="false"></string>
 
     <!-- The default mobile provisioning url. Empty by default, maybe overridden by
          an mcc/mnc specific config.xml -->
     <string name="mobile_provisioning_url" translatable="false"></string>
 
     <!-- The default character set for GsmAlphabet -->

commit 823de121e46ef160a016e5dc0db91e98e0b33aa5
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Mon 2018-04-02 10:37:46-0400

    SettingsLib: use Cloudflare DNS servers as hints
    
    Cloudflare DNS has a better privacy policy than Google Public DNS while
    still supporting DNS over TLS.
---
 packages/SettingsLib/res/values/strings.xml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/packages/SettingsLib/res/values/strings.xml b/packages/SettingsLib/res/values/strings.xml
index 6b840bd7901d382522c82678f550a5cc2938d6a0..b5006f34c628d1f960b286f6da063d62b4403c9f 100644
--- a/packages/SettingsLib/res/values/strings.xml
+++ b/packages/SettingsLib/res/values/strings.xml
@@ -1180,23 +1180,23 @@
 
     <!-- Label for length of time since the battery graph started [CHAR LIMIT=20] -->
     <string name="charge_length_format"><xliff:g name="time" example="3 hours">%1$s</xliff:g> ago</string>
 
     <!-- Label for length of time until battery is charged [CHAR LIMIT=20] -->
     <string name="remaining_length_format"><xliff:g name="time" example="3 hours">%1$s</xliff:g> left</string>
 
     <!-- Hint text for the IP address -->
     <string name="wifi_ip_address_hint" translatable="false">192.168.1.128</string>
     <!-- Hint text for DNS -->
-    <string name="wifi_dns1_hint" translatable="false">8.8.8.8</string>
+    <string name="wifi_dns1_hint" translatable="false">1.0.0.1</string>
     <!-- Hint text for DNS -->
-    <string name="wifi_dns2_hint" translatable="false">8.8.4.4</string>
+    <string name="wifi_dns2_hint" translatable="false">1.1.1.1</string>
     <!-- Hint text for the gateway -->
     <string name="wifi_gateway_hint" translatable="false">192.168.1.1</string>
     <!-- Hint text for network prefix length -->
     <string name="wifi_network_prefix_length_hint" translatable="false">24</string>
     <!-- HTTP proxy settings. The hint text field for port. -->
     <string name="proxy_port_hint" translatable="false">8080</string>
     <!-- HTTP proxy settings. Hint for Proxy-Auto Config URL. -->
     <string name="proxy_url_hint" translatable="false">https://www.example.com/proxy.pac</string>
     <!-- HTTP proxy settings. The hint text for proxy exclusion list. -->
     <string name="proxy_exclusionlist_hint" translatable="false">example.com,mycomp.test.com,localhost</string>

commit 3c63c4e393fdbedb07b086f76daa9d617295310d
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2019-05-16 11:47:02-0400

    raise maximum users to 16
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 4f792cf2fc911096a1a7d17c3b3f6474ec1ec044..4347621f8f150b3824d8965122778ce7582a9dbd 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2477,21 +2477,21 @@
     <integer-array translatable="false" name="config_oemUsbModeOverride">
     </integer-array>
 
     <!-- Set to true to add links to Cell Broadcast app from Settings and MMS app. -->
     <bool name="config_cellBroadcastAppLinks">true</bool>
 
     <!-- The default value if the SyncStorageEngine should sync automatically or not -->
     <bool name="config_syncstorageengine_masterSyncAutomatically">true</bool>
 
     <!--  Maximum number of supported users -->
-    <integer name="config_multiuserMaximumUsers">4</integer>
+    <integer name="config_multiuserMaximumUsers">16</integer>
 
     <!-- Maximum number of users we allow to be running at a time -->
     <integer name="config_multiuserMaxRunningUsers">3</integer>
 
     <!-- Whether to delay user data locking for background user.
          If false, user switched-out from user switching will still be in running state until
          config_multiuserMaxRunningUsers is reached. Once config_multiuserMaxRunningUsers is
          reached, user will be stopped and user data is locked.
          If true, user switched out from user switching will always be stopped but its user data
          is not locked. Total number of unlocked users will be limited by

commit 7ec8419401294b009294b253fda22065b8cabea1
Author: Pratyush <codelab@pratyush.dev>
Date:   Tue 2021-07-06 18:18:06+0530

    Wi-Fi auto turn off
---
 core/java/android/provider/Settings.java           |  6 ++
 .../android/server/net/NetworkStatsService.java    | 69 ++++++++++++++++++++++
 2 files changed, 75 insertions(+)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 30b39c6e6bb61a7f4902cba948101957c23f7391..fd85557031bafcbc25a65b41f17826090503a74d 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -16192,20 +16192,26 @@ public final class Settings {
          * Used to enable / disable the Restricted Networking Mode in which network access is
          * restricted to apps holding the CONNECTIVITY_USE_RESTRICTED_NETWORKS permission.
          *
          * Values are:
          * 0: disabled
          * 1: enabled
          * @hide
          */
         public static final String RESTRICTED_NETWORKING_MODE = "restricted_networking_mode";
 
+        /**
+         * The amount of time in milliseconds before Wi-Fi is turned off
+         * @hide
+         */
+        public static final String WIFI_OFF_TIMEOUT = "wifi_off_timeout";
+
         /**
          * Whether to automatically reboot the device after a user defined timeout
          *
          * @hide
          */
         public static final String SETTINGS_REBOOT_AFTER_TIMEOUT = "settings_reboot_after_timeout";
         
         /**
          * The amount of time in milliseconds before bluetooth is turned off
          * @hide
diff --git a/services/core/java/com/android/server/net/NetworkStatsService.java b/services/core/java/com/android/server/net/NetworkStatsService.java
index 097b0711eff7813448ef7ae872421f8d6179e51d..0a4fca3ec09d53199397713d9e8c437fb696ce83 100644
--- a/services/core/java/com/android/server/net/NetworkStatsService.java
+++ b/services/core/java/com/android/server/net/NetworkStatsService.java
@@ -89,36 +89,39 @@ import android.content.IntentFilter;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.database.ContentObserver;
 import android.net.DataUsageRequest;
 import android.net.INetworkManagementEventObserver;
 import android.net.INetworkStatsService;
 import android.net.INetworkStatsSession;
 import android.net.Network;
 import android.net.NetworkCapabilities;
 import android.net.NetworkIdentity;
+import android.net.NetworkInfo;
 import android.net.NetworkSpecifier;
 import android.net.NetworkStack;
 import android.net.NetworkStateSnapshot;
 import android.net.NetworkStats;
 import android.net.NetworkStats.NonMonotonicObserver;
 import android.net.NetworkStatsHistory;
 import android.net.NetworkTemplate;
 import android.net.TelephonyNetworkSpecifier;
 import android.net.TrafficStats;
 import android.net.UnderlyingNetworkInfo;
 import android.net.Uri;
 import android.net.netstats.provider.INetworkStatsProvider;
 import android.net.netstats.provider.INetworkStatsProviderCallback;
 import android.net.netstats.provider.NetworkStatsProvider;
+import android.net.wifi.WifiManager;
 import android.os.BestClock;
 import android.os.Binder;
+import android.os.Bundle;
 import android.os.DropBoxManager;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerExecutor;
 import android.os.HandlerThread;
 import android.os.IBinder;
 import android.os.INetworkManagementService;
 import android.os.Looper;
 import android.os.Message;
 import android.os.Messenger;
@@ -442,20 +445,86 @@ public class NetworkStatsService extends INetworkStatsService.Stub {
         mDeps = Objects.requireNonNull(deps, "missing Dependencies");
 
         final HandlerThread handlerThread = mDeps.makeHandlerThread();
         handlerThread.start();
         mHandler = new NetworkStatsHandler(handlerThread.getLooper());
         mNetworkStatsSubscriptionsMonitor = deps.makeSubscriptionsMonitor(mContext,
                 mHandler.getLooper(), new HandlerExecutor(mHandler), this);
         mContentResolver = mContext.getContentResolver();
         mContentObserver = mDeps.makeContentObserver(mHandler, mSettings,
                 mNetworkStatsSubscriptionsMonitor);
+        IntentFilter wifiFilter = new IntentFilter();
+        wifiFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
+        wifiFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
+
+        context.registerReceiver(
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                        if (WifiManager.NETWORK_STATE_CHANGED_ACTION.equals(intent.getAction())) {
+                            Bundle bundle = intent.getExtras();
+                            NetworkInfo networkInfo = bundle.getParcelable(WifiManager.EXTRA_NETWORK_INFO);
+                            isWifiConnected = networkInfo != null && networkInfo.isConnected();
+                        }
+                        reconfigureWiFiTimeoutListener();
+                    }
+                }, wifiFilter
+        );
+
+        context.getContentResolver().registerContentObserver(
+                Global.getUriFor(Global.WIFI_OFF_TIMEOUT),
+                false,
+                new ContentObserver(new Handler(context.getMainLooper())) {
+                    @Override
+                    public void onChange(boolean selfChange) {
+                        super.onChange(selfChange);
+                        reconfigureWiFiTimeoutListener();
+                    }
+                });
+    }
+
+    private static boolean isWifiConnected = false;
+    private final AlarmManager.OnAlarmListener listener = this::turnOffWifi;
+
+    private void turnOffWifi() {
+        WifiManager wifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
+        if (isWifiTimeoutEnabled(mContext) && wifiManager.isWifiEnabled()) {
+            // setWifiEnabled(enabled) is deprecated, though AOSP still uses
+            // it internally and system apps/services are exempted
+            wifiManager.setWifiEnabled(false);
+        }
+    }
+
+    private void reconfigureWiFiTimeoutListener() {
+        if (isWifiTimeoutEnabled(mContext) && !isWifiConnected) {
+            final long timeout = SystemClock.elapsedRealtime() + wifiTimeoutDurationInMilli(mContext);
+            mAlarmManager.cancel(listener);
+            mAlarmManager.setExact(
+                    AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                    timeout,
+                    "Wi-Fi Idle Timeout",
+                    listener,
+                    new Handler(mContext.getMainLooper())
+            );
+        } else {
+            mAlarmManager.cancel(listener);
+        }
+    }
+
+    private static long wifiTimeoutDurationInMilli(Context mContext) {
+        return Settings.Global.getLong(mContext.getContentResolver(),
+                Global.WIFI_OFF_TIMEOUT, 0);
+    }
+
+    /** Zero is default and means disabled */
+    private static boolean isWifiTimeoutEnabled(Context mContext) {
+        return 0 != wifiTimeoutDurationInMilli(mContext);
     }
 
     /**
      * Dependencies of NetworkStatsService, for injection in tests.
      */
     // TODO: Move more stuff into dependencies object.
     @VisibleForTesting
     public static class Dependencies {
         /**
          * Create a HandlerThread to use in NetworkStatsService.

commit 3977ccbc35fb763f1475f932430a6629b557f9f3
Author: flawedworld <flawedworld@flawed.world>
Date:   Tue 2021-10-19 00:46:21+0100

    Migration for legacy fingerprint keyguard toggle to modern biometric keyguard toggle
---
 .../src/com/android/providers/settings/SettingsProvider.java | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java b/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java
index db301f698753620069438202df3f160cd0ac89dd..c3b1612907bb2bc2a4a7aee07890a3d423aff19f 100644
--- a/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java
+++ b/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java
@@ -5217,20 +5217,32 @@ public class SettingsProvider extends ContentProvider {
                             tiles.remove("wifi");
                             tiles.remove("cell");
                         }
                         secureSettings.insertSettingOverrideableByRestoreLocked(
                                 Secure.QS_TILES,
                                 TextUtils.join(",", tiles),
                                 null /* tag */,
                                 true /* makeDefault */,
                                 SettingsState.SYSTEM_PACKAGE_NAME);
                     }
+                    // Migrate legacy fingerprint keyguard toggle to new unified
+                    // biometric api toggle
+                    final Setting oldFingerSetting = secureSettings.getSettingLocked("fingerprint_unlock_keyguard_enabled");
+                    if (!oldFingerSetting.isNull()) {
+                        secureSettings.insertSettingLocked(
+                                Secure.BIOMETRIC_KEYGUARD_ENABLED,
+                                oldFingerSetting.getValue(),
+                                null,
+                                false,
+                                SettingsState.SYSTEM_PACKAGE_NAME);
+                        secureSettings.deleteSettingLocked("fingerprint_unlock_keyguard_enabled");
+                    }
                     currentVersion = 204;
                 }
 
                 // vXXX: Add new settings above this point.
 
                 if (currentVersion != newVersion) {
                     Slog.wtf("SettingsProvider", "warning: upgrading settings database to version "
                             + newVersion + " left it at "
                             + currentVersion +
                             " instead; this is probably a bug. Did you update SETTINGS_VERSION?",

commit b12b347a03088a17e9beeeb5691a1cd1a0a35295
Author: randomhydrosol <randomhydrosol@glassrom.org>
Date:   Tue 2021-10-19 01:31:34+0100

    Only use GNSS provided time when NITZ is enabled
---
 .../java/com/android/server/timedetector/TimeDetectorStrategyImpl.java  | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java b/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java
index 5c95d02a34de3b810fa9e4ad4d0019ac134af1eb..0508789251927ebca9e6780531814d278680fd87 100644
--- a/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java
+++ b/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java
@@ -466,21 +466,21 @@ public final class TimeDetectorStrategyImpl implements TimeDetectorStrategy {
                             + ", detectionReason=" + detectionReason;
                 }
             } else if (origin == ORIGIN_NETWORK) {
                 NetworkTimeSuggestion networkSuggestion = findLatestValidNetworkSuggestion();
                 if (networkSuggestion != null) {
                     newUtcTime = networkSuggestion.getUtcTime();
                     cause = "Found good network suggestion."
                             + ", networkSuggestion=" + networkSuggestion
                             + ", detectionReason=" + detectionReason;
                 }
-            } else if (origin == ORIGIN_GNSS) {
+            } else if (mEnvironment.isNITZTimeDetectionEnabled() && origin == ORIGIN_GNSS) {
                 GnssTimeSuggestion gnssTimeSuggestion = findLatestValidGnssSuggestion();
                 if (gnssTimeSuggestion != null) {
                     newUtcTime = gnssTimeSuggestion.getUtcTime();
                     cause = "Found good gnss suggestion."
                             + ", gnssTimeSuggestion=" + gnssTimeSuggestion
                             + ", detectionReason=" + detectionReason;
                 }
             } else if (origin == ORIGIN_EXTERNAL) {
                 ExternalTimeSuggestion externalTimeSuggestion = findLatestValidExternalSuggestion();
                 if (externalTimeSuggestion != null) {

commit 91f3f988317748984b1b084a4c7e6c7bbb9b8f94
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2021-10-19 08:05:17-0400

    change default quick tiles and quick tile order
---
 packages/SystemUI/res/values/config.xml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/packages/SystemUI/res/values/config.xml b/packages/SystemUI/res/values/config.xml
index 8bd036b70d5f92ea5ea64cf4302dc8756b58d7bd..d3d047df8a3714576341a83089d669a0dac595bf 100644
--- a/packages/SystemUI/res/values/config.xml
+++ b/packages/SystemUI/res/values/config.xml
@@ -92,29 +92,29 @@
     <integer name="quick_settings_num_columns">2</integer>
 
     <!-- The number of rows in the QuickSettings -->
     <integer name="quick_settings_max_rows">4</integer>
 
     <!-- The number of columns that the top level tiles span in the QuickSettings -->
     <integer name="quick_settings_user_time_settings_tile_span">1</integer>
 
     <!-- The default tiles to display in QuickSettings -->
     <string name="quick_settings_tiles_default" translatable="false">
-        internet,bt,flashlight,dnd,alarm,airplane,controls,wallet,rotation,battery,cast,screenrecord,mictoggle,cameratoggle
+        internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location
     </string>
 
     <!-- The minimum number of tiles to display in QuickSettings -->
     <integer name="quick_settings_min_num_tiles">6</integer>
 
     <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default" -->
     <string name="quick_settings_tiles_stock" translatable="false">
-        internet,bt,flashlight,dnd,alarm,airplane,controls,wallet,rotation,battery,cast,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness
+        internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness,controls,wallet,cast
     </string>
 
     <!-- The tiles to display in QuickSettings -->
     <string name="quick_settings_tiles" translatable="false">default</string>
 
     <!-- The tiles to display in QuickSettings in retail mode -->
     <string name="quick_settings_tiles_retail_mode" translatable="false">
         night,dark,dnd,flashlight,rotation,location
     </string>
 

commit f31cc69fd72d69c65ca6b3821f5c6e922acb0c28
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Mon 2021-03-15 23:57:54-0400

    set GrapheneOS launcher as notification listener
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 4347621f8f150b3824d8965122778ce7582a9dbd..32bfbdffae12cc688f06a0dfc26c629dd3eb2098 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -3799,21 +3799,21 @@
          and followed the pertinent sections of the escrow tokens section of the CDD <link>-->
     <!-- TODO(b/35230407) complete the link field -->
     <bool name="config_allowEscrowTokenForTrustAgent">false</bool>
 
     <!-- A flattened ComponentName which corresponds to the only trust agent that should be enabled
          by default. If the default value is used, or set to an empty string, the restriction will
          not be applied. -->
     <string name="config_defaultTrustAgent" translatable="false"></string>
 
     <!-- Colon separated list of package names that should be granted Notification Listener access -->
-    <string name="config_defaultListenerAccessPackages" translatable="false"></string>
+    <string name="config_defaultListenerAccessPackages" translatable="false">com.android.launcher3</string>
 
     <!-- Maximum size, specified in pixels, to restrain the display space width to. Height and
          density will be scaled accordingly to maintain aspect ratio. A value of 0 indicates no
          constraint will be enforced. -->
     <integer name="config_maxUiWidth">0</integer>
 
     <!-- Whether the device supports quick settings and its associated APIs -->
     <bool name="config_quickSettingsSupported">true</bool>
 
     <!-- The component name, flattened to a string, for the default autofill service

commit 9e69600f5a105cf9716ea0f3d331ea3877b6ea94
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2021-10-26 01:31:20-0400

    add missing display cutout overlays
---
 packages/overlays/Android.mk | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/packages/overlays/Android.mk b/packages/overlays/Android.mk
index a6bb258bccb0d907557854d710ab90a18264d3ee..a93b3c72b50b240cd28855014f21d8cfd529b991 100644
--- a/packages/overlays/Android.mk
+++ b/packages/overlays/Android.mk
@@ -13,33 +13,37 @@
 # limitations under the License.
 
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
 LOCAL_MODULE := frameworks-base-overlays
 LOCAL_LICENSE_KINDS := SPDX-license-identifier-Apache-2.0
 LOCAL_LICENSE_CONDITIONS := notice
 LOCAL_NOTICE_FILE := $(LOCAL_PATH)/../../NOTICE
 LOCAL_REQUIRED_MODULES := \
+	AvoidAppsInCutoutOverlay \
 	DisplayCutoutEmulationCornerOverlay \
 	DisplayCutoutEmulationDoubleOverlay \
-    DisplayCutoutEmulationHoleOverlay \
+	DisplayCutoutEmulationHoleOverlay \
+	DisplayCutoutEmulationNarrowOverlay \
 	DisplayCutoutEmulationTallOverlay \
 	DisplayCutoutEmulationWaterfallOverlay \
+	DisplayCutoutEmulationWideOverlay \
 	FontNotoSerifSourceOverlay \
 	NavigationBarMode3ButtonOverlay \
 	NavigationBarMode2ButtonOverlay \
 	NavigationBarModeGesturalOverlay \
 	NavigationBarModeGesturalOverlayNarrowBack \
 	NavigationBarModeGesturalOverlayWideBack \
 	NavigationBarModeGesturalOverlayExtraWideBack \
-        OneHandedModeGesturalOverlay \
+	NoCutoutOverlay \
+	OneHandedModeGesturalOverlay \
 	preinstalled-packages-platform-overlays.xml
 
 include $(BUILD_PHONY_PACKAGE)
 include $(CLEAR_VARS)
 
 LOCAL_MODULE := frameworks-base-overlays-debug
 LOCAL_LICENSE_KINDS := SPDX-license-identifier-Apache-2.0
 LOCAL_LICENSE_CONDITIONS := notice
 LOCAL_NOTICE_FILE := $(LOCAL_PATH)/../../NOTICE
 

commit 6528d4f82cfba1631b6642845b964f45459f34f7
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2021-10-21 14:41:10-0400

    support using the legacy wifi/cell quick tiles
---
 packages/SystemUI/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/packages/SystemUI/res/values/config.xml b/packages/SystemUI/res/values/config.xml
index d3d047df8a3714576341a83089d669a0dac595bf..4cce2285a60ae5baf0bddbd928f479a7db24cff2 100644
--- a/packages/SystemUI/res/values/config.xml
+++ b/packages/SystemUI/res/values/config.xml
@@ -100,21 +100,21 @@
     <!-- The default tiles to display in QuickSettings -->
     <string name="quick_settings_tiles_default" translatable="false">
         internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location
     </string>
 
     <!-- The minimum number of tiles to display in QuickSettings -->
     <integer name="quick_settings_min_num_tiles">6</integer>
 
     <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default" -->
     <string name="quick_settings_tiles_stock" translatable="false">
-        internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness,controls,wallet,cast
+        internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness,controls,wallet,cast,wifi,cell
     </string>
 
     <!-- The tiles to display in QuickSettings -->
     <string name="quick_settings_tiles" translatable="false">default</string>
 
     <!-- The tiles to display in QuickSettings in retail mode -->
     <string name="quick_settings_tiles_retail_mode" translatable="false">
         night,dark,dnd,flashlight,rotation,location
     </string>
 

commit 969a226b92a087f767535e49d7aac154ab32d5b3
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2021-10-22 20:51:50-0400

    Revert "support using the legacy wifi/cell quick tiles"
    
    This reverts commit 9d3ff5bd0b5fd8ef16f1dd8cbc172332512f6385.
---
 packages/SystemUI/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/packages/SystemUI/res/values/config.xml b/packages/SystemUI/res/values/config.xml
index 4cce2285a60ae5baf0bddbd928f479a7db24cff2..d3d047df8a3714576341a83089d669a0dac595bf 100644
--- a/packages/SystemUI/res/values/config.xml
+++ b/packages/SystemUI/res/values/config.xml
@@ -100,21 +100,21 @@
     <!-- The default tiles to display in QuickSettings -->
     <string name="quick_settings_tiles_default" translatable="false">
         internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location
     </string>
 
     <!-- The minimum number of tiles to display in QuickSettings -->
     <integer name="quick_settings_min_num_tiles">6</integer>
 
     <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default" -->
     <string name="quick_settings_tiles_stock" translatable="false">
-        internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness,controls,wallet,cast,wifi,cell
+        internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness,controls,wallet,cast
     </string>
 
     <!-- The tiles to display in QuickSettings -->
     <string name="quick_settings_tiles" translatable="false">default</string>
 
     <!-- The tiles to display in QuickSettings in retail mode -->
     <string name="quick_settings_tiles_retail_mode" translatable="false">
         night,dark,dnd,flashlight,rotation,location
     </string>
 

commit 3c4f80d637fd485f5063d021055517b304a803f8
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2021-10-20 19:40:42-0400

    [temporary] don't report statementservice crashes
    
    There's a known issue in AOSP 12 caused by it creating overly large
    intents for the work manager. It's not caused by anything done by end
    users and they can't work around it so avoid reporting it to them since
    they get a message each time it tries again.
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 32bfbdffae12cc688f06a0dfc26c629dd3eb2098..9ec03a2d5bda65db35a9a9adffd84df6a618fbeb 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -3537,21 +3537,21 @@
              2 - 1 snap target: 1:1
     -->
     <integer name="config_dockedStackDividerSnapMode">0</integer>
 
     <!-- The maximum aspect ratio (longerSide/shorterSide) that is treated as close-to-square. The
          orientation requests from apps would be ignored if the display is close-to-square. -->
     <item name="config_closeToSquareDisplayMaxAspectRatio" format="float" type="dimen">1.333</item>
 
     <!-- List of comma separated package names for which we the system will not show crash, ANR,
          etc. dialogs. -->
-    <string translatable="false" name="config_appsNotReportingCrashes"></string>
+    <string translatable="false" name="config_appsNotReportingCrashes">com.android.statementservice</string>
 
     <!-- Inactivity threshold (in milliseconds) used in JobScheduler. JobScheduler will consider
          the device to be "idle" after being inactive for this long. -->
     <integer name="config_jobSchedulerInactivityIdleThreshold">1860000</integer>
     <!-- The alarm window (in milliseconds) that JobScheduler uses to enter the idle state -->
     <integer name="config_jobSchedulerIdleWindowSlop">300000</integer>
 
     <!-- If true, jobs from background user will be restricted -->
     <bool name="config_jobSchedulerRestrictBackgroundUser">false</bool>
     <!-- The length of grace period after user becomes background user -->

commit 63cbb07e1d4dda441f1a8515a1eb751df48f91de
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2021-10-26 09:15:42-0400

    [temporary] disable broken AvoidAppsInCutoutOverlay
---
 packages/overlays/Android.mk | 1 -
 1 file changed, 1 deletion(-)

diff --git a/packages/overlays/Android.mk b/packages/overlays/Android.mk
index a93b3c72b50b240cd28855014f21d8cfd529b991..c7a3d40ccf36d04ca971009ebd41885620941ec9 100644
--- a/packages/overlays/Android.mk
+++ b/packages/overlays/Android.mk
@@ -13,21 +13,20 @@
 # limitations under the License.
 
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
 LOCAL_MODULE := frameworks-base-overlays
 LOCAL_LICENSE_KINDS := SPDX-license-identifier-Apache-2.0
 LOCAL_LICENSE_CONDITIONS := notice
 LOCAL_NOTICE_FILE := $(LOCAL_PATH)/../../NOTICE
 LOCAL_REQUIRED_MODULES := \
-	AvoidAppsInCutoutOverlay \
 	DisplayCutoutEmulationCornerOverlay \
 	DisplayCutoutEmulationDoubleOverlay \
 	DisplayCutoutEmulationHoleOverlay \
 	DisplayCutoutEmulationNarrowOverlay \
 	DisplayCutoutEmulationTallOverlay \
 	DisplayCutoutEmulationWaterfallOverlay \
 	DisplayCutoutEmulationWideOverlay \
 	FontNotoSerifSourceOverlay \
 	NavigationBarMode3ButtonOverlay \
 	NavigationBarMode2ButtonOverlay \

commit 72f31490950e49dead1cf2f7ca6b595d720d3765
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Mon 2021-11-01 20:41:05-0700

    colors: Switch to GrapheneOS blue color palette for Material You
    
    Generated with Android 12 Extensions v9.0.0-test2 [1] using #1565C0
    (light link accent color from GrapheneOS website) as a seed color,
    with all other settings left at themelib [2] and colorkt [3] defaults.
    
    [1] https://github.com/kdrag0n/android12-extensions/
    [2] https://github.com/ProtonAOSP/android_external_themelib
    [3] https://github.com/kdrag0n/colorkt
---
 core/res/res/values/colors.xml | 110 ++++++++++++++++++++---------------------
 1 file changed, 55 insertions(+), 55 deletions(-)

diff --git a/core/res/res/values/colors.xml b/core/res/res/values/colors.xml
index b191584345ef32bb459b0cb811334eb0e2cf9f06..13a4f7738cbac3676b82aedd72bfff931f1a6527 100644
--- a/core/res/res/values/colors.xml
+++ b/core/res/res/values/colors.xml
@@ -241,211 +241,211 @@
     <!-- Color for personal app suspension notification button text and icon tint. -->
     <color name="personal_apps_suspension_notification_color">#1A73E8</color>
 
     <color name="conversation_important_highlight">#F9AB00</color>
 
     <!-- Lightest shade of the accent color used by the system. White.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_accent1_0">#ffffff</color>
     <!-- Shade of the accent system color at 99% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_10">#F9FCFF</color>
+    <color name="system_accent1_10">#fafcff</color>
     <!-- Shade of the accent system color at 95% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_50">#E0F3FF</color>
+    <color name="system_accent1_50">#e5f1ff</color>
     <!-- Shade of the accent system color at 90% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_100">#C1E8FF</color>
+    <color name="system_accent1_100">#cbe2ff</color>
     <!-- Shade of the accent system color at 80% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_200">#76D1FF</color>
+    <color name="system_accent1_200">#95c4ff</color>
     <!-- Shade of the accent system color at 70% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_300">#4BB6E8</color>
+    <color name="system_accent1_300">#5ba2ff</color>
     <!-- Shade of the accent system color at 60% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_400">#219BCC</color>
+    <color name="system_accent1_400">#3884e7</color>
     <!-- Shade of the accent system color at 49% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_500">#007FAC</color>
+    <color name="system_accent1_500">#1b69c5</color>
     <!-- Shade of the accent system color at 40% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_600">#00668B</color>
+    <color name="system_accent1_600">#0053a3</color>
     <!-- Shade of the accent system color at 30% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_700">#004C69</color>
+    <color name="system_accent1_700">#003f7b</color>
     <!-- Shade of the accent system color at 20% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_800">#003549</color>
+    <color name="system_accent1_800">#002b55</color>
     <!-- Shade of the accent system color at 10% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_900">#001E2C</color>
+    <color name="system_accent1_900">#001933</color>
     <!-- Darkest shade of the accent color used by the system. Black.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_accent1_1000">#000000</color>
 
     <!-- Lightest shade of the secondary accent color used by the system. White.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_accent2_0">#ffffff</color>
     <!-- Shade of the secondary accent system color at 99% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_10">#F9FCFF</color>
+    <color name="system_accent2_10">#fafcff</color>
     <!-- Shade of the secondary accent system color at 95% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_50">#E0F3FF</color>
+    <color name="system_accent2_50">#e5f1ff</color>
     <!-- Shade of the secondary accent system color at 90% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_100">#D1E5F4</color>
+    <color name="system_accent2_100">#cee2fb</color>
     <!-- Shade of the secondary accent system color at 80% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_200">#B5CAD7</color>
+    <color name="system_accent2_200">#b4c6dd</color>
     <!-- Shade of the secondary accent system color at 70% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_300">#9AAEBB</color>
+    <color name="system_accent2_300">#9aabc0</color>
     <!-- Shade of the secondary accent system color at 60% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_400">#8094A0</color>
+    <color name="system_accent2_400">#8090a4</color>
     <!-- Shade of the secondary accent system color at 49% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_500">#657985</color>
+    <color name="system_accent2_500">#677688</color>
     <!-- Shade of the secondary accent system color at 40% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_600">#4E616C</color>
+    <color name="system_accent2_600">#505e6f</color>
     <!-- Shade of the secondary accent system color at 30% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_700">#374955</color>
+    <color name="system_accent2_700">#394656</color>
     <!-- Shade of the secondary accent system color at 20% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_800">#20333D</color>
+    <color name="system_accent2_800">#23303f</color>
     <!-- Shade of the secondary accent system color at 10% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_900">#091E28</color>
+    <color name="system_accent2_900">#0d1b29</color>
     <!-- Darkest shade of the secondary accent color used by the system. Black.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_accent2_1000">#000000</color>
 
     <!-- Lightest shade of the tertiary accent color used by the system. White.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_accent3_0">#ffffff</color>
     <!-- Shade of the tertiary accent system color at 99% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_10">#FFFBFF</color>
+    <color name="system_accent3_10">#fffaff</color>
     <!-- Shade of the tertiary accent system color at 95% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_50">#F5EEFF</color>
+    <color name="system_accent3_50">#fce8ff</color>
     <!-- Shade of the tertiary accent system color at 90% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_100">#E6DEFF</color>
+    <color name="system_accent3_100">#f8d0ff</color>
     <!-- Shade of the tertiary accent system color at 80% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_200">#CAC1EA</color>
+    <color name="system_accent3_200">#eba3f8</color>
     <!-- Shade of the tertiary accent system color at 70% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_300">#AEA6CE</color>
+    <color name="system_accent3_300">#ce8ad9</color>
     <!-- Shade of the tertiary accent system color at 60% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_400">#938CB1</color>
+    <color name="system_accent3_400">#b071bb</color>
     <!-- Shade of the tertiary accent system color at 49% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_500">#787296</color>
+    <color name="system_accent3_500">#93589d</color>
     <!-- Shade of the tertiary accent system color at 40% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_600">#605A7C</color>
+    <color name="system_accent3_600">#794183</color>
     <!-- Shade of the tertiary accent system color at 30% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_700">#484264</color>
+    <color name="system_accent3_700">#5f2968</color>
     <!-- Shade of the tertiary accent system color at 20% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_800">#322C4C</color>
+    <color name="system_accent3_800">#470e4f</color>
     <!-- Shade of the tertiary accent system color at 10% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_900">#1D1736</color>
+    <color name="system_accent3_900">#2d0033</color>
     <!-- Darkest shade of the tertiary accent color used by the system. Black.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_accent3_1000">#000000</color>
 
     <!-- Lightest shade of the neutral color used by the system. White.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_neutral1_0">#ffffff</color>
     <!-- Shade of the neutral system color at 99% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_10">#FCFCFF</color>
+    <color name="system_neutral1_10">#fafcff</color>
     <!-- Shade of the neutral system color at 95% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_50">#F0F0F3</color>
+    <color name="system_neutral1_50">#ebf1f7</color>
     <!-- Shade of the neutral system color at 90% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_100">#E1E3E5</color>
+    <color name="system_neutral1_100">#dde2e9</color>
     <!-- Shade of the neutral system color at 80% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_200">#C5C7C9</color>
+    <color name="system_neutral1_200">#c2c6cc</color>
     <!-- Shade of the neutral system color at 70% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_300">#AAABAE</color>
+    <color name="system_neutral1_300">#a7abb1</color>
     <!-- Shade of the neutral system color at 60% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_400">#8F9193</color>
+    <color name="system_neutral1_400">#8c9196</color>
     <!-- Shade of the neutral system color at 49% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_500">#747679</color>
+    <color name="system_neutral1_500">#72767b</color>
     <!-- Shade of the neutral system color at 40% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_600">#5C5F61</color>
+    <color name="system_neutral1_600">#5b5e63</color>
     <!-- Shade of the neutral system color at 30% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_700">#454749</color>
+    <color name="system_neutral1_700">#43474b</color>
     <!-- Shade of the neutral system color at 20% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_800">#2E3133</color>
+    <color name="system_neutral1_800">#2d3034</color>
     <!-- Shade of the neutral system color at 10% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_900">#191C1E</color>
+    <color name="system_neutral1_900">#181c1f</color>
     <!-- Darkest shade of the neutral color used by the system. Black.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_neutral1_1000">#000000</color>
 
     <!-- Lightest shade of the secondary neutral color used by the system. White.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_neutral2_0">#ffffff</color>
     <!-- Shade of the secondary neutral system color at 99% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_10">#F9FCFF</color>
+    <color name="system_neutral2_10">#fafcff</color>
     <!-- Shade of the secondary neutral system color at 95% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_50">#EBF1F8</color>
+    <color name="system_neutral2_50">#e6f1fd</color>
     <!-- Shade of the secondary neutral system color at 90% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_100">#DCE3E9</color>
+    <color name="system_neutral2_100">#d9e2ef</color>
     <!-- Shade of the secondary neutral system color at 80% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_200">#C0C7CD</color>
+    <color name="system_neutral2_200">#bdc6d2</color>
     <!-- Shade of the secondary neutral system color at 70% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_300">#A5ACB2</color>
+    <color name="system_neutral2_300">#a2abb6</color>
     <!-- Shade of the secondary neutral system color at 60% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_400">#8A9297</color>
+    <color name="system_neutral2_400">#88919a</color>
     <!-- Shade of the secondary neutral system color at 49% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_500">#70777C</color>
+    <color name="system_neutral2_500">#6e767f</color>
     <!-- Shade of the secondary neutral system color at 40% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_600">#585F65</color>
+    <color name="system_neutral2_600">#575e67</color>
     <!-- Shade of the secondary neutral system color at 30% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_700">#40484D</color>
+    <color name="system_neutral2_700">#40474f</color>
     <!-- Shade of the secondary neutral system color at 20% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_800">#2A3136</color>
+    <color name="system_neutral2_800">#2a3038</color>
     <!-- Shade of the secondary neutral system color at 10% lightness.
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_900">#161C20</color>
+    <color name="system_neutral2_900">#151b23</color>
     <!-- Darkest shade of the secondary neutral color used by the system. Black.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_neutral2_1000">#000000</color>
 
     <!-- Accessibility shortcut icon background color -->
     <color name="accessibility_feature_background">#5F6368</color> <!-- Google grey 700 -->
     <color name="accessibility_magnification_background">#F50D60</color>
     <color name="accessibility_daltonizer_background">#00BCD4</color>
     <color name="accessibility_color_inversion_background">#546E7A</color>
 </resources>

commit 61be0d8f599a1198b862365455d9915e894abcac
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2021-11-13 18:38:39-0500

    gmscompat: use new API for long-running AppOps
    
    Android 12 added startProxyOpNoThrow and finishProxyOp so we no longer
    need to use noteProxyOpNoThrow as an approximation.
---
 core/java/android/app/AppOpsManager.java | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java
index f0b749c40a5ff65cf14e394795cd3fea4d1723b8..968af357a46252aba32b22eaf4b95d9a47001f95 100644
--- a/core/java/android/app/AppOpsManager.java
+++ b/core/java/android/app/AppOpsManager.java
@@ -8775,21 +8775,21 @@ public class AppOpsManager {
 
     /**
      * @see #startOpNoThrow(String, int, String, String, String)
      *
      * @hide
      */
     public int startOpNoThrow(@NonNull IBinder token, int op, int uid, @NonNull String packageName,
             boolean startIfModeDefault, @Nullable String attributionTag, @Nullable String message,
             @AttributionFlags int attributionFlags, int attributionChainId) {
         if (GmsCompat.isEnabled() && uid != Process.myUid()) {
-            return noteProxyOpNoThrow(op, packageName, uid, attributionTag, message);
+            return startProxyOpNoThrow(opToPublicName(op), uid, packageName, attributionTag, message);
         }
 
         try {
             collectNoteOpCallsForValidation(op);
             int collectionMode = getNotedOpCollectionMode(uid, packageName, op);
             boolean shouldCollectMessage = Process.myUid() == Process.SYSTEM_UID;
             if (collectionMode == COLLECT_ASYNC) {
                 if (message == null) {
                     // Set stack trace as default message
                     message = getFormattedStackTrace();
@@ -9002,20 +9002,21 @@ public class AppOpsManager {
     }
 
     /**
      * @see #finishOp(String, int, String, String)
      *
      * @hide
      */
     public void finishOp(IBinder token, int op, int uid, @NonNull String packageName,
             @Nullable String attributionTag) {
         if (GmsCompat.isEnabled() && uid != Process.myUid()) {
+            finishProxyOp(opToPublicName(op), uid, packageName, attributionTag);
             return;
         }
 
         try {
             mService.finishOperation(token, op, uid, packageName, attributionTag);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 

commit 4575fe46db851663d72ccac1f456357bbd17e521
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Tue 2021-11-16 18:54:30+0200

    gmscompat: improve Play Store compatibility
    
    Implements package (un)installation confirmation handling and
    enables unattended app updates.
---
 .../android/app/ApplicationPackageManager.java     |   5 +
 core/java/android/app/LoadedApk.java               |   4 -
 core/java/android/app/compat/gms/GmsCompat.java    |  18 +-
 core/java/android/content/pm/PackageInstaller.java |  12 ++
 core/java/android/content/pm/PackageParser.java    |   4 +
 .../com/android/internal/gmscompat/GmsHooks.java   | 101 ++++------
 .../internal/gmscompat/PlayStoreHooks.java (new)   | 217 +++++++++++++++++++++
 core/res/res/values/strings.xml                    |   6 +-
 core/res/res/values/symbols.xml                    |   3 +-
 9 files changed, 298 insertions(+), 72 deletions(-)

diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index 4dabe78f2f737c12314bd4697a839b9f44f39d7b..0f1d8dfc023006f17d6a21b3f06d9d344ff03f6c 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -115,20 +115,21 @@ import android.system.StructStat;
 import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.LauncherIcons;
 import android.util.Log;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.Immutable;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.gmscompat.PlayStoreHooks;
 import com.android.internal.os.SomeArgs;
 import com.android.internal.util.UserIcons;
 
 import dalvik.system.VMRuntime;
 
 import libcore.util.EmptyArray;
 
 import java.io.File;
 import java.lang.ref.WeakReference;
 import java.security.cert.Certificate;
@@ -2506,20 +2507,24 @@ public class ApplicationPackageManager extends PackageManager {
             return false;
         }
 
         // We can move to any private volume
         return (vol.getType() == VolumeInfo.TYPE_PRIVATE);
     }
 
     @Override
     @UnsupportedAppUsage
     public void deletePackage(String packageName, IPackageDeleteObserver observer, int flags) {
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.deletePackage(mContext, this, packageName, observer, flags);
+            return;
+        }
         deletePackageAsUser(packageName, observer, flags, getUserId());
     }
 
     @Override
     public void deletePackageAsUser(String packageName, IPackageDeleteObserver observer,
             int flags, int userId) {
         try {
             mPM.deletePackageAsUser(packageName, VERSION_CODE_HIGHEST,
                     observer, userId, flags);
         } catch (RemoteException e) {
diff --git a/core/java/android/app/LoadedApk.java b/core/java/android/app/LoadedApk.java
index 5a2533115b46e5d04d66346b48c682dad39a2ff9..e6b1bd7fb767bdb518f2cad7f46216c9c7ae8a19 100644
--- a/core/java/android/app/LoadedApk.java
+++ b/core/java/android/app/LoadedApk.java
@@ -1566,24 +1566,20 @@ public final class LoadedApk {
             final LoadedApk.ReceiverDispatcher mStrongRef;
 
             InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) {
                 mDispatcher = new WeakReference<LoadedApk.ReceiverDispatcher>(rd);
                 mStrongRef = strong ? rd : null;
             }
 
             @Override
             public void performReceive(Intent intent, int resultCode, String data,
                     Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
-                if (GmsHooks.performReceive(intent)) {
-                    return;
-                }
-
                 final LoadedApk.ReceiverDispatcher rd;
                 if (intent == null) {
                     Log.wtf(TAG, "Null intent received");
                     rd = null;
                 } else {
                     rd = mDispatcher.get();
                 }
                 if (ActivityThread.DEBUG_BROADCAST) {
                     int seq = intent.getIntExtra("seq", -1);
                     Slog.i(ActivityThread.TAG, "Receiving broadcast " + intent.getAction()
diff --git a/core/java/android/app/compat/gms/GmsCompat.java b/core/java/android/app/compat/gms/GmsCompat.java
index 15ee23822299bee53065b4e2267a9db8df8819d2..524a6f3a09bf67d83aa4acfd4aed45e5f8b5602d 100644
--- a/core/java/android/app/compat/gms/GmsCompat.java
+++ b/core/java/android/app/compat/gms/GmsCompat.java
@@ -11,20 +11,21 @@
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package android.app.compat.gms;
 
 import android.annotation.SystemApi;
 import android.app.ActivityThread;
+import android.app.Application;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.Disabled;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageManager;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.Signature;
 import android.os.Binder;
 import android.os.Process;
@@ -69,35 +70,42 @@ public final class GmsCompat {
 
     /**
      * Whether to enable hooks for this app to load Dynamite modules from unprivileged GMS.
      * This is for CLIENT apps, not GMS itself.
      */
     @ChangeId
     @Disabled // Overridden as a special case in CompatChange
     private static final long GMS_UNPRIVILEGED_DYNAMITE_CLIENT = 7528921493777479941L;
 
     // Some hooks are in (potentially) hot paths, so cache the change enable states.
-    private static volatile boolean isGmsCompatEnabled = false;
-    private static volatile boolean isDynamiteClientEnabled = false;
+    // no need to declare these fields as volatile, they are written when app has only the main thread
+    private static boolean isGmsCompatEnabled;
+    private static boolean isDynamiteClientEnabled;
+    private static boolean isPlayStore;
 
     // Static only
     private GmsCompat() { }
 
     public static boolean isEnabled() {
         return isGmsCompatEnabled;
     }
 
     /** @hide */
     public static boolean isDynamiteClient() {
         return isDynamiteClientEnabled;
     }
 
+    /** @hide */
+    public static boolean isPlayStore() {
+        return isPlayStore;
+    }
+
     private static void logEnabled(String changeName, boolean enabled) {
         if (!DEBUG_VERBOSE) {
             return;
         }
 
         String pkg = ActivityThread.currentPackageName();
         if (pkg == null) {
             pkg = (Process.myUid() == Process.SYSTEM_UID) ? "system_server" : "[unknown]";
         }
 
@@ -116,23 +124,27 @@ public final class GmsCompat {
 
         logEnabled(changeName, enabled);
         return enabled;
     }
 
     /**
      * Must be called to initialize the compatibility change enable states before any hooks run.
      *
      * @hide
      */
-    public static void initChangeEnableStates() {
+    public static void initChangeEnableStates(Application app) {
         isGmsCompatEnabled = isChangeEnabled("GMS_UNPRIVILEGED_COMPAT", GMS_UNPRIVILEGED_COMPAT);
         isDynamiteClientEnabled = isChangeEnabled("GMS_UNPRIVILEGED_DYNAMITE_CLIENT", GMS_UNPRIVILEGED_DYNAMITE_CLIENT);
+        if (isGmsCompatEnabled) {
+            // certificate is already checked if isGmsCompatEnabled is set
+            isPlayStore = GmsInfo.PACKAGE_PLAY_STORE.equals(app.getPackageName());
+        }
     }
 
     private static boolean validateCerts(Signature[] signatures) {
         for (Signature signature : signatures) {
             if (signature.toCharsString().equals(GmsInfo.SIGNING_CERT)) {
                 return true;
             }
         }
 
         return false;
diff --git a/core/java/android/content/pm/PackageInstaller.java b/core/java/android/content/pm/PackageInstaller.java
index 3f8aedb31ea9c99c3737b6e174442ae0675ef155..6071d4e5a98c698b4e5c2a1053c12a4291d5890e 100644
--- a/core/java/android/content/pm/PackageInstaller.java
+++ b/core/java/android/content/pm/PackageInstaller.java
@@ -25,20 +25,21 @@ import android.annotation.CurrentTimeMillisLong;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.app.ActivityManager;
 import android.app.AppGlobals;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Intent;
 import android.content.IntentSender;
 import android.content.pm.PackageManager.DeleteFlags;
 import android.content.pm.PackageManager.InstallReason;
 import android.content.pm.PackageManager.InstallScenario;
 import android.graphics.Bitmap;
 import android.net.Uri;
 import android.os.Build;
 import android.os.FileBridge;
@@ -50,20 +51,21 @@ import android.os.Parcelable;
 import android.os.ParcelableException;
 import android.os.RemoteException;
 import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.system.ErrnoException;
 import android.system.Os;
 import android.text.TextUtils;
 import android.util.ArraySet;
 import android.util.ExceptionUtils;
 
+import com.android.internal.gmscompat.PlayStoreHooks;
 import com.android.internal.util.IndentingPrintWriter;
 import com.android.internal.util.Preconditions;
 import com.android.internal.util.function.pooled.PooledLambda;
 
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -683,20 +685,23 @@ public class PackageInstaller {
      * @param statusReceiver Where to deliver the result.
      *
      * @hide
      */
     @RequiresPermission(anyOf = {
             Manifest.permission.DELETE_PACKAGES,
             Manifest.permission.REQUEST_DELETE_PACKAGES})
     public void uninstall(@NonNull VersionedPackage versionedPackage, @DeleteFlags int flags,
             @NonNull IntentSender statusReceiver) {
         Objects.requireNonNull(versionedPackage, "versionedPackage cannot be null");
+        if (GmsCompat.isPlayStore()) {
+            statusReceiver = PlayStoreHooks.wrapPackageInstallerStatusReceiver(statusReceiver);
+        }
         try {
             mInstaller.uninstall(versionedPackage, mInstallerPackageName,
                     flags, statusReceiver, mUserId);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Install the given package, which already exists on the device, for the user for which this
@@ -1302,20 +1307,23 @@ public class PackageInstaller {
          * @param statusReceiver Called when the state of the session changes. Intents
          *                       sent to this receiver contain {@link #EXTRA_STATUS}. Refer to the
          *                       individual status codes on how to handle them.
          *
          * @throws SecurityException if streams opened through
          *             {@link #openWrite(String, long, long)} are still open.
          *
          * @see android.app.admin.DevicePolicyManager
          */
         public void commit(@NonNull IntentSender statusReceiver) {
+            if (GmsCompat.isPlayStore()) {
+                statusReceiver = PlayStoreHooks.wrapPackageInstallerStatusReceiver(statusReceiver);
+            }
             try {
                 mSession.commit(statusReceiver, false);
             } catch (RemoteException e) {
                 throw e.rethrowFromSystemServer();
             }
         }
 
         /**
          * Attempt to commit a session that has been {@link #transfer(String) transferred}.
          *
@@ -1624,20 +1632,24 @@ public class PackageInstaller {
 
         /**
          * Construct parameters for a new package install session.
          *
          * @param mode one of {@link #MODE_FULL_INSTALL} or
          *            {@link #MODE_INHERIT_EXISTING} describing how the session
          *            should interact with an existing app.
          */
         public SessionParams(int mode) {
             this.mode = mode;
+            if (GmsCompat.isPlayStore()) {
+                // called here instead of in createSession() to give Play Store a chance to override
+                setRequireUserAction(USER_ACTION_NOT_REQUIRED);
+            }
         }
 
         /** {@hide} */
         public SessionParams(Parcel source) {
             mode = source.readInt();
             installFlags = source.readInt();
             installLocation = source.readInt();
             installReason = source.readInt();
             installScenario = source.readInt();
             sizeBytes = source.readLong();
diff --git a/core/java/android/content/pm/PackageParser.java b/core/java/android/content/pm/PackageParser.java
index 1eca93ab2886f534afb2a294df4c6a97f2210818..de6804e72ef0a9ac4c800b84c3c0e78241377715 100644
--- a/core/java/android/content/pm/PackageParser.java
+++ b/core/java/android/content/pm/PackageParser.java
@@ -283,20 +283,24 @@ public class PackageParser {
      * If sdkVersion is 0, then this is not a permission that we want to
      * automatically add to older apps, but we do want to allow it to be
      * granted during a platform update.
      * @hide
      */
     @UnsupportedAppUsage
     public static final PackageParser.NewPermissionInfo NEW_PERMISSIONS[] =
         new PackageParser.NewPermissionInfo[] {
             new PackageParser.NewPermissionInfo(android.Manifest.permission.REQUEST_INSTALL_PACKAGES,
                     android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0, GmsInfo.PACKAGE_PLAY_STORE),
+            new PackageParser.NewPermissionInfo(android.Manifest.permission.REQUEST_DELETE_PACKAGES,
+                    android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0, GmsInfo.PACKAGE_PLAY_STORE),
+            new PackageParser.NewPermissionInfo(android.Manifest.permission.UPDATE_PACKAGES_WITHOUT_USER_ACTION,
+                    android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0, GmsInfo.PACKAGE_PLAY_STORE),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.OTHER_SENSORS,
                     android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.WRITE_EXTERNAL_STORAGE,
                     android.os.Build.VERSION_CODES.DONUT, 0),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.READ_PHONE_STATE,
                     android.os.Build.VERSION_CODES.DONUT, 0)
     };
 
     /**
      * @deprecated callers should move to explicitly passing around source path.
diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
index 620bb7e46fa0a065692dbf6082ae1c6af02578a0..9150bdf03d3571d75dd777d7a27befff017832c5 100644
--- a/core/java/com/android/internal/gmscompat/GmsHooks.java
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -36,114 +36,126 @@ import android.os.Build;
 import android.os.Process;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.provider.Settings;
 import android.util.Log;
 import android.webkit.WebView;
 
 import com.android.internal.R;
 import com.android.internal.gmscompat.dynamite.GmsDynamiteHooks;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
 /**
  * API shims for Google Play Services compatibility. Hooks that are more complicated than a simple
  * constant return value should be delegated to this class for easier maintenance.
  *
  * @hide
  */
 public final class GmsHooks {
     private static final String TAG = "GmsCompat/Hooks";
 
     // Foreground service notifications
-    private static final String FGS_GROUP_ID = "gmscompat_fgs_group";
+    // id was chosen when fgs was the only channel
+    static final String COMPAT_GROUP_ID = "gmscompat_fgs_group";
     private static final String FGS_CHANNEL_ID = "gmscompat_fgs_channel";
     private static final int FGS_NOTIFICATION_ID = 529977835;
-    private static boolean fgsChannelCreated = false;
+    private static boolean notificationChannelsCreated;
 
     // Static only
     private GmsHooks() { }
 
 
     /*
      * Foreground service notifications to keep GMS services alive
      */
 
     // Make all services foreground to keep them alive
     // ContextImpl#startService(Intent)
     public static ComponentName startService(Context context, Intent service) {
         return context.startForegroundService(service);
     }
 
-    private static void createFgsChannel(Context context) {
-        if (fgsChannelCreated) {
-            return;
+    static Notification.Builder obtainNotificationBuilder(Context context, String channelId) {
+        if (!notificationChannelsCreated) {
+            createNotificationChannels(context);
+            notificationChannelsCreated = true;
         }
+        return new Notification.Builder(context, channelId);
+    }
 
-        NotificationManager notificationManager = (NotificationManager)
-                context.getSystemService(Context.NOTIFICATION_SERVICE);
-
-        NotificationChannelGroup group = new NotificationChannelGroup(FGS_GROUP_ID,
-                context.getText(R.string.foreground_service_gmscompat_group));
-        notificationManager.createNotificationChannelGroup(group);
+    private static void createNotificationChannels(Context context) {
+        NotificationManager manager = context.getSystemService(NotificationManager.class);
+        NotificationChannelGroup group = new NotificationChannelGroup(COMPAT_GROUP_ID,
+                context.getText(R.string.gmscompat_channel_group));
+        manager.createNotificationChannelGroup(group);
+
+        ArrayList<NotificationChannel> channels = new ArrayList<>(7);
+        {
+            CharSequence name = context.getText(R.string.foreground_service_gmscompat_channel);
+            NotificationChannel c = new NotificationChannel(FGS_CHANNEL_ID, name,
+                    NotificationManager.IMPORTANCE_LOW);
+            c.setDescription(context.getString(R.string.foreground_service_gmscompat_channel_desc));
+            c.setShowBadge(false);
+            channels.add(c);
+        }
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.createNotificationChannel(context, channels);
+        }
 
-        CharSequence name = context.getText(R.string.foreground_service_gmscompat_channel);
-        NotificationChannel channel = new NotificationChannel(FGS_CHANNEL_ID, name,
-                NotificationManager.IMPORTANCE_LOW);
-        channel.setGroup(FGS_GROUP_ID);
-        channel.setDescription(context.getString(R.string.foreground_service_gmscompat_channel_desc));
-        channel.setShowBadge(false);
-        notificationManager.createNotificationChannel(channel);
+        for (int i = 0; i < channels.size(); ++i) {
+            channels.get(i).setGroup(COMPAT_GROUP_ID);
+        }
 
-        fgsChannelCreated = true;
+        manager.createNotificationChannels(channels);
     }
 
     // Post notification on foreground service start
     // ActivityThread#handleCreateService(CreateServiceData)
     public static void attachService(Service service) {
         // Isolated processes (e.g. WebView) don't have access to NotificationManager. They don't
         // need a foreground notification anyway, so bail out early.
         if (!GmsCompat.isEnabled() || Process.isIsolated()) {
             return;
         }
 
-        // Channel
-        createFgsChannel(service);
-
         // Intent: notification channel settings
         Intent intent = new Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);
         intent.putExtra(Settings.EXTRA_APP_PACKAGE, service.getPackageName());
         intent.putExtra(Settings.EXTRA_CHANNEL_ID, FGS_CHANNEL_ID);
         PendingIntent pi = PendingIntent.getActivity(service, 0, intent, PendingIntent.FLAG_IMMUTABLE);
 
         // Notification
         CharSequence appName = service.getApplicationInfo().loadLabel(service.getPackageManager());
-        Notification notification = new Notification.Builder(service, FGS_CHANNEL_ID)
+        Notification notification = obtainNotificationBuilder(service, FGS_CHANNEL_ID)
                 .setSmallIcon(service.getApplicationInfo().icon)
                 .setContentTitle(service.getString(R.string.app_running_notification_title, appName))
                 .setContentText(service.getText(R.string.foreground_service_gmscompat_notif_desc))
                 .setContentIntent(pi)
                 .build();
 
         Log.d(TAG, "Posting notification for service: " + service.getClass().getName());
         service.startForeground(FGS_NOTIFICATION_ID, notification);
     }
 
     // GMS tries to clean up its own notification channels periodically.
-    // Don't let it delete the FGS shim channel because that throws an exception and crashes GMS.
+    // Don't let it delete any of compat channels because that throws an exception and crashes GMS.
     // NotificationManager#deleteNotificationChannel(String)
     public static boolean skipDeleteNotificationChannel(String channelId) {
-        return GmsCompat.isEnabled() && FGS_CHANNEL_ID.equals(channelId);
+        if (! GmsCompat.isEnabled()) {
+            return false;
+        }
+        return FGS_CHANNEL_ID.equals(channelId) || PlayStoreHooks.PUA_CHANNEL_ID.equals(channelId);
     }
 
-
     /**
      * API shims
      */
 
     // Report a single user on the system
     // UserManager#getSerialNumbersOfUsers(boolean)
     public static long[] getSerialNumbersOfUsers(UserManager userManager) {
         return new long[] { userManager.getSerialNumberForUser(Process.myUserHandle()) };
     }
 
@@ -191,66 +203,31 @@ public final class GmsHooks {
         }
 
         // Remove MATCH_ANY_USER flag to avoid permission denial
         return flags & ~PackageManager.MATCH_ANY_USER;
     }
 
     // Fix RuntimeException: Using WebView from more than one process at once with the same data
     // directory is not supported. https://crbug.com/558377
     // Instrumentation#newApplication(ClassLoader, String, Context)
     public static void initApplicationBeforeOnCreate(Application app) {
-        GmsCompat.initChangeEnableStates();
+        GmsCompat.initChangeEnableStates(app);
 
         if (GmsCompat.isEnabled()) {
             String processName = Application.getProcessName();
             if (!app.getPackageName().equals(processName)) {
                 WebView.setDataDirectorySuffix("process-shim--" + processName);
             }
 
             GmsDynamiteHooks.initGmsServerApp(app);
         } else if (GmsCompat.isDynamiteClient()) {
             GmsDynamiteHooks.initClientApp();
         }
     }
 
-    // Request user action for package install sessions
-    // LoadedApk.ReceiverDispatcher.InnerReceiver#performReceive(Intent, int, String, Bundle, boolean, boolean, int)
-    public static boolean performReceive(Intent intent) {
-        if (!GmsCompat.isEnabled()) {
-            return false;
-        }
-
-        // Validate - we only want to handle user action requests
-        if (!(intent.hasExtra(PackageInstaller.EXTRA_SESSION_ID) &&
-                intent.hasExtra(PackageInstaller.EXTRA_STATUS) &&
-                intent.hasExtra(Intent.EXTRA_INTENT))) {
-            return false;
-        }
-        if (intent.getIntExtra(PackageInstaller.EXTRA_STATUS, 0) !=
-                PackageInstaller.STATUS_PENDING_USER_ACTION) {
-            return false;
-        }
-
-        Application app = ActivityThread.currentApplication();
-        if (app == null) {
-            return false;
-        }
-
-        // Use the intent
-        Log.i(TAG, "Requesting user confirmation for package install session");
-        Intent confirmIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
-        // Make it work with the Application context
-        confirmIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        // TODO: post notification if app is in the background
-        app.startActivity(confirmIntent);
-
-        // Don't dispatch it, otherwise Play Store abandons the session
-        return true;
-    }
-
     // Redirect cross-user interactions to current user
     // ContextImpl#sendOrderedBroadcastAsUser
     // ContextImpl#sendBroadcastAsUser
     public static UserHandle getUserHandle(UserHandle user) {
         return GmsCompat.isEnabled() ? Process.myUserHandle() : user;
     }
 }
diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
new file mode 100644
index 0000000000000000000000000000000000000000..85f14b531bac25056088b3d6caec6635a0c099fb
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+import android.app.ActivityManager;
+import android.app.ActivityThread;
+import android.app.IActivityManager;
+import android.app.Notification;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.IntentSender;
+import android.content.pm.IPackageDeleteObserver;
+import android.content.pm.PackageInstaller;
+import android.content.pm.PackageManager;
+import android.os.Process;
+import android.os.RemoteException;
+
+import com.android.internal.R;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicLong;
+
+import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
+
+public final class PlayStoreHooks {
+
+    private static final String TAG = "GmsCompat/PlayStore";
+
+    // Pending user action notifications
+    static final String PUA_CHANNEL_ID = "gmscompat_playstore_pua_channel";
+    private static final int PUA_NOTIFICATION_ID = 429825706;
+
+    private PlayStoreHooks() {}
+
+    static void createNotificationChannel(Context context, ArrayList<NotificationChannel> dest) {
+        CharSequence name = context.getText(R.string.gmscompat_notif_channel_action_required);
+        NotificationChannel c = new NotificationChannel(PUA_CHANNEL_ID, name,
+                NotificationManager.IMPORTANCE_LOW);
+        c.setShowBadge(false);
+
+        dest.add(c);
+    }
+
+    // Play Store doesn't handle PENDING_USER_ACTION status from PackageInstaller
+    // PackageInstaller.Session#commit(IntentSender)
+    // PackageInstaller#uninstall(VersionedPackage, int, IntentSender)
+    public static IntentSender wrapPackageInstallerStatusReceiver(IntentSender statusReceiver) {
+        Context context = ActivityThread.currentApplication();
+        Objects.requireNonNull(context);
+        return PackageInstallerStatusForwarder.wrap(context, statusReceiver).getIntentSender();
+    }
+
+    static class PackageInstallerStatusForwarder extends BroadcastReceiver {
+        private Context context;
+        private IntentSender target;
+
+        private static final AtomicLong lastId = new AtomicLong();
+
+        static PendingIntent wrap(Context context, IntentSender target) {
+            PackageInstallerStatusForwarder sf = new PackageInstallerStatusForwarder();
+            sf.context = context;
+            sf.target = target;
+
+            String intentAction = context.getPackageName()
+                + "." + PackageInstallerStatusForwarder.class.getName() + "."
+                + lastId.getAndIncrement();
+            context.registerReceiver(sf, new IntentFilter(intentAction));
+
+            return PendingIntent.getBroadcast(context, 0, new Intent(intentAction),
+                    PendingIntent.FLAG_CANCEL_CURRENT |
+                        PendingIntent.FLAG_MUTABLE);
+        }
+
+        public void onReceive(Context br_context, Intent intent) {
+            String statusKey = PackageInstaller.EXTRA_STATUS;
+            if (! intent.hasExtra(statusKey)) {
+                throw new IllegalStateException("no EXTRA_STATUS in intent " + intent);
+            }
+            int status = intent.getIntExtra(statusKey, 0);
+
+            if (status == PackageInstaller.STATUS_PENDING_USER_ACTION) {
+                Intent confirmationIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
+                confirmationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+                boolean foreground = isForeground(Process.myUid(), Process.myPid());
+
+                if (foreground) {
+                    context.startActivity(confirmationIntent);
+                } else {
+                    // allow multiple PUA notifications
+                    int id = PUA_NOTIFICATION_ID + (((int) lastId.get()) & 0xffff);
+
+                    PendingIntent pi = PendingIntent.getActivity(context, id, confirmationIntent,
+                        PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT);
+
+                    Notification notification =
+                        GmsHooks.obtainNotificationBuilder(context, PUA_CHANNEL_ID)
+                        // TODO better icon
+                        .setSmallIcon(context.getApplicationInfo().icon)
+                        .setContentTitle(context.getText(R.string.gmscompat_notif_channel_action_required))
+                        .setContentIntent(pi)
+                        .setAutoCancel(true)
+                        .build();
+
+                    NotificationManager nm = context.getSystemService(NotificationManager.class);
+                    nm.notify(id, notification);
+                }
+                // confirmationIntent has a PendingIntent to this instance, don't unregister yet
+                return;
+            }
+
+            context.unregisterReceiver(this);
+
+            try {
+                target.sendIntent(context, 0, intent, null, null);
+            } catch (IntentSender.SendIntentException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    static boolean isForeground(int uid, int pid) {
+        final List<ActivityManager.RunningAppProcessInfo> procs;
+        try {
+            // returns only processes that belong to the current app
+            procs = ActivityManager.getService().getRunningAppProcesses();
+            Objects.requireNonNull(procs);
+        } catch (RemoteException e) {
+            throw e.rethrowAsRuntimeException();
+        }
+        for (int i = 0; i < procs.size(); i++) {
+            ActivityManager.RunningAppProcessInfo proc = procs.get(i);
+            if (proc.pid == pid && proc.uid == uid
+                    && proc.importance == IMPORTANCE_FOREGROUND) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    // Request user action to uninstall a package
+    // ApplicationPackageManager#deletePackage(String, IPackageDeleteObserver, int)
+    public static void deletePackage(Context context, PackageManager pm, String packageName, IPackageDeleteObserver observer, int flags) {
+        if (flags != 0) {
+            throw new IllegalStateException("unexpected flags: " + flags);
+        }
+        PendingIntent pi = UninstallStatusForwarder.getPendingIntent(context, packageName, observer);
+        // will call PackageInstallerStatusForwarder,
+        // no need to handle confirmation in UninstallStatusForwarder
+        pm.getPackageInstaller().uninstall(packageName, pi.getIntentSender());
+    }
+
+    static class UninstallStatusForwarder extends BroadcastReceiver {
+        private Context context;
+        private String packageName;
+        private IPackageDeleteObserver target;
+
+        private static final AtomicLong lastId = new AtomicLong();
+
+        static PendingIntent getPendingIntent(Context context, String packageName, IPackageDeleteObserver target) {
+            UninstallStatusForwarder sf = new UninstallStatusForwarder();
+            sf.context = context;
+            sf.packageName = packageName;
+            sf.target = target;
+
+            String intentAction = context.getPackageName()
+                + "." + UninstallStatusForwarder.class.getName() + "."
+                + lastId.getAndIncrement();
+
+            context.registerReceiver(sf, new IntentFilter(intentAction));
+
+            return PendingIntent.getBroadcast(context, 0, new Intent(intentAction),
+                    PendingIntent.FLAG_CANCEL_CURRENT |
+                        PendingIntent.FLAG_ONE_SHOT |
+                        PendingIntent.FLAG_MUTABLE);
+        }
+
+        public void onReceive(Context br_context, Intent intent) {
+            context.unregisterReceiver(this);
+
+            // EXTRA_STATUS returns PackageInstaller constant,
+            // EXTRA_LEGACY_STATUS returns PackageManager constant
+            String statusKey = PackageInstaller.EXTRA_LEGACY_STATUS;
+            if (!intent.hasExtra(statusKey)) {
+                throw new IllegalStateException("no EXTRA_LEGACY_STATUS in intent " + intent);
+            }
+
+            int status = intent.getIntExtra(statusKey, 0);
+            try {
+                target.packageDeleted(packageName, status);
+            } catch (RemoteException e) {
+                throw e.rethrowAsRuntimeException();
+            }
+        }
+    }
+}
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index 43cba7b85e2cfd5c510f9fed50dbd3b2639e7a9b..a07307392f6a626803e5c38e4c93ce639668cf10 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -757,34 +757,36 @@
         data usage</string>
 
     <!-- Separator for foreground service notification content listing all apps when there
         are multiple apps running.  The left and right side may both already be compound
         (constructed using this separator).  Should be kept as short as possible, this is
         for summary text in the notification where there is not a lot of space.
         [CHAR LIMIT=NONE] -->
     <string name="foreground_service_multiple_separator"><xliff:g id="left_side">%1$s</xliff:g>,
         <xliff:g id="right_side">%2$s</xliff:g></string>
 
-    <!-- Name for foreground service notification channel group created by GmsCompat  -->
-    <string name="foreground_service_gmscompat_group">Compatibility</string>
+    <!-- Name for GmsCompat notification channel group -->
+    <string name="gmscompat_channel_group">Compatibility</string>
 
     <!-- Name for foreground service notification channel created by GmsCompat  -->
     <string name="foreground_service_gmscompat_channel">Services</string>
 
     <!-- Description for foreground service notification channel created by GmsCompat  -->
     <string name="foreground_service_gmscompat_channel_desc">These notifications are created by the
         Google Play Services compatibility layer in order to keep services running in the
         background.\n\nDisable this category to hide the unnecessary notifications.</string>
 
     <!-- Description for foreground service notifications created by GmsCompat  -->
     <string name="foreground_service_gmscompat_notif_desc">Tap to hide</string>
 
+    <string name="gmscompat_notif_channel_action_required">Action required</string>
+
     <!-- Displayed to the user to tell them that they have started up the phone in "safe mode" -->
     <string name="safeMode">Safe mode</string>
 
     <!-- Label for the Android system components when they are shown to the user. -->
     <string name="android_system_label">Android System</string>
 
     <!-- "Switch" is a verb; it means to change user profile by tapping another user profile name. -->
     <string name="user_owner_label">Switch to personal profile</string>
 
     <!-- "Switch" is a verb; it means to change user profile by tapping another user profile name. -->
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index f65dbc469e4a2f5cbcda553e4dcee8c81457e256..9a59dc450c0d008c0001384cfaab0b9dee5d9b6a 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -3618,24 +3618,25 @@
   <java-symbol type="string" name="config_defaultSystemCaptionsManagerService" />
   <java-symbol type="string" name="config_retailDemoPackage" />
   <java-symbol type="string" name="config_retailDemoPackageSignature" />
 
   <java-symbol type="string" name="notification_channel_foreground_service" />
   <java-symbol type="string" name="foreground_service_app_in_background" />
   <java-symbol type="string" name="foreground_service_apps_in_background" />
   <java-symbol type="string" name="foreground_service_tap_for_details" />
   <java-symbol type="string" name="foreground_service_multiple_separator" />
 
-  <java-symbol type="string" name="foreground_service_gmscompat_group" />
+  <java-symbol type="string" name="gmscompat_channel_group" />
   <java-symbol type="string" name="foreground_service_gmscompat_channel" />
   <java-symbol type="string" name="foreground_service_gmscompat_channel_desc" />
   <java-symbol type="string" name="foreground_service_gmscompat_notif_desc" />
+  <java-symbol type="string" name="gmscompat_notif_channel_action_required" />
 
   <java-symbol type="bool" name="config_enableCredentialFactoryResetProtection" />
 
   <!-- ETWS primary messages -->
   <java-symbol type="string" name="etws_primary_default_message_earthquake" />
   <java-symbol type="string" name="etws_primary_default_message_tsunami" />
   <java-symbol type="string" name="etws_primary_default_message_earthquake_and_tsunami" />
   <java-symbol type="string" name="etws_primary_default_message_test" />
   <java-symbol type="string" name="etws_primary_default_message_others" />
 

commit d66787984b786eff3571673ac54db973ac2f4edd
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2021-11-18 12:04:59-0500

    minor style fix
---
 core/java/com/android/internal/gmscompat/GmsHooks.java       | 2 +-
 core/java/com/android/internal/gmscompat/PlayStoreHooks.java | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
index 9150bdf03d3571d75dd777d7a27befff017832c5..345a8b1619e68b62b8d17464d3f711b3421d8dd6 100644
--- a/core/java/com/android/internal/gmscompat/GmsHooks.java
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -136,21 +136,21 @@ public final class GmsHooks {
                 .build();
 
         Log.d(TAG, "Posting notification for service: " + service.getClass().getName());
         service.startForeground(FGS_NOTIFICATION_ID, notification);
     }
 
     // GMS tries to clean up its own notification channels periodically.
     // Don't let it delete any of compat channels because that throws an exception and crashes GMS.
     // NotificationManager#deleteNotificationChannel(String)
     public static boolean skipDeleteNotificationChannel(String channelId) {
-        if (! GmsCompat.isEnabled()) {
+        if (!GmsCompat.isEnabled()) {
             return false;
         }
         return FGS_CHANNEL_ID.equals(channelId) || PlayStoreHooks.PUA_CHANNEL_ID.equals(channelId);
     }
 
     /**
      * API shims
      */
 
     // Report a single user on the system
diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
index 85f14b531bac25056088b3d6caec6635a0c099fb..938cb4c67291039ae46517b5a977d49b0b137389 100644
--- a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -87,21 +87,21 @@ public final class PlayStoreHooks {
                 + lastId.getAndIncrement();
             context.registerReceiver(sf, new IntentFilter(intentAction));
 
             return PendingIntent.getBroadcast(context, 0, new Intent(intentAction),
                     PendingIntent.FLAG_CANCEL_CURRENT |
                         PendingIntent.FLAG_MUTABLE);
         }
 
         public void onReceive(Context br_context, Intent intent) {
             String statusKey = PackageInstaller.EXTRA_STATUS;
-            if (! intent.hasExtra(statusKey)) {
+            if (!intent.hasExtra(statusKey)) {
                 throw new IllegalStateException("no EXTRA_STATUS in intent " + intent);
             }
             int status = intent.getIntExtra(statusKey, 0);
 
             if (status == PackageInstaller.STATUS_PENDING_USER_ACTION) {
                 Intent confirmationIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
                 confirmationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
 
                 boolean foreground = isForeground(Process.myUid(), Process.myPid());
 

commit 2196f8bd38bce27f129c9fa2508d2a76a99740ae
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Fri 2021-11-19 13:48:41+0200

    gmscompat: compatibility with Play Store self-update
---
 .../android/app/ApplicationPackageManager.java     |  4 ++
 core/java/android/content/ContentResolver.java     |  5 +++
 .../android/internal/gmscompat/PlayStoreHooks.java | 47 ++++++++++++++++++++++
 3 files changed, 56 insertions(+)

diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index 0f1d8dfc023006f17d6a21b3f06d9d344ff03f6c..1dff532256e8a361b7fe6fdeacbc2d40cac28076 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -2557,20 +2557,24 @@ public class ApplicationPackageManager extends PackageManager {
         try {
             mPM.deleteApplicationCacheFilesAsUser(packageName, userId, observer);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public void freeStorageAndNotify(String volumeUuid, long idealStorageSize,
             IPackageDataObserver observer) {
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.freeStorageAndNotify(mContext, volumeUuid, idealStorageSize, observer);
+            return;
+        }
         try {
             mPM.freeStorageAndNotify(volumeUuid, idealStorageSize, 0, observer);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public void freeStorage(String volumeUuid, long freeStorageSize, IntentSender pi) {
         try {
diff --git a/core/java/android/content/ContentResolver.java b/core/java/android/content/ContentResolver.java
index 265ff331ffa06398b7e68f396cbf86c238303f54..65e8f48a3c6eb8d748e3d693df38c2fd3aceef7a 100644
--- a/core/java/android/content/ContentResolver.java
+++ b/core/java/android/content/ContentResolver.java
@@ -24,20 +24,21 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.annotation.UserIdInt;
 import android.app.ActivityManager;
 import android.app.ActivityThread;
 import android.app.AppGlobals;
 import android.app.UriGrantsManager;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.res.AssetFileDescriptor;
 import android.content.res.Resources;
 import android.database.ContentObserver;
 import android.database.CrossProcessCursorWrapper;
 import android.database.Cursor;
 import android.database.IContentObserver;
 import android.graphics.Bitmap;
@@ -64,20 +65,21 @@ import android.os.ServiceManager;
 import android.os.SystemClock;
 import android.os.UserHandle;
 import android.system.Int64Ref;
 import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
 import android.util.Size;
 import android.util.SparseArray;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.PlayStoreHooks;
 import com.android.internal.util.MimeIconUtils;
 
 import dalvik.system.CloseGuard;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -2170,20 +2172,23 @@ public abstract class ContentResolver implements ContentInterface {
      *            which arguments they support.
      * @return the URL of the newly created row. May return <code>null</code> if the underlying
      *         content provider returns <code>null</code>, or if it crashes.
      * @throws IllegalArgumentException if the provider doesn't support one of
      *             the requested Bundle arguments.
      */
     @Override
     public final @Nullable Uri insert(@RequiresPermission.Write @NonNull Uri url,
             @Nullable ContentValues values, @Nullable Bundle extras) {
         Objects.requireNonNull(url, "url");
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.filterContentValues(url, values);
+        }
 
         try {
             if (mWrapped != null) return mWrapped.insert(url, values, extras);
         } catch (RemoteException e) {
             return null;
         }
 
         IContentProvider provider = acquireProvider(url);
         if (provider == null) {
             throw new IllegalArgumentException("Unknown URL " + url);
diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
index 938cb4c67291039ae46517b5a977d49b0b137389..f197ee2da3e14c25dc91e84cd431fdd82e137c0f 100644
--- a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -17,32 +17,38 @@
 package com.android.internal.gmscompat;
 
 import android.app.ActivityManager;
 import android.app.ActivityThread;
 import android.app.IActivityManager;
 import android.app.Notification;
 import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.content.BroadcastReceiver;
+import android.content.ContentValues;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.IntentSender;
+import android.content.pm.IPackageDataObserver;
 import android.content.pm.IPackageDeleteObserver;
 import android.content.pm.PackageInstaller;
 import android.content.pm.PackageManager;
+import android.net.Uri;
 import android.os.Process;
 import android.os.RemoteException;
+import android.os.storage.StorageManager;
+import android.provider.Downloads;
 
 import com.android.internal.R;
 
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicLong;
 
 import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
 
 public final class PlayStoreHooks {
 
     private static final String TAG = "GmsCompat/PlayStore";
@@ -207,11 +213,52 @@ public final class PlayStoreHooks {
             }
 
             int status = intent.getIntExtra(statusKey, 0);
             try {
                 target.packageDeleted(packageName, status);
             } catch (RemoteException e) {
                 throw e.rethrowAsRuntimeException();
             }
         }
     }
+
+    // Called during self-update sequence because PackageManager requires
+    // the restricted CLEAR_APP_CACHE permission
+    // ApplicationPackageManager#freeStorageAndNotify(String, long, IPackageDataObserver)
+    public static void freeStorageAndNotify(Context context, String volumeUuid, long idealStorageSize,
+            IPackageDataObserver observer) {
+        if (volumeUuid != null) {
+            throw new IllegalStateException("unexpected volumeUuid " + volumeUuid);
+        }
+        StorageManager sm = context.getSystemService(StorageManager.class);
+        boolean success = false;
+        try {
+            sm.allocateBytes(StorageManager.UUID_DEFAULT, idealStorageSize);
+            success = true;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        try {
+            // same behavior as PackageManagerService#freeStorageAndNotify()
+            String packageName = null;
+            observer.onRemoveCompleted(packageName, success);
+        } catch (RemoteException e) {
+            throw e.rethrowAsRuntimeException();
+        }
+    }
+
+    // Called during self-update sequence
+    // ContentResolver#insert(Uri, ContentValues, Bundle)
+    public static void filterContentValues(Uri url, ContentValues values) {
+        if (values != null && "content://downloads/my_downloads".equals(url.toString())) {
+            // gated by the restricted ACCESS_DOWNLOAD_MANAGER_ADVANCED permission
+            String otherUid = Downloads.Impl.COLUMN_OTHER_UID;
+            if (values.containsKey(otherUid)) {
+                int v = values.getAsInteger(otherUid).intValue();
+                if (v != 1000) {
+                    throw new IllegalStateException("unexpected COLUMN_OTHER_UID " + v);
+                }
+                values.remove(otherUid);
+            }
+        }
+    }
 }

commit f1f7a3a5d80ea1e27607572ef5b4c5e23277709d
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Mon 2021-11-22 17:56:16+0200

    gmscompat: mark confirmation notification from Play Store as ongoing
    
    Play Store will wait for confirmation indefinitely if notification is dismissed.
    Ongoing notifications can't be dismissed (swiped away) by the user.
---
 core/java/com/android/internal/gmscompat/PlayStoreHooks.java | 1 +
 1 file changed, 1 insertion(+)

diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
index f197ee2da3e14c25dc91e84cd431fdd82e137c0f..659a5a0c40503b909cb78f5f94338dd6492aca9b 100644
--- a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -119,20 +119,21 @@ public final class PlayStoreHooks {
 
                     PendingIntent pi = PendingIntent.getActivity(context, id, confirmationIntent,
                         PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT);
 
                     Notification notification =
                         GmsHooks.obtainNotificationBuilder(context, PUA_CHANNEL_ID)
                         // TODO better icon
                         .setSmallIcon(context.getApplicationInfo().icon)
                         .setContentTitle(context.getText(R.string.gmscompat_notif_channel_action_required))
                         .setContentIntent(pi)
+                        .setOngoing(true)
                         .setAutoCancel(true)
                         .build();
 
                     NotificationManager nm = context.getSystemService(NotificationManager.class);
                     nm.notify(id, notification);
                 }
                 // confirmationIntent has a PendingIntent to this instance, don't unregister yet
                 return;
             }
 

commit bc2bd20d17578fecff5da9eec46bc5b2a80ed485
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Tue 2021-11-23 21:02:26+0200

    gmscompat: fix push notifications in secondary user profiles
    
    UserManager.isUserUnlocked(userId) returns whether a user exited the Direct Boot mode.
    This method requires a restricted permission if userId parameter differs from the current userId.
    GMS called this method with userId 0 in both primary (userId == 0) and secondary (userId != 0)
    profiles. userId was always 0 likely because of the stubbed out
    UserManager.getUserSerialNumber(userId),
    which always returned 0 as a workaround to a different issue.
---
 core/java/android/os/UserManager.java | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/core/java/android/os/UserManager.java b/core/java/android/os/UserManager.java
index d1f0d12e039a98fc7430b5c1869245e58ce8c710..b8179c8c3dc5b1161b00c981c3bfd2d6e0725df6 100644
--- a/core/java/android/os/UserManager.java
+++ b/core/java/android/os/UserManager.java
@@ -2520,20 +2520,23 @@ public class UserManager {
                         throw re.rethrowFromSystemServer();
                     }
                 }
             };
 
     /** {@hide} */
     @UnsupportedAppUsage
     @RequiresPermission(anyOf = {Manifest.permission.MANAGE_USERS,
             Manifest.permission.INTERACT_ACROSS_USERS}, conditional = true)
     public boolean isUserUnlocked(@UserIdInt int userId) {
+        if (GmsCompat.isEnabled()) {
+            return mIsUserUnlockedCache.query(mUserId);
+        }
         return mIsUserUnlockedCache.query(userId);
     }
 
     /** {@hide} */
     public void disableIsUserUnlockedCache() {
         mIsUserUnlockedCache.disableLocal();
         mIsUserUnlockingOrUnlockedCache.disableLocal();
     }
 
     /** {@hide} */

commit 408cb5210cafe0e798d59766d122f2a8bfd201e8
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Thu 2021-11-25 21:46:42+0200

    gmscompat: make sure PackageInstaller UI returns a result
---
 .../android/packageinstaller/PackageInstallerActivity.java   | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java b/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java
index 9c6113ce4b47935d36ae29430e91d943ddf82df5..9f4fb4cabf3a467e31685ac44988d4bd6ace4289 100644
--- a/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java
+++ b/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java
@@ -122,20 +122,21 @@ public class PackageInstallerActivity extends AlertActivity {
     private static final int DLG_ANONYMOUS_SOURCE = DLG_BASE + 6;
     private static final int DLG_NOT_SUPPORTED_ON_WEAR = DLG_BASE + 7;
     private static final int DLG_EXTERNAL_SOURCE_BLOCKED = DLG_BASE + 8;
     private static final int DLG_INSTALL_APPS_RESTRICTED_FOR_USER = DLG_BASE + 9;
 
     // If unknown sources are temporary allowed
     private boolean mAllowUnknownSources;
 
     // Would the mOk button be enabled if this activity would be resumed
     private boolean mEnableOk = false;
+    private boolean mPermissionResultWasSet;
 
     private void startInstallConfirm() {
         View viewToEnable;
 
         if (mAppInfo != null) {
             viewToEnable = requireViewById(R.id.install_confirm_question_update);
             mOk.setText(R.string.update);
         } else {
             // This is a new application with no permissions.
             viewToEnable = requireViewById(R.id.install_confirm_question);
@@ -291,20 +292,21 @@ public class PackageInstallerActivity extends AlertActivity {
         Intent result = new Intent();
         result.putExtra(Intent.EXTRA_INSTALL_RESULT, pmResult);
         setResult(pmResult == PackageManager.INSTALL_SUCCEEDED
                 ? RESULT_OK : RESULT_FIRST_USER, result);
     }
 
     @Override
     protected void onCreate(Bundle icicle) {
         if (mLocalLOGV) Log.i(TAG, "creating for user " + getUserId());
         getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);
+        getWindow().setCloseOnTouchOutside(false);
 
         super.onCreate(null);
 
         if (icicle != null) {
             mAllowUnknownSources = icicle.getBoolean(ALLOW_UNKNOWN_SOURCES_KEY);
         }
 
         mPm = getPackageManager();
         mIpm = AppGlobals.getPackageManager();
         mAppOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);
@@ -383,20 +385,27 @@ public class PackageInstallerActivity extends AlertActivity {
     }
 
     @Override
     protected void onPause() {
         super.onPause();
 
         if (mOk != null) {
             // Don't allow the install button to be clicked as there might be overlays
             mOk.setEnabled(false);
         }
+        // sometimes this activity becomes hidden after onPause(),
+        // and the user is unable to bring it back
+        if (!mPermissionResultWasSet && mSessionId != -1) {
+            mInstaller.setPermissionsResult(mSessionId, false);
+            mPermissionResultWasSet = true;
+            finish();
+        }
     }
 
     @Override
     protected void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
 
         outState.putBoolean(ALLOW_UNKNOWN_SOURCES_KEY, mAllowUnknownSources);
     }
 
     @Override
@@ -409,32 +418,34 @@ public class PackageInstallerActivity extends AlertActivity {
 
     private void bindUi() {
         mAlert.setIcon(mAppSnippet.icon);
         mAlert.setTitle(mAppSnippet.label);
         mAlert.setView(R.layout.install_content_view);
         mAlert.setButton(DialogInterface.BUTTON_POSITIVE, getString(R.string.install),
                 (ignored, ignored2) -> {
                     if (mOk.isEnabled()) {
                         if (mSessionId != -1) {
                             mInstaller.setPermissionsResult(mSessionId, true);
+                            mPermissionResultWasSet = true;
                             finish();
                         } else {
                             startInstall();
                         }
                     }
                 }, null);
         mAlert.setButton(DialogInterface.BUTTON_NEGATIVE, getString(R.string.cancel),
                 (ignored, ignored2) -> {
                     // Cancel and finish
                     setResult(RESULT_CANCELED);
                     if (mSessionId != -1) {
                         mInstaller.setPermissionsResult(mSessionId, false);
+                        mPermissionResultWasSet = true;
                     }
                     finish();
                 }, null);
         setupAlert();
 
         mOk = mAlert.getButton(DialogInterface.BUTTON_POSITIVE);
         mOk.setEnabled(false);
 
         if (!mOk.isInTouchMode()) {
             mAlert.getButton(DialogInterface.BUTTON_NEGATIVE).requestFocus();
@@ -592,20 +603,21 @@ public class PackageInstallerActivity extends AlertActivity {
             }
         }
 
         return true;
     }
 
     @Override
     public void onBackPressed() {
         if (mSessionId != -1) {
             mInstaller.setPermissionsResult(mSessionId, false);
+            mPermissionResultWasSet = true;
         }
         super.onBackPressed();
     }
 
     private void startInstall() {
         // Start subactivity to actually install the application
         Intent newIntent = new Intent();
         newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,
                 mPkgInfo.applicationInfo);
         newIntent.setData(mPackageURI);

commit b0b56c44cefe612a98136418fa2515b5c69e814c
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Thu 2021-11-25 21:53:44+0200

    gmscompat: use a reliable "is app foreground" check
    
    Previous check returned a false positive shortly after activity was paused,
    which led to startActivity() silently failing.
---
 core/java/android/app/ActivityThread.java          | 11 ++++++++
 .../android/internal/gmscompat/PlayStoreHooks.java | 29 +++-------------------
 2 files changed, 14 insertions(+), 26 deletions(-)

diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index 29f1c906c5db315cd3b88dfd295f04d42fb42b7c..f8f23fb0dff91ec60f63d23d451521b54b34ab70 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -7927,11 +7927,22 @@ public final class ActivityThread extends ClientTransactionHandler
 
     @Override
     public boolean hasImeComponent() {
         return mHasImeComponent;
     }
 
     // ------------------ Regular JNI ------------------------
     private native void nPurgePendingResources();
     private native void nDumpGraphicsInfo(FileDescriptor fd);
     private native void nInitZygoteChildHeapProfiling();
+
+    public boolean hasAtLeastOneResumedActivity() {
+        synchronized (mResourcesManager) {
+            for (int i = 0; i < mActivities.size(); ++i) {
+                if (mActivities.valueAt(i).getLifecycleState() == ActivityLifecycleItem.ON_RESUME) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
 }
diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
index 659a5a0c40503b909cb78f5f94338dd6492aca9b..34832a6ee6f6c94174fd0f9c59a3b03959e53dcb 100644
--- a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -9,21 +9,20 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.android.internal.gmscompat;
 
-import android.app.ActivityManager;
 import android.app.ActivityThread;
 import android.app.IActivityManager;
 import android.app.Notification;
 import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.content.BroadcastReceiver;
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.Intent;
@@ -36,26 +35,23 @@ import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.storage.StorageManager;
 import android.provider.Downloads;
 
 import com.android.internal.R;
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicLong;
 
-import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
-
 public final class PlayStoreHooks {
 
     private static final String TAG = "GmsCompat/PlayStore";
 
     // Pending user action notifications
     static final String PUA_CHANNEL_ID = "gmscompat_playstore_pua_channel";
     private static final int PUA_NOTIFICATION_ID = 429825706;
 
     private PlayStoreHooks() {}
 
@@ -102,23 +98,23 @@ public final class PlayStoreHooks {
             String statusKey = PackageInstaller.EXTRA_STATUS;
             if (!intent.hasExtra(statusKey)) {
                 throw new IllegalStateException("no EXTRA_STATUS in intent " + intent);
             }
             int status = intent.getIntExtra(statusKey, 0);
 
             if (status == PackageInstaller.STATUS_PENDING_USER_ACTION) {
                 Intent confirmationIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
                 confirmationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
 
-                boolean foreground = isForeground(Process.myUid(), Process.myPid());
-
-                if (foreground) {
+                // there is no public API that I'm aware of (as of API 31)
+                // that would allow to *reliably* find this out
+                if (ActivityThread.currentActivityThread().hasAtLeastOneResumedActivity()) {
                     context.startActivity(confirmationIntent);
                 } else {
                     // allow multiple PUA notifications
                     int id = PUA_NOTIFICATION_ID + (((int) lastId.get()) & 0xffff);
 
                     PendingIntent pi = PendingIntent.getActivity(context, id, confirmationIntent,
                         PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT);
 
                     Notification notification =
                         GmsHooks.obtainNotificationBuilder(context, PUA_CHANNEL_ID)
@@ -140,39 +136,20 @@ public final class PlayStoreHooks {
             context.unregisterReceiver(this);
 
             try {
                 target.sendIntent(context, 0, intent, null, null);
             } catch (IntentSender.SendIntentException e) {
                 e.printStackTrace();
             }
         }
     }
 
-    static boolean isForeground(int uid, int pid) {
-        final List<ActivityManager.RunningAppProcessInfo> procs;
-        try {
-            // returns only processes that belong to the current app
-            procs = ActivityManager.getService().getRunningAppProcesses();
-            Objects.requireNonNull(procs);
-        } catch (RemoteException e) {
-            throw e.rethrowAsRuntimeException();
-        }
-        for (int i = 0; i < procs.size(); i++) {
-            ActivityManager.RunningAppProcessInfo proc = procs.get(i);
-            if (proc.pid == pid && proc.uid == uid
-                    && proc.importance == IMPORTANCE_FOREGROUND) {
-                return true;
-            }
-        }
-        return false;
-    }
-
     // Request user action to uninstall a package
     // ApplicationPackageManager#deletePackage(String, IPackageDeleteObserver, int)
     public static void deletePackage(Context context, PackageManager pm, String packageName, IPackageDeleteObserver observer, int flags) {
         if (flags != 0) {
             throw new IllegalStateException("unexpected flags: " + flags);
         }
         PendingIntent pi = UninstallStatusForwarder.getPendingIntent(context, packageName, observer);
         // will call PackageInstallerStatusForwarder,
         // no need to handle confirmation in UninstallStatusForwarder
         pm.getPackageInstaller().uninstall(packageName, pi.getIntentSender());

commit 62754dfc34e15ba11bca87f009e84f1e0caba28d (HEAD, m/master, grapheneos/12)
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Thu 2021-11-25 21:56:12+0200

    gmscompat: System.exit(1) if package uninstallation is declined
---
 core/java/com/android/internal/gmscompat/PlayStoreHooks.java | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
index 34832a6ee6f6c94174fd0f9c59a3b03959e53dcb..b854ac439b1e6c84aff516f56a8bd7e4883967d1 100644
--- a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -184,20 +184,29 @@ public final class PlayStoreHooks {
             context.unregisterReceiver(this);
 
             // EXTRA_STATUS returns PackageInstaller constant,
             // EXTRA_LEGACY_STATUS returns PackageManager constant
             String statusKey = PackageInstaller.EXTRA_LEGACY_STATUS;
             if (!intent.hasExtra(statusKey)) {
                 throw new IllegalStateException("no EXTRA_LEGACY_STATUS in intent " + intent);
             }
 
             int status = intent.getIntExtra(statusKey, 0);
+            if (status != PackageManager.DELETE_SUCCEEDED) {
+                // Play Store doesn't expect uninstallation to fail and ends up in an inconsistent UI state,
+                // which requires user-initiated "Force stop" as a workaround
+                // Most likely cause of a failure is accidental rejection of the second confirmation prompt:
+                // Play Store shows its own confirmation UI before PackageInstaller confirmation UI
+                // is shown. It is unlikely that the user deliberately accepted the first prompt and
+                // rejected the second one
+                System.exit(1);
+            }
             try {
                 target.packageDeleted(packageName, status);
             } catch (RemoteException e) {
                 throw e.rethrowAsRuntimeException();
             }
         }
     }
 
     // Called during self-update sequence because PackageManager requires
     // the restricted CLEAR_APP_CACHE permission

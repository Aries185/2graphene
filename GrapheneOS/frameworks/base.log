commit eb4b5e415ec00dde81a11112163fce5a5025ab2f
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Tue 2021-10-05 21:01:17-0700

    fonts: Use variable font for Roboto Regular
    
    I'm not sure why Google decided to revert to a static variant of *only*
    the regular non-italic and non-condensed weight, but using the default
    "Roboto" font for the lock screen clock (i.e. AOSP default) is broken
    with the change:
        - Clock is too bold when notifications are present (because SystemUI
          loads the regular font but can't change the weight to be less
          bold)
        - Weight animation between lock screen and AOD is broken (because
          weight can't be animated without the variable font)
        - AOD clock font is too bold (could cause burn-in)
    
    Switch back to the variable font in order to fix the clock issues.
    
    Change-Id: Ia2e5ef52e4edb5d4275f6d5faf8c74266b784762
---
 data/fonts/fonts.xml | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/data/fonts/fonts.xml b/data/fonts/fonts.xml
index 4ae0fc4ae6ed93db604db863cbd93b0e10d1f30c..48da31b90eed16a3f534151178a6d10c0fbd9922 100644
--- a/data/fonts/fonts.xml
+++ b/data/fonts/fonts.xml
@@ -32,21 +32,25 @@
         <font weight="200" style="normal">Roboto-Regular.ttf
           <axis tag="ital" stylevalue="0" />
           <axis tag="wdth" stylevalue="100" />
           <axis tag="wght" stylevalue="200" />
         </font>
         <font weight="300" style="normal">Roboto-Regular.ttf
           <axis tag="ital" stylevalue="0" />
           <axis tag="wdth" stylevalue="100" />
           <axis tag="wght" stylevalue="300" />
         </font>
-        <font weight="400" style="normal">RobotoStatic-Regular.ttf</font>
+        <font weight="400" style="normal">Roboto-Regular.ttf
+          <axis tag="ital" stylevalue="0" />
+          <axis tag="wdth" stylevalue="100" />
+          <axis tag="wght" stylevalue="400" />
+        </font>
         <font weight="500" style="normal">Roboto-Regular.ttf
           <axis tag="ital" stylevalue="0" />
           <axis tag="wdth" stylevalue="100" />
           <axis tag="wght" stylevalue="500" />
         </font>
         <font weight="600" style="normal">Roboto-Regular.ttf
           <axis tag="ital" stylevalue="0" />
           <axis tag="wdth" stylevalue="100" />
           <axis tag="wght" stylevalue="600" />
         </font>

commit 562a14ee50dc469f595fa0efb912b1a89676d62c
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2016-10-15 20:09:49-0400

    enable doze and app standby
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index d9007e50c7c664e5de1d325809d1d3182166cc44..307cc2b5ae71b7b1006c44f47b875a3f57f7d4a3 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -242,21 +242,21 @@
          ActivityManager based on screen size. -->
     <integer name="config_extraFreeKbytesAdjust">0</integer>
 
     <!-- Set this to true to enable the platform's auto-power-save modes like doze and
          app standby.  These are not enabled by default because they require a standard
          cloud-to-device messaging service for apps to interact correctly with the modes
          (such as to be able to deliver an instant message to the device even when it is
          dozing).  This should be enabled if you have such services and expect apps to
          correctly use them when installed on your device.  Otherwise, keep this disabled
          so that applications can still use their own mechanisms. -->
-    <bool name="config_enableAutoPowerModes">false</bool>
+    <bool name="config_enableAutoPowerModes">true</bool>
 
     <!-- Whether (if true) this is a kind of device that can be moved around (eg. phone/laptop),
          or (if false) something for which movement is either not measurable or should not count
          toward power states (eg. tv/soundbar). -->
     <bool name="config_autoPowerModeUseMotionSensor">true</bool>
 
     <!-- The threshold angle for any motion detection in auto-power save modes.
          In hundreths of a degree. -->
     <integer name="config_autoPowerModeThresholdAngle">200</integer>
 

commit 3bfc892c0bf799edc87420a23568d77a19fd5245
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2017-06-15 19:35:32-0400

    enable boot/bootloader/radio version checks
    
    This enables the Build.isBuildConsistent checks after tweaking the radio
    check to stop failing when the radio hasn't been turned on. The property
    used to check the radio version (gsm.baseband.version) is only set once
    the radio is turned on and initialized.
    
    The API documentation already claims that this is done.
---
 core/java/android/os/Build.java | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/core/java/android/os/Build.java b/core/java/android/os/Build.java
index b7dd36e2c4f5eb7284a92398494c296fd21a47e1..a1f8b6eab903c1c66561270aeba24400e08fb5ed 100755
--- a/core/java/android/os/Build.java
+++ b/core/java/android/os/Build.java
@@ -1251,45 +1251,43 @@ public class Build {
         }
 
         if (!TextUtils.isEmpty(vendor)) {
             if (!Objects.equals(system, vendor)) {
                 Slog.e(TAG, "Mismatched fingerprints; system reported " + system
                         + " but vendor reported " + vendor);
                 return false;
             }
         }
 
-        /* TODO: Figure out issue with checks failing
         if (!TextUtils.isEmpty(bootimage)) {
             if (!Objects.equals(system, bootimage)) {
                 Slog.e(TAG, "Mismatched fingerprints; system reported " + system
                         + " but bootimage reported " + bootimage);
                 return false;
             }
         }
 
         if (!TextUtils.isEmpty(requiredBootloader)) {
             if (!Objects.equals(currentBootloader, requiredBootloader)) {
                 Slog.e(TAG, "Mismatched bootloader version: build requires " + requiredBootloader
                         + " but runtime reports " + currentBootloader);
                 return false;
             }
         }
 
-        if (!TextUtils.isEmpty(requiredRadio)) {
+        if (!TextUtils.isEmpty(requiredRadio) && !TextUtils.isEmpty(currentRadio)) {
             if (!Objects.equals(currentRadio, requiredRadio)) {
                 Slog.e(TAG, "Mismatched radio version: build requires " + requiredRadio
                         + " but runtime reports " + currentRadio);
                 return false;
             }
         }
-        */
 
         return true;
     }
 
     /** Build information for a particular device partition. */
     public static class Partition {
         /** The name identifying the system partition. */
         public static final String PARTITION_NAME_SYSTEM = "system";
 
         private final String mName;

commit 87bb7d6071a75df5c819f58b29bfa70d2581a965
Author: flawedworld <38294951+flawedworld@users.noreply.github.com>
Date:   Fri 2021-07-16 02:00:19+0000

    Display UART notification on user builds
    
    The prior implementation relied on checking the init.svc.console prop,
    however as the console service is never launched on a user build due to
    it requiring ro.debuggable=1 , the UART notification will never appear.
    If UART is enabled the kernel cmdline is changed so that console is no
    longer null so use this to determine if UART is enabled and use the old
    method as an additional check.
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 .../android/server/am/ActivityManagerService.java  | 23 +++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index 330d2ddc0a945dc93f3fa1e471914023ec96e9a8..ade36d8bf7e5b7f8215a65219e94fc5d1b9aa3b6 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -399,40 +399,42 @@ import com.android.server.wm.ActivityTaskManagerService;
 import com.android.server.wm.WindowManagerInternal;
 import com.android.server.wm.WindowManagerService;
 import com.android.server.wm.WindowProcessController;
 
 import dalvik.system.VMRuntime;
 
 import libcore.util.EmptyArray;
 
 import java.io.File;
 import java.io.FileDescriptor;
+import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.nio.charset.StandardCharsets;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
+import java.util.Scanner;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 
 public class ActivityManagerService extends IActivityManager.Stub
         implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback, ActivityManagerGlobalLock {
 
     private static final String SYSTEM_PROPERTY_DEVICE_PROVISIONED =
             "persist.sys.device_provisioned";
@@ -4793,22 +4795,41 @@ public class ActivityManagerService extends IActivityManager.Stub
                     });
             maybeLogUserspaceRebootEvent();
             mUserController.scheduleStartProfiles();
         }
         // UART is on if init's console service is running, send a warning notification.
         showConsoleNotificationIfActive();
 
         t.traceEnd();
     }
 
+    private static Boolean isUartEnabled() {
+        // console=null should be set in the kernel cmdline when UART is off
+        final String console_string = "console=null";
+        boolean isEnabled = false;
+        try (Scanner sc = new Scanner(new FileInputStream("/proc/cmdline"))) {
+            StringBuilder scOutput = new StringBuilder();
+            while (sc.hasNextLine()){
+                scOutput.append(sc.nextLine());
+            }
+            isEnabled = !scOutput.toString().contains(console_string);
+        } catch (IOException ignored) {}
+        // This check will only work on userdebug and eng builds due
+        // to the console service not being present on user builds.
+        if (SystemProperties.get("init.svc.console").equals("running")) {
+            isEnabled = true;
+        }
+        return isEnabled;
+    }
+
     private void showConsoleNotificationIfActive() {
-        if (!SystemProperties.get("init.svc.console").equals("running")) {
+        if (!isUartEnabled()) {
             return;
         }
         String title = mContext
                 .getString(com.android.internal.R.string.console_running_notification_title);
         String message = mContext
                 .getString(com.android.internal.R.string.console_running_notification_message);
         Notification notification =
                 new Notification.Builder(mContext, SystemNotificationChannels.DEVELOPER)
                         .setSmallIcon(com.android.internal.R.drawable.stat_sys_adb)
                         .setWhen(0)

commit 159cf8b31a6b328e948210ba360bb03c19d11904
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2018-03-09 20:23:12-0500

    use round adaptive icon mask and parse round icons
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 core/res/res/values/config.xml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 307cc2b5ae71b7b1006c44f47b875a3f57f7d4a3..bbf642ff9458bbea63ccc5c30f4f791f9be5468a 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -3731,21 +3731,21 @@
     <bool name="config_pinnerHomeApp">false</bool>
 
     <!-- True if assistant app should be pinned via Pinner Service -->
     <bool name="config_pinnerAssistantApp">false</bool>
 
     <!-- Number of days preloaded file cache should be preserved on a device before it can be
          deleted -->
     <integer name="config_keepPreloadsMinDays">7</integer>
 
     <!-- Flag indicating whether round icons should be parsed from the application manifest. -->
-    <bool name="config_useRoundIcon">false</bool>
+    <bool name="config_useRoundIcon">true</bool>
 
     <!-- Flag indicating whether the assist disclosure can be disabled using
          ASSIST_DISCLOSURE_ENABLED. -->
     <bool name="config_allowDisablingAssistDisclosure">true</bool>
 
     <!-- True if the device supports system navigation keys. -->
     <bool name="config_supportSystemNavigationKeys">false</bool>
 
     <!-- emergency call number for the emergency affordance -->
     <string name="config_emergency_call_number" translatable="false">112</string>
@@ -3828,21 +3828,21 @@
          1.0 corresponds to 1x animator scale, 0 means that there will be no transition
          animations. Note that this is only a default and will be overridden by a
          user-set value if toggled by settings so the "Transition animation scale" setting
          should also be hidden if intended to be permanent. -->
     <item name="config_appTransitionAnimationDurationScaleDefault" format="float" type="dimen">1.0</item>
 
     <!-- Flag indicates that whether non-system apps can be installed on internal storage. -->
     <bool name="config_allow3rdPartyAppOnInternal">true</bool>
 
     <!-- Specifies the path that is used by AdaptiveIconDrawable class to crop launcher icons. -->
-    <string name="config_icon_mask" translatable="false">"M50,0L92,0C96.42,0 100,4.58 100 8L100,92C100, 96.42 96.42 100 92 100L8 100C4.58, 100 0 96.42 0 92L0 8 C 0 4.42 4.42 0 8 0L50 0Z"</string>
+    <string name="config_icon_mask" translatable="false">"M50 0C77.6 0 100 22.4 100 50C100 77.6 77.6 100 50 100C22.4 100 0 77.6 0 50C0 22.4 22.4 0 50 0Z"</string>
 
     <!-- The component name, flattened to a string, for the default accessibility service to be
          enabled by the accessibility shortcut. This service must be trusted, as it can be activated
          without explicit consent of the user. If no accessibility service with the specified name
          exists on the device, the accessibility shortcut will be disabled by default. -->
     <string name="config_defaultAccessibilityService" translatable="false"></string>
 
     <!-- Flag indicates that whether escrow token API is enabled for TrustAgent -->
     <!-- Warning: This API can be dangerous when not implemented properly. In particular,
          escrow token must NOT be retrievable from device storage. In other words, either

commit c491ff2ec35a8a663f06f7632cc194daa08381d9
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2018-11-28 01:08:00-0500

    enable gesture navigation by default
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index bbf642ff9458bbea63ccc5c30f4f791f9be5468a..6741daf496aa88f8a10e1e6e7247dfb633e6a63a 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -3500,21 +3500,21 @@
          1 - Nav bar is always translucent when the freeform stack is visible, otherwise always
              opaque.
          2 - Nav bar is never forced opaque.
          -->
     <integer name="config_navBarOpacityMode">0</integer>
 
     <!-- Controls the navigation bar interaction mode:
          0: 3 button mode (back, home, overview buttons)
          1: 2 button mode (back, home buttons + swipe up for overview)
          2: gestures only for back, home and overview -->
-    <integer name="config_navBarInteractionMode">0</integer>
+    <integer name="config_navBarInteractionMode">2</integer>
 
     <!-- Controls whether the nav bar can move from the bottom to the side in landscape.
          Only applies if the device display is not square. -->
     <bool name="config_navBarCanMove">true</bool>
 
     <!-- Controls whether the navigation bar lets through taps. -->
     <bool name="config_navBarTapThrough">false</bool>
 
     <!-- Controls whether the side edge gestures can always trigger the transient nav bar to
          show. -->

commit 8056f8f864b015db62fa08222a6ecc81bf8ecd72
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2021-10-09 00:54:03-0400

    revert to pre-12 power button behavior
---
 core/res/res/values/config.xml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 6741daf496aa88f8a10e1e6e7247dfb633e6a63a..1146f7f77b246d25e6588465bbaa637fa28c81f7 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -970,21 +970,21 @@
     <integer name="config_attentiveWarningDuration">30000</integer>
 
     <!-- Control the behavior when the user long presses the power button.
             0 - Nothing
             1 - Global actions menu
             2 - Power off (with confirmation)
             3 - Power off (without confirmation)
             4 - Go to voice assist
             5 - Go to assistant (Settings.Secure.ASSISTANT)
     -->
-    <integer name="config_longPressOnPowerBehavior">5</integer>
+    <integer name="config_longPressOnPowerBehavior">1</integer>
 
     <!-- The time in milliseconds after which a press on power button is considered "long". -->
     <integer name="config_longPressOnPowerDurationMs">500</integer>
 
     <!-- The possible UI options to be surfaced for configuring long press power on duration
          action. Value set in config_longPressOnPowerDurationMs should be one of the available
          options to allow users to restore default. -->
     <integer-array name="config_longPressOnPowerDurationSettings">
         <item>250</item>
         <item>350</item>
@@ -1002,21 +1002,21 @@
             0 - Nothing
             1 - Global actions menu
     -->
     <integer name="config_veryLongPressOnPowerBehavior">0</integer>
 
     <!-- Control the behavior when the user presses the power and volume up buttons together.
             0 - Nothing
             1 - Mute toggle
             2 - Global actions menu
     -->
-    <integer name="config_keyChordPowerVolumeUp">2</integer>
+    <integer name="config_keyChordPowerVolumeUp">1</integer>
 
     <!-- Control the behavior when the user long presses the back button.  Non-zero values are only
          valid for watches as part of CDD/CTS.
             0 - Nothing
             1 - Go to voice assist
     -->
     <integer name="config_longPressOnBackBehavior">0</integer>
 
     <!-- Allows activities to be launched on a long press on power during device setup. -->
     <bool name="config_allowStartActivityForLongPressOnPowerInSetup">false</bool>

commit 57d3326222b1eb2222f4d60e77afa8c6d635a006
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2018-11-28 01:14:54-0500

    enable multi user UI
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 1146f7f77b246d25e6588465bbaa637fa28c81f7..c33251edb3515614c7cd77d89a909735df5ee2cc 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2538,21 +2538,21 @@
           - to enable feature (fully enforced) for a complete allowlist: 1
           - to enable feature for an incomplete allowlist (so use implicit allowlist mode): 5
           - to enable feature but implicitly allowlist for SYSTEM user to ease local development: 9
           - to disable feature completely if it had never been enabled: 16
           - to henceforth disable feature and try to undo its previous effects: 0
         Note: This list must be kept current with PACKAGE_WHITELIST_MODE_PROP in
         frameworks/base/services/core/java/com/android/server/pm/UserSystemPackageInstaller.java -->
     <integer name="config_userTypePackageWhitelistMode">13</integer> <!-- 1+4+8 -->
 
     <!-- Whether UI for multi user should be shown -->
-    <bool name="config_enableMultiUserUI">false</bool>
+    <bool name="config_enableMultiUserUI">true</bool>
 
     <!-- Whether the new Auto Selection Network UI should be shown -->
     <bool name="config_enableNewAutoSelectNetworkUI">false</bool>
 
     <!-- If true, then we do not ask user for permission for apps to connect to USB devices.
          Do not set this to true for production devices. Doing so will cause you to fail CTS. -->
     <bool name="config_disableUsbPermissionDialogs">false</bool>
 
     <!-- Activity to handle Usb Device connection in USB Host side. Keeping it to null value will
          lead into handling it inside system using Intent resolution. Non-null contents will have

commit 5802d56f1063a0bc3842beeb51959d8a8d6bf9f3
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2018-11-28 01:16:09-0500

    raise maximum users to 4
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index c33251edb3515614c7cd77d89a909735df5ee2cc..5d81ea19c93b8b94a85aa76d9751dcde08d2d073 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2504,21 +2504,21 @@
     <integer-array translatable="false" name="config_oemUsbModeOverride">
     </integer-array>
 
     <!-- Set to true to add links to Cell Broadcast app from Settings and MMS app. -->
     <bool name="config_cellBroadcastAppLinks">true</bool>
 
     <!-- The default value if the SyncStorageEngine should sync automatically or not -->
     <bool name="config_syncstorageengine_masterSyncAutomatically">true</bool>
 
     <!--  Maximum number of supported users -->
-    <integer name="config_multiuserMaximumUsers">1</integer>
+    <integer name="config_multiuserMaximumUsers">4</integer>
 
     <!-- Maximum number of users we allow to be running at a time -->
     <integer name="config_multiuserMaxRunningUsers">3</integer>
 
     <!-- Whether to delay user data locking for background user.
          If false, user switched-out from user switching will still be in running state until
          config_multiuserMaxRunningUsers is reached. Once config_multiuserMaxRunningUsers is
          reached, user will be stopped and user data is locked.
          If true, user switched out from user switching will always be stopped but its user data
          is not locked. Total number of unlocked users will be limited by

commit b54ea117d11cbda29f9747633886f92a908a4d5e
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2018-12-04 00:34:24-0500

    disable bluetooth by default
---
 packages/SettingsProvider/res/values/defaults.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/packages/SettingsProvider/res/values/defaults.xml b/packages/SettingsProvider/res/values/defaults.xml
index 8e6e251ff3f25ce4240f894c652a3c2adcd86f76..53324ba4d9664dc170a81c39dcf77d1affe7812a 100644
--- a/packages/SettingsProvider/res/values/defaults.xml
+++ b/packages/SettingsProvider/res/values/defaults.xml
@@ -29,21 +29,21 @@
     <bool name="def_auto_time">true</bool>
     <bool name="def_auto_time_zone">true</bool>
     <bool name="def_accelerometer_rotation">false</bool>
     <!-- Default screen brightness, from 0 to 255.  102 is 40%. -->
     <integer name="def_screen_brightness">102</integer>
     <bool name="def_screen_brightness_automatic_mode">false</bool>
     <fraction name="def_window_animation_scale">100%</fraction>
     <fraction name="def_window_transition_scale">100%</fraction>
     <bool name="def_haptic_feedback">true</bool>
 
-    <bool name="def_bluetooth_on">true</bool>
+    <bool name="def_bluetooth_on">false</bool>
     <bool name="def_wifi_display_on">false</bool>
     <bool name="def_install_non_market_apps">false</bool>
     <!-- 0 == off, 3 == on -->
     <integer name="def_location_mode">3</integer>
     <bool name="assisted_gps_enabled">true</bool>
     <bool name="def_netstats_enabled">true</bool>
     <bool name="def_usb_mass_storage_enabled">true</bool>
     <bool name="def_wifi_on">false</bool>
     <!-- 0 == never, 1 == only when plugged in, 2 == always -->
     <integer name="def_wifi_sleep_policy">2</integer>

commit ffb3578d706e5ce1303406fe23d266bf7b5e2869
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2017-06-29 10:16:52-0400

    increase default max password length to 64
---
 core/java/android/app/admin/DevicePolicyManager.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/java/android/app/admin/DevicePolicyManager.java b/core/java/android/app/admin/DevicePolicyManager.java
index 3553748e50040aad72700910647bf058ecf5f0ad..b7dbb7b1bbb280daa694abd150db68461764c985 100644
--- a/core/java/android/app/admin/DevicePolicyManager.java
+++ b/core/java/android/app/admin/DevicePolicyManager.java
@@ -2794,21 +2794,21 @@ public class DevicePolicyManager {
      *
      * @see #ACTION_GET_PROVISIONING_MODE
      */
     public static final String ACTION_ADMIN_POLICY_COMPLIANCE =
             "android.app.action.ADMIN_POLICY_COMPLIANCE";
 
     /**
      * Maximum supported password length. Kind-of arbitrary.
      * @hide
      */
-    public static final int MAX_PASSWORD_LENGTH = 16;
+    public static final int MAX_PASSWORD_LENGTH = 64;
 
     /**
      * Service Action: Service implemented by a device owner or profile owner supervision app to
      * provide a secondary lockscreen.
      * @hide
      */
     @SystemApi
     public static final String ACTION_BIND_SECONDARY_LOCKSCREEN_SERVICE =
             "android.app.action.BIND_SECONDARY_LOCKSCREEN_SERVICE";
 

commit 17f8831b4aa0f220030ae517e8290fe4283f2383
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2017-09-12 01:52:11-0400

    use permanent fingerprint lockout immediately
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 .../biometrics/sensors/fingerprint/hidl/LockoutFrameworkImpl.java       | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/LockoutFrameworkImpl.java b/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/LockoutFrameworkImpl.java
index dc5dace98825d97a848af0bb9902e0651080d9fe..2f745264422743eecd18be72fe61992d60908201 100644
--- a/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/LockoutFrameworkImpl.java
+++ b/services/core/java/com/android/server/biometrics/sensors/fingerprint/hidl/LockoutFrameworkImpl.java
@@ -34,21 +34,21 @@ import com.android.server.biometrics.sensors.LockoutTracker;
 /**
  * Tracks and enforces biometric lockout for biometric sensors that do not support lockout in the
  * HAL.
  */
 public class LockoutFrameworkImpl implements LockoutTracker {
 
     private static final String TAG = "LockoutTracker";
     private static final String ACTION_LOCKOUT_RESET =
             "com.android.server.biometrics.sensors.fingerprint.ACTION_LOCKOUT_RESET";
     private static final int MAX_FAILED_ATTEMPTS_LOCKOUT_TIMED = 5;
-    private static final int MAX_FAILED_ATTEMPTS_LOCKOUT_PERMANENT = 20;
+    private static final int MAX_FAILED_ATTEMPTS_LOCKOUT_PERMANENT = 5;
     private static final long FAIL_LOCKOUT_TIMEOUT_MS = 30 * 1000;
     private static final String KEY_LOCKOUT_RESET_USER = "lockout_reset_user";
 
     private final class LockoutReceiver extends BroadcastReceiver {
         @Override
         public void onReceive(Context context, Intent intent) {
             Slog.v(TAG, "Resetting lockout: " + intent.getAction());
             if (ACTION_LOCKOUT_RESET.equals(intent.getAction())) {
                 final int user = intent.getIntExtra(KEY_LOCKOUT_RESET_USER, 0);
                 resetFailedAttemptsForUser(false /* clearAttemptCounter */, user);

commit 6009bd79b293a80d963ef558d8bc682b31e58759
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2021-10-09 03:22:39-0400

    use rounded corners in system UI
    
    Based on kdrag0n's work for ProtonAOSP.
---
 core/res/res/values/config.xml | 8 ++++----
 core/res/res/values/dimens.xml | 4 ++--
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 5d81ea19c93b8b94a85aa76d9751dcde08d2d073..7d25d4582b8f1a190594814cc4115d19597a2343 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -4163,27 +4163,27 @@
     <string translatable="false" name="config_deviceSpecificAudioService"></string>
 
     <!-- Class name of the device specific implementation of DisplayAreaPolicy.Provider
          or empty if the default should be used. -->
     <string translatable="false" name="config_deviceSpecificDisplayAreaPolicyProvider"></string>
 
     <!-- Component name of media projection permission dialog -->
     <string name="config_mediaProjectionPermissionDialogComponent" translatable="false">com.android.systemui/com.android.systemui.media.MediaProjectionPermissionActivity</string>
 
     <!-- Corner radius of system dialogs -->
-    <dimen name="config_dialogCornerRadius">2dp</dimen>
+    <dimen name="config_dialogCornerRadius">28dp</dimen>
     <!-- Corner radius of system buttons -->
-    <dimen name="config_buttonCornerRadius">@dimen/control_corner_material</dimen>
+    <dimen name="config_buttonCornerRadius">4dp</dimen>
     <!-- Corner radius for bottom sheet system dialogs -->
-    <dimen name="config_bottomDialogCornerRadius">@dimen/config_dialogCornerRadius</dimen>
+    <dimen name="config_bottomDialogCornerRadius">16dp</dimen>
     <!-- Corner radius of system progress bars -->
-    <dimen name="config_progressBarCornerRadius">@dimen/progress_bar_corner_material</dimen>
+    <dimen name="config_progressBarCornerRadius">1000dp</dimen>
     <!-- Controls whether system buttons use all caps for text -->
     <bool name="config_buttonTextAllCaps">true</bool>
     <!-- Name of the font family used for system surfaces where the font should use medium weight -->
     <string name="config_headlineFontFamilyMedium" translateable="false">@string/font_family_button_material</string>
     <!-- Name of a font family to use for body text. -->
     <string name="config_bodyFontFamily" translatable="false">sans-serif</string>
     <!-- Name of a font family to use for medium body text. -->
     <string name="config_bodyFontFamilyMedium" translatable="false">sans-serif-medium</string>
 
     <!-- Size of icon shown beside a preference locked by admin -->
diff --git a/core/res/res/values/dimens.xml b/core/res/res/values/dimens.xml
index f331f1ab720f5ec2707af617b645e506441117af..ab674fb76ddd5f889e4daedc2bcea1167a42638b 100644
--- a/core/res/res/values/dimens.xml
+++ b/core/res/res/values/dimens.xml
@@ -941,23 +941,23 @@
     <dimen name="waterfall_display_right_edge_size">0px</dimen>
     <dimen name="waterfall_display_bottom_edge_size">0px</dimen>
 
     <dimen name="default_background_blur_radius">100dp</dimen>
     <!-- The maximum height of a thumbnail in a ThumbnailTemplate. The image will be reduced to that height in case they are bigger. -->
     <dimen name="controls_thumbnail_image_max_height">140dp</dimen>
     <!-- The maximum width of a thumbnail in a ThumbnailTemplate. The image will be reduced to that width in case they are bigger.-->
     <dimen name="controls_thumbnail_image_max_width">280dp</dimen>
 
     <!-- System-provided radius for the background view of app widgets. The resolved value of this resource may change at runtime. -->
-    <dimen name="system_app_widget_background_radius">16dp</dimen>
+    <dimen name="system_app_widget_background_radius">28dp</dimen>
     <!-- System-provided radius for inner views on app widgets. The resolved value of this resource may change at runtime. -->
-    <dimen name="system_app_widget_inner_radius">8dp</dimen>
+    <dimen name="system_app_widget_inner_radius">20dp</dimen>
     <!-- System-provided padding for inner views on app widgets. The resolved value of this resource may change at runtime. @removed -->
     <dimen name="__removed_system_app_widget_internal_padding">16dp</dimen>
 
     <!-- The width/height of the icon view on staring surface. -->
     <dimen name="starting_surface_icon_size">160dp</dimen>
     <!-- The default width/height of the icon on the spec of adaptive icon drawable. -->
     <dimen name="starting_surface_default_icon_size">108dp</dimen>
 
     <!-- For secondary built-in Waterfall Display -->
     <dimen name="secondary_waterfall_display_left_edge_size">0px</dimen>

commit 917e96f50fbb65326f8a7721d91771a1f82e79c9
Author: inthewaves <inthewaves@pm.me>
Date:   Tue 2020-10-06 16:02:25-0700

    switch to providing WebView via Vanadium
---
 core/res/res/xml/config_webview_packages.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/xml/config_webview_packages.xml b/core/res/res/xml/config_webview_packages.xml
index f062b59a008c900260a691e55b6328a5ca6692c2..1db99d8bc404e5b496541ca44e962d61e84a46c6 100644
--- a/core/res/res/xml/config_webview_packages.xml
+++ b/core/res/res/xml/config_webview_packages.xml
@@ -9,13 +9,13 @@
 
      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
 -->
 
 <webviewproviders>
     <!-- The default WebView implementation -->
-    <webviewprovider description="Android WebView" packageName="com.android.webview" availableByDefault="true">
+    <webviewprovider description="Vanadium" packageName="app.vanadium.webview" availableByDefault="true">
     </webviewprovider>
 </webviewproviders>

commit f7b3ca2b6368f67c937f0f1427294f0f10e7265e
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2020-09-27 17:37:28-0400

    add 2 button navigation overlay
---
 packages/overlays/Android.mk | 1 +
 1 file changed, 1 insertion(+)

diff --git a/packages/overlays/Android.mk b/packages/overlays/Android.mk
index 928892c60e47ae5b7fa247c02c1320569c58c0ec..a6bb258bccb0d907557854d710ab90a18264d3ee 100644
--- a/packages/overlays/Android.mk
+++ b/packages/overlays/Android.mk
@@ -20,20 +20,21 @@ LOCAL_LICENSE_KINDS := SPDX-license-identifier-Apache-2.0
 LOCAL_LICENSE_CONDITIONS := notice
 LOCAL_NOTICE_FILE := $(LOCAL_PATH)/../../NOTICE
 LOCAL_REQUIRED_MODULES := \
 	DisplayCutoutEmulationCornerOverlay \
 	DisplayCutoutEmulationDoubleOverlay \
     DisplayCutoutEmulationHoleOverlay \
 	DisplayCutoutEmulationTallOverlay \
 	DisplayCutoutEmulationWaterfallOverlay \
 	FontNotoSerifSourceOverlay \
 	NavigationBarMode3ButtonOverlay \
+	NavigationBarMode2ButtonOverlay \
 	NavigationBarModeGesturalOverlay \
 	NavigationBarModeGesturalOverlayNarrowBack \
 	NavigationBarModeGesturalOverlayWideBack \
 	NavigationBarModeGesturalOverlayExtraWideBack \
         OneHandedModeGesturalOverlay \
 	preinstalled-packages-platform-overlays.xml
 
 include $(BUILD_PHONY_PACKAGE)
 include $(CLEAR_VARS)
 

commit 7be9efd79a50edf14a9de96ba5cd10275a0e393d
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2019-05-11 15:47:05-0400

    GrapheneOS logo mask
---
 core/res/assets/images/android-logo-mask.png | Bin 12104 -> 5937 bytes
 1 file changed, 0 insertions(+), 0 deletions(-)

diff --git a/core/res/assets/images/android-logo-mask.png b/core/res/assets/images/android-logo-mask.png
index 5512c0ad8a83b8df0b5d396fb2dac9487a240a4d..fae0c03f594e4bd23e843afb3bc8a1e09653dfb5 100644
Binary files a/core/res/assets/images/android-logo-mask.png and b/core/res/assets/images/android-logo-mask.png differ

commit 83a43882ab96c7af977a3ee56c1dc0e2abeb02b9
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2017-09-06 21:40:48-0400

    always set deprecated Build.SERIAL to UNKNOWN
    
    Only support fetching the serial number via the new Build.getSerial()
    requiring the READ_PHONE_STATE permission.
---
 .../core/java/com/android/server/am/ActivityManagerService.java    | 7 +------
 1 file changed, 1 insertion(+), 6 deletions(-)

diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index ade36d8bf7e5b7f8215a65219e94fc5d1b9aa3b6..d4bb8abc3224ac493cf95802297dcc8fd5f79c7a 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -4473,26 +4473,21 @@ public class ActivityManagerService extends IActivityManager.Stub
                 notifyPackageUse(instr.mClass.getPackageName(),
                                  PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION);
             }
             ProtoLog.v(WM_DEBUG_CONFIGURATION, "Binding proc %s with config %s",
                     processName, app.getWindowProcessController().getConfiguration());
             ApplicationInfo appInfo = instr != null ? instr.mTargetInfo : app.info;
             app.setCompat(compatibilityInfoForPackage(appInfo));
 
             ProfilerInfo profilerInfo = mAppProfiler.setupProfilerInfoLocked(thread, app, instr);
 
-            // We deprecated Build.SERIAL and it is not accessible to
-            // Instant Apps and target APIs higher than O MR1. Since access to the serial
-            // is now behind a permission we push down the value.
-            final String buildSerial = (!appInfo.isInstantApp()
-                    && appInfo.targetSdkVersion < Build.VERSION_CODES.P)
-                            ? sTheRealBuildSerial : Build.UNKNOWN;
+            final String buildSerial = Build.UNKNOWN;
 
             // Figure out whether the app needs to run in autofill compat mode.
             AutofillOptions autofillOptions = null;
             if (UserHandle.getAppId(app.info.uid) >= Process.FIRST_APPLICATION_UID) {
                 final AutofillManagerInternal afm = LocalServices.getService(
                         AutofillManagerInternal.class);
                 if (afm != null) {
                     autofillOptions = afm.getAutofillOptions(
                             app.info.packageName, app.info.longVersionCode, app.userId);
                 }

commit a6a3544456316c6dfcf3bb98d924a6f970264c0d
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2019-03-17 19:54:30-0400

    stop auto-granting location to system browsers
---
 .../server/pm/permission/DefaultPermissionGrantPolicy.java  | 13 -------------
 1 file changed, 13 deletions(-)

diff --git a/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java b/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
index cb28637e8c1037bfa0c9278151dd5ddb5d25b82d..77ae50533f42f8dc3c6d7955805d4687431c7549 100644
--- a/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
+++ b/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
@@ -699,33 +699,20 @@ final class DefaultPermissionGrantPolicy {
                 getDefaultSystemHandlerActivityPackage(pm,
                         DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE, userId),
                 userId, CONTACTS_PERMISSIONS);
 
         // Email
         grantPermissionsToSystemPackage(pm,
                 getDefaultSystemHandlerActivityPackageForCategory(pm,
                         Intent.CATEGORY_APP_EMAIL, userId),
                 userId, CONTACTS_PERMISSIONS, CALENDAR_PERMISSIONS);
 
-        // Browser
-        String browserPackage = ArrayUtils.firstOrNull(getKnownPackages(
-                PackageManagerInternal.PACKAGE_BROWSER, userId));
-        if (browserPackage == null) {
-            browserPackage = getDefaultSystemHandlerActivityPackageForCategory(pm,
-                    Intent.CATEGORY_APP_BROWSER, userId);
-            if (!pm.isSystemPackage(browserPackage)) {
-                browserPackage = null;
-            }
-        }
-        grantPermissionsToPackage(pm, browserPackage, userId, false /* ignoreSystemPackage */,
-                true /*whitelistRestrictedPermissions*/, FOREGROUND_LOCATION_PERMISSIONS);
-
         // Voice interaction
         if (voiceInteractPackageNames != null) {
             for (String voiceInteractPackageName : voiceInteractPackageNames) {
                 grantPermissionsToSystemPackage(pm, voiceInteractPackageName, userId,
                         CONTACTS_PERMISSIONS, CALENDAR_PERMISSIONS, MICROPHONE_PERMISSIONS,
                         PHONE_PERMISSIONS, SMS_PERMISSIONS, ALWAYS_LOCATION_PERMISSIONS,
                         NEARBY_DEVICES_PERMISSIONS);
             }
         }
 

commit 1e8da0ac6feceb419ee26ffb69a47bdd8adaf419
Author: inthewaves <inthewaves@pm.me>
Date:   Sat 2020-09-12 12:28:34-0700

    support new special runtime permissions
    
    These are treated as a runtime permission even for legacy apps. They
    need to be granted by default for all apps to maintain compatibility.
    
    Ported from 10: 4d5d82f4e2fb9ff68158bf30f3944591bb74dd04
    
    Changes from 10:
    - It seems like parts of PackageManagerService#resetUserChangesToRuntimePermissionsAndFlagsLPw
    were refactored into PermissionManagerService#resetRuntimePermissionsInternal.
    As a result, PackageManagerService is no longer modified.
    
    [kdrag0n: Ported to Android 12]
    Signed-off-by: Danny Lin <danny@kdrag0n.dev>
---
 .../pm/permission/PermissionManagerService.java    | 25 +++++++++++++++++-----
 1 file changed, 20 insertions(+), 5 deletions(-)

diff --git a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
index 54a6c678e0da97a90a6c0ef4f0cbbb9150a99c9a..41b43e3c38bde52f111be3ef8e733af0a6fe0460 100644
--- a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
+++ b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
@@ -1518,21 +1518,22 @@ public class PermissionManagerService extends IPermissionManager.Stub {
             if (!(uidState.hasPermissionState(permName)
                     || pkg.getRequestedPermissions().contains(permName))) {
                 throw new SecurityException("Package " + pkg.getPackageName()
                         + " has not requested permission " + permName);
             }
 
             // If a permission review is required for legacy apps we represent
             // their permissions as always granted runtime ones since we need
             // to keep the review required permission flag per user while an
             // install permission's state is shared across all users.
-            if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.M && bp.isRuntime()) {
+            if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.M && bp.isRuntime() &&
+                    !isSpecialRuntimePermission(permName)) {
                 return;
             }
 
             final int flags = uidState.getPermissionFlags(permName);
             if ((flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0) {
                 Log.e(TAG, "Cannot grant system fixed permission "
                         + permName + " for package " + packageName);
                 return;
             }
             if (!overridePolicy && (flags & PackageManager.FLAG_PERMISSION_POLICY_FIXED) != 0) {
@@ -1561,21 +1562,22 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                 //  per-user. It isn't documented behavior and relatively rarely used anyway.
                 if (!uidState.grantPermission(bp)) {
                     return;
                 }
             } else {
                 if (ps.getInstantApp(userId) && !bp.isInstant()) {
                     throw new SecurityException("Cannot grant non-ephemeral permission" + permName
                             + " for package " + packageName);
                 }
 
-                if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.M) {
+                if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.M &&
+                    !isSpecialRuntimePermission(permName)) {
                     Slog.w(TAG, "Cannot grant runtime permission to a legacy app");
                     return;
                 }
 
                 if (!uidState.grantPermission(bp)) {
                     return;
                 }
             }
         }
 
@@ -1686,21 +1688,22 @@ public class PermissionManagerService extends IPermissionManager.Stub {
             if (!(uidState.hasPermissionState(permName)
                     || pkg.getRequestedPermissions().contains(permName))) {
                 throw new SecurityException("Package " + pkg.getPackageName()
                         + " has not requested permission " + permName);
             }
 
             // If a permission review is required for legacy apps we represent
             // their permissions as always granted runtime ones since we need
             // to keep the review required permission flag per user while an
             // install permission's state is shared across all users.
-            if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.M && bp.isRuntime()) {
+            if (pkg.getTargetSdkVersion() < Build.VERSION_CODES.M && bp.isRuntime() &&
+                    !isSpecialRuntimePermission(permName)) {
                 return;
             }
 
             final int flags = uidState.getPermissionFlags(permName);
             // Only the system may revoke SYSTEM_FIXED permissions.
             if ((flags & PackageManager.FLAG_PERMISSION_SYSTEM_FIXED) != 0
                     && UserHandle.getCallingAppId() != Process.SYSTEM_UID) {
                 throw new SecurityException("Non-System UID cannot revoke system fixed permission "
                         + permName + " for package " + packageName);
             }
@@ -1891,21 +1894,22 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                 continue;
             }
 
             // Never clobber system or policy.
             if ((oldFlags & policyOrSystemFlags) != 0) {
                 continue;
             }
 
             // If this permission was granted by default or role, make sure it is.
             if ((oldFlags & FLAG_PERMISSION_GRANTED_BY_DEFAULT) != 0
-                    || (oldFlags & FLAG_PERMISSION_GRANTED_BY_ROLE) != 0) {
+                    || (oldFlags & FLAG_PERMISSION_GRANTED_BY_ROLE) != 0
+                    || isSpecialRuntimePermission(permName)) {
                 // PermissionPolicyService will handle the app op for runtime permissions later.
                 grantRuntimePermissionInternal(packageName, permName, false,
                         Process.SYSTEM_UID, userId, delayingPermCallback);
             // In certain cases we should leave the state unchanged:
             // -- If permission review is enabled the permissions for a legacy apps
             // are represented as constantly granted runtime ones
             // -- If the permission was split from a non-runtime permission
             } else if ((flags & FLAG_PERMISSION_REVIEW_REQUIRED) == 0
                     && !isPermissionSplitFromNonRuntime(permName, targetSdk)) {
                 // Otherwise, reset the permission.
@@ -2580,20 +2584,24 @@ public class PermissionManagerService extends IPermissionManager.Stub {
     private int[] getPermissionGidsInternal(@NonNull String permissionName, @UserIdInt int userId) {
         synchronized (mLock) {
             Permission permission = mRegistry.getPermission(permissionName);
             if (permission == null) {
                 return EmptyArray.INT;
             }
             return permission.computeGids(userId);
         }
     }
 
+    public static boolean isSpecialRuntimePermission(final String permission) {
+        return false;
+    }
+
     /**
      * Restore the permission state for a package.
      *
      * <ul>
      *     <li>During boot the state gets restored from the disk</li>
      *     <li>During app update the state gets restored from the last version of the app</li>
      * </ul>
      *
      * @param pkg the package the permissions belong to
      * @param replace if the package is getting replaced (this might change the requested
@@ -2959,20 +2967,27 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                             // Hard restricted permissions cannot be held.
                             } else if (!permissionPolicyInitialized
                                     || (!hardRestricted || restrictionExempt)) {
                                 if ((origPermState != null && origPermState.isGranted())
                                         || legacyActivityRecognitionPermission != null) {
                                     if (!uidState.grantPermission(bp)) {
                                         wasChanged = true;
                                     }
                                 }
                             }
+
+                            if (isSpecialRuntimePermission(permName) &&
+                                    origPermState == null) {
+                                if (uidState.grantPermission(bp)) {
+                                    wasChanged = true;
+                                }
+                            }
                         } else {
                             if (origPermState == null) {
                                 // New permission
                                 if (PLATFORM_PACKAGE_NAME.equals(
                                         bp.getPackageName())) {
                                     if (!bp.isRemoved()) {
                                         flags |= FLAG_PERMISSION_REVIEW_REQUIRED
                                                 | FLAG_PERMISSION_REVOKED_COMPAT;
                                         wasChanged = true;
                                     }
@@ -3796,21 +3811,21 @@ public class PermissionManagerService extends IPermissionManager.Stub {
             synchronized (mLock) {
                 final Permission bp = mRegistry.getPermission(permission);
                 shouldGrantPermission = bp != null && (bp.isRuntime() || bp.isDevelopment())
                         && (!instantApp || bp.isInstant())
                         && (supportsRuntimePermissions || !bp.isRuntimeOnly())
                         && (permissions == null || permissions.contains(permission));
             }
             if (shouldGrantPermission) {
                 final int flags = getPermissionFlagsInternal(pkg.getPackageName(), permission,
                         myUid, userId);
-                if (supportsRuntimePermissions) {
+                if (supportsRuntimePermissions || isSpecialRuntimePermission(permission)) {
                     // Installer cannot change immutable permissions.
                     if ((flags & immutableFlags) == 0) {
                         grantRuntimePermissionInternal(pkg.getPackageName(), permission, false,
                                 myUid, userId, mDefaultPermissionCallback);
                     }
                 } else {
                     // In permission review mode we clear the review flag and the revoked compat
                     // flag when we are asked to install the app with all permissions granted.
                     if ((flags & compatFlags) != 0) {
                         updatePermissionFlagsInternal(pkg.getPackageName(), permission, compatFlags,

commit 69e9dd5b11af2ab28a384499bee5d22dfd62fd7f
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2019-03-17 11:59:15-0400

    make INTERNET into a special runtime permission
    
    Ported from 10: 5e2898e9d21dd6802bb0b0139e7e496c41e1cd80
---
 core/res/AndroidManifest.xml                                            | 2 +-
 .../java/com/android/server/pm/permission/PermissionManagerService.java | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index f525315dd5fa0b6e0fc323898c15ad106f98324c..d1f27726c4dd42d4395aed707b646090fbf0fad5 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -1715,21 +1715,21 @@
     <!-- Permissions for accessing networks -->
     <!-- ======================================= -->
     <eat-comment />
 
     <!-- Allows applications to open network sockets.
          <p>Protection level: normal
     -->
     <permission android:name="android.permission.INTERNET"
         android:description="@string/permdesc_createNetworkSockets"
         android:label="@string/permlab_createNetworkSockets"
-        android:protectionLevel="normal|instant" />
+        android:protectionLevel="dangerous|instant" />
 
     <!-- Allows applications to access information about networks.
          <p>Protection level: normal
     -->
     <permission android:name="android.permission.ACCESS_NETWORK_STATE"
         android:description="@string/permdesc_accessNetworkState"
         android:label="@string/permlab_accessNetworkState"
         android:protectionLevel="normal|instant" />
 
     <!-- Allows applications to access information about Wi-Fi networks.
diff --git a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
index 41b43e3c38bde52f111be3ef8e733af0a6fe0460..22d3fd41ea64b152a1fe56c333b8cd5d0c503542 100644
--- a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
+++ b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
@@ -2585,21 +2585,21 @@ public class PermissionManagerService extends IPermissionManager.Stub {
         synchronized (mLock) {
             Permission permission = mRegistry.getPermission(permissionName);
             if (permission == null) {
                 return EmptyArray.INT;
             }
             return permission.computeGids(userId);
         }
     }
 
     public static boolean isSpecialRuntimePermission(final String permission) {
-        return false;
+        return Manifest.permission.INTERNET.equals(permission);
     }
 
     /**
      * Restore the permission state for a package.
      *
      * <ul>
      *     <li>During boot the state gets restored from the disk</li>
      *     <li>During app update the state gets restored from the last version of the app</li>
      * </ul>
      *

commit 98035f6b80887997a82a1547155efa40b7f81a55
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2017-07-21 11:23:07-0400

    add a NETWORK permission group for INTERNET
    
    Ported from 10: b5c9f9407d5f5407686ea8c02fa67573ddc07824
    
    Changes from 10:
    - Needed to run `m api-stubs-docs-non-updatable-update-current-api`
    to fix the "You have tried to change the API from what has been
    previously approved" errors.
---
 core/api/current.txt            | 2 ++
 core/res/AndroidManifest.xml    | 8 ++++++++
 core/res/res/values/strings.xml | 5 +++++
 3 files changed, 15 insertions(+)

diff --git a/core/api/current.txt b/core/api/current.txt
index 1dd401d04e2b09e3858bd98ace438be82a9df780..8d0391a801931cbe7be1ee80c8babcf93826c636 100644
--- a/core/api/current.txt
+++ b/core/api/current.txt
@@ -196,20 +196,22 @@ package android {
   public static final class Manifest.permission_group {
     ctor public Manifest.permission_group();
     field public static final String ACTIVITY_RECOGNITION = "android.permission-group.ACTIVITY_RECOGNITION";
     field public static final String CALENDAR = "android.permission-group.CALENDAR";
     field public static final String CALL_LOG = "android.permission-group.CALL_LOG";
     field public static final String CAMERA = "android.permission-group.CAMERA";
     field public static final String CONTACTS = "android.permission-group.CONTACTS";
     field public static final String LOCATION = "android.permission-group.LOCATION";
     field public static final String MICROPHONE = "android.permission-group.MICROPHONE";
     field public static final String NEARBY_DEVICES = "android.permission-group.NEARBY_DEVICES";
+    field public static final String NETWORK = "android.permission-group.NETWORK";
+    field public static final String OTHER_SENSORS = "android.permission-group.OTHER_SENSORS";
     field public static final String PHONE = "android.permission-group.PHONE";
     field public static final String SENSORS = "android.permission-group.SENSORS";
     field public static final String SMS = "android.permission-group.SMS";
     field public static final String STORAGE = "android.permission-group.STORAGE";
   }
 
   public final class R {
     ctor public R();
   }
 
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index d1f27726c4dd42d4395aed707b646090fbf0fad5..d146c64dd187339ab18b7d6bd216039295ad910d 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -1709,24 +1709,32 @@
          @hide
     -->
     <permission android:name="android.permission.ACCESS_MOCK_LOCATION"
         android:protectionLevel="signature" />
 
     <!-- ======================================= -->
     <!-- Permissions for accessing networks -->
     <!-- ======================================= -->
     <eat-comment />
 
+    <!-- Network access -->
+    <permission-group android:name="android.permission-group.NETWORK"
+        android:icon="@drawable/perm_group_network"
+        android:label="@string/permgrouplab_network"
+        android:description="@string/permgroupdesc_network"
+        android:priority="900" />
+
     <!-- Allows applications to open network sockets.
          <p>Protection level: normal
     -->
     <permission android:name="android.permission.INTERNET"
+        android:permissionGroup="android.permission-group.UNDEFINED"
         android:description="@string/permdesc_createNetworkSockets"
         android:label="@string/permlab_createNetworkSockets"
         android:protectionLevel="dangerous|instant" />
 
     <!-- Allows applications to access information about networks.
          <p>Protection level: normal
     -->
     <permission android:name="android.permission.ACCESS_NETWORK_STATE"
         android:description="@string/permdesc_accessNetworkState"
         android:label="@string/permlab_accessNetworkState"
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index 166d6abd1809f49d41e7429a2dc9bfed32028b9f..27c9026c863aba2027624584582e5881c8b23f5b 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -830,20 +830,25 @@
     <string name="permgrouplab_phone">Phone</string>
     <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgroupdesc_phone">make and manage phone calls</string>
     <!-- Message shown to the user when the apps requests permission from this group. If ever possible this should stay below 80 characters (assuming the parameters takes 20 characters). Don't abbreviate until the message reaches 120 characters though. [CHAR LIMIT=120] -->
 
     <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgrouplab_sensors">Body sensors</string>
     <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgroupdesc_sensors">access sensor data about your vital signs</string>
 
+    <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_network">Network</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_network">access the network</string>
+
     <!-- Title for the capability of an accessibility service to retrieve window content. -->
     <string name="capability_title_canRetrieveWindowContent">Retrieve window content</string>
     <!-- Description for the capability of an accessibility service to retrieve window content. -->
     <string name="capability_desc_canRetrieveWindowContent">Inspect the content of a window you\'re
         interacting with.</string>
 
     <!-- Title for the capability of an accessibility service to request touch exploration. -->
     <string name="capability_title_canRequestTouchExploration">Turn on Explore by Touch</string>
     <!-- Description for the capability of an accessibility service to request touch exploration. -->
     <string name="capability_desc_canRequestTouchExploration">Tapped items will be spoken aloud

commit 4d9e07e504405d0ac70a8000605b79401a07bdd5
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2017-10-07 15:54:42-0400

    add special runtime permission for other sensors
    
    This covers sensors not included in the existing runtime permission for
    body sensors.
    
    Ported from 10: 9ec9f7f521323552fa658b46862c8408f1a7b41b
    
    Changes from 10:
    - Needed to run `m api-stubs-docs-non-updatable-update-current-api`
    to fix the "You have tried to change the API from what has been
    previously approved" errors.
---
 core/api/current.txt                                         |  1 +
 core/java/android/content/pm/PackageParser.java              |  2 ++
 core/res/AndroidManifest.xml                                 | 12 ++++++++++++
 core/res/res/values/strings.xml                              | 12 ++++++++++++
 .../server/pm/permission/PermissionManagerService.java       |  2 +-
 5 files changed, 28 insertions(+), 1 deletion(-)

diff --git a/core/api/current.txt b/core/api/current.txt
index 8d0391a801931cbe7be1ee80c8babcf93826c636..57f4821bb63148645f4cbfedff27855e6401f024 100644
--- a/core/api/current.txt
+++ b/core/api/current.txt
@@ -109,20 +109,21 @@ package android {
     field public static final String MANAGE_OWN_CALLS = "android.permission.MANAGE_OWN_CALLS";
     field public static final String MASTER_CLEAR = "android.permission.MASTER_CLEAR";
     field public static final String MEDIA_CONTENT_CONTROL = "android.permission.MEDIA_CONTENT_CONTROL";
     field public static final String MODIFY_AUDIO_SETTINGS = "android.permission.MODIFY_AUDIO_SETTINGS";
     field public static final String MODIFY_PHONE_STATE = "android.permission.MODIFY_PHONE_STATE";
     field public static final String MOUNT_FORMAT_FILESYSTEMS = "android.permission.MOUNT_FORMAT_FILESYSTEMS";
     field public static final String MOUNT_UNMOUNT_FILESYSTEMS = "android.permission.MOUNT_UNMOUNT_FILESYSTEMS";
     field public static final String NFC = "android.permission.NFC";
     field public static final String NFC_PREFERRED_PAYMENT_INFO = "android.permission.NFC_PREFERRED_PAYMENT_INFO";
     field public static final String NFC_TRANSACTION_EVENT = "android.permission.NFC_TRANSACTION_EVENT";
+    field public static final String OTHER_SENSORS = "android.permission.OTHER_SENSORS";
     field public static final String PACKAGE_USAGE_STATS = "android.permission.PACKAGE_USAGE_STATS";
     field @Deprecated public static final String PERSISTENT_ACTIVITY = "android.permission.PERSISTENT_ACTIVITY";
     field @Deprecated public static final String PROCESS_OUTGOING_CALLS = "android.permission.PROCESS_OUTGOING_CALLS";
     field public static final String QUERY_ALL_PACKAGES = "android.permission.QUERY_ALL_PACKAGES";
     field public static final String READ_CALENDAR = "android.permission.READ_CALENDAR";
     field public static final String READ_CALL_LOG = "android.permission.READ_CALL_LOG";
     field public static final String READ_CONTACTS = "android.permission.READ_CONTACTS";
     field public static final String READ_EXTERNAL_STORAGE = "android.permission.READ_EXTERNAL_STORAGE";
     field @Deprecated public static final String READ_INPUT_STATE = "android.permission.READ_INPUT_STATE";
     field public static final String READ_LOGS = "android.permission.READ_LOGS";
diff --git a/core/java/android/content/pm/PackageParser.java b/core/java/android/content/pm/PackageParser.java
index 4ff26242dab2beae2e6e77964c7bf1172c75b685..bd273f3001f9bfb7f19e7fe4606297e641604e3a 100644
--- a/core/java/android/content/pm/PackageParser.java
+++ b/core/java/android/content/pm/PackageParser.java
@@ -274,20 +274,22 @@ public class PackageParser {
      * NOTE: These must be declared in SDK version order, with permissions
      * added to older SDKs appearing before those added to newer SDKs.
      * If sdkVersion is 0, then this is not a permission that we want to
      * automatically add to older apps, but we do want to allow it to be
      * granted during a platform update.
      * @hide
      */
     @UnsupportedAppUsage
     public static final PackageParser.NewPermissionInfo NEW_PERMISSIONS[] =
         new PackageParser.NewPermissionInfo[] {
+            new PackageParser.NewPermissionInfo(android.Manifest.permission.OTHER_SENSORS,
+                    android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.WRITE_EXTERNAL_STORAGE,
                     android.os.Build.VERSION_CODES.DONUT, 0),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.READ_PHONE_STATE,
                     android.os.Build.VERSION_CODES.DONUT, 0)
     };
 
     /**
      * @deprecated callers should move to explicitly passing around source path.
      */
     @Deprecated
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index d146c64dd187339ab18b7d6bd216039295ad910d..876b526e9aba70b364e205a9a4974d83085afd6f 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -1478,20 +1478,32 @@
 
     <!-- Allows an app to use device supported biometric modalities.
          <p>Protection level: normal
     -->
     <permission android:name="android.permission.USE_BIOMETRIC"
         android:permissionGroup="android.permission-group.SENSORS"
         android:label="@string/permlab_useBiometric"
         android:description="@string/permdesc_useBiometric"
         android:protectionLevel="normal" />
 
+    <permission-group android:name="android.permission-group.OTHER_SENSORS"
+        android:icon="@drawable/perm_group_location"
+        android:label="@string/permgrouplab_otherSensors"
+        android:description="@string/permgroupdesc_otherSensors"
+        android:priority="1000" />
+
+    <permission android:name="android.permission.OTHER_SENSORS"
+        android:permissionGroup="android.permission-group.UNDEFINED"
+        android:label="@string/permlab_otherSensors"
+        android:description="@string/permdesc_otherSensors"
+        android:protectionLevel="dangerous" />
+
     <!-- ====================================================================== -->
     <!-- REMOVED PERMISSIONS                                                    -->
     <!-- ====================================================================== -->
 
     <!-- @hide We need to keep this around for backwards compatibility -->
     <permission android:name="android.permission.READ_PROFILE"
         android:protectionLevel="normal"
         android:permissionFlags="removed"/>
 
     <!-- @hide We need to keep this around for backwards compatibility -->
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index 27c9026c863aba2027624584582e5881c8b23f5b..4a8624222ae822b6d0ce7112470d9feb6b3819ea 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -830,20 +830,25 @@
     <string name="permgrouplab_phone">Phone</string>
     <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgroupdesc_phone">make and manage phone calls</string>
     <!-- Message shown to the user when the apps requests permission from this group. If ever possible this should stay below 80 characters (assuming the parameters takes 20 characters). Don't abbreviate until the message reaches 120 characters though. [CHAR LIMIT=120] -->
 
     <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgrouplab_sensors">Body sensors</string>
     <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgroupdesc_sensors">access sensor data about your vital signs</string>
 
+    <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgrouplab_otherSensors">Sensors</string>
+    <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permgroupdesc_otherSensors">access sensor data about orientation, movement, etc.</string>
+
     <!-- Title of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgrouplab_network">Network</string>
     <!-- Description of a category of application permissions, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permgroupdesc_network">access the network</string>
 
     <!-- Title for the capability of an accessibility service to retrieve window content. -->
     <string name="capability_title_canRetrieveWindowContent">Retrieve window content</string>
     <!-- Description for the capability of an accessibility service to retrieve window content. -->
     <string name="capability_desc_canRetrieveWindowContent">Inspect the content of a window you\'re
         interacting with.</string>
@@ -1158,20 +1163,27 @@
     <string name="permdesc_writeCallLog" product="default">Allows the app to modify your phone\'s call log, including data about incoming and outgoing calls.
         Malicious apps may use this to erase or modify your call log.</string>
 
     <!-- Title of the body sensors permission, listed so the user can decide whether to allow the application to access body sensor data. [CHAR LIMIT=80] -->
     <string name="permlab_bodySensors">access body sensors (like heart rate monitors)
     </string>
     <!-- Description of the body sensors permission, listed so the user can decide whether to allow the application to access data from body sensors. [CHAR LIMIT=NONE] -->
     <string name="permdesc_bodySensors" product="default">Allows the app to access data from sensors
     that monitor your physical condition, such as your heart rate.</string>
 
+    <!-- Title of the sensors permission, listed so the user can decide whether to allow the application to access sensor data. [CHAR LIMIT=80] -->
+    <string name="permlab_otherSensors">access sensors (like the compass)
+    </string>
+    <!-- Description of the sensors permission, listed so the user can decide whether to allow the application to access data from sensors. [CHAR LIMIT=NONE] -->
+    <string name="permdesc_otherSensors" product="default">Allows the app to access data from sensors
+    monitoring orientation, movement, vibration (including low frequency sound) and environmental data</string>
+
     <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permlab_readCalendar">Read calendar events and details</string>
     <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permdesc_readCalendar" product="tablet">This app can read all calendar events stored on your tablet and share or save your calendar data.</string>
     <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permdesc_readCalendar" product="tv">This app can read all calendar events stored on your Android TV device and share or save your calendar data.</string>
     <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permdesc_readCalendar" product="default">This app can read all calendar events stored on your phone and share or save your calendar data.</string>
 
     <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
diff --git a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
index 22d3fd41ea64b152a1fe56c333b8cd5d0c503542..60dc0a0277254b6cf1cd2539e1cca36c58305499 100644
--- a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
+++ b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
@@ -2585,21 +2585,21 @@ public class PermissionManagerService extends IPermissionManager.Stub {
         synchronized (mLock) {
             Permission permission = mRegistry.getPermission(permissionName);
             if (permission == null) {
                 return EmptyArray.INT;
             }
             return permission.computeGids(userId);
         }
     }
 
     public static boolean isSpecialRuntimePermission(final String permission) {
-        return Manifest.permission.INTERNET.equals(permission);
+        return Manifest.permission.INTERNET.equals(permission) || Manifest.permission.OTHER_SENSORS.equals(permission);
     }
 
     /**
      * Restore the permission state for a package.
      *
      * <ul>
      *     <li>During boot the state gets restored from the disk</li>
      *     <li>During app update the state gets restored from the last version of the app</li>
      * </ul>
      *

commit 0a4626fd485bef443f2d8324a7601eeb98f9309b
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Tue 2021-10-05 16:27:43-0700

    net: Notify ConnectivityService of runtime permission changes
    
    ConnectivityService needs permission change events in order to enforce
    INTERNET permission updates correctly at runtime.
    
    Change-Id: I74b0b8a5aa70f0794b4f3d72c70167dbe2aae88d
---
 .../com/android/server/net/NetworkPolicyManagerService.java  | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/services/core/java/com/android/server/net/NetworkPolicyManagerService.java b/services/core/java/com/android/server/net/NetworkPolicyManagerService.java
index cfefffcdd2e829a7ec9e2dceab2a75231b1ad2ef..d317953a2c27704efc7351a83f310fcd65b5c7b9 100644
--- a/services/core/java/com/android/server/net/NetworkPolicyManagerService.java
+++ b/services/core/java/com/android/server/net/NetworkPolicyManagerService.java
@@ -166,22 +166,24 @@ import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.usage.UsageStatsManagerInternal;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageManager;
+import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.PackageManagerInternal;
 import android.content.pm.UserInfo;
 import android.content.res.Resources;
 import android.database.ContentObserver;
 import android.net.ConnectivityManager;
 import android.net.ConnectivityManager.NetworkCallback;
 import android.net.INetworkManagementEventObserver;
 import android.net.INetworkPolicyListener;
 import android.net.INetworkPolicyManager;
 import android.net.INetworkStatsService;
 import android.net.Network;
@@ -267,20 +269,21 @@ import com.android.internal.util.DumpUtils;
 import com.android.internal.util.IndentingPrintWriter;
 import com.android.internal.util.StatLogger;
 import com.android.internal.util.XmlUtils;
 import com.android.net.module.util.NetworkIdentityUtils;
 import com.android.net.module.util.PermissionUtils;
 import com.android.server.EventLogTags;
 import com.android.server.LocalServices;
 import com.android.server.ServiceThread;
 import com.android.server.SystemConfig;
 import com.android.server.connectivity.MultipathPolicyTracker;
+import com.android.server.pm.permission.PermissionManagerServiceInternal;
 import com.android.server.usage.AppStandbyInternal;
 import com.android.server.usage.AppStandbyInternal.AppIdleStateChangeListener;
 
 import libcore.io.IoUtils;
 
 import org.xmlpull.v1.XmlPullParserException;
 
 import java.io.File;
 import java.io.FileDescriptor;
 import java.io.FileInputStream;
@@ -757,20 +760,29 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         mAppOps = context.getSystemService(AppOpsManager.class);
         mMultipathPolicyTracker = new MultipathPolicyTracker(mContext, mHandler);
         // Expose private service for system components to use.
         LocalServices.addService(NetworkPolicyManagerInternal.class,
                 new NetworkPolicyManagerInternalImpl());
     }
 
     public void bindConnectivityManager() {
         mConnManager = Objects.requireNonNull(mContext.getSystemService(ConnectivityManager.class),
                 "missing ConnectivityManager");
+
+        // Listen for permission changes and forward to ConnectivityService
+        PermissionManagerServiceInternal pm = LocalServices.getService(
+                PermissionManagerServiceInternal.class);
+        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);
+        pm.addOnRuntimePermissionStateChangedListener((packageName, userId) -> {
+            int uid = pmi.getPackageUid(packageName, PackageManager.GET_PERMISSIONS, userId);
+            mConnManager.onPackagePermissionChanged(uid);
+        });
     }
 
     @GuardedBy("mUidRulesFirstLock")
     private void updatePowerSaveWhitelistUL() {
         int[] whitelist = mPowerWhitelistManager.getWhitelistedAppIds(/* includingIdle */ false);
         mPowerSaveWhitelistExceptIdleAppIds.clear();
         for (int uid : whitelist) {
             mPowerSaveWhitelistExceptIdleAppIds.put(uid, true);
         }
 

commit 36c001b642bc24cf0204c9aee74b360f33e0ce8e
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Sun 2021-10-10 22:20:11-0700

    gmscompat: Add compatibility layer for unprivileged Google Play services
    
    This is a compatibility layer that allows installing Google Play
    services, Google Play Store, and Google Services Framework as regular,
    unprivileged apps in the standard app sandbox. Most functionality works
    without giving Google Play Services any special privileges, permissions,
    or security exceptions, including:
    
    - Account login (including two-factor authentication with NFC security keys)
    - Play Store
    - Firebase Cloud Messaging notifications (tested with Signal, Discord, Slack, and Gmail)
    - Firebase database API (tested with Swift Backup)
    - Firebase app indexing
    - Google Play Games
    - Account settings
    - Google My Account
    - Autofill
    - SMS verification receiver (tested with Signal)
    - Play license verification (both in-app purchases and paid apps)
    - Play Store app purchases
    - Play Store app installation (buggy)
    - SafetyNet (basic integrity passes, but not CTS profile checks)
    - Dynamite modules (e.g. Maps API v2 and Cronet)
    - Play geolocation API (buggy)
    
    The Google Play services family of apps can also be installed in a
    secondary user profile for isolation, and all of the above functionality
    will still work.
    
    NB: The DropBoxManager and DeviceConfig shims are not functionally
    meaningful, but they help reduce log spam that could obscure fatal
    errors.
    
    Change-Id: Ib6f6b36946dab2f6bb51650c1b6aabb628af46be
---
 core/api/module-lib-current.txt                    |   8 +
 core/java/android/app/ActivityManager.java         |   6 +
 core/java/android/app/ActivityThread.java          |   2 +
 core/java/android/app/AppOpsManager.java           |  21 ++
 .../android/app/ApplicationPackageManager.java     |  14 ++
 core/java/android/app/ContextImpl.java             |  14 ++
 core/java/android/app/Instrumentation.java         |   4 +
 core/java/android/app/LoadedApk.java               |   5 +
 core/java/android/app/NotificationManager.java     |   6 +
 core/java/android/app/SystemServiceRegistry.java   |   5 +
 .../android/app/admin/DevicePolicyManager.java     |  17 ++
 .../android/app/compat/gms/GmsCompat.java (new)    | 230 ++++++++++++++++++
 .../content/integrity/AppIntegrityManager.java     |  13 ++
 core/java/android/content/pm/PackageParser.java    |  11 +-
 .../content/pm/parsing/ParsingPackageUtils.java    |   3 +
 core/java/android/content/res/ApkAssets.java       |   9 +
 .../hardware/location/ContextHubManager.java       |  11 +
 core/java/android/net/NetworkScoreManager.java     |  13 ++
 core/java/android/os/Build.java                    |   7 +
 core/java/android/os/DropBoxManager.java           |   5 +
 core/java/android/os/UserManager.java              |  41 ++++
 core/java/android/provider/DeviceConfig.java       |  13 ++
 core/java/android/provider/Settings.java           |   5 +
 .../android/internal/gmscompat/GmsHooks.java (new) | 256 +++++++++++++++++++++
 .../android/internal/gmscompat/GmsInfo.java (new)  |  34 +++
 .../gmscompat/dynamite/GmsDynamiteHooks.java (new) | 197 ++++++++++++++++
 .../dynamite/client/DynamiteContext.java (new)     | 156 +++++++++++++
 .../dynamite/client/ModuleLoadState.java (new)     |  64 ++++++
 .../dynamite/server/FileProxyProvider.java (new)   |  87 +++++++
 .../dynamite/server/FileProxyService.java (new)    | 100 ++++++++
 .../dynamite/server/IFileProxyService.aidl (new)   |   7 +
 core/res/AndroidManifest.xml                       |   2 +-
 core/res/res/values/strings.xml                    |  14 ++
 core/res/res/values/symbols.xml                    |   5 +
 .../java/android/location/LocationManager.java     |   5 +
 .../android/server/am/ActivityManagerService.java  |   5 +
 .../com/android/server/compat/CompatChange.java    |   4 +
 .../java/com/android/server/pm/AppsFilter.java     |   7 +
 .../java/android/telephony/TelephonyManager.java   |  51 ++++
 39 files changed, 1455 insertions(+), 2 deletions(-)

diff --git a/core/api/module-lib-current.txt b/core/api/module-lib-current.txt
index e48a1da7b6a7e1aadf492309927a7b32d84e88b4..c04ec72ba9f7c5b1b83f520e189a5c1223f4dfeb 100644
--- a/core/api/module-lib-current.txt
+++ b/core/api/module-lib-current.txt
@@ -38,20 +38,28 @@ package android.app {
     method @RequiresPermission(android.Manifest.permission.GET_INTENT_SENDER_INTENT) public boolean intentFilterEquals(@Nullable android.app.PendingIntent);
     method @NonNull @RequiresPermission(android.Manifest.permission.GET_INTENT_SENDER_INTENT) public java.util.List<android.content.pm.ResolveInfo> queryIntentComponents(int);
   }
 
   public class StatusBarManager {
     method @RequiresPermission(android.Manifest.permission.STATUS_BAR) public void setExpansionDisabledForSimNetworkLock(boolean);
   }
 
 }
 
+package android.app.compat.gms {
+
+  public final class GmsCompat {
+    method public static boolean isEnabled();
+  }
+
+}
+
 package android.app.usage {
 
   public class NetworkStatsManager {
     method @RequiresPermission(anyOf={android.net.NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK, android.Manifest.permission.NETWORK_STACK}) public void notifyNetworkStatus(@NonNull java.util.List<android.net.Network>, @NonNull java.util.List<android.net.NetworkStateSnapshot>, @Nullable String, @NonNull java.util.List<android.net.UnderlyingNetworkInfo>);
   }
 
 }
 
 package android.content {
 
diff --git a/core/java/android/app/ActivityManager.java b/core/java/android/app/ActivityManager.java
index db45466d98d251e1ba075fb2c42cce2abcbf40b0..c9992424f36ae4b56f4a051128783674842ab5f7 100644
--- a/core/java/android/app/ActivityManager.java
+++ b/core/java/android/app/ActivityManager.java
@@ -25,20 +25,21 @@ import android.Manifest;
 import android.annotation.DrawableRes;
 import android.annotation.IntDef;
 import android.annotation.IntRange;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.annotation.UserIdInt;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.ConfigurationInfo;
 import android.content.pm.IPackageDataObserver;
@@ -76,20 +77,21 @@ import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.DisplayMetrics;
 import android.util.Singleton;
 import android.util.Size;
 import android.util.TypedXmlPullParser;
 import android.util.TypedXmlSerializer;
 import android.window.TaskSnapshot;
 
 import com.android.internal.app.LocalePicker;
 import com.android.internal.app.procstats.ProcessStats;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.RoSystemProperties;
 import com.android.internal.os.TransferPipe;
 import com.android.internal.util.FastPrintWriter;
 import com.android.internal.util.MemInfoReader;
 import com.android.internal.util.Preconditions;
 import com.android.server.LocalServices;
 
 import java.io.FileDescriptor;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -4030,20 +4032,24 @@ public class ActivityManager {
     /**
      * Gets the userId of the current foreground user. Requires system permissions.
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {
             "android.permission.INTERACT_ACROSS_USERS",
             "android.permission.INTERACT_ACROSS_USERS_FULL"
     })
     public static int getCurrentUser() {
+        if (GmsCompat.isEnabled()) {
+            return GmsHooks.getCurrentUser();
+        }
+
         try {
             return getService().getCurrentUserId();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * @param userid the user's id. Zero indicates the default user.
      * @hide
diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index 8af74edb88ff3654e663f54468fd098180e08beb..f6336956b35b9c65ab85c5ecc8c74d0cf24f8ac2 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -191,20 +191,21 @@ import android.view.translation.UiTranslationSpec;
 import android.webkit.WebView;
 import android.window.SizeConfigurationBuckets;
 import android.window.SplashScreen;
 import android.window.SplashScreenView;
 import android.window.WindowProviderService;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.app.IVoiceInteractor;
 import com.android.internal.content.ReferrerIntent;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.BinderInternal;
 import com.android.internal.os.RuntimeInit;
 import com.android.internal.os.SomeArgs;
 import com.android.internal.policy.DecorView;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.FastPrintWriter;
 import com.android.internal.util.Preconditions;
 import com.android.internal.util.function.pooled.PooledLambda;
 import com.android.org.conscrypt.OpenSSLSocketImpl;
 import com.android.org.conscrypt.TrustedCertificateStore;
@@ -4544,20 +4545,21 @@ public final class ActivityThread extends ClientTransactionHandler
                 context = (ContextImpl) context.createAttributionContext(attributionTag);
             }
             // Service resources must be initialized with the same loaders as the application
             // context.
             context.getResources().addLoaders(
                     app.getResources().getLoaders().toArray(new ResourcesLoader[0]));
 
             context.setOuterContext(service);
             service.attach(context, this, data.info.name, data.token, app,
                     ActivityManager.getService());
+            GmsHooks.attachService(service);
             service.onCreate();
             mServicesData.put(data.token, data);
             mServices.put(data.token, service);
             try {
                 ActivityManager.getService().serviceDoneExecuting(
                         data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
             } catch (RemoteException e) {
                 throw e.rethrowFromSystemServer();
             }
         } catch (Exception e) {
diff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java
index d932a29beca616c5115ccb18ed871fd18dd6865e..f0b749c40a5ff65cf14e394795cd3fea4d1723b8 100644
--- a/core/java/android/app/AppOpsManager.java
+++ b/core/java/android/app/AppOpsManager.java
@@ -21,20 +21,21 @@ import static java.lang.Long.max;
 import android.Manifest;
 import android.annotation.CallbackExecutor;
 import android.annotation.IntDef;
 import android.annotation.IntRange;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
+import android.app.compat.gms.GmsCompat;
 import android.app.usage.UsageStatsManager;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.AttributionSource;
 import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
@@ -8256,20 +8257,24 @@ public class AppOpsManager {
         return noteOpNoThrow(strOpToOp(op), uid, packageName, attributionTag, message);
     }
 
     /**
      * @see #noteOpNoThrow(String, int, String, String, String)
      *
      * @hide
      */
     public int noteOpNoThrow(int op, int uid, @Nullable String packageName,
             @Nullable String attributionTag, @Nullable String message) {
+        if (GmsCompat.isEnabled() && uid != Process.myUid()) {
+            return noteProxyOpNoThrow(op, packageName, uid, attributionTag, message);
+        }
+
         try {
             collectNoteOpCallsForValidation(op);
             int collectionMode = getNotedOpCollectionMode(uid, packageName, op);
             boolean shouldCollectMessage = Process.myUid() == Process.SYSTEM_UID;
             if (collectionMode == COLLECT_ASYNC) {
                 if (message == null) {
                     // Set stack trace as default message
                     message = getFormattedStackTrace();
                     shouldCollectMessage = true;
                 }
@@ -8405,20 +8410,28 @@ public class AppOpsManager {
      * @see #noteOpNoThrow(String, int, String, String, String)
      */
     public int noteProxyOpNoThrow(@NonNull String op, @Nullable String proxiedPackageName,
             int proxiedUid, @Nullable String proxiedAttributionTag, @Nullable String message) {
         return noteProxyOpNoThrow(strOpToOp(op), new AttributionSource(
                 mContext.getAttributionSource(), new AttributionSource(proxiedUid,
                         proxiedPackageName, proxiedAttributionTag, mContext.getAttributionSource()
                         .getToken())), message,/*skipProxyOperation*/ false);
     }
 
+    private int noteProxyOpNoThrow(int op, @Nullable String proxiedPackageName,
+            int proxiedUid, @Nullable String proxiedAttributionTag, @Nullable String message) {
+        return noteProxyOpNoThrow(op, new AttributionSource(
+                mContext.getAttributionSource(), new AttributionSource(proxiedUid,
+                proxiedPackageName, proxiedAttributionTag, mContext.getAttributionSource()
+                .getToken())), message,/*skipProxyOperation*/ false);
+    }
+
     /**
      * Make note of an application performing an operation on behalf of another application(s).
      *
      * @param op The operation to note. One of the OPSTR_* constants.
      * @param attributionSource The permission identity for which to note.
      * @param message A message describing the reason the op was noted
      * @param skipProxyOperation Whether to note op for the proxy
      *
      * @return Returns {@link #MODE_ALLOWED} if the operation is allowed, or {@link #MODE_IGNORED}
      * if it is not allowed and should be silently ignored (without causing the app to crash).
@@ -8761,20 +8774,24 @@ public class AppOpsManager {
     }
 
     /**
      * @see #startOpNoThrow(String, int, String, String, String)
      *
      * @hide
      */
     public int startOpNoThrow(@NonNull IBinder token, int op, int uid, @NonNull String packageName,
             boolean startIfModeDefault, @Nullable String attributionTag, @Nullable String message,
             @AttributionFlags int attributionFlags, int attributionChainId) {
+        if (GmsCompat.isEnabled() && uid != Process.myUid()) {
+            return noteProxyOpNoThrow(op, packageName, uid, attributionTag, message);
+        }
+
         try {
             collectNoteOpCallsForValidation(op);
             int collectionMode = getNotedOpCollectionMode(uid, packageName, op);
             boolean shouldCollectMessage = Process.myUid() == Process.SYSTEM_UID;
             if (collectionMode == COLLECT_ASYNC) {
                 if (message == null) {
                     // Set stack trace as default message
                     message = getFormattedStackTrace();
                     shouldCollectMessage = true;
                 }
@@ -8984,20 +9001,24 @@ public class AppOpsManager {
         finishOp(mContext.getAttributionSource().getToken(), op, uid, packageName, attributionTag);
     }
 
     /**
      * @see #finishOp(String, int, String, String)
      *
      * @hide
      */
     public void finishOp(IBinder token, int op, int uid, @NonNull String packageName,
             @Nullable String attributionTag) {
+        if (GmsCompat.isEnabled() && uid != Process.myUid()) {
+            return;
+        }
+
         try {
             mService.finishOperation(token, op, uid, packageName, attributionTag);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Report that an application is no longer performing an operation that had previously
      * been started with {@link #startProxyOp(String, int, String, String, String)}. There is no
diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index cd2c12cb4b6f221872ffdcf78dc70f9f957ba636..4dabe78f2f737c12314bd4697a839b9f44f39d7b 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -24,20 +24,21 @@ import static android.content.pm.Checksum.TYPE_WHOLE_SHA1;
 import static android.content.pm.Checksum.TYPE_WHOLE_SHA256;
 import static android.content.pm.Checksum.TYPE_WHOLE_SHA512;
 
 import android.annotation.CallbackExecutor;
 import android.annotation.DrawableRes;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.StringRes;
 import android.annotation.UserIdInt;
 import android.annotation.XmlRes;
+import android.app.compat.gms.GmsCompat;
 import android.app.role.RoleManager;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.IntentSender;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApkChecksum;
@@ -113,20 +114,21 @@ import android.system.OsConstants;
 import android.system.StructStat;
 import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.LauncherIcons;
 import android.util.Log;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.Immutable;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.SomeArgs;
 import com.android.internal.util.UserIcons;
 
 import dalvik.system.VMRuntime;
 
 import libcore.util.EmptyArray;
 
 import java.io.File;
 import java.lang.ref.WeakReference;
 import java.security.cert.Certificate;
@@ -209,36 +211,40 @@ public class ApplicationPackageManager extends PackageManager {
 
     @Override
     public PackageInfo getPackageInfo(String packageName, int flags)
             throws NameNotFoundException {
         return getPackageInfoAsUser(packageName, flags, getUserId());
     }
 
     @Override
     public PackageInfo getPackageInfo(VersionedPackage versionedPackage, int flags)
             throws NameNotFoundException {
+        flags = GmsHooks.getPackageInfoFlags(flags);
+
         final int userId = getUserId();
         try {
             PackageInfo pi = mPM.getPackageInfoVersioned(versionedPackage,
                     updateFlagsForPackage(flags, userId), userId);
             if (pi != null) {
                 return pi;
             }
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
         throw new NameNotFoundException(versionedPackage.toString());
     }
 
     @Override
     public PackageInfo getPackageInfoAsUser(String packageName, int flags, int userId)
             throws NameNotFoundException {
+        flags = GmsHooks.getPackageInfoFlags(flags);
+
         PackageInfo pi =
                 getPackageInfoAsUserCached(
                         packageName,
                         updateFlagsForPackage(flags, userId),
                         userId);
         if (pi == null) {
             throw new NameNotFoundException(packageName);
         }
         return pi;
     }
@@ -572,20 +578,24 @@ public class ApplicationPackageManager extends PackageManager {
     /** @hide */
     @Override
     public @NonNull List<SharedLibraryInfo> getSharedLibraries(int flags) {
         return getSharedLibrariesAsUser(flags, getUserId());
     }
 
     /** @hide */
     @Override
     @SuppressWarnings("unchecked")
     public @NonNull List<SharedLibraryInfo> getSharedLibrariesAsUser(int flags, int userId) {
+        if (GmsCompat.isEnabled()) {
+            return GmsHooks.getSharedLibrariesAsUser();
+        }
+
         try {
             ParceledListSlice<SharedLibraryInfo> sharedLibs = mPM.getSharedLibraries(
                     mContext.getOpPackageName(), flags, userId);
             if (sharedLibs == null) {
                 return Collections.emptyList();
             }
             return sharedLibs.getList();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
@@ -1797,20 +1807,24 @@ public class ApplicationPackageManager extends PackageManager {
                 mCachedSafeMode = mPM.isSafeMode() ? 1 : 0;
             }
             return mCachedSafeMode != 0;
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public void addOnPermissionsChangeListener(OnPermissionsChangedListener listener) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         getPermissionManager().addOnPermissionsChangeListener(listener);
     }
 
     @Override
     public void removeOnPermissionsChangeListener(OnPermissionsChangedListener listener) {
         getPermissionManager().removeOnPermissionsChangeListener(listener);
     }
 
     @UnsupportedAppUsage
     static void configurationChanged() {
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 06af6b180d075a44667ec46ca41fb11b87b3e973..078c3d639430295fba7654a8ff4da50ef37d717c 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -18,20 +18,21 @@ package android.app;
 
 import static android.content.pm.PackageManager.PERMISSION_DENIED;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.os.StrictMode.vmIncorrectContextUseEnabled;
 import static android.view.WindowManager.LayoutParams.WindowType;
 
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.UiContext;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.AttributionSource;
 import android.content.AutofillOptions;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.ContentCaptureOptions;
 import android.content.ContentProvider;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.ContextParams;
@@ -87,20 +88,21 @@ import android.util.AndroidRuntimeException;
 import android.util.ArrayMap;
 import android.util.Log;
 import android.util.Slog;
 import android.view.Display;
 import android.view.DisplayAdjustments;
 import android.view.autofill.AutofillManager.AutofillClient;
 import android.window.WindowContext;
 import android.window.WindowTokenClient;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.util.Preconditions;
 
 import dalvik.system.BlockGuard;
 
 import libcore.io.Memory;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
@@ -1385,20 +1387,22 @@ class ContextImpl extends Context {
                     mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType,
                     rd, initialCode, initialData, initialExtras, receiverPermissions,
                     null /*excludedPermissions=*/, appOp, options, true, false, getUserId());
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user) {
+        user = GmsHooks.getUserHandle(user);
+
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         try {
             intent.prepareToLeaveProcess(this);
             ActivityManager.getService().broadcastIntentWithFeature(
                     mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType,
                     null, Activity.RESULT_OK, null, null, null, null /*excludedPermissions=*/,
                     AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
@@ -1406,38 +1410,42 @@ class ContextImpl extends Context {
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user,
             String receiverPermission) {
         sendBroadcastAsUser(intent, user, receiverPermission, AppOpsManager.OP_NONE);
     }
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission,
             Bundle options) {
+        user = GmsHooks.getUserHandle(user);
+
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         String[] receiverPermissions = receiverPermission == null ? null
                 : new String[] {receiverPermission};
         try {
             intent.prepareToLeaveProcess(this);
             ActivityManager.getService().broadcastIntentWithFeature(
                     mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType,
                     null, Activity.RESULT_OK, null, null, receiverPermissions,
                     null /*excludedPermissions=*/, AppOpsManager.OP_NONE, options, false, false,
                     user.getIdentifier());
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user,
             String receiverPermission, int appOp) {
+        user = GmsHooks.getUserHandle(user);
+
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         String[] receiverPermissions = receiverPermission == null ? null
                 : new String[] {receiverPermission};
         try {
             intent.prepareToLeaveProcess(this);
             ActivityManager.getService().broadcastIntentWithFeature(
                     mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType,
                     null, Activity.RESULT_OK, null, null, receiverPermissions,
                     null /*excludedPermissions=*/, appOp, null, false, false, user.getIdentifier());
         } catch (RemoteException e) {
@@ -1458,20 +1466,22 @@ class ContextImpl extends Context {
             String receiverPermission, int appOp, BroadcastReceiver resultReceiver,
             Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
         sendOrderedBroadcastAsUser(intent, user, receiverPermission, appOp,
                 null, resultReceiver, scheduler, initialCode, initialData, initialExtras);
     }
 
     @Override
     public void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
             String receiverPermission, int appOp, Bundle options, BroadcastReceiver resultReceiver,
             Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
+        user = GmsHooks.getUserHandle(user);
+
         IIntentReceiver rd = null;
         if (resultReceiver != null) {
             if (mPackageInfo != null) {
                 if (scheduler == null) {
                     scheduler = mMainThread.getHandler();
                 }
                 rd = mPackageInfo.getReceiverDispatcher(
                     resultReceiver, getOuterContext(), scheduler,
                     mMainThread.getInstrumentation(), false);
             } else {
@@ -1814,20 +1824,24 @@ class ContextImpl extends Context {
                 throw ex;
             } else {
                 Log.w(TAG, "Implicit intents with startService are not safe: " + service
                         + " " + Debug.getCallers(2, 3));
             }
         }
     }
 
     @Override
     public ComponentName startService(Intent service) {
+        if (GmsCompat.isEnabled()) {
+            return GmsHooks.startService(this, service);
+        }
+
         warnIfCallingFromSystemProcess();
         return startServiceCommon(service, false, mUser);
     }
 
     @Override
     public ComponentName startForegroundService(Intent service) {
         warnIfCallingFromSystemProcess();
         return startServiceCommon(service, true, mUser);
     }
 
diff --git a/core/java/android/app/Instrumentation.java b/core/java/android/app/Instrumentation.java
index fd6fa57b9e8d1780d1dac7b9be00b9ef42700032..cbbaa0518cf1feb54377f72e8241cecbf0ad20fd 100644
--- a/core/java/android/app/Instrumentation.java
+++ b/core/java/android/app/Instrumentation.java
@@ -50,20 +50,22 @@ import android.view.InputDevice;
 import android.view.KeyCharacterMap;
 import android.view.KeyEvent;
 import android.view.MotionEvent;
 import android.view.SurfaceControl;
 import android.view.ViewConfiguration;
 import android.view.Window;
 import android.view.WindowManagerGlobal;
 
 import com.android.internal.content.ReferrerIntent;
 
+import com.android.internal.gmscompat.GmsHooks;
+
 import java.io.File;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeoutException;
 
 /**
  * Base class for implementing application instrumentation code.  When running
  * with instrumentation turned on, this class will be instantiated for you
@@ -1181,37 +1183,39 @@ public class Instrumentation {
      * @param context The context to initialize the application with
      * 
      * @return The newly instantiated Application object.
      */
     public Application newApplication(ClassLoader cl, String className, Context context)
             throws InstantiationException, IllegalAccessException, 
             ClassNotFoundException {
         Application app = getFactory(context.getPackageName())
                 .instantiateApplication(cl, className);
         app.attach(context);
+        GmsHooks.initApplicationBeforeOnCreate(app);
         return app;
     }
     
     /**
      * Perform instantiation of the process's {@link Application} object.  The
      * default implementation provides the normal system behavior.
      * 
      * @param clazz The class used to create an Application object from.
      * @param context The context to initialize the application with
      * 
      * @return The newly instantiated Application object.
      */
     static public Application newApplication(Class<?> clazz, Context context)
             throws InstantiationException, IllegalAccessException, 
             ClassNotFoundException {
         Application app = (Application)clazz.newInstance();
         app.attach(context);
+        GmsHooks.initApplicationBeforeOnCreate(app);
         return app;
     }
 
     /**
      * Perform calling of the application's {@link Application#onCreate}
      * method.  The default implementation simply calls through to that method.
      *
      * <p>Note: This method will be called immediately after {@link #onCreate(Bundle)}.
      * Often instrumentation tests start their test thread in onCreate(); you
      * need to be careful of races between these.  (Well between it and
diff --git a/core/java/android/app/LoadedApk.java b/core/java/android/app/LoadedApk.java
index 74208c3a4aff617da9225e6ccf11076de73e3d30..d4032729d68376616b7c1fb5cf3344c6571c6847 100644
--- a/core/java/android/app/LoadedApk.java
+++ b/core/java/android/app/LoadedApk.java
@@ -52,20 +52,21 @@ import android.security.net.config.NetworkSecurityConfigProvider;
 import android.sysprop.VndkProperties;
 import android.text.TextUtils;
 import android.util.AndroidRuntimeException;
 import android.util.ArrayMap;
 import android.util.Log;
 import android.util.Slog;
 import android.util.SparseArray;
 import android.view.DisplayAdjustments;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.util.ArrayUtils;
 
 import dalvik.system.BaseDexClassLoader;
 import dalvik.system.VMRuntime;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.ref.WeakReference;
 import java.lang.reflect.InvocationTargetException;
@@ -1565,20 +1566,24 @@ public final class LoadedApk {
             final LoadedApk.ReceiverDispatcher mStrongRef;
 
             InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) {
                 mDispatcher = new WeakReference<LoadedApk.ReceiverDispatcher>(rd);
                 mStrongRef = strong ? rd : null;
             }
 
             @Override
             public void performReceive(Intent intent, int resultCode, String data,
                     Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
+                if (GmsHooks.performReceive(intent)) {
+                    return;
+                }
+
                 final LoadedApk.ReceiverDispatcher rd;
                 if (intent == null) {
                     Log.wtf(TAG, "Null intent received");
                     rd = null;
                 } else {
                     rd = mDispatcher.get();
                 }
                 if (ActivityThread.DEBUG_BROADCAST) {
                     int seq = intent.getIntExtra("seq", -1);
                     Slog.i(ActivityThread.TAG, "Receiving broadcast " + intent.getAction()
diff --git a/core/java/android/app/NotificationManager.java b/core/java/android/app/NotificationManager.java
index ccf1edb3fecc06502d683af58faa2a2c6ad92545..66b47a6edeaa4b32bcd6a16f0c6199540f529c3d 100644
--- a/core/java/android/app/NotificationManager.java
+++ b/core/java/android/app/NotificationManager.java
@@ -47,20 +47,22 @@ import android.os.StrictMode;
 import android.os.UserHandle;
 import android.provider.Settings.Global;
 import android.service.notification.Adjustment;
 import android.service.notification.Condition;
 import android.service.notification.StatusBarNotification;
 import android.service.notification.ZenModeConfig;
 import android.service.notification.ZenPolicy;
 import android.util.Log;
 import android.util.proto.ProtoOutputStream;
 
+import com.android.internal.gmscompat.GmsHooks;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 
 /**
@@ -990,20 +992,24 @@ public class NotificationManager {
     }
 
     /**
      * Deletes the given notification channel.
      *
      * <p>If you {@link #createNotificationChannel(NotificationChannel) create} a new channel with
      * this same id, the deleted channel will be un-deleted with all of the same settings it
      * had before it was deleted.
      */
     public void deleteNotificationChannel(String channelId) {
+        if (GmsHooks.skipDeleteNotificationChannel(channelId)) {
+            return;
+        }
+
         INotificationManager service = getService();
         try {
             service.deleteNotificationChannel(mContext.getPackageName(), channelId);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Returns the notification channel group settings for a given channel group id.
diff --git a/core/java/android/app/SystemServiceRegistry.java b/core/java/android/app/SystemServiceRegistry.java
index 32ea41b2c75f553bb7546e290a3b386d8db93aae..5cc2f5e63393aedf859049501475abcbb611141f 100644
--- a/core/java/android/app/SystemServiceRegistry.java
+++ b/core/java/android/app/SystemServiceRegistry.java
@@ -19,20 +19,21 @@ package android.app;
 import android.accounts.AccountManager;
 import android.accounts.IAccountManager;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SystemApi;
 import android.app.ContextImpl.ServiceInitializationState;
 import android.app.admin.DevicePolicyManager;
 import android.app.admin.IDevicePolicyManager;
 import android.app.appsearch.AppSearchManagerFrameworkInitializer;
 import android.app.blob.BlobStoreManagerFrameworkInitializer;
+import android.app.compat.gms.GmsCompat;
 import android.app.contentsuggestions.ContentSuggestionsManager;
 import android.app.contentsuggestions.IContentSuggestionsManager;
 import android.app.job.JobSchedulerFrameworkInitializer;
 import android.app.people.PeopleManager;
 import android.app.prediction.AppPredictionManager;
 import android.app.role.RoleFrameworkInitializer;
 import android.app.search.SearchUiManager;
 import android.app.slice.SliceManager;
 import android.app.smartspace.SmartspaceManager;
 import android.app.time.TimeManager;
@@ -1397,20 +1398,24 @@ public final class SystemServiceRegistry {
                                 Context.FILE_INTEGRITY_SERVICE);
                         return new FileIntegrityManager(ctx.getOuterContext(),
                                 IFileIntegrityService.Stub.asInterface(b));
                     }});
         //CHECKSTYLE:ON IndentationCheck
         registerService(Context.APP_INTEGRITY_SERVICE, AppIntegrityManager.class,
                 new CachedServiceFetcher<AppIntegrityManager>() {
                     @Override
                     public AppIntegrityManager createService(ContextImpl ctx)
                             throws ServiceNotFoundException {
+                        if (GmsCompat.isEnabled()) {
+                            return new AppIntegrityManager(null);
+                        }
+
                         IBinder b = ServiceManager.getServiceOrThrow(Context.APP_INTEGRITY_SERVICE);
                         return new AppIntegrityManager(IAppIntegrityManager.Stub.asInterface(b));
                     }});
         registerService(Context.APP_HIBERNATION_SERVICE, AppHibernationManager.class,
                 new CachedServiceFetcher<AppHibernationManager>() {
                     @Override
                     public AppHibernationManager createService(ContextImpl ctx) {
                         IBinder b = ServiceManager.getService(Context.APP_HIBERNATION_SERVICE);
                         return b == null ? null : new AppHibernationManager(ctx);
                     }});
diff --git a/core/java/android/app/admin/DevicePolicyManager.java b/core/java/android/app/admin/DevicePolicyManager.java
index b7dbb7b1bbb280daa694abd150db68461764c985..a7e32eef36c4dace32dfac83267a390ca0d11cf1 100644
--- a/core/java/android/app/admin/DevicePolicyManager.java
+++ b/core/java/android/app/admin/DevicePolicyManager.java
@@ -33,20 +33,21 @@ import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.annotation.UserHandleAware;
 import android.annotation.UserIdInt;
 import android.annotation.WorkerThread;
 import android.app.Activity;
 import android.app.IServiceConnection;
 import android.app.KeyguardManager;
 import android.app.admin.SecurityLog.SecurityEvent;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.ServiceConnection;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageDataObserver;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
@@ -7872,20 +7873,24 @@ public class DevicePolicyManager {
      * @return device owner component name, even if it's running on a different user.
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS,
     })
     public ComponentName getDeviceOwnerComponentOnAnyUser() {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         return getDeviceOwnerComponentInner(/* callingUserOnly =*/ false);
     }
 
     private boolean isDeviceOwnerAppOnAnyUserInner(String packageName, boolean callingUserOnly) {
         if (packageName == null) {
             return false;
         }
         final ComponentName deviceOwner = getDeviceOwnerComponentInner(callingUserOnly);
         if (deviceOwner == null) {
             return false;
@@ -8006,20 +8011,24 @@ public class DevicePolicyManager {
 
     /**
      * Returns the device owner name.  Note this method *will* return the device owner
      * name when it's running on a different user.
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(android.Manifest.permission.MANAGE_USERS)
     public String getDeviceOwnerNameOnAnyUser() {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         throwIfParentInstance("getDeviceOwnerNameOnAnyUser");
         if (mService != null) {
             try {
                 return mService.getDeviceOwnerName();
             } catch (RemoteException re) {
                 throw re.rethrowFromSystemServer();
             }
         }
         return null;
     }
@@ -8396,20 +8405,24 @@ public class DevicePolicyManager {
     /**
      * @hide
      * @param userId The user for whom to fetch the profile owner name, if any.
      * @return the human readable name of the organisation associated with this profile owner or
      *         null if one is not set.
      * @throws IllegalArgumentException if the userId is invalid.
      */
     @SystemApi
     @RequiresPermission(android.Manifest.permission.MANAGE_USERS)
     public @Nullable String getProfileOwnerNameAsUser(int userId) throws IllegalArgumentException {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         throwIfParentInstance("getProfileOwnerNameAsUser");
         if (mService != null) {
             try {
                 return mService.getProfileOwnerName(userId);
             } catch (RemoteException re) {
                 throw re.rethrowFromSystemServer();
             }
         }
         return null;
     }
@@ -12093,20 +12106,24 @@ public class DevicePolicyManager {
     /**
      * Returns whether the device has been provisioned.
      *
      * <p>Not for use by third-party applications.
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(android.Manifest.permission.MANAGE_USERS)
     public boolean isDeviceProvisioned() {
+        if (GmsCompat.isEnabled()) {
+            return true;
+        }
+
         try {
             return mService.isDeviceProvisioned();
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
     }
 
     /**
       * Writes that the provisioning configuration has been applied.
       *
diff --git a/core/java/android/app/compat/gms/GmsCompat.java b/core/java/android/app/compat/gms/GmsCompat.java
new file mode 100644
index 0000000000000000000000000000000000000000..15ee23822299bee53065b4e2267a9db8df8819d2
--- /dev/null
+++ b/core/java/android/app/compat/gms/GmsCompat.java
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.compat.gms;
+
+import android.annotation.SystemApi;
+import android.app.ActivityThread;
+import android.compat.Compatibility;
+import android.compat.annotation.ChangeId;
+import android.compat.annotation.Disabled;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.Signature;
+import android.os.Binder;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.UserHandle;
+import android.util.Log;
+
+import com.android.internal.compat.CompatibilityChangeInfo;
+import com.android.internal.gmscompat.GmsInfo;
+
+/**
+ * This class provides helpers for Google Play Services compatibility. It allows the following apps
+ * to work as regular, unprivileged user apps:
+ *     - Google Play Services (Google Mobile Services, aka "GMS")
+ *     - Google Services Framework
+ *     - Google Play Store
+ *     - All apps depending on Google Play Services
+ *
+ * All GMS compatibility hooks should call methods on GmsCompat. Hooks that are more complicated
+ * than returning a simple constant value should also be implemented in GmsHooks to reduce
+ * maintenance overhead.
+ *
+ * @hide
+ */
+@SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)
+public final class GmsCompat {
+    private static final String TAG = "GmsCompat/Core";
+    private static final boolean DEBUG_VERBOSE = false;
+
+    /**
+     * Whether to enable Google Play Services compatibility for this app.
+     *
+     * This compatibility change is special because the system enables it automatically for certain
+     * apps, but it still needs to be declared with a change ID.
+     *
+     * We don't have a bug for this in Google's issue tracker, so the change ID is a
+     * randomly-generated long.
+     */
+    @ChangeId
+    @Disabled // Overridden as a special case in CompatChange
+    private static final long GMS_UNPRIVILEGED_COMPAT = 1531297613045645771L;
+
+    /**
+     * Whether to enable hooks for this app to load Dynamite modules from unprivileged GMS.
+     * This is for CLIENT apps, not GMS itself.
+     */
+    @ChangeId
+    @Disabled // Overridden as a special case in CompatChange
+    private static final long GMS_UNPRIVILEGED_DYNAMITE_CLIENT = 7528921493777479941L;
+
+    // Some hooks are in (potentially) hot paths, so cache the change enable states.
+    private static volatile boolean isGmsCompatEnabled = false;
+    private static volatile boolean isDynamiteClientEnabled = false;
+
+    // Static only
+    private GmsCompat() { }
+
+    public static boolean isEnabled() {
+        return isGmsCompatEnabled;
+    }
+
+    /** @hide */
+    public static boolean isDynamiteClient() {
+        return isDynamiteClientEnabled;
+    }
+
+    private static void logEnabled(String changeName, boolean enabled) {
+        if (!DEBUG_VERBOSE) {
+            return;
+        }
+
+        String pkg = ActivityThread.currentPackageName();
+        if (pkg == null) {
+            pkg = (Process.myUid() == Process.SYSTEM_UID) ? "system_server" : "[unknown]";
+        }
+
+        Log.d(TAG, changeName + " enabled for " + pkg + " (" + Process.myPid() + ") = " + enabled);
+    }
+
+    private static boolean isChangeEnabled(String changeName, long changeId) {
+        boolean enabled = Compatibility.isChangeEnabled(changeId);
+
+        // Compatibility changes aren't available in the system process, but this should never be
+        // enabled for it or other core "android" system processes (such as the android:ui process
+        // used for chooser and resolver activities).
+        if (UserHandle.getAppId(Process.myUid()) == Process.SYSTEM_UID) {
+            enabled = false;
+        }
+
+        logEnabled(changeName, enabled);
+        return enabled;
+    }
+
+    /**
+     * Must be called to initialize the compatibility change enable states before any hooks run.
+     *
+     * @hide
+     */
+    public static void initChangeEnableStates() {
+        isGmsCompatEnabled = isChangeEnabled("GMS_UNPRIVILEGED_COMPAT", GMS_UNPRIVILEGED_COMPAT);
+        isDynamiteClientEnabled = isChangeEnabled("GMS_UNPRIVILEGED_DYNAMITE_CLIENT", GMS_UNPRIVILEGED_DYNAMITE_CLIENT);
+    }
+
+    private static boolean validateCerts(Signature[] signatures) {
+        for (Signature signature : signatures) {
+            if (signature.toCharsString().equals(GmsInfo.SIGNING_CERT)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Check whether the given app is unprivileged and part of the Google Play Services family.
+     *
+     * @hide
+     */
+    public static boolean isGmsApp(String packageName, Signature[] signatures,
+            Signature[] signatures2, boolean isPrivileged, String sharedUserId) {
+        // Privileged GMS doesn't need any compatibility changes
+        if (isPrivileged) {
+            return false;
+        }
+
+        if (GmsInfo.PACKAGE_GMS.equals(packageName) || GmsInfo.PACKAGE_GSF.equals(packageName)) {
+            // Check the shared user ID to avoid affecting microG with a spoofed signature. This is a
+            // reliable indicator because apps can't change their shared user ID after shipping with it.
+            if (!GmsInfo.SHARED_USER_ID.equals(sharedUserId)) {
+                return false;
+            }
+        } else if (!GmsInfo.PACKAGE_PLAY_STORE.equals(packageName)) {
+            return false;
+        }
+
+        // Validate signature to avoid affecting apps like microG and Gcam Services Provider.
+        // This isn't actually necessary from a security perspective because GMS doesn't get any
+        // special privileges, but it's a failsafe to avoid unintentional compatibility issues.
+        boolean validCert = validateCerts(signatures);
+
+        // Try past signing certificates if necessary. We iterate through two separate arrays here
+        // instead of concatenating them beforehand because this method gets called for every
+        // package installed in the system.
+        if (!validCert && signatures2 != null) {
+            validCert = validateCerts(signatures2);
+        }
+
+        return validCert;
+    }
+
+    /** @hide */
+    public static boolean isGmsApp(ApplicationInfo app) {
+        int userId = UserHandle.getUserId(app.uid);
+        IPackageManager pm = ActivityThread.getPackageManager();
+
+        // Fetch PackageInfo to get signing certificates
+        PackageInfo pkg;
+        long token = Binder.clearCallingIdentity();
+        try {
+            pkg = pm.getPackageInfo(app.packageName, PackageManager.GET_SIGNING_CERTIFICATES, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        } finally {
+            Binder.restoreCallingIdentity(token);
+        }
+
+        // Get all applicable certificates, even if GMS switches to multiple signing certificates
+        // in the future
+        Signature[] signatures = pkg.signingInfo.hasMultipleSigners() ?
+                pkg.signingInfo.getApkContentsSigners() :
+                pkg.signingInfo.getSigningCertificateHistory();
+        return isGmsApp(app.packageName, signatures, null, app.isPrivilegedApp(), pkg.sharedUserId);
+    }
+
+    private static boolean isGmsInstalled(ApplicationInfo relatedApp) {
+        int userId = UserHandle.getUserId(relatedApp.uid);
+        IPackageManager pm = ActivityThread.getPackageManager();
+
+        ApplicationInfo gmsApp;
+        try {
+            gmsApp = pm.getApplicationInfo(GmsInfo.PACKAGE_GMS, 0, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+
+        // Check signature to avoid breaking microG's implementation of Dynamite
+        return gmsApp != null && isGmsApp(gmsApp);
+    }
+
+    /** @hide */
+    // CompatChange#isEnabled(ApplicationInfo)
+    public static boolean isChangeEnabled(CompatibilityChangeInfo change, ApplicationInfo app) {
+        if (change.getId() == GMS_UNPRIVILEGED_COMPAT) {
+            return isGmsApp(app);
+        } else if (change.getId() == GMS_UNPRIVILEGED_DYNAMITE_CLIENT) {
+            // Client apps can't be GMS itself, but GMS must be installed in the same user
+            return !(GmsInfo.PACKAGE_GMS.equals(app.packageName) && isGmsApp(app)) &&
+                    isGmsInstalled(app);
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/core/java/android/content/integrity/AppIntegrityManager.java b/core/java/android/content/integrity/AppIntegrityManager.java
index 1196064768e8d3ed7d15e4c84adac82652971021..52f3c2aaa6d57656a67c5191784d3b59cc58a036 100644
--- a/core/java/android/content/integrity/AppIntegrityManager.java
+++ b/core/java/android/content/integrity/AppIntegrityManager.java
@@ -13,20 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package android.content.integrity;
 
 import android.annotation.NonNull;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
+import android.app.compat.gms.GmsCompat;
 import android.content.Context;
 import android.content.IntentSender;
 import android.content.pm.ParceledListSlice;
 import android.os.RemoteException;
 
 import java.util.List;
 
 /**
  * Class for pushing rules used to check the integrity of app installs.
  *
@@ -67,43 +68,55 @@ public class AppIntegrityManager {
     /**
      * Update the rules to evaluate during install time.
      *
      * @param updateRequest request containing the data of the rule set update
      * @param statusReceiver Called when the state of the session changes. Intents sent to this
      *     receiver contain {@link #EXTRA_STATUS}. Refer to the individual status codes on how to
      *     handle them.
      */
     public void updateRuleSet(
             @NonNull RuleSet updateRequest, @NonNull IntentSender statusReceiver) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         try {
             mManager.updateRuleSet(
                     updateRequest.getVersion(),
                     new ParceledListSlice<>(updateRequest.getRules()),
                     statusReceiver);
         } catch (RemoteException e) {
             throw e.rethrowAsRuntimeException();
         }
     }
 
     /** Get the current version of the rule set. */
     @NonNull
     public String getCurrentRuleSetVersion() {
+        if (GmsCompat.isEnabled()) {
+            return "";
+        }
+
         try {
             return mManager.getCurrentRuleSetVersion();
         } catch (RemoteException e) {
             throw e.rethrowAsRuntimeException();
         }
     }
 
     /** Get the name of the package that provided the current rule set. */
     @NonNull
     public String getCurrentRuleSetProvider() {
+        if (GmsCompat.isEnabled()) {
+            return "";
+        }
+
         try {
             return mManager.getCurrentRuleSetProvider();
         } catch (RemoteException e) {
             throw e.rethrowAsRuntimeException();
         }
     }
 
     /**
      * Get current RuleSet on device.
      *
diff --git a/core/java/android/content/pm/PackageParser.java b/core/java/android/content/pm/PackageParser.java
index bd273f3001f9bfb7f19e7fe4606297e641604e3a..1eca93ab2886f534afb2a294df4c6a97f2210818 100644
--- a/core/java/android/content/pm/PackageParser.java
+++ b/core/java/android/content/pm/PackageParser.java
@@ -85,20 +85,21 @@ import android.util.Log;
 import android.util.PackageUtils;
 import android.util.Pair;
 import android.util.Slog;
 import android.util.SparseArray;
 import android.util.TypedValue;
 import android.util.apk.ApkSignatureVerifier;
 import android.view.Gravity;
 
 import com.android.internal.R;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.gmscompat.GmsInfo;
 import com.android.internal.os.ClassLoaderFactory;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.XmlUtils;
 
 import libcore.io.IoUtils;
 import libcore.util.EmptyArray;
 import libcore.util.HexEncoding;
 
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
@@ -254,40 +255,48 @@ public class PackageParser {
     /** @hide */
     public static final String APEX_FILE_EXTENSION = ".apex";
 
     /** @hide */
     public static class NewPermissionInfo {
         @UnsupportedAppUsage
         public final String name;
         @UnsupportedAppUsage
         public final int sdkVersion;
         public final int fileVersion;
+        public final String targetPackage;
 
-        public NewPermissionInfo(String name, int sdkVersion, int fileVersion) {
+        public NewPermissionInfo(String name, int sdkVersion, int fileVersion, String targetPackage) {
             this.name = name;
             this.sdkVersion = sdkVersion;
             this.fileVersion = fileVersion;
+            this.targetPackage = targetPackage;
+        }
+
+        public NewPermissionInfo(String name, int sdkVersion, int fileVersion) {
+            this(name, sdkVersion, fileVersion, null);
         }
     }
 
     /**
      * List of new permissions that have been added since 1.0.
      * NOTE: These must be declared in SDK version order, with permissions
      * added to older SDKs appearing before those added to newer SDKs.
      * If sdkVersion is 0, then this is not a permission that we want to
      * automatically add to older apps, but we do want to allow it to be
      * granted during a platform update.
      * @hide
      */
     @UnsupportedAppUsage
     public static final PackageParser.NewPermissionInfo NEW_PERMISSIONS[] =
         new PackageParser.NewPermissionInfo[] {
+            new PackageParser.NewPermissionInfo(android.Manifest.permission.REQUEST_INSTALL_PACKAGES,
+                    android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0, GmsInfo.PACKAGE_PLAY_STORE),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.OTHER_SENSORS,
                     android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.WRITE_EXTERNAL_STORAGE,
                     android.os.Build.VERSION_CODES.DONUT, 0),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.READ_PHONE_STATE,
                     android.os.Build.VERSION_CODES.DONUT, 0)
     };
 
     /**
      * @deprecated callers should move to explicitly passing around source path.
diff --git a/core/java/android/content/pm/parsing/ParsingPackageUtils.java b/core/java/android/content/pm/parsing/ParsingPackageUtils.java
index dce242c9d87c5ab024ca729c0b7d7ecbb7e3e7ca..27198fd0113fa2ef7218183a5554ae03c00b0b5c 100644
--- a/core/java/android/content/pm/parsing/ParsingPackageUtils.java
+++ b/core/java/android/content/pm/parsing/ParsingPackageUtils.java
@@ -2793,20 +2793,23 @@ public class ParsingPackageUtils {
 
     private static void convertNewPermissions(ParsingPackage pkg) {
         final int NP = PackageParser.NEW_PERMISSIONS.length;
         StringBuilder newPermsMsg = null;
         for (int ip = 0; ip < NP; ip++) {
             final PackageParser.NewPermissionInfo npi
                     = PackageParser.NEW_PERMISSIONS[ip];
             if (pkg.getTargetSdkVersion() >= npi.sdkVersion) {
                 break;
             }
+            if (npi.targetPackage != null && !pkg.getPackageName().equals(npi.targetPackage)) {
+                continue;
+            }
             if (!pkg.getRequestedPermissions().contains(npi.name)) {
                 if (newPermsMsg == null) {
                     newPermsMsg = new StringBuilder(128);
                     newPermsMsg.append(pkg.getPackageName());
                     newPermsMsg.append(": compat added ");
                 } else {
                     newPermsMsg.append(' ');
                 }
                 newPermsMsg.append(npi.name);
                 pkg.addUsesPermission(new ParsedUsesPermission(npi.name, 0))
diff --git a/core/java/android/content/res/ApkAssets.java b/core/java/android/content/res/ApkAssets.java
index 6fd2d05ad13572649121dc6d0a1dc49232552809..0bf5b0ea5489c1a1b34afd50e2fcf2814cd8a941 100644
--- a/core/java/android/content/res/ApkAssets.java
+++ b/core/java/android/content/res/ApkAssets.java
@@ -11,27 +11,29 @@
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package android.content.res;
 
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.om.OverlayableInfo;
 import android.content.res.loader.AssetsProvider;
 import android.content.res.loader.ResourcesProvider;
 import android.text.TextUtils;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.dynamite.GmsDynamiteHooks;
 
 import java.io.FileDescriptor;
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Objects;
 
 /**
  * The loaded, immutable, in-memory representation of an APK.
  *
@@ -134,20 +136,27 @@ public final class ApkAssets {
     /**
      * Creates a new ApkAssets instance from the given path on disk.
      *
      * @param path The path to an APK on disk.
      * @param flags flags that change the behavior of loaded apk assets
      * @return a new instance of ApkAssets.
      * @throws IOException if a disk I/O error or parsing error occurred.
      */
     public static @NonNull ApkAssets loadFromPath(@NonNull String path, @PropertyFlags int flags)
             throws IOException {
+        if (GmsCompat.isDynamiteClient()) {
+            ApkAssets assets = GmsDynamiteHooks.loadAssetsFromPath(path, flags);
+            if (assets != null) {
+                return assets;
+            }
+        }
+
         return new ApkAssets(FORMAT_APK, path, flags, null /* assets */);
     }
 
     /**
      * Creates a new ApkAssets instance from the given path on disk.
      *
      * @param path The path to an APK on disk.
      * @param flags flags that change the behavior of loaded apk assets
      * @param assets The assets provider that overrides the loading of file-based resources
      * @return a new instance of ApkAssets.
diff --git a/core/java/android/hardware/location/ContextHubManager.java b/core/java/android/hardware/location/ContextHubManager.java
index 9af0e09ee97ad010768c16176f83f1a26149af94..271f24c4f127efac9bd79abccda53f844aaa6f53 100644
--- a/core/java/android/hardware/location/ContextHubManager.java
+++ b/core/java/android/hardware/location/ContextHubManager.java
@@ -19,33 +19,35 @@ import android.annotation.CallbackExecutor;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresFeature;
 import android.annotation.RequiresPermission;
 import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.app.ActivityThread;
 import android.app.PendingIntent;
+import android.app.compat.gms.GmsCompat;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.os.Handler;
 import android.os.HandlerExecutor;
 import android.os.Looper;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.ServiceManager.ServiceNotFoundException;
 import android.util.Log;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.Executor;
 
 /**
  * A class that exposes the Context hubs on a device to applications.
  *
  * Please note that this class is not expected to be used by unbundled applications. Also, calling
  * applications are expected to have LOCATION_HARDWARE or ACCESS_CONTEXT_HUB permissions to use this
  * class. Use of LOCATION_HARDWARE to enable access to these APIs is deprecated and may be removed
@@ -465,20 +467,24 @@ public final class ContextHubManager {
      *
      * @return the list of ContextHubInfo objects
      *
      * @see ContextHubInfo
      */
     @RequiresPermission(anyOf = {
             android.Manifest.permission.LOCATION_HARDWARE,
             android.Manifest.permission.ACCESS_CONTEXT_HUB
     })
     @NonNull public List<ContextHubInfo> getContextHubs() {
+        if (GmsCompat.isEnabled()) {
+            return Collections.emptyList();
+        }
+
         try {
             return mService.getContextHubs();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Helper function to generate a stub for a non-query transaction callback.
      *
@@ -1055,17 +1061,22 @@ public final class ContextHubManager {
             }
         }
     };
 
     /** @throws ServiceNotFoundException
      * @hide */
     public ContextHubManager(Context context, Looper mainLooper) throws ServiceNotFoundException {
         mMainLooper = mainLooper;
         mService = IContextHubService.Stub.asInterface(
                 ServiceManager.getServiceOrThrow(Context.CONTEXTHUB_SERVICE));
+
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         try {
             mService.registerCallback(mClientCallback);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 }
diff --git a/core/java/android/net/NetworkScoreManager.java b/core/java/android/net/NetworkScoreManager.java
index 0ba266345a601181147b5764dcf96788b0ec5c66..6367926c22179aaeaadadab428f1e7f086a34170 100644
--- a/core/java/android/net/NetworkScoreManager.java
+++ b/core/java/android/net/NetworkScoreManager.java
@@ -19,20 +19,21 @@ package android.net;
 import android.Manifest.permission;
 import android.annotation.CallbackExecutor;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
+import android.app.compat.gms.GmsCompat;
 import android.content.Context;
 import android.os.Binder;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.ServiceManager.ServiceNotFoundException;
 import android.util.Log;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collection;
@@ -240,20 +241,24 @@ public class NetworkScoreManager {
      * determine the current scorer and offer the user the ability to select a different scorer via
      * the {@link #ACTION_CHANGE_ACTIVE} intent.
      * @return the full package name of the current active scorer, or null if there is no active
      *         scorer.
      * @throws SecurityException if the caller doesn't hold either {@link permission#SCORE_NETWORKS}
      *                           or {@link permission#REQUEST_NETWORK_SCORES} permissions.
      */
     @RequiresPermission(anyOf = {android.Manifest.permission.SCORE_NETWORKS,
                                  android.Manifest.permission.REQUEST_NETWORK_SCORES})
     public String getActiveScorerPackage() {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             return mService.getActiveScorerPackage();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Returns metadata about the active scorer or <code>null</code> if there is no active scorer.
      *
@@ -441,39 +446,47 @@ public class NetworkScoreManager {
      * @param scoreCache implementation of {@link INetworkScoreCache} to store the scores
      * @param filterType the {@link ScoreUpdateFilter} to apply
      * @throws SecurityException if the caller does not hold the
      *         {@link permission#REQUEST_NETWORK_SCORES} permission.
      * @throws IllegalArgumentException if a score cache is already registered for this type.
      * @hide
      */
     @RequiresPermission(android.Manifest.permission.REQUEST_NETWORK_SCORES)
     public void registerNetworkScoreCache(int networkType, INetworkScoreCache scoreCache,
             @ScoreUpdateFilter int filterType) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         try {
             mService.registerNetworkScoreCache(networkType, scoreCache, filterType);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Unregister a network score cache.
      *
      * @param networkType the type of network this cache can handle. See {@link NetworkKey#type}.
      * @param scoreCache implementation of {@link INetworkScoreCache} to store the scores.
      * @throws SecurityException if the caller does not hold the
      *         {@link permission#REQUEST_NETWORK_SCORES} permission.
      * @throws IllegalArgumentException if a score cache is already registered for this type.
      * @hide
      */
     @RequiresPermission(android.Manifest.permission.REQUEST_NETWORK_SCORES)
     public void unregisterNetworkScoreCache(int networkType, INetworkScoreCache scoreCache) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         try {
             mService.unregisterNetworkScoreCache(networkType, scoreCache);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Base class for network score cache callback. Should be extended by applications and set
      * when calling {@link #registerNetworkScoreCallback(int, int, Executor, NetworkScoreCallback)}.
diff --git a/core/java/android/os/Build.java b/core/java/android/os/Build.java
index a1f8b6eab903c1c66561270aeba24400e08fb5ed..4534528baaa221e6948df1022082d54883578c3f 100755
--- a/core/java/android/os/Build.java
+++ b/core/java/android/os/Build.java
@@ -18,29 +18,32 @@ package android.os;
 
 import android.Manifest;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SuppressAutoDoc;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.app.ActivityThread;
 import android.app.Application;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Context;
 import android.sysprop.DeviceProperties;
 import android.sysprop.SocProperties;
 import android.sysprop.TelephonyProperties;
 import android.text.TextUtils;
 import android.util.Slog;
 import android.view.View;
 
+import com.android.internal.gmscompat.GmsHooks;
+
 import dalvik.system.VMRuntime;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
 import java.util.stream.Collectors;
 
 /**
  * Information about the current build, extracted from system properties.
  */
@@ -192,20 +195,24 @@ public class Build {
      *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have
      *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or
      *     higher, then a SecurityException is thrown.</li>
      * </ul>
      *
      * @return The serial number if specified.
      */
     @SuppressAutoDoc // No support for device / profile owner.
     @RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public static String getSerial() {
+        if (GmsCompat.isEnabled()) {
+            return GmsHooks.getSerial();
+        }
+
         IDeviceIdentifiersPolicyService service = IDeviceIdentifiersPolicyService.Stub
                 .asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE));
         try {
             Application application = ActivityThread.currentApplication();
             String callingPackage = application != null ? application.getPackageName() : null;
             return service.getSerialForPackage(callingPackage, null);
         } catch (RemoteException e) {
             e.rethrowFromSystemServer();
         }
         return UNKNOWN;
diff --git a/core/java/android/os/DropBoxManager.java b/core/java/android/os/DropBoxManager.java
index f38271aad867ae410d2cb36095afa9a1ec29bfb6..3bc1e8a72b34c35677c17a3ac14f4c775d5bff7d 100644
--- a/core/java/android/os/DropBoxManager.java
+++ b/core/java/android/os/DropBoxManager.java
@@ -21,20 +21,21 @@ import static android.Manifest.permission.READ_LOGS;
 
 import android.annotation.BytesLong;
 import android.annotation.CurrentTimeMillisLong;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SystemService;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Context;
 import android.util.Log;
 
 import com.android.internal.os.IDropBoxManagerService;
 
 import java.io.ByteArrayInputStream;
 import java.io.Closeable;
 import java.io.File;
 import java.io.IOException;
@@ -380,20 +381,24 @@ public class DropBoxManager {
     /**
      * Gets the next entry from the drop box <em>after</em> the specified time.
      * You must always call {@link Entry#close()} on the return value!
      *
      * @param tag of entry to look for, null for all tags
      * @param msec time of the last entry seen
      * @return the next entry, or null if there are no more entries
      */
     @RequiresPermission(allOf = { READ_LOGS, PACKAGE_USAGE_STATS })
     public @Nullable Entry getNextEntry(String tag, long msec) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             return mService.getNextEntryWithAttribution(tag, msec, mContext.getOpPackageName(),
                     mContext.getAttributionTag());
         } catch (SecurityException e) {
             if (mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.P) {
                 throw e;
             } else {
                 Log.w(TAG, e.getMessage());
                 return null;
             }
diff --git a/core/java/android/os/UserManager.java b/core/java/android/os/UserManager.java
index 8709f071f222d59fca2e398ea77e8bb969810874..d1f0d12e039a98fc7430b5c1869245e58ce8c710 100644
--- a/core/java/android/os/UserManager.java
+++ b/core/java/android/os/UserManager.java
@@ -30,20 +30,21 @@ import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.annotation.UserHandleAware;
 import android.annotation.UserIdInt;
 import android.annotation.WorkerThread;
 import android.app.Activity;
 import android.app.ActivityManager;
 import android.app.PropertyInvalidatedCache;
 import android.app.admin.DevicePolicyManager;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.IntentSender;
 import android.content.pm.UserInfo;
 import android.content.pm.UserInfo.UserInfoFlag;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -51,20 +52,21 @@ import android.graphics.BitmapFactory;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.location.LocationManager;
 import android.provider.Settings;
 import android.telephony.TelephonyManager;
 import android.util.AndroidException;
 import android.util.ArraySet;
 import android.view.WindowManager.LayoutParams;
 
 import com.android.internal.R;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.RoSystemProperties;
 import com.android.internal.util.FrameworkStatsLog;
 
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
@@ -1963,20 +1965,25 @@ public class UserManager {
     }
 
     /**
      * Used to check if this process is running under the system user. The system user
      * is the initial user that is implicitly created on first boot and hosts most of the
      * system services.
      *
      * @return whether this process is running under the system user.
      */
     public boolean isSystemUser() {
+        if (GmsCompat.isEnabled()) {
+            // com.android.vending: java.lang.IllegalStateException: This method must be called in primary profile
+            return true;
+        }
+
         return UserHandle.myUserId() == UserHandle.USER_SYSTEM;
     }
 
     /**
      * Used to check if this process is running as an admin user. An admin user is allowed to
      * modify or configure certain settings that aren't available to non-admin users,
      * create and delete additional users, etc. There can be more than one admin users.
      *
      * @return whether this process is running under an admin user.
      * @hide
@@ -2191,34 +2198,42 @@ public class UserManager {
 
     /**
      * Checks if a user is a guest user.
      * @return whether user is a guest user.
      * @hide
      */
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     @RequiresPermission(anyOf = {Manifest.permission.MANAGE_USERS,
             Manifest.permission.CREATE_USERS})
     public boolean isGuestUser(@UserIdInt int userId) {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
+
         UserInfo user = getUserInfo(userId);
         return user != null && user.isGuest();
     }
 
     /**
      * Used to check if this process is running under a guest user. A guest user may be transient.
      *
      * @return whether this process is running under a guest user.
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {Manifest.permission.MANAGE_USERS,
             Manifest.permission.CREATE_USERS})
     public boolean isGuestUser() {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
+
         UserInfo user = getUserInfo(UserHandle.myUserId());
         return user != null && user.isGuest();
     }
 
 
     /**
      * Checks if the calling app is running in a demo user. When running in a demo user,
      * apps can be more helpful to the user, or explain their features in more detail.
      *
      * @return whether the caller is a demo user.
@@ -2684,20 +2699,25 @@ public class UserManager {
      * restrictions set by device policy.
      * @param restrictionKey the string key representing the restriction
      * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.
      */
     @TestApi
     @UnsupportedAppUsage
     @RequiresPermission(anyOf = {Manifest.permission.MANAGE_USERS,
             Manifest.permission.CREATE_USERS})
     public boolean hasBaseUserRestriction(@UserRestrictionKey @NonNull String restrictionKey,
             @NonNull UserHandle userHandle) {
+        if (GmsCompat.isEnabled()) {
+            // Can't ignore device policy restrictions without permission
+            return hasUserRestriction(restrictionKey, userHandle);
+        }
+
         try {
             return mService.hasBaseUserRestriction(restrictionKey, userHandle.getIdentifier());
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
     }
 
     /**
      * This will no longer work.  Device owners and profile owners should use
      * {@link DevicePolicyManager#addUserRestriction(ComponentName, String)} instead.
@@ -3401,20 +3421,24 @@ public class UserManager {
     }
 
     /**
      * Return the number of users currently created on the device.
      */
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.CREATE_USERS
     })
     public int getUserCount() {
+        if (GmsCompat.isEnabled()) {
+            return 1;
+        }
+
         List<UserInfo> users = getUsers();
         return users != null ? users.size() : 1;
     }
 
     /**
      * Returns information for all fully-created users on this device, including ones marked for
      * deletion.
      *
      * <p>To retrieve only users that are not marked for deletion, use {@link #getAliveUsers()}.
      *
@@ -3523,20 +3547,24 @@ public class UserManager {
      * @param excludeDying specify if the list should exclude users being removed.
      * @return the list of serial numbers of users that exist on the device.
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.CREATE_USERS
     })
     public long[] getSerialNumbersOfUsers(boolean excludeDying) {
+        if (GmsCompat.isEnabled()) {
+            return GmsHooks.getSerialNumbersOfUsers(this);
+        }
+
         List<UserInfo> users = getUsers(/* excludePartial= */ true, excludeDying,
                 /* excludePreCreated= */ true);
         long[] result = new long[users.size()];
         for (int i = 0; i < result.length; i++) {
             result[i] = users.get(i).serialNumber;
         }
         return result;
     }
 
     /**
@@ -3850,20 +3878,24 @@ public class UserManager {
      * or null if called from a user that is not a profile.
      *
      * @hide
      */
     @UnsupportedAppUsage
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.INTERACT_ACROSS_USERS
     })
     public UserInfo getProfileParent(@UserIdInt int userId) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             return mService.getProfileParent(userId);
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
     }
 
     /**
      * Get the parent of a user profile.
      *
@@ -3872,20 +3904,24 @@ public class UserManager {
      * @return the parent of the user or {@code null} if the user is not profile
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.INTERACT_ACROSS_USERS
     })
     public @Nullable UserHandle getProfileParent(@NonNull UserHandle user) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         UserInfo info = getProfileParent(user.getIdentifier());
 
         if (info == null) {
             return null;
         }
 
         return UserHandle.of(info.id);
     }
 
     /**
@@ -4489,20 +4525,25 @@ public class UserManager {
 
     /**
      * Returns a serial number on this device for a given userId. User handles can be recycled
      * when deleting and creating users, but serial numbers are not reused until the device is wiped.
      * @param userId
      * @return a serial number associated with that user, or -1 if the userId is not valid.
      * @hide
      */
     @UnsupportedAppUsage
     public int getUserSerialNumber(@UserIdInt int userId) {
+        if (GmsCompat.isEnabled()) {
+            // com.google.android.gms.persistent: java.lang.IllegalStateException - com.google.android.gms.gcm.GcmProxyIntentOperation.b
+            return 0;
+        }
+
         try {
             return mService.getUserSerialNumber(userId);
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
     }
 
     /**
      * Returns a userId on this device for a given user serial number. User handles can be
      * recycled when deleting and creating users, but serial numbers are not reused until the device
diff --git a/core/java/android/provider/DeviceConfig.java b/core/java/android/provider/DeviceConfig.java
index e58419fb688d8faa2ca09dd81479f96433adc13c..b24f4755bc901af821f9046169d9caa9382afb13 100644
--- a/core/java/android/provider/DeviceConfig.java
+++ b/core/java/android/provider/DeviceConfig.java
@@ -19,20 +19,21 @@ package android.provider;
 import static android.Manifest.permission.READ_DEVICE_CONFIG;
 import static android.Manifest.permission.WRITE_DEVICE_CONFIG;
 
 import android.annotation.CallbackExecutor;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.app.ActivityThread;
+import android.app.compat.gms.GmsCompat;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.database.ContentObserver;
 import android.net.Uri;
 import android.provider.Settings.Config.SyncDisabledMode;
 import android.provider.Settings.ResetMode;
 import android.util.ArrayMap;
 import android.util.Log;
 import android.util.Pair;
@@ -797,20 +798,24 @@ public final class DeviceConfig {
      * @param value       The value to store for the property.
      * @param makeDefault Whether to make the new value the default one.
      * @return True if the value was set, false if the storage implementation throws errors.
      * @hide
      * @see #resetToDefaults(int, String).
      */
     @SystemApi
     @RequiresPermission(WRITE_DEVICE_CONFIG)
     public static boolean setProperty(@NonNull String namespace, @NonNull String name,
             @Nullable String value, boolean makeDefault) {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
+
         ContentResolver contentResolver = ActivityThread.currentApplication().getContentResolver();
         return Settings.Config.putString(contentResolver, namespace, name, value, makeDefault);
     }
 
     /**
      * Set all of the properties for a specific namespace. Pre-existing properties will be updated
      * and new properties will be added if necessary. Any pre-existing properties for the specific
      * namespace which are not part of the provided {@link Properties} object will be deleted from
      * the namespace. These changes are all applied atomically, such that no calls to read or reset
      * these properties can happen in the middle of this update.
@@ -819,20 +824,24 @@ public final class DeviceConfig {
      * none or all of this update is picked up, but never only part of it.
      *
      * @param properties the complete set of properties to set for a specific namespace.
      * @throws BadConfigException if the provided properties are banned by RescueParty.
      * @return True if the values were set, false otherwise.
      * @hide
      */
     @SystemApi
     @RequiresPermission(WRITE_DEVICE_CONFIG)
     public static boolean setProperties(@NonNull Properties properties) throws BadConfigException {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
+
         ContentResolver contentResolver = ActivityThread.currentApplication().getContentResolver();
         return Settings.Config.setStrings(contentResolver, properties.getNamespace(),
                 properties.mMap);
     }
 
     /**
      * Reset properties to their default values by removing the underlying values.
      * <p>
      * The method accepts an optional namespace parameter. If provided, only properties set within
      * that namespace will be reset. Otherwise, all properties will be reset.
@@ -852,20 +861,24 @@ public final class DeviceConfig {
      * to using {@link #setProperties(Properties)} as outlined above.
      *
      * @param resetMode The reset mode to use.
      * @param namespace Optionally, the specific namespace which resets will be limited to.
      * @hide
      * @see #setProperty(String, String, String, boolean)
      */
     @SystemApi
     @RequiresPermission(WRITE_DEVICE_CONFIG)
     public static void resetToDefaults(@ResetMode int resetMode, @Nullable String namespace) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         ContentResolver contentResolver = ActivityThread.currentApplication().getContentResolver();
         Settings.Config.resetToDefaults(contentResolver, resetMode, namespace);
     }
 
     /**
      * Disables or re-enables bulk modifications ({@link #setProperties(Properties)}) to device
      * config values. This is intended for use during tests to prevent a sync operation clearing
      * config values, which could influence the outcome of the tests, i.e. by changing behavior.
      *
      * @param syncDisabledMode the mode to use, see {@link Settings.Config#SYNC_DISABLED_MODE_NONE},
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 54952fc2dc39f728fae63a8ea28cca4986740ffb..a8744b512332f8decf8437913a6df2fc1c72568f 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -30,20 +30,21 @@ import android.annotation.TestApi;
 import android.annotation.UserIdInt;
 import android.app.Activity;
 import android.app.ActivityThread;
 import android.app.AppOpsManager;
 import android.app.Application;
 import android.app.AutomaticZenRule;
 import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.SearchManager;
 import android.app.WallpaperManager;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.IContentProvider;
 import android.content.Intent;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
@@ -2843,20 +2844,24 @@ public final class Settings {
             mReadableFields = new ArraySet<>();
             mAllFields = new ArraySet<>();
             mReadableFieldsWithMaxTargetSdk = new ArrayMap<>();
             getPublicSettingsForClass(callerClass, mAllFields, mReadableFields,
                     mReadableFieldsWithMaxTargetSdk);
         }
 
         public boolean putStringForUser(ContentResolver cr, String name, String value,
                 String tag, boolean makeDefault, final int userHandle,
                 boolean overrideableByRestore) {
+            if (GmsCompat.isEnabled()) {
+                return true;
+            }
+
             try {
                 Bundle arg = new Bundle();
                 arg.putString(Settings.NameValueTable.VALUE, value);
                 arg.putInt(CALL_METHOD_USER_KEY, userHandle);
                 if (tag != null) {
                     arg.putString(CALL_METHOD_TAG_KEY, tag);
                 }
                 if (makeDefault) {
                     arg.putBoolean(CALL_METHOD_MAKE_DEFAULT_KEY, true);
                 }
diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
new file mode 100644
index 0000000000000000000000000000000000000000..620bb7e46fa0a065692dbf6082ae1c6af02578a0
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+import android.annotation.SuppressLint;
+import android.app.ActivityThread;
+import android.app.Application;
+import android.app.Notification;
+import android.app.NotificationChannel;
+import android.app.NotificationChannelGroup;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.app.compat.gms.GmsCompat;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInstaller;
+import android.content.pm.PackageManager;
+import android.content.pm.SharedLibraryInfo;
+import android.os.Build;
+import android.os.Process;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.provider.Settings;
+import android.util.Log;
+import android.webkit.WebView;
+
+import com.android.internal.R;
+import com.android.internal.gmscompat.dynamite.GmsDynamiteHooks;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * API shims for Google Play Services compatibility. Hooks that are more complicated than a simple
+ * constant return value should be delegated to this class for easier maintenance.
+ *
+ * @hide
+ */
+public final class GmsHooks {
+    private static final String TAG = "GmsCompat/Hooks";
+
+    // Foreground service notifications
+    private static final String FGS_GROUP_ID = "gmscompat_fgs_group";
+    private static final String FGS_CHANNEL_ID = "gmscompat_fgs_channel";
+    private static final int FGS_NOTIFICATION_ID = 529977835;
+    private static boolean fgsChannelCreated = false;
+
+    // Static only
+    private GmsHooks() { }
+
+
+    /*
+     * Foreground service notifications to keep GMS services alive
+     */
+
+    // Make all services foreground to keep them alive
+    // ContextImpl#startService(Intent)
+    public static ComponentName startService(Context context, Intent service) {
+        return context.startForegroundService(service);
+    }
+
+    private static void createFgsChannel(Context context) {
+        if (fgsChannelCreated) {
+            return;
+        }
+
+        NotificationManager notificationManager = (NotificationManager)
+                context.getSystemService(Context.NOTIFICATION_SERVICE);
+
+        NotificationChannelGroup group = new NotificationChannelGroup(FGS_GROUP_ID,
+                context.getText(R.string.foreground_service_gmscompat_group));
+        notificationManager.createNotificationChannelGroup(group);
+
+        CharSequence name = context.getText(R.string.foreground_service_gmscompat_channel);
+        NotificationChannel channel = new NotificationChannel(FGS_CHANNEL_ID, name,
+                NotificationManager.IMPORTANCE_LOW);
+        channel.setGroup(FGS_GROUP_ID);
+        channel.setDescription(context.getString(R.string.foreground_service_gmscompat_channel_desc));
+        channel.setShowBadge(false);
+        notificationManager.createNotificationChannel(channel);
+
+        fgsChannelCreated = true;
+    }
+
+    // Post notification on foreground service start
+    // ActivityThread#handleCreateService(CreateServiceData)
+    public static void attachService(Service service) {
+        // Isolated processes (e.g. WebView) don't have access to NotificationManager. They don't
+        // need a foreground notification anyway, so bail out early.
+        if (!GmsCompat.isEnabled() || Process.isIsolated()) {
+            return;
+        }
+
+        // Channel
+        createFgsChannel(service);
+
+        // Intent: notification channel settings
+        Intent intent = new Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);
+        intent.putExtra(Settings.EXTRA_APP_PACKAGE, service.getPackageName());
+        intent.putExtra(Settings.EXTRA_CHANNEL_ID, FGS_CHANNEL_ID);
+        PendingIntent pi = PendingIntent.getActivity(service, 0, intent, PendingIntent.FLAG_IMMUTABLE);
+
+        // Notification
+        CharSequence appName = service.getApplicationInfo().loadLabel(service.getPackageManager());
+        Notification notification = new Notification.Builder(service, FGS_CHANNEL_ID)
+                .setSmallIcon(service.getApplicationInfo().icon)
+                .setContentTitle(service.getString(R.string.app_running_notification_title, appName))
+                .setContentText(service.getText(R.string.foreground_service_gmscompat_notif_desc))
+                .setContentIntent(pi)
+                .build();
+
+        Log.d(TAG, "Posting notification for service: " + service.getClass().getName());
+        service.startForeground(FGS_NOTIFICATION_ID, notification);
+    }
+
+    // GMS tries to clean up its own notification channels periodically.
+    // Don't let it delete the FGS shim channel because that throws an exception and crashes GMS.
+    // NotificationManager#deleteNotificationChannel(String)
+    public static boolean skipDeleteNotificationChannel(String channelId) {
+        return GmsCompat.isEnabled() && FGS_CHANNEL_ID.equals(channelId);
+    }
+
+
+    /**
+     * API shims
+     */
+
+    // Report a single user on the system
+    // UserManager#getSerialNumbersOfUsers(boolean)
+    public static long[] getSerialNumbersOfUsers(UserManager userManager) {
+        return new long[] { userManager.getSerialNumberForUser(Process.myUserHandle()) };
+    }
+
+    // Current user is always active
+    // ActivityManager#getCurrentUser()
+    public static int getCurrentUser() {
+        return Process.myUserHandle().getIdentifier();
+    }
+
+    /**
+     * Use the per-app SSAID as a random serial number for SafetyNet. This doesn't necessarily make
+     * pass, but at least it retusn a valid "failed" response and stops spamming device key
+     * requests.
+     *
+     * This isn't a privacy risk because all unprivileged apps already have access to random SSAIDs.
+     */
+    // Build#getSerial()
+    @SuppressLint("HardwareIds")
+    public static String getSerial() {
+        Application app = ActivityThread.currentApplication();
+        if (app == null) {
+            return Build.UNKNOWN;
+        }
+
+        String ssaid = Settings.Secure.getString(app.getContentResolver(),
+                Settings.Secure.ANDROID_ID);
+        String serial = ssaid.toUpperCase();
+        Log.d(TAG, "Generating serial number from SSAID: " + serial);
+        return serial;
+    }
+
+    // Report no shared libraries
+    // ApplicationPackageManager#getSharedLibrariesAsUser(int, int)
+    public static List<SharedLibraryInfo> getSharedLibrariesAsUser() {
+        // TODO: Report standard Pixel libraries?
+        return Collections.emptyList();
+    }
+
+    // Only get package info for current user
+    // ApplicationPackageManager#getPackageInfo(VersionedPackage, int)
+    // ApplicationPackageManager#getPackageInfoAsUser(String, int, int)
+    public static int getPackageInfoFlags(int flags) {
+        if (!GmsCompat.isEnabled()) {
+            return flags;
+        }
+
+        // Remove MATCH_ANY_USER flag to avoid permission denial
+        return flags & ~PackageManager.MATCH_ANY_USER;
+    }
+
+    // Fix RuntimeException: Using WebView from more than one process at once with the same data
+    // directory is not supported. https://crbug.com/558377
+    // Instrumentation#newApplication(ClassLoader, String, Context)
+    public static void initApplicationBeforeOnCreate(Application app) {
+        GmsCompat.initChangeEnableStates();
+
+        if (GmsCompat.isEnabled()) {
+            String processName = Application.getProcessName();
+            if (!app.getPackageName().equals(processName)) {
+                WebView.setDataDirectorySuffix("process-shim--" + processName);
+            }
+
+            GmsDynamiteHooks.initGmsServerApp(app);
+        } else if (GmsCompat.isDynamiteClient()) {
+            GmsDynamiteHooks.initClientApp();
+        }
+    }
+
+    // Request user action for package install sessions
+    // LoadedApk.ReceiverDispatcher.InnerReceiver#performReceive(Intent, int, String, Bundle, boolean, boolean, int)
+    public static boolean performReceive(Intent intent) {
+        if (!GmsCompat.isEnabled()) {
+            return false;
+        }
+
+        // Validate - we only want to handle user action requests
+        if (!(intent.hasExtra(PackageInstaller.EXTRA_SESSION_ID) &&
+                intent.hasExtra(PackageInstaller.EXTRA_STATUS) &&
+                intent.hasExtra(Intent.EXTRA_INTENT))) {
+            return false;
+        }
+        if (intent.getIntExtra(PackageInstaller.EXTRA_STATUS, 0) !=
+                PackageInstaller.STATUS_PENDING_USER_ACTION) {
+            return false;
+        }
+
+        Application app = ActivityThread.currentApplication();
+        if (app == null) {
+            return false;
+        }
+
+        // Use the intent
+        Log.i(TAG, "Requesting user confirmation for package install session");
+        Intent confirmIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
+        // Make it work with the Application context
+        confirmIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        // TODO: post notification if app is in the background
+        app.startActivity(confirmIntent);
+
+        // Don't dispatch it, otherwise Play Store abandons the session
+        return true;
+    }
+
+    // Redirect cross-user interactions to current user
+    // ContextImpl#sendOrderedBroadcastAsUser
+    // ContextImpl#sendBroadcastAsUser
+    public static UserHandle getUserHandle(UserHandle user) {
+        return GmsCompat.isEnabled() ? Process.myUserHandle() : user;
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/GmsInfo.java b/core/java/com/android/internal/gmscompat/GmsInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..15e6560930ba9c917b1789754f0323e6c2dc2551
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmsInfo.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+/** @hide */
+public final class GmsInfo {
+    // Package names for GMS apps
+    public static final String PACKAGE_GMS = "com.google.android.gms";
+    public static final String PACKAGE_GSF = "com.google.android.gsf";
+    public static final String PACKAGE_PLAY_STORE = "com.android.vending";
+
+    // Shared user ID for GMS and GSF
+    public static final String SHARED_USER_ID = "com.google.uid.shared";
+
+    // Signing certificate for GMS apps, used to check package eligibility.
+    // This is Google's 2008 MD5 certificate because Play Store doesn't use the new SHA-256 one yet.
+    public static final String SIGNING_CERT = "308204433082032ba003020102020900c2e08746644a308d300d06092a864886f70d01010405003074310b3009060355040613025553311330110603550408130a43616c69666f726e6961311630140603550407130d4d6f756e7461696e205669657731143012060355040a130b476f6f676c6520496e632e3110300e060355040b1307416e64726f69643110300e06035504031307416e64726f6964301e170d3038303832313233313333345a170d3336303130373233313333345a3074310b3009060355040613025553311330110603550408130a43616c69666f726e6961311630140603550407130d4d6f756e7461696e205669657731143012060355040a130b476f6f676c6520496e632e3110300e060355040b1307416e64726f69643110300e06035504031307416e64726f696430820120300d06092a864886f70d01010105000382010d00308201080282010100ab562e00d83ba208ae0a966f124e29da11f2ab56d08f58e2cca91303e9b754d372f640a71b1dcb130967624e4656a7776a92193db2e5bfb724a91e77188b0e6a47a43b33d9609b77183145ccdf7b2e586674c9e1565b1f4c6a5955bff251a63dabf9c55c27222252e875e4f8154a645f897168c0b1bfc612eabf785769bb34aa7984dc7e2ea2764cae8307d8c17154d7ee5f64a51a44a602c249054157dc02cd5f5c0e55fbef8519fbe327f0b1511692c5a06f19d18385f5c4dbc2d6b93f68cc2979c70e18ab93866b3bd5db8999552a0e3b4c99df58fb918bedc182ba35e003c1b4b10dd244a8ee24fffd333872ab5221985edab0fc0d0b145b6aa192858e79020103a381d93081d6301d0603551d0e04160414c77d8cc2211756259a7fd382df6be398e4d786a53081a60603551d2304819e30819b8014c77d8cc2211756259a7fd382df6be398e4d786a5a178a4763074310b3009060355040613025553311330110603550408130a43616c69666f726e6961311630140603550407130d4d6f756e7461696e205669657731143012060355040a130b476f6f676c6520496e632e3110300e060355040b1307416e64726f69643110300e06035504031307416e64726f6964820900c2e08746644a308d300c0603551d13040530030101ff300d06092a864886f70d010104050003820101006dd252ceef85302c360aaace939bcff2cca904bb5d7a1661f8ae46b2994204d0ff4a68c7ed1a531ec4595a623ce60763b167297a7ae35712c407f208f0cb109429124d7b106219c084ca3eb3f9ad5fb871ef92269a8be28bf16d44c8d9a08e6cb2f005bb3fe2cb96447e868e731076ad45b33f6009ea19c161e62641aa99271dfd5228c5c587875ddb7f452758d661f6cc0cccb7352e424cc4365c523532f7325137593c4ae341f4db41edda0d0b1071a7c440f0fe9ea01cb627ca674369d084bd2fd911ff06cdbf2cfa10dc0f893ae35762919048c7efc64c7144178342f70581c9de573af55b390dd7fdb9418631895d5f759f30112687ff621410c069308a";
+
+    private GmsInfo() { }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java b/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java
new file mode 100644
index 0000000000000000000000000000000000000000..937613790d770f23006f50be35eee1d9f4e78397
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.dynamite;
+
+import android.app.ActivityThread;
+import android.app.Application;
+import android.app.compat.gms.GmsCompat;
+import android.content.Context;
+import android.content.res.ApkAssets;
+import android.os.ParcelFileDescriptor;
+import android.os.Process;
+import android.os.RemoteException;
+import android.util.Log;
+
+import com.android.internal.gmscompat.GmsInfo;
+import com.android.internal.gmscompat.dynamite.client.ModuleLoadState;
+import com.android.internal.gmscompat.dynamite.client.DynamiteContext;
+import com.android.internal.gmscompat.dynamite.server.FileProxyProvider;
+
+import dalvik.system.DelegateLastClassLoader;
+import dalvik.system.DexPathList;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+/**
+ * Hooks specific to Dynamite module compatibility.
+ *
+ * @hide
+ */
+public final class GmsDynamiteHooks {
+    // Created lazily because most apps don't use Dynamite modules
+    private static DynamiteContext clientContext = null;
+
+    private GmsDynamiteHooks() { }
+
+    private static DynamiteContext getClientContext() {
+        if (clientContext != null) {
+            return clientContext;
+        }
+
+        Context context = Objects.requireNonNull(ActivityThread.currentApplication());
+        clientContext = new DynamiteContext(context);
+        return clientContext;
+    }
+
+    public static void initClientApp() {
+        // Install hooks (requires libcore changes)
+        DexPathList.postConstructorBufferHook = GmsDynamiteHooks::getDexPathListBuffers;
+        File.lastModifiedHook = GmsDynamiteHooks::getFileLastModified;
+        DelegateLastClassLoader.librarySearchPathHook = GmsDynamiteHooks::mapRemoteLibraryPaths;
+    }
+
+    public static void initGmsServerApp(Application app) {
+        // Main GMS process only, to avoid serving proxy requests multiple times.
+        // This is specifically the main process, not persistent, because
+        // com.google.android.gms.chimera.container.FileApkIntentOperation$ExternalFileApkService
+        // is in the main process and thus the process is guaranteed to start before
+        // DelegateLastClassLoader requests the file proxy service.
+        if (!Process.isIsolated() && GmsInfo.PACKAGE_GMS.equals(Application.getProcessName())) {
+            FileProxyProvider.register(app);
+        }
+    }
+
+    // For Android assets and resources
+    // ApkAssets#loadFromPath(String, int)
+    public static ApkAssets loadAssetsFromPath(String path, int flags) throws IOException {
+        if (!GmsCompat.isDynamiteClient()) {
+            return null;
+        }
+
+        ModuleLoadState state = getClientContext().getState();
+        if (state == null || !state.modulePath.equals(path)) {
+            return null;
+        }
+
+        Log.d(DynamiteContext.TAG, "Replacing " + path + " -> fd " + state.moduleFd.getInt$());
+        return ApkAssets.loadFromFd(state.moduleFd, path, flags, null);
+    }
+
+    // For Java code
+    // DexPathList(ClassLoader, String, String, File, boolean)
+    private static ByteBuffer[] getDexPathListBuffers(DexPathList pathList) {
+        if (!GmsCompat.isDynamiteClient()) {
+            return null;
+        }
+
+        ModuleLoadState state = getClientContext().getState();
+        if (state == null) {
+            return null;
+        }
+
+        ByteBuffer[] buffers;
+        try {
+            buffers = state.mapDexBuffers();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+
+        Log.d(DynamiteContext.TAG, "Creating class loader with " + buffers.length + " dex buffer(s)");
+
+        // Undo path init and re-initialize with the ByteBuffers
+        return buffers;
+    }
+
+    // To fix false-positive "Module APK has been modified" check
+    // File#lastModified()
+    private static Long getFileLastModified(File file) {
+        if (!GmsCompat.isDynamiteClient()) {
+            return null;
+        }
+
+        ModuleLoadState state = getClientContext().getState();
+        if (state == null || !state.modulePath.equals(file.getPath())) {
+            return null;
+        }
+
+        long lastModified;
+        try {
+            lastModified = getClientContext().getService().getLastModified(file.getPath());
+        } catch (RemoteException e) {
+            throw e.rethrowAsRuntimeException();
+        }
+        Log.d(DynamiteContext.TAG, "File " + file.getPath() + " lastModified=" + lastModified);
+
+        // This is the final hook in the module loading process, so clear the state.
+        getClientContext().setState(null);
+
+        Log.d(DynamiteContext.TAG, "Finished loading module " + state.modulePath);
+        return lastModified;
+    }
+
+    // To start the module loading process and map native library paths to fd from remote
+    public static String mapRemoteLibraryPaths(String librarySearchPath) {
+        if (!GmsCompat.isDynamiteClient() || librarySearchPath == null) {
+            return librarySearchPath;
+        }
+
+        String[] searchPaths = librarySearchPath.split(Pattern.quote(File.pathSeparator));
+
+        List<String> newPaths = Arrays.stream(searchPaths).map(libPath -> {
+            if (!libPath.startsWith(getClientContext().gmsDataPrefix)) {
+                return libPath;
+            }
+
+            Log.d(DynamiteContext.TAG, "Loading module: " + libPath);
+            String[] libComponents = libPath.split("!");
+            String path = libComponents[0];
+
+            // Ask GMS to open the file and return a PFD. Be careful with ownership.
+            ParcelFileDescriptor srcPfd;
+            try {
+                srcPfd = getClientContext().getService().openFile(path);
+            } catch (RemoteException e) {
+                throw e.rethrowAsRuntimeException();
+            }
+            if (srcPfd == null) {
+                throw new RuntimeException(new FileNotFoundException(path));
+            }
+
+            // For ApkAssets, DexPathList, File#lastModified()
+            Log.d(DynamiteContext.TAG, "Received remote fd: " + path + " -> " + srcPfd.getFd());
+            ModuleLoadState state = new ModuleLoadState(path, srcPfd.getFileDescriptor());
+            getClientContext().setState(state);
+
+            // Native code dups the fd each time it loads a lib
+            String fdPath = "/proc/self/fd/" + srcPfd.getFd();
+            libComponents[0] = fdPath;
+
+            // Re-combine the path with native library components
+            return String.join("!", libComponents);
+        }).collect(Collectors.toList());
+
+        return String.join(File.pathSeparator, newPaths);
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/client/DynamiteContext.java b/core/java/com/android/internal/gmscompat/dynamite/client/DynamiteContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..4fd3e06f996ed2fcd2cf08c35a6f223adff8f289
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/client/DynamiteContext.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.dynamite.client;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Log;
+
+import com.android.internal.gmscompat.GmsInfo;
+import com.android.internal.gmscompat.dynamite.server.FileProxyProvider;
+import com.android.internal.gmscompat.dynamite.server.IFileProxyService;
+
+import java.io.File;
+
+/** @hide */
+public final class DynamiteContext {
+    public static final String TAG = "GmsCompat/DynamiteClient";
+
+    // Permission that only GMS holds
+    private static final String GMS_PERM = "com.google.android.gms.permission.INTERNAL_BROADCAST";
+
+    // Make sure we don't block the main thread for too long if GMS isn't available
+    private static final long GET_SERVICE_TIMEOUT = 250L;
+
+    private final Context context;
+    public final String gmsDataPrefix;
+
+    // Manage state for loading one module at a time per thread
+    private final ThreadLocal<ModuleLoadState> threadLocalState = new ThreadLocal<>();
+
+    // The remote GMS process can die at any time, so this needs to be managed carefully.
+    private IFileProxyService serviceBinder = null;
+
+    public DynamiteContext(Context context) {
+        this.context = context;
+
+        // Get data directory path without using package context or current data dir, since not all
+        // packages have data directories and package context causes recursion in ApkAssets
+        File userDe = Environment.getDataUserDeDirectory(null, context.getUserId());
+        gmsDataPrefix = userDe.getPath() + '/' + GmsInfo.PACKAGE_GMS + '/';
+    }
+
+    public ModuleLoadState getState() {
+        return threadLocalState.get();
+    }
+    public void setState(ModuleLoadState state) {
+        threadLocalState.set(state);
+    }
+
+    public IFileProxyService getService() {
+        return serviceBinder == null ? getNewBinder() : serviceBinder;
+    }
+
+    private IFileProxyService getNewBinder() {
+        // Request a fresh service unconditionally
+        IFileProxyService binder = requestGmsService();
+
+        // Register before saving to avoid race condition if GMS dies *now*
+        try {
+            binder.asBinder().linkToDeath(() -> {
+                Log.d(DynamiteContext.TAG, "File proxy service has died");
+                serviceBinder = null;
+            }, 0);
+
+            serviceBinder = binder;
+            return binder;
+        } catch (RemoteException e) {
+            serviceBinder = null;
+            return null;
+        }
+    }
+
+    private IFileProxyService requestGmsService() {
+        // Create a dedicated thread to avoid deadlocks, since this might be called on the main thread
+        HandlerThread thread = new HandlerThread(FileProxyProvider.THREAD_NAME);
+        thread.start();
+        Handler handler = new Handler(thread.getLooper());
+
+        // Potential return values
+        final IFileProxyService[] service = {null};
+        final RuntimeException[] receiverException = {null};
+        BroadcastReceiver replyReceiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                if (!intent.getAction().equals(FileProxyProvider.ACTION_RESPONSE)) {
+                    return;
+                }
+
+                try {
+                    Bundle bundle = intent.getBundleExtra(FileProxyProvider.EXTRA_BUNDLE);
+                    IBinder binder = bundle.getBinder(FileProxyProvider.EXTRA_BINDER);
+                    service[0] = IFileProxyService.Stub.asInterface(binder);
+                } catch (RuntimeException e) {
+                    receiverException[0] = e;
+                } finally {
+                    thread.quitSafely();
+                }
+            }
+        };
+
+        // Register receiver first
+        IntentFilter filter = new IntentFilter(FileProxyProvider.ACTION_RESPONSE);
+        // For security, we require the reply to come from GMS (by permission) so other apps
+        // can't inject code into our process by replying with a fake proxy service that returns
+        // malicious APKs.
+        context.registerReceiver(replyReceiver, filter, GMS_PERM, handler);
+
+        // Now, send the broadcast and wait...
+        try {
+            Log.d(TAG, "Requesting file proxy service from GMS");
+
+            Intent intent = new Intent(FileProxyProvider.ACTION_REQUEST);
+            intent.setPackage(GmsInfo.PACKAGE_GMS);
+            intent.putExtra(FileProxyProvider.EXTRA_PACKAGE, context.getPackageName());
+            context.sendBroadcast(intent, GMS_PERM);
+            thread.join(GET_SERVICE_TIMEOUT);
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        } finally {
+            context.unregisterReceiver(replyReceiver);
+            // Attempt to stop the thread if join() timed out
+            thread.quit();
+        }
+
+        // Rethrow exception or return value
+        if (receiverException[0] != null) {
+            throw receiverException[0];
+        } else if (service[0] != null) {
+            return service[0];
+        } else {
+            throw new IllegalStateException("Dynamite file proxy request timed out");
+        }
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/client/ModuleLoadState.java b/core/java/com/android/internal/gmscompat/dynamite/client/ModuleLoadState.java
new file mode 100644
index 0000000000000000000000000000000000000000..29b39679b75d6fb524ee2e452c8eda05e5d5ca58
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/client/ModuleLoadState.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.dynamite.client;
+
+import android.util.jar.StrictJarFile;
+
+import java.io.FileDescriptor;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.util.ArrayList;
+import java.util.regex.Pattern;
+import java.util.zip.ZipEntry;
+
+/** @hide */
+public final class ModuleLoadState {
+    private static final Pattern CLASSES_DEX_PATTERN = Pattern.compile("^classes\\d*\\.dex$");
+
+    public String modulePath;
+    public FileDescriptor moduleFd;
+
+    public ModuleLoadState(String modulePath, FileDescriptor moduleFd) {
+        this.modulePath = modulePath;
+        // Do NOT close the original fd. The Bionic linker could dup it for library loading
+        // at any time. Unfortunately, this results in CloseGuard warnings, but it's more efficient
+        // to just ignore them.
+        this.moduleFd = moduleFd;
+    }
+
+    public ByteBuffer[] mapDexBuffers() throws IOException {
+        // Native code doesn't assume ownership, so we can safely use the original fd temporarily
+        FileChannel channel = new FileInputStream(moduleFd).getChannel();
+        // Dynamite modules don't seem to have proper v2 signatures, so don't verify them
+        StrictJarFile jar = new StrictJarFile(moduleFd, false, false);
+
+        ArrayList<ByteBuffer> buffers = new ArrayList<>(1);
+        jar.iterator().forEachRemaining(entry -> {
+            if (entry.getMethod() == ZipEntry.STORED && CLASSES_DEX_PATTERN.matcher(entry.getName()).matches()) {
+                try {
+                    buffers.add(channel.map(FileChannel.MapMode.READ_ONLY, entry.getDataOffset(), entry.getSize()));
+                } catch (IOException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        });
+
+        return buffers.toArray(new ByteBuffer[0]);
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyProvider.java b/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..b7eae2bbc289abccb5b5ae05496bb5b4640291a0
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyProvider.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.dynamite.server;
+
+import android.app.Application;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.util.Log;
+
+/** @hide */
+public final class FileProxyProvider extends BroadcastReceiver {
+    public static final String EXTRA_BUNDLE = "service_bundle";
+    public static final String EXTRA_BINDER = "service_binder";
+    public static final String EXTRA_PACKAGE = "service_client_package";
+
+    public static final String ACTION_REQUEST = "com.android.internal.gmscompat.REQUEST_DYNAMITE_FILE_PROXY";
+    public static final String ACTION_RESPONSE = "com.android.internal.gmscompat.DYNAMITE_FILE_PROXY";
+
+    public static final String THREAD_NAME = "DynamiteFileProxy";
+
+    private FileProxyService service;
+
+    private FileProxyProvider() { }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        if (!intent.getAction().equals(ACTION_REQUEST)) {
+            return;
+        }
+
+        if (service == null) {
+            // The service is a singleton, so use the application context to prevent memory leaks.
+            service = new FileProxyService(context.getApplicationContext());
+        }
+
+        Intent reply = new Intent(ACTION_RESPONSE);
+
+        // Use an explicit intent to avoid sending multiple replies to clients that
+        // request the file proxy binder at the same time. Security doesn't matter because
+        // this is a public service, and we can't use PendingIntents due to permission checks
+        // on the client side.
+        String clientPackage = intent.getStringExtra(EXTRA_PACKAGE);
+        if (clientPackage == null) {
+            return;
+        }
+        reply.setPackage(clientPackage);
+
+        // New bundle is required because Intent doesn't expose IBinder extras
+        Bundle bundle = new Bundle();
+        bundle.putBinder(EXTRA_BINDER, service.asBinder());
+        reply.putExtra(EXTRA_BUNDLE, bundle);
+
+        Log.d(FileProxyService.TAG, "Sending file proxy binder to " + clientPackage);
+        context.sendBroadcast(reply);
+    }
+
+    public static void register(Context context) {
+        Log.d(FileProxyService.TAG, "Registering file proxy provider from " + Application.getProcessName());
+
+        // Create a dedicated thread to avoid blocking clients for too long
+        HandlerThread thread = new HandlerThread(THREAD_NAME);
+        thread.start();
+        Handler handler = new Handler(thread.getLooper());
+
+        IntentFilter filter = new IntentFilter(ACTION_REQUEST);
+        context.registerReceiver(new FileProxyProvider(), filter, null, handler);
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyService.java b/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyService.java
new file mode 100644
index 0000000000000000000000000000000000000000..8656f0767d6167eaa6532c2c427765d7cd720dd4
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyService.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.dynamite.server;
+
+import android.content.Context;
+import android.os.ParcelFileDescriptor;
+import android.system.ErrnoException;
+import android.system.Os;
+import android.system.OsConstants;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+/** @hide */
+public final class FileProxyService extends IFileProxyService.Stub {
+    public static final String TAG = "GmsCompat/DynamiteServer";
+    private static final String CHIMERA_REL_PATH = "app_chimera/m/";
+
+    private final File deDataRoot;
+    private final String chimeraRoot;
+
+    public FileProxyService(Context context) {
+        deDataRoot = context.createDeviceProtectedStorageContext().getDataDir();
+        chimeraRoot = deDataRoot.getPath() + "/" + CHIMERA_REL_PATH;
+    }
+
+    private String sanitizeModulePath(String rawPath) {
+        // Normalize path for security checks
+        String path;
+        try {
+            path = new File(rawPath).getCanonicalPath();
+        } catch (IOException e) {
+            throw new SecurityException("Invalid path " + rawPath + ": " + e.getMessage());
+        }
+
+        // Modules can only be in DE Chimera storage
+        if (!path.startsWith(chimeraRoot)) {
+            throw new SecurityException("Path " + rawPath + " is not in " + chimeraRoot);
+        }
+
+        // Check permissions recursively
+        String relPath = path.substring(deDataRoot.getPath().length() + 1); // already checked prefix above
+        List<String> relParts = Arrays.asList(relPath.split("/"));
+        for (int i = 0; i < relParts.size(); i++) {
+            List<String> leadingParts = relParts.subList(0, i + 1);
+            String nodePath = deDataRoot + "/" + String.join("/", leadingParts);
+            int mode;
+            try {
+                mode = Os.stat(nodePath).st_mode;
+            } catch (ErrnoException e) {
+                throw new SecurityException("Failed to stat " + rawPath + ": " + e.getMessage());
+            }
+
+            // World-readable or world-executable, depending on type
+            int permBit = OsConstants.S_ISDIR(mode) ? OsConstants.S_IXOTH : OsConstants.S_IROTH;
+            if ((mode & permBit) == 0) {
+                throw new SecurityException("Node " + nodePath + " in path " + rawPath + " is not world-readable");
+            }
+        }
+
+        return path;
+    }
+
+    private ParcelFileDescriptor getFilePfd(String path) {
+        Log.d(TAG, "Opening " + path + " for remote");
+        try {
+            return ParcelFileDescriptor.open(new File(path), ParcelFileDescriptor.MODE_READ_ONLY);
+        } catch (FileNotFoundException e) {
+            return null;
+        }
+    }
+
+    @Override
+    public ParcelFileDescriptor openFile(String rawPath) {
+        return getFilePfd(sanitizeModulePath(rawPath));
+    }
+
+    @Override
+    public long getLastModified(String rawPath) {
+        return new File(sanitizeModulePath(rawPath)).lastModified();
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/server/IFileProxyService.aidl b/core/java/com/android/internal/gmscompat/dynamite/server/IFileProxyService.aidl
new file mode 100644
index 0000000000000000000000000000000000000000..15e5c4195715e9cf93bf6bf89023063c589ae24d
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/server/IFileProxyService.aidl
@@ -0,0 +1,7 @@
+package com.android.internal.gmscompat.dynamite.server;
+
+/** @hide */
+interface IFileProxyService {
+    ParcelFileDescriptor openFile(String path);
+    long getLastModified(String path);
+}
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index 876b526e9aba70b364e205a9a4974d83085afd6f..f350ddff5a3f6d4f8662ab6fbf27ed3be5f8d78e 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -5795,21 +5795,21 @@
 
     <!-- @hide @SystemApi Allows an application to retrieve whether shortcut is backed by a
          Conversation.
          TODO(b/180412052): STOPSHIP: Define a role so it can be granted to Shell and AiAi. -->
     <permission android:name="android.permission.READ_PEOPLE_DATA"
                 android:protectionLevel="signature|recents|role"/>
 
     <!-- @hide @SystemApi Allows a logical component within an application to
          temporarily renounce a set of otherwise granted permissions. -->
     <permission android:name="android.permission.RENOUNCE_PERMISSIONS"
-                android:protectionLevel="signature|privileged" />
+                android:protectionLevel="normal" />
 
     <!-- Allows an application to read nearby streaming policy. The policy allows the device
          to stream its notifications and apps to nearby devices.
          @hide -->
     <permission android:name="android.permission.READ_NEARBY_STREAMING_POLICY"
         android:protectionLevel="signature|privileged" />
 
     <!-- @SystemApi Allows the holder to set the source of the data when setting a clip on the
          clipboard.
          @hide -->
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index 4a8624222ae822b6d0ce7112470d9feb6b3819ea..00b1bbfb52f180923370130deb4498cf67a83543 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -757,20 +757,34 @@
         data usage</string>
 
     <!-- Separator for foreground service notification content listing all apps when there
         are multiple apps running.  The left and right side may both already be compound
         (constructed using this separator).  Should be kept as short as possible, this is
         for summary text in the notification where there is not a lot of space.
         [CHAR LIMIT=NONE] -->
     <string name="foreground_service_multiple_separator"><xliff:g id="left_side">%1$s</xliff:g>,
         <xliff:g id="right_side">%2$s</xliff:g></string>
 
+    <!-- Name for foreground service notification channel group created by GmsCompat  -->
+    <string name="foreground_service_gmscompat_group">Compatibility</string>
+
+    <!-- Name for foreground service notification channel created by GmsCompat  -->
+    <string name="foreground_service_gmscompat_channel">Services</string>
+
+    <!-- Description for foreground service notification channel created by GmsCompat  -->
+    <string name="foreground_service_gmscompat_channel_desc">These notifications are created by the
+        Google Play Services compatibility layer in order to keep services running in the
+        background.\n\nDisable this category to hide the unnecessary notifications.</string>
+
+    <!-- Description for foreground service notifications created by GmsCompat  -->
+    <string name="foreground_service_gmscompat_notif_desc">Tap to hide</string>
+
     <!-- Displayed to the user to tell them that they have started up the phone in "safe mode" -->
     <string name="safeMode">Safe mode</string>
 
     <!-- Label for the Android system components when they are shown to the user. -->
     <string name="android_system_label">Android System</string>
 
     <!-- "Switch" is a verb; it means to change user profile by tapping another user profile name. -->
     <string name="user_owner_label">Switch to personal profile</string>
 
     <!-- "Switch" is a verb; it means to change user profile by tapping another user profile name. -->
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index f68c26d76610aac5e45ba414f3a7a5547a2909b0..af2393bf3b8d594ada4129c3e8b65911edb14e3a 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -3631,20 +3631,25 @@
   <java-symbol type="string" name="config_defaultSystemCaptionsManagerService" />
   <java-symbol type="string" name="config_retailDemoPackage" />
   <java-symbol type="string" name="config_retailDemoPackageSignature" />
 
   <java-symbol type="string" name="notification_channel_foreground_service" />
   <java-symbol type="string" name="foreground_service_app_in_background" />
   <java-symbol type="string" name="foreground_service_apps_in_background" />
   <java-symbol type="string" name="foreground_service_tap_for_details" />
   <java-symbol type="string" name="foreground_service_multiple_separator" />
 
+  <java-symbol type="string" name="foreground_service_gmscompat_group" />
+  <java-symbol type="string" name="foreground_service_gmscompat_channel" />
+  <java-symbol type="string" name="foreground_service_gmscompat_channel_desc" />
+  <java-symbol type="string" name="foreground_service_gmscompat_notif_desc" />
+
   <java-symbol type="bool" name="config_enableCredentialFactoryResetProtection" />
 
   <!-- ETWS primary messages -->
   <java-symbol type="string" name="etws_primary_default_message_earthquake" />
   <java-symbol type="string" name="etws_primary_default_message_tsunami" />
   <java-symbol type="string" name="etws_primary_default_message_earthquake_and_tsunami" />
   <java-symbol type="string" name="etws_primary_default_message_test" />
   <java-symbol type="string" name="etws_primary_default_message_others" />
 
   <java-symbol type="bool" name="config_quickSettingsSupported" />
diff --git a/location/java/android/location/LocationManager.java b/location/java/android/location/LocationManager.java
index 526b84e85e383d2e17097f831f0a41baf6d7502c..c427a9dec87c4ededfd6f37e9305a43c97667573 100644
--- a/location/java/android/location/LocationManager.java
+++ b/location/java/android/location/LocationManager.java
@@ -33,20 +33,21 @@ import android.annotation.RequiresFeature;
 import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.app.AppOpsManager;
 import android.app.PendingIntent;
 import android.app.PropertyInvalidatedCache;
+import android.app.compat.gms.GmsCompat;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.location.provider.IProviderRequestListener;
 import android.location.provider.ProviderProperties;
 import android.location.provider.ProviderRequest;
 import android.location.provider.ProviderRequest.ChangedListener;
@@ -527,20 +528,24 @@ public class LocationManager {
     }
 
     /**
      * Set whether the extra location controller package is currently enabled on the device.
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(Manifest.permission.LOCATION_HARDWARE)
     public void setExtraLocationControllerPackageEnabled(boolean enabled) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         try {
             mService.setExtraLocationControllerPackageEnabled(enabled);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Returns whether extra location controller package is currently enabled on the device.
      *
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index d4bb8abc3224ac493cf95802297dcc8fd5f79c7a..d0f340f2f89e97d9c97f4e729fbbbcc226e1623b 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -181,20 +181,21 @@ import android.app.Instrumentation;
 import android.app.Notification;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.ProcessMemoryState;
 import android.app.ProfilerInfo;
 import android.app.PropertyInvalidatedCache;
 import android.app.SyncNotedAppOp;
 import android.app.WaitResult;
 import android.app.backup.BackupManager.OperationType;
 import android.app.backup.IBackupManager;
+import android.app.compat.gms.GmsCompat;
 import android.app.job.JobParameters;
 import android.app.usage.UsageEvents;
 import android.app.usage.UsageEvents.Event;
 import android.app.usage.UsageStatsManager;
 import android.app.usage.UsageStatsManagerInternal;
 import android.appwidget.AppWidgetManager;
 import android.appwidget.AppWidgetManagerInternal;
 import android.content.AttributionSource;
 import android.content.AutofillOptions;
 import android.content.BroadcastReceiver;
@@ -11960,20 +11961,24 @@ public class ActivityManagerService extends IActivityManager.Stub
 
     @Override
     public int handleIncomingUser(int callingPid, int callingUid, int userId, boolean allowAll,
             boolean requireFull, String name, String callerPackage) {
         return mUserController.handleIncomingUser(callingPid, callingUid, userId, allowAll,
                 requireFull ? ALLOW_FULL_ONLY : ALLOW_NON_FULL, name, callerPackage);
     }
 
     boolean isSingleton(String componentProcessName, ApplicationInfo aInfo,
             String className, int flags) {
+        if (GmsCompat.isGmsApp(aInfo)) {
+            return false;
+        }
+
         boolean result = false;
         // For apps that don't have pre-defined UIDs, check for permission
         if (UserHandle.getAppId(aInfo.uid) >= FIRST_APPLICATION_UID) {
             if ((flags & ServiceInfo.FLAG_SINGLE_USER) != 0) {
                 if (ActivityManager.checkUidPermission(
                         INTERACT_ACROSS_USERS,
                         aInfo.uid) != PackageManager.PERMISSION_GRANTED) {
                     ComponentName comp = new ComponentName(aInfo.packageName, className);
                     String msg = "Permission Denial: Component " + comp.flattenToShortString()
                             + " requests FLAG_SINGLE_USER, but app does not hold "
diff --git a/services/core/java/com/android/server/compat/CompatChange.java b/services/core/java/com/android/server/compat/CompatChange.java
index b5846b555747579b4be3028579deb07e8161e1aa..33f872489d8a1fa49ed8ae5c94a68b8ba3017086 100644
--- a/services/core/java/com/android/server/compat/CompatChange.java
+++ b/services/core/java/com/android/server/compat/CompatChange.java
@@ -15,20 +15,21 @@
  */
 
 package com.android.server.compat;
 
 import static android.app.compat.PackageOverride.VALUE_DISABLED;
 import static android.app.compat.PackageOverride.VALUE_ENABLED;
 import static android.app.compat.PackageOverride.VALUE_UNDEFINED;
 
 import android.annotation.Nullable;
 import android.app.compat.PackageOverride;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.Disabled;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.Overridable;
 import android.content.pm.ApplicationInfo;
 
 import com.android.internal.compat.AndroidBuildClassifier;
 import com.android.internal.compat.CompatibilityChangeInfo;
 import com.android.internal.compat.OverrideAllowedState;
 import com.android.server.compat.config.Change;
@@ -238,20 +239,23 @@ public final class CompatChange extends CompatibilityChangeInfo {
     boolean isEnabled(ApplicationInfo app, AndroidBuildClassifier buildClassifier) {
         if (app == null) {
             return defaultValue();
         }
         if (app.packageName != null) {
             final Boolean enabled = mEvaluatedOverrides.get(app.packageName);
             if (enabled != null) {
                 return enabled;
             }
         }
+        if (GmsCompat.isChangeEnabled(this, app)) {
+            return true;
+        }
         if (getDisabled()) {
             return false;
         }
         if (getEnableSinceTargetSdk() != -1) {
             // If the change is gated by a platform version newer than the one currently installed
             // on the device, disregard the app's target sdk version.
             int compareSdk = Math.min(app.targetSdkVersion, buildClassifier.platformTargetSdk());
             if (compareSdk != app.targetSdkVersion) {
                 compareSdk = app.targetSdkVersion;
             }
diff --git a/services/core/java/com/android/server/pm/AppsFilter.java b/services/core/java/com/android/server/pm/AppsFilter.java
index ed9b539c05df239ff5d0a6bd1e7fd69775122a36..7d1d1224348d6647298ae5604837e9dd446511e6 100644
--- a/services/core/java/com/android/server/pm/AppsFilter.java
+++ b/services/core/java/com/android/server/pm/AppsFilter.java
@@ -17,20 +17,21 @@
 package com.android.server.pm;
 
 import static android.os.Trace.TRACE_TAG_PACKAGE_MANAGER;
 import static android.provider.DeviceConfig.NAMESPACE_PACKAGE_MANAGER_SERVICE;
 
 import static com.android.internal.annotations.VisibleForTesting.Visibility.PRIVATE;
 
 import android.Manifest;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManagerInternal;
 import android.content.pm.PackageParser;
 import android.content.pm.UserInfo;
 import android.content.pm.parsing.component.ParsedComponent;
 import android.content.pm.parsing.component.ParsedInstrumentation;
 import android.content.pm.parsing.component.ParsedIntentInfo;
 import android.content.pm.parsing.component.ParsedMainComponent;
@@ -733,24 +734,30 @@ public class AppsFilter implements Watchable, Snappable {
 
         final AndroidPackage newPkg = newPkgSetting.pkg;
         if (newPkg == null) {
             return null;
         }
 
         if (mProtectedBroadcasts.addAll(newPkg.getProtectedBroadcasts())) {
             mQueriesViaComponentRequireRecompute = true;
         }
 
+        final boolean isGmsApp = GmsCompat.isGmsApp(newPkg.getPackageName(),
+                newPkg.getSigningDetails().signatures,
+                newPkg.getSigningDetails().pastSigningCertificates,
+                newPkg.isPrivileged(),
+                newPkgSetting.sharedUser != null ? newPkgSetting.sharedUser.name : null);
         final boolean newIsForceQueryable =
                 mForceQueryable.contains(newPkgSetting.appId)
                         /* shared user that is already force queryable */
                         || newPkgSetting.forceQueryableOverride /* adb override */
+                        || isGmsApp
                         || (newPkgSetting.isSystem() && (mSystemAppsQueryable
                         || newPkg.isForceQueryable()
                         || ArrayUtils.contains(mForceQueryableByDevicePackageNames,
                         newPkg.getPackageName())));
         if (newIsForceQueryable
                 || (mSystemSigningDetails != null
                 && isSystemSigned(mSystemSigningDetails, newPkgSetting))) {
             mForceQueryable.add(newPkgSetting.appId);
         }
 
diff --git a/telephony/java/android/telephony/TelephonyManager.java b/telephony/java/android/telephony/TelephonyManager.java
index 8bc4d381e2dd6e04ff6f927c64fb0c29cb2695b5..88cc345a3f7ef9900223c4022c6d464d8bfbf2e4 100644
--- a/telephony/java/android/telephony/TelephonyManager.java
+++ b/telephony/java/android/telephony/TelephonyManager.java
@@ -34,20 +34,21 @@ import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.StringDef;
 import android.annotation.SuppressAutoDoc;
 import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.annotation.WorkerThread;
 import android.app.PendingIntent;
+import android.app.compat.gms.GmsCompat;
 import android.app.role.RoleManager;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.database.Cursor;
 import android.net.ConnectivityManager;
@@ -1956,20 +1957,24 @@ public class TelephonyManager {
      *     higher, then a SecurityException is thrown.</li>
      * </ul>
      *
      * @deprecated Use {@link #getImei} which returns IMEI for GSM or {@link #getMeid} which returns
      * MEID for CDMA.
      */
     @Deprecated
     @SuppressAutoDoc // No support for device / profile owner or carrier privileges (b/72967236).
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public String getDeviceId() {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             ITelephony telephony = getITelephony();
             if (telephony == null)
                 return null;
             return telephony.getDeviceIdWithFeature(mContext.getOpPackageName(),
                     mContext.getAttributionTag());
         } catch (RemoteException ex) {
             return null;
         } catch (NullPointerException ex) {
             return null;
@@ -2009,20 +2014,24 @@ public class TelephonyManager {
      *
      * @param slotIndex of which deviceID is returned
      *
      * @deprecated Use {@link #getImei} which returns IMEI for GSM or {@link #getMeid} which returns
      * MEID for CDMA.
      */
     @Deprecated
     @SuppressAutoDoc // No support for device / profile owner or carrier privileges (b/72967236).
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public String getDeviceId(int slotIndex) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         // FIXME this assumes phoneId == slotIndex
         try {
             IPhoneSubInfo info = getSubscriberInfoService();
             if (info == null)
                 return null;
             return info.getDeviceIdForPhone(slotIndex, mContext.getOpPackageName(),
                     mContext.getAttributionTag());
         } catch (RemoteException ex) {
             return null;
         } catch (NullPointerException ex) {
@@ -2074,20 +2083,24 @@ public class TelephonyManager {
      *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have
      *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or
      *     higher, then a SecurityException is thrown.</li>
      * </ul>
      *
      * @param slotIndex of which IMEI is returned
      */
     @SuppressAutoDoc // No support for device / profile owner or carrier privileges (b/72967236).
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public String getImei(int slotIndex) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         ITelephony telephony = getITelephony();
         if (telephony == null) return null;
 
         try {
             return telephony.getImeiForSlot(slotIndex, getOpPackageName(), getAttributionTag());
         } catch (RemoteException ex) {
             return null;
         } catch (NullPointerException ex) {
             return null;
         }
@@ -2186,20 +2199,24 @@ public class TelephonyManager {
      *     <li>If the calling app's target SDK is API level 28 or lower and the app does not have
      *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or
      *     higher, then a SecurityException is thrown.</li>
      * </ul>
      *
      * @param slotIndex of which MEID is returned
      */
     @SuppressAutoDoc // No support for device / profile owner or carrier privileges (b/72967236).
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public String getMeid(int slotIndex) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         ITelephony telephony = getITelephony();
         if (telephony == null) return null;
 
         try {
             String meid = telephony.getMeidForSlot(slotIndex, getOpPackageName(),
                     getAttributionTag());
             if (TextUtils.isEmpty(meid)) {
                 Log.d(TAG, "getMeid: return null because MEID is not available");
                 return null;
             }
@@ -2915,20 +2932,24 @@ public class TelephonyManager {
      * @see #NETWORK_TYPE_LTE
      * @see #NETWORK_TYPE_EHRPD
      * @see #NETWORK_TYPE_HSPAP
      * @see #NETWORK_TYPE_NR
      *
      * @hide
      */
     @RequiresPermission(android.Manifest.permission.READ_PHONE_STATE)
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)
     public int getNetworkType(int subId) {
+        if (GmsCompat.isEnabled()) {
+            return NETWORK_TYPE_UNKNOWN;
+        }
+
         try {
             ITelephony telephony = getITelephony();
             if (telephony != null) {
                 return telephony.getNetworkTypeForSubscriber(subId, getOpPackageName(),
                         getAttributionTag());
             } else {
                 // This can happen when the ITelephony interface is not up yet.
                 return NETWORK_TYPE_UNKNOWN;
             }
         } catch (RemoteException ex) {
@@ -3824,20 +3845,24 @@ public class TelephonyManager {
      *     the READ_PHONE_STATE permission, or if the calling app is targeting API level 29 or
      *     higher, then a SecurityException is thrown.</li>
      * </ul>
      *
      * @param subId for which Sim Serial number is returned
      * @hide
      */
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     @UnsupportedAppUsage
     public String getSimSerialNumber(int subId) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             IPhoneSubInfo info = getSubscriberInfoService();
             if (info == null)
                 return null;
             return info.getIccSerialNumberForSubscriber(subId, mContext.getOpPackageName(),
                     mContext.getAttributionTag());
         } catch (RemoteException ex) {
             return null;
         } catch (NullPointerException ex) {
             // This could happen before phone restarts due to crashing
@@ -3953,20 +3978,24 @@ public class TelephonyManager {
      * Gets all the UICC slots. The objects in the array can be null if the slot info is not
      * available, which is possible between phone process starting and getting slot info from modem.
      *
      * @return UiccSlotInfo array.
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public UiccSlotInfo[] getUiccSlotsInfo() {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             ITelephony telephony = getITelephony();
             if (telephony == null) {
                 return null;
             }
             return telephony.getUiccSlotsInfo();
         } catch (RemoteException e) {
             return null;
         }
     }
@@ -4092,20 +4121,24 @@ public class TelephonyManager {
      *
      * See {@link #getSubscriberId()} for details on the required permissions and behavior
      * when the caller does not hold sufficient permissions.
      *
      * @param subId whose subscriber id is returned
      * @hide
      */
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P)
     public String getSubscriberId(int subId) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         try {
             IPhoneSubInfo info = getSubscriberInfoService();
             if (info == null)
                 return null;
             return info.getSubscriberIdForSubscriber(subId, mContext.getOpPackageName(),
                     mContext.getAttributionTag());
         } catch (RemoteException ex) {
             return null;
         } catch (NullPointerException ex) {
             // This could happen before phone restarts due to crashing
@@ -4706,20 +4739,28 @@ public class TelephonyManager {
     @UnsupportedAppUsage
     public String getLine1Number(int subId) {
         String number = null;
         try {
             ITelephony telephony = getITelephony();
             if (telephony != null)
                 number = telephony.getLine1NumberForDisplay(subId, mContext.getOpPackageName(),
                          mContext.getAttributionTag());
         } catch (RemoteException ex) {
         } catch (NullPointerException ex) {
+        } catch (SecurityException ex) {
+            if (GmsCompat.isEnabled()) {
+                // Google Play Services settings -> Account services -> Google Pay -> Add a payment method
+                // com.google.android.gms: java.lang.SecurityException: getLine1NumberForDisplay: Neither user 1010142 nor current process has android.permission.READ_PHONE_STATE, android.permission.READ_SMS, or android.permission.READ_PHONE_NUMBERS
+                return null;
+            } else {
+                throw ex;
+            }
         }
         if (number != null) {
             return number;
         }
         try {
             IPhoneSubInfo info = getSubscriberInfoService();
             if (info == null)
                 return null;
             return info.getLine1NumberForSubscriber(subId, mContext.getOpPackageName(),
                     mContext.getAttributionTag());
@@ -6376,20 +6417,26 @@ public class TelephonyManager {
      * @param workSource the requestor to whom the power consumption for this should be attributed.
      * @param executor the executor on which callback will be invoked.
      * @param callback a callback to receive CellInfo.
      * @hide
      */
     @SystemApi
     @RequiresPermission(allOf = {android.Manifest.permission.ACCESS_FINE_LOCATION,
             android.Manifest.permission.MODIFY_PHONE_STATE})
     public void requestCellInfoUpdate(@NonNull WorkSource workSource,
             @NonNull @CallbackExecutor Executor executor, @NonNull CellInfoCallback callback) {
+        if (GmsCompat.isEnabled()) {
+            // Attribute the work to GMS instead of the client
+            requestCellInfoUpdate(executor, callback);
+            return;
+        }
+
         try {
             ITelephony telephony = getITelephony();
             if (telephony == null) {
                 if (Compatibility.isChangeEnabled(NULL_TELEPHONY_THROW_NO_CB)) {
                     throw new IllegalStateException("Telephony is null");
                 } else {
                     return;
                 }
             }
 
@@ -14581,20 +14628,24 @@ public class TelephonyManager {
      * <p>Requires Permission:
      * {@link android.Manifest.permission#READ_PRIVILEGED_PHONE_STATE READ_PRIVILEGED_PHONE_STATE}
      * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).
      *
      * @hide
      */
     @WorkerThread
     @RequiresPermission(android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     @SystemApi
     public boolean isIccLockEnabled() {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
+
         try {
             ITelephony telephony = getITelephony();
             if (telephony != null) {
                 return telephony.isIccLockEnabled(getSubId());
             } else {
                 throw new IllegalStateException("telephony service is null.");
             }
         } catch (RemoteException e) {
             Log.e(TAG, "isIccLockEnabled RemoteException", e);
             e.rethrowFromSystemServer();

commit 1077751ef10e4623d5eca3673693db350cc5bd53
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2021-03-16 02:54:57-0400

    enable app compaction by default
---
 services/core/java/com/android/server/am/CachedAppOptimizer.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/services/core/java/com/android/server/am/CachedAppOptimizer.java b/services/core/java/com/android/server/am/CachedAppOptimizer.java
index 6bb5aa148e5990786126c785df4a538e3d18ca5e..0cf8e3df0f851eba1641c0931d0c9207d04cc1d8 100644
--- a/services/core/java/com/android/server/am/CachedAppOptimizer.java
+++ b/services/core/java/com/android/server/am/CachedAppOptimizer.java
@@ -93,21 +93,21 @@ public final class CachedAppOptimizer {
     private static final int COMPACT_ACTION_ANON = 2;
     private static final int COMPACT_ACTION_FULL = 3;
 
     private static final String COMPACT_ACTION_STRING[] = {"", "file", "anon", "all"};
 
     // Keeps these flags in sync with services/core/jni/com_android_server_am_CachedAppOptimizer.cpp
     private static final int COMPACT_ACTION_FILE_FLAG = 1;
     private static final int COMPACT_ACTION_ANON_FLAG = 2;
 
     // Defaults for phenotype flags.
-    @VisibleForTesting static final Boolean DEFAULT_USE_COMPACTION = false;
+    @VisibleForTesting static final Boolean DEFAULT_USE_COMPACTION = true;
     @VisibleForTesting static final Boolean DEFAULT_USE_FREEZER = true;
     @VisibleForTesting static final int DEFAULT_COMPACT_ACTION_1 = COMPACT_ACTION_FILE;
     @VisibleForTesting static final int DEFAULT_COMPACT_ACTION_2 = COMPACT_ACTION_FULL;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_1 = 5_000;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_2 = 10_000;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_3 = 500;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_4 = 10_000;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_5 = 10 * 60 * 1000;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_6 = 10 * 60 * 1000;
     @VisibleForTesting static final long DEFAULT_COMPACT_THROTTLE_MIN_OOM_ADJ =

commit 429ff19b419ed1e2f8657b50e93af5d589d90121
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Mon 2021-10-11 15:03:59-0700

    SystemUI: Use new privacy indicators for location
    
    Android has had location indicators for a while, but let's use the new
    privacy indicator infrastructure for displaying them. This makes them
    integrate better with the new camera and microphone indicators.
    
    Change-Id: Ie457bb2dad17bddbf9dc3a818e3ec586023ce918
---
 core/java/android/permission/PermissionUsageHelper.java               | 2 +-
 .../src/com/android/systemui/privacy/PrivacyItemController.kt         | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/core/java/android/permission/PermissionUsageHelper.java b/core/java/android/permission/PermissionUsageHelper.java
index cf2361a1026a0c2b5ae02adbeb4aa61378e4f861..5ba24a3d4e7a9d4d5d6b1e56956d5f2db6818f71 100644
--- a/core/java/android/permission/PermissionUsageHelper.java
+++ b/core/java/android/permission/PermissionUsageHelper.java
@@ -94,21 +94,21 @@ public class PermissionUsageHelper implements AppOpsManager.OnOpActiveChangedLis
                 PROPERTY_PERMISSIONS_HUB_2_ENABLED, false);
     }
 
     private static boolean shouldShowIndicators() {
         return DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_PRIVACY,
                 PROPERTY_CAMERA_MIC_ICONS_ENABLED, true) || shouldShowPermissionsHub();
     }
 
     private static boolean shouldShowLocationIndicator() {
         return DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_PRIVACY,
-                PROPERTY_LOCATION_INDICATORS_ENABLED, false);
+                PROPERTY_LOCATION_INDICATORS_ENABLED, true);
     }
 
     private static long getRecentThreshold(Long now) {
         return now - DeviceConfig.getLong(DeviceConfig.NAMESPACE_PRIVACY,
                 RECENT_ACCESS_TIME_MS, DEFAULT_RECENT_TIME_MS);
     }
 
     private static long getRunningThreshold(Long now) {
         return now - DeviceConfig.getLong(DeviceConfig.NAMESPACE_PRIVACY,
                 RUNNING_ACCESS_TIME_MS, DEFAULT_RUNNING_TIME_MS);
diff --git a/packages/SystemUI/src/com/android/systemui/privacy/PrivacyItemController.kt b/packages/SystemUI/src/com/android/systemui/privacy/PrivacyItemController.kt
index e072b4a3646c992ebe5da076ed96e2885cb1d0f7..f7bf1c3af7a24b720299e01597ecaa5ce0da2f4c 100644
--- a/packages/SystemUI/src/com/android/systemui/privacy/PrivacyItemController.kt
+++ b/packages/SystemUI/src/com/android/systemui/privacy/PrivacyItemController.kt
@@ -66,21 +66,21 @@ class PrivacyItemController @Inject constructor(
         val OPS = OPS_MIC_CAMERA + OPS_LOCATION
         val intentFilter = IntentFilter().apply {
             addAction(Intent.ACTION_USER_SWITCHED)
             addAction(Intent.ACTION_MANAGED_PROFILE_AVAILABLE)
             addAction(Intent.ACTION_MANAGED_PROFILE_UNAVAILABLE)
         }
         const val TAG = "PrivacyItemController"
         private const val MIC_CAMERA = SystemUiDeviceConfigFlags.PROPERTY_MIC_CAMERA_ENABLED
         private const val LOCATION = SystemUiDeviceConfigFlags.PROPERTY_LOCATION_INDICATORS_ENABLED
         private const val DEFAULT_MIC_CAMERA = true
-        private const val DEFAULT_LOCATION = false
+        private const val DEFAULT_LOCATION = true
         @VisibleForTesting const val TIME_TO_HOLD_INDICATORS = 5000L
     }
 
     @VisibleForTesting
     internal var privacyList = emptyList<PrivacyItem>()
         @Synchronized get() = field.toList() // Returns a shallow copy of the list
         @Synchronized set
 
     private fun isMicCameraEnabled(): Boolean {
         return deviceConfigProxy.getBoolean(DeviceConfig.NAMESPACE_PRIVACY,
@@ -374,11 +374,11 @@ class PrivacyItemController @Inject constructor(
 
         override fun execute(command: Runnable) {
             delegate.execute(command)
         }
 
         fun updateListeningState() {
             listeningCanceller?.run()
             listeningCanceller = delegate.executeDelayed({ setListeningState() }, 0L)
         }
     }
-}
\ No newline at end of file
+}

commit 815964d680b58eb8c2ecddabaec0be32be95a30e
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Mon 2021-10-11 15:04:50-0700

    appop: Keep up to 7 days of permission usage history
    
    Keeping 7 days of discrete app op history allows us to show a 7-day
    permission usage timeline in the privacy dashboard.
    
    Change-Id: Ia4683e9a8dddb944d56465ce8a3829281556e723
---
 services/core/java/com/android/server/appop/DiscreteRegistry.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/services/core/java/com/android/server/appop/DiscreteRegistry.java b/services/core/java/com/android/server/appop/DiscreteRegistry.java
index b9cc992b438eea501fbb6934e1e9f2a9e6619ccf..8de515d4d3e522e13b10ebf775f701cd545f1aeb 100644
--- a/services/core/java/com/android/server/appop/DiscreteRegistry.java
+++ b/services/core/java/com/android/server/appop/DiscreteRegistry.java
@@ -127,21 +127,21 @@ final class DiscreteRegistry {
     private static final String TAG = DiscreteRegistry.class.getSimpleName();
 
     private static final String PROPERTY_DISCRETE_HISTORY_CUTOFF = "discrete_history_cutoff_millis";
     private static final String PROPERTY_DISCRETE_HISTORY_QUANTIZATION =
             "discrete_history_quantization_millis";
     private static final String PROPERTY_DISCRETE_FLAGS = "discrete_history_op_flags";
     private static final String PROPERTY_DISCRETE_OPS_LIST = "discrete_history_ops_cslist";
     private static final String DEFAULT_DISCRETE_OPS = OP_FINE_LOCATION + "," + OP_COARSE_LOCATION
             + "," + OP_CAMERA + "," + OP_RECORD_AUDIO + "," + OP_PHONE_CALL_MICROPHONE + ","
             + OP_PHONE_CALL_CAMERA;
-    private static final long DEFAULT_DISCRETE_HISTORY_CUTOFF = Duration.ofHours(24).toMillis();
+    private static final long DEFAULT_DISCRETE_HISTORY_CUTOFF = Duration.ofDays(7).toMillis();
     private static final long MAXIMUM_DISCRETE_HISTORY_CUTOFF = Duration.ofDays(30).toMillis();
     private static final long DEFAULT_DISCRETE_HISTORY_QUANTIZATION =
             Duration.ofMinutes(1).toMillis();
 
     private static long sDiscreteHistoryCutoff;
     private static long sDiscreteHistoryQuantization;
     private static int[] sDiscreteOps;
     private static int sDiscreteFlags;
 
     private static final String TAG_HISTORY = "h";

commit d6b0d8bff31bb49c578bc8c84eeb1d9d93268456
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Mon 2021-10-11 15:15:40-0700

    appop: Save discrete app op history for more permissions
    
    Android 12's privacy dashboard shows permission usage timelines for
    location, camera, and microphone. However, there's no reason to limit it
    to those specific permissions; all the infrastructure is in place for
    other permissions.
    
    To enable the usage timeline for more permissions, keep discrete app op
    history for all permission groups shown in the privacy dashboard. The
    list of permission group -> app op mappings was obtained from
    AppOpsManager.RUNTIME_AND_APPOP_PERMISSION_OPS with a few additional ops
    from PrivacyItemController, and each op was resolved to its respective
    enum ordinal from frameworks/proto_logging/stats/enums/app/enums.proto.
    
    Change-Id: I6b1c476ea4c0edbc0b3fdf2e3e5cfcb11da77e33
---
 .../com/android/server/appop/DiscreteRegistry.java | 67 +++++++++++++++++++++-
 1 file changed, 64 insertions(+), 3 deletions(-)

diff --git a/services/core/java/com/android/server/appop/DiscreteRegistry.java b/services/core/java/com/android/server/appop/DiscreteRegistry.java
index 8de515d4d3e522e13b10ebf775f701cd545f1aeb..49fbc1cc1181938c01d767b4a4b49ee78a3c388b 100644
--- a/services/core/java/com/android/server/appop/DiscreteRegistry.java
+++ b/services/core/java/com/android/server/appop/DiscreteRegistry.java
@@ -17,31 +17,60 @@
 package com.android.server.appop;
 
 import static android.app.AppOpsManager.ATTRIBUTION_CHAIN_ID_NONE;
 import static android.app.AppOpsManager.ATTRIBUTION_FLAG_ACCESSOR;
 import static android.app.AppOpsManager.ATTRIBUTION_FLAG_RECEIVER;
 import static android.app.AppOpsManager.ATTRIBUTION_FLAG_TRUSTED;
 import static android.app.AppOpsManager.FILTER_BY_ATTRIBUTION_TAG;
 import static android.app.AppOpsManager.FILTER_BY_OP_NAMES;
 import static android.app.AppOpsManager.FILTER_BY_PACKAGE_NAME;
 import static android.app.AppOpsManager.FILTER_BY_UID;
+import static android.app.AppOpsManager.OP_ACCEPT_HANDOVER;
+import static android.app.AppOpsManager.OP_ACCESS_MEDIA_LOCATION;
+import static android.app.AppOpsManager.OP_ACTIVITY_RECOGNITION;
+import static android.app.AppOpsManager.OP_ADD_VOICEMAIL;
+import static android.app.AppOpsManager.OP_ANSWER_PHONE_CALLS;
+import static android.app.AppOpsManager.OP_BLUETOOTH_ADVERTISE;
+import static android.app.AppOpsManager.OP_BLUETOOTH_CONNECT;
+import static android.app.AppOpsManager.OP_BLUETOOTH_SCAN;
+import static android.app.AppOpsManager.OP_CALL_PHONE;
 import static android.app.AppOpsManager.OP_CAMERA;
 import static android.app.AppOpsManager.OP_COARSE_LOCATION;
 import static android.app.AppOpsManager.OP_FINE_LOCATION;
 import static android.app.AppOpsManager.OP_FLAGS_ALL;
 import static android.app.AppOpsManager.OP_FLAG_SELF;
 import static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED;
 import static android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXY;
+import static android.app.AppOpsManager.OP_GET_ACCOUNTS;
 import static android.app.AppOpsManager.OP_NONE;
 import static android.app.AppOpsManager.OP_PHONE_CALL_CAMERA;
 import static android.app.AppOpsManager.OP_PHONE_CALL_MICROPHONE;
+import static android.app.AppOpsManager.OP_PROCESS_OUTGOING_CALLS;
+import static android.app.AppOpsManager.OP_READ_CALENDAR;
+import static android.app.AppOpsManager.OP_READ_CALL_LOG;
+import static android.app.AppOpsManager.OP_READ_CELL_BROADCASTS;
+import static android.app.AppOpsManager.OP_READ_CONTACTS;
+import static android.app.AppOpsManager.OP_READ_EXTERNAL_STORAGE;
+import static android.app.AppOpsManager.OP_READ_PHONE_NUMBERS;
+import static android.app.AppOpsManager.OP_READ_PHONE_STATE;
+import static android.app.AppOpsManager.OP_READ_SMS;
+import static android.app.AppOpsManager.OP_RECEIVE_MMS;
+import static android.app.AppOpsManager.OP_RECEIVE_SMS;
+import static android.app.AppOpsManager.OP_RECEIVE_WAP_PUSH;
 import static android.app.AppOpsManager.OP_RECORD_AUDIO;
+import static android.app.AppOpsManager.OP_SEND_SMS;
+import static android.app.AppOpsManager.OP_USE_SIP;
+import static android.app.AppOpsManager.OP_UWB_RANGING;
+import static android.app.AppOpsManager.OP_WRITE_CALENDAR;
+import static android.app.AppOpsManager.OP_WRITE_CALL_LOG;
+import static android.app.AppOpsManager.OP_WRITE_CONTACTS;
+import static android.app.AppOpsManager.OP_WRITE_EXTERNAL_STORAGE;
 import static android.app.AppOpsManager.flagsToString;
 import static android.app.AppOpsManager.getUidStateName;
 
 import static java.lang.Long.min;
 import static java.lang.Math.max;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.AppOpsManager;
 import android.os.AsyncTask;
@@ -124,23 +153,55 @@ import java.util.Set;
 
 final class DiscreteRegistry {
     static final String DISCRETE_HISTORY_FILE_SUFFIX = "tl";
     private static final String TAG = DiscreteRegistry.class.getSimpleName();
 
     private static final String PROPERTY_DISCRETE_HISTORY_CUTOFF = "discrete_history_cutoff_millis";
     private static final String PROPERTY_DISCRETE_HISTORY_QUANTIZATION =
             "discrete_history_quantization_millis";
     private static final String PROPERTY_DISCRETE_FLAGS = "discrete_history_op_flags";
     private static final String PROPERTY_DISCRETE_OPS_LIST = "discrete_history_ops_cslist";
-    private static final String DEFAULT_DISCRETE_OPS = OP_FINE_LOCATION + "," + OP_COARSE_LOCATION
-            + "," + OP_CAMERA + "," + OP_RECORD_AUDIO + "," + OP_PHONE_CALL_MICROPHONE + ","
-            + OP_PHONE_CALL_CAMERA;
+
+    /**
+     * Keep track of more app ops for privacy dashboard display.
+     *
+     * From AppOpsManager.RUNTIME_AND_APPOP_PERMISSIONS_OPS:
+     * Location: COARSE_LOCATION, FINE_LOCATION
+     * Camera: CAMERA
+     * Microphone: RECORD_AUDIO
+     * Calendar: READ_CALENDAR, WRITE_CALENDAR
+     * Call logs: READ_CALL_LOG, WRITE_CALL_LOG
+     * Contacts: READ_CONTACTS, WRITE_CONTACTS, GET_ACCOUNTS
+     * Files and media: READ_EXTERNAL_STORAGE, WRITE_EXTERNAL_STORAGE, ACCESS_MEDIA_LOCATION
+     * Nearby devices: BLUETOOTH_SCAN, BLUETOOTH_CONNECT, BLUETOOTH_ADVERTISE, UWB_RANGING
+     * Phone: READ_PHONE_STATE, READ_PHONE_NUMBERS, CALL_PHONE, READ_CALL_LOG, WRITE_CALL_LOG, ADD_VOICEMAIL, USE_SIP, PROCESS_OUTGOING_CALLS, ANSWER_PHONE_CALLS, ACCEPT_HANDOVER
+     * Body sensors: ACTIVITY_RECOGNITION
+     * SMS: SEND_SMS, RECEIVE_SMS, READ_SMS, RECEIVE_WAP_PUSH, RECEIVE_MMS, READ_CELL_BROADCASTS
+     *
+     * From PrivacyItemController:
+     * Camera: PHONE_CALL_CAMERA
+     * Microphone: PHONE_CALL_MICROPHONE
+     */
+    private static final String DEFAULT_DISCRETE_OPS = OP_COARSE_LOCATION + "," + OP_FINE_LOCATION +
+            "," + OP_CAMERA + "," + OP_RECORD_AUDIO + "," + OP_READ_CALENDAR + "," +
+            OP_WRITE_CALENDAR + "," + OP_READ_CALL_LOG + "," + OP_WRITE_CALL_LOG + "," +
+            OP_READ_CONTACTS + "," + OP_WRITE_CONTACTS + "," + OP_GET_ACCOUNTS + "," +
+            OP_READ_EXTERNAL_STORAGE + "," + OP_WRITE_EXTERNAL_STORAGE + "," +
+            OP_ACCESS_MEDIA_LOCATION + "," + OP_BLUETOOTH_SCAN + "," + OP_BLUETOOTH_CONNECT + "," +
+            OP_BLUETOOTH_ADVERTISE + "," + OP_UWB_RANGING + "," + OP_READ_PHONE_STATE + "," +
+            OP_READ_PHONE_NUMBERS + "," + OP_CALL_PHONE + "," + OP_READ_CALL_LOG + "," +
+            OP_WRITE_CALL_LOG + "," + OP_ADD_VOICEMAIL + "," + OP_USE_SIP + "," +
+            OP_PROCESS_OUTGOING_CALLS + "," + OP_ANSWER_PHONE_CALLS + "," + OP_ACCEPT_HANDOVER +
+            "," + OP_ACTIVITY_RECOGNITION + "," + OP_SEND_SMS + "," + OP_RECEIVE_SMS + "," +
+            OP_READ_SMS + "," + OP_RECEIVE_WAP_PUSH + "," + OP_RECEIVE_MMS + "," +
+            OP_READ_CELL_BROADCASTS + "," + OP_PHONE_CALL_CAMERA + "," + OP_PHONE_CALL_MICROPHONE;
+
     private static final long DEFAULT_DISCRETE_HISTORY_CUTOFF = Duration.ofDays(7).toMillis();
     private static final long MAXIMUM_DISCRETE_HISTORY_CUTOFF = Duration.ofDays(30).toMillis();
     private static final long DEFAULT_DISCRETE_HISTORY_QUANTIZATION =
             Duration.ofMinutes(1).toMillis();
 
     private static long sDiscreteHistoryCutoff;
     private static long sDiscreteHistoryQuantization;
     private static int[] sDiscreteOps;
     private static int sDiscreteFlags;
 

commit 8d9df5461f7dab23087313ca00482a68fb86fab5
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2021-10-14 22:10:58-0400

    enable backup support via seedvault
---
 packages/SettingsProvider/res/values/defaults.xml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/packages/SettingsProvider/res/values/defaults.xml b/packages/SettingsProvider/res/values/defaults.xml
index 53324ba4d9664dc170a81c39dcf77d1affe7812a..93efe5060a2f642841b4d662225d30935e9b48b7 100644
--- a/packages/SettingsProvider/res/values/defaults.xml
+++ b/packages/SettingsProvider/res/values/defaults.xml
@@ -43,22 +43,22 @@
     <integer name="def_location_mode">3</integer>
     <bool name="assisted_gps_enabled">true</bool>
     <bool name="def_netstats_enabled">true</bool>
     <bool name="def_usb_mass_storage_enabled">true</bool>
     <bool name="def_wifi_on">false</bool>
     <!-- 0 == never, 1 == only when plugged in, 2 == always -->
     <integer name="def_wifi_sleep_policy">2</integer>
     <bool name="def_wifi_wakeup_enabled">true</bool>
     <bool name="def_networks_available_notification_on">true</bool>
 
-    <bool name="def_backup_enabled">false</bool>
-    <string name="def_backup_transport" translatable="false">com.android.localtransport/.LocalTransport</string>
+    <bool name="def_backup_enabled">true</bool>
+    <string name="def_backup_transport" translatable="false">com.stevesoltys.seedvault.transport.ConfigurableBackupTransport</string>
 
     <!-- Default value for whether or not to pulse the notification LED when there is a
          pending notification -->
     <bool name="def_notification_pulse">true</bool>
 
     <bool name="def_mount_play_notification_snd">true</bool>
     <bool name="def_mount_ums_autostart">false</bool>
     <bool name="def_mount_ums_prompt">true</bool>
     <bool name="def_mount_ums_notify_enabled">true</bool>
 

commit 81c98015e6decb22cbd5aca50658e208ab2b058d
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Fri 2021-10-15 17:18:57-0700

    gmscompat: Fix crash with SDK 31 Google Services Framework
    
    Change-Id: I0cd34f32ccb59922bf85a220f485765bc34dbaf1
---
 core/java/android/provider/DeviceConfig.java | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/core/java/android/provider/DeviceConfig.java b/core/java/android/provider/DeviceConfig.java
index b24f4755bc901af821f9046169d9caa9382afb13..d1fe02f48e5aef23a96a8132d6f0adaf44441b47 100644
--- a/core/java/android/provider/DeviceConfig.java
+++ b/core/java/android/provider/DeviceConfig.java
@@ -629,20 +629,24 @@ public final class DeviceConfig {
      * Look up the value of a property for a particular namespace.
      *
      * @param namespace The namespace containing the property to look up.
      * @param name      The name of the property to look up.
      * @return the corresponding value, or null if not present.
      * @hide
      */
     @SystemApi
     @RequiresPermission(READ_DEVICE_CONFIG)
     public static String getProperty(@NonNull String namespace, @NonNull String name) {
+        if (GmsCompat.isEnabled()) {
+            return null;
+        }
+
         // Fetch all properties for the namespace at once and cache them in the local process, so we
         // incur the cost of the IPC less often. Lookups happen much more frequently than updates,
         // and we want to optimize the former.
         return getProperties(namespace, name).getString(name, null);
     }
 
     /**
      * Look up the values of multiple properties for a particular namespace. The lookup is atomic,
      * such that the values of these properties cannot change between the time when the first is
      * fetched and the time when the last is fetched.

commit 4801d52b178b369b00c41841f63db4832329d0a7
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Fri 2021-10-15 17:55:04-0700

    gmscompat: Fall back to batched alarms when necessary
    
    Exact alarms are only available if the app is set to unrestricted
    battery usage.
    
    Change-Id: Id8e45726e9bc63cbfa70e873f56f375240209b70
---
 apex/jobscheduler/framework/java/android/app/AlarmManager.java | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/apex/jobscheduler/framework/java/android/app/AlarmManager.java b/apex/jobscheduler/framework/java/android/app/AlarmManager.java
index 9c0c3657bff33c5d8209c309fd4e6afd57a61fa0..f1483d23f9824d78e0c44cca5034ee60852d80f5 100644
--- a/apex/jobscheduler/framework/java/android/app/AlarmManager.java
+++ b/apex/jobscheduler/framework/java/android/app/AlarmManager.java
@@ -19,20 +19,21 @@ package android.app;
 import android.Manifest;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Context;
 import android.content.Intent;
 import android.os.Build;
 import android.os.Handler;
 import android.os.HandlerExecutor;
 import android.os.Parcel;
 import android.os.Parcelable;
@@ -1165,20 +1166,25 @@ public class AlarmManager {
      * @see android.content.Intent#filterEquals
      * @see #ELAPSED_REALTIME
      * @see #ELAPSED_REALTIME_WAKEUP
      * @see #RTC
      * @see #RTC_WAKEUP
      * @see Manifest.permission#SCHEDULE_EXACT_ALARM SCHEDULE_EXACT_ALARM
      */
     @RequiresPermission(value = Manifest.permission.SCHEDULE_EXACT_ALARM, conditional = true)
     public void setExactAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis,
             PendingIntent operation) {
+        if (GmsCompat.isEnabled() && !canScheduleExactAlarms()) {
+            setAndAllowWhileIdle(type, triggerAtMillis, operation);
+            return;
+        }
+
         setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, FLAG_ALLOW_WHILE_IDLE, operation,
                 null, null, (Handler) null, null, null);
     }
 
     /**
      * Remove any alarms with a matching {@link Intent}.
      * Any alarm, of any type, whose Intent matches this one (as defined by
      * {@link Intent#filterEquals}), will be canceled.
      *
      * @param operation IntentSender which matches a previously added

commit 4a303f010586844e5fa48e6f50807ff12f8dd5fa
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Wed 2021-10-20 16:06:40-0700

    gmscompat: Handle all exact alarm denials
    
    java.lang.SecurityException: Caller com.google.android.gms needs to hold android.permission.SCHEDULE_EXACT_ALARM to set exact alarms.
            at android.os.Parcel.createExceptionOrNull(Parcel.java:2425)
            at android.os.Parcel.createException(Parcel.java:2409)
            at android.os.Parcel.readException(Parcel.java:2392)
            at android.os.Parcel.readException(Parcel.java:2334)
            at android.app.IAlarmManager$Stub$Proxy.set(IAlarmManager.java:359)
            at android.app.AlarmManager.setImpl(AlarmManager.java:948)
            at android.app.AlarmManager.setImpl(AlarmManager.java:908)
            at android.app.AlarmManager.set(AlarmManager.java:818)
            at usv.k(:com.google.android.gms@213314046@21.33.14 (150400-395723304):1)
            at usv.o(:com.google.android.gms@213314046@21.33.14 (150400-395723304):0)
            at usv.e(:com.google.android.gms@213314046@21.33.14 (150400-395723304):2)
            at com.google.android.contextmanager.controller.EventHandler$AlarmSetter.c(:com.google.android.gms@213314046@21.33.14 (150400-395723304):8)
            at exr.d(:com.google.android.gms@213314046@21.33.14 (150400-395723304):3)
            at ext.l(:com.google.android.gms@213314046@21.33.14 (150400-395723304):0)
            at evr.a(:com.google.android.gms@213314046@21.33.14 (150400-395723304):143)
            at ext.run(:com.google.android.gms@213314046@21.33.14 (150400-395723304):2)
            at exp.handleMessage(:com.google.android.gms@213314046@21.33.14 (150400-395723304):3)
            at uwe.run(:com.google.android.gms@213314046@21.33.14 (150400-395723304):2)
            at uwo.c(:com.google.android.gms@213314046@21.33.14 (150400-395723304):6)
            at uwo.run(:com.google.android.gms@213314046@21.33.14 (150400-395723304):8)
            at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
            at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
            at vcm.run(:com.google.android.gms@213314046@21.33.14 (150400-395723304):0)
            at java.lang.Thread.run(Thread.java:920)
    
    Change-Id: I6a179661a3da33cba54cbc07c48adcebcaf008a8
---
 apex/jobscheduler/framework/java/android/app/AlarmManager.java | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/apex/jobscheduler/framework/java/android/app/AlarmManager.java b/apex/jobscheduler/framework/java/android/app/AlarmManager.java
index f1483d23f9824d78e0c44cca5034ee60852d80f5..d6f3f42d10ab488b1c947a694e9d76a721bf4ec6 100644
--- a/apex/jobscheduler/framework/java/android/app/AlarmManager.java
+++ b/apex/jobscheduler/framework/java/android/app/AlarmManager.java
@@ -906,20 +906,25 @@ public class AlarmManager {
             AlarmClockInfo alarmClock) {
         final Handler handlerToUse = (targetHandler != null) ? targetHandler : mMainThreadHandler;
         setImpl(type, triggerAtMillis, windowMillis, intervalMillis, flags, operation, listener,
                 listenerTag, new HandlerExecutor(handlerToUse), workSource, alarmClock);
     }
 
     private void setImpl(@AlarmType int type, long triggerAtMillis, long windowMillis,
             long intervalMillis, int flags, PendingIntent operation, final OnAlarmListener listener,
             String listenerTag, Executor targetExecutor, WorkSource workSource,
             AlarmClockInfo alarmClock) {
+        if (GmsCompat.isEnabled() && windowMillis == WINDOW_EXACT &&
+                !canScheduleExactAlarms()) {
+            windowMillis = WINDOW_HEURISTIC;
+        }
+
         if (triggerAtMillis < 0) {
             /* NOTYET
             if (mAlwaysExact) {
                 // Fatal error for KLP+ apps to use negative trigger times
                 throw new IllegalArgumentException("Invalid alarm trigger time "
                         + triggerAtMillis);
             }
             */
             triggerAtMillis = 0;
         }
@@ -1166,25 +1171,20 @@ public class AlarmManager {
      * @see android.content.Intent#filterEquals
      * @see #ELAPSED_REALTIME
      * @see #ELAPSED_REALTIME_WAKEUP
      * @see #RTC
      * @see #RTC_WAKEUP
      * @see Manifest.permission#SCHEDULE_EXACT_ALARM SCHEDULE_EXACT_ALARM
      */
     @RequiresPermission(value = Manifest.permission.SCHEDULE_EXACT_ALARM, conditional = true)
     public void setExactAndAllowWhileIdle(@AlarmType int type, long triggerAtMillis,
             PendingIntent operation) {
-        if (GmsCompat.isEnabled() && !canScheduleExactAlarms()) {
-            setAndAllowWhileIdle(type, triggerAtMillis, operation);
-            return;
-        }
-
         setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, FLAG_ALLOW_WHILE_IDLE, operation,
                 null, null, (Handler) null, null, null);
     }
 
     /**
      * Remove any alarms with a matching {@link Intent}.
      * Any alarm, of any type, whose Intent matches this one (as defined by
      * {@link Intent#filterEquals}), will be canceled.
      *
      * @param operation IntentSender which matches a previously added

commit 1cd10742c542fb46c8564dfed65a607a24d34393
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2015-03-14 18:10:20-0400

    add exec-based spawning support
---
 .../com/android/internal/os/ExecInit.java (new)    | 115 +++++++++++++++++++++
 core/java/com/android/internal/os/WrapperInit.java |   2 +-
 .../com/android/internal/os/ZygoteConnection.java  |  10 +-
 3 files changed, 125 insertions(+), 2 deletions(-)

diff --git a/core/java/com/android/internal/os/ExecInit.java b/core/java/com/android/internal/os/ExecInit.java
new file mode 100644
index 0000000000000000000000000000000000000000..2adcab7fdbe687f72143491b5e9a87c936431abb
--- /dev/null
+++ b/core/java/com/android/internal/os/ExecInit.java
@@ -0,0 +1,115 @@
+package com.android.internal.os;
+
+import android.os.Trace;
+import android.system.ErrnoException;
+import android.system.Os;
+import android.util.Slog;
+import android.util.TimingsTraceLog;
+import dalvik.system.VMRuntime;
+
+/**
+ * Startup class for the process.
+ * @hide
+ */
+public class ExecInit {
+    /**
+     * Class not instantiable.
+     */
+    private ExecInit() {
+    }
+
+    /**
+     * The main function called when starting a runtime application.
+     *
+     * The first argument is the target SDK version for the app.
+     *
+     * The remaining arguments are passed to the runtime.
+     *
+     * @param args The command-line arguments.
+     */
+    public static void main(String[] args) {
+        // Parse our mandatory argument.
+        int targetSdkVersion = Integer.parseInt(args[0], 10);
+
+        // Mimic system Zygote preloading.
+        ZygoteInit.preload(new TimingsTraceLog("ExecInitTiming",
+                Trace.TRACE_TAG_DALVIK));
+
+        // Launch the application.
+        String[] runtimeArgs = new String[args.length - 1];
+        System.arraycopy(args, 1, runtimeArgs, 0, runtimeArgs.length);
+        Runnable r = execInit(targetSdkVersion, runtimeArgs);
+
+        r.run();
+    }
+
+    /**
+     * Executes a runtime application with exec-based spawning.
+     * This method never returns.
+     *
+     * @param niceName The nice name for the application, or null if none.
+     * @param targetSdkVersion The target SDK version for the app.
+     * @param args Arguments for {@link RuntimeInit#main}.
+     */
+    public static void execApplication(String niceName, int targetSdkVersion,
+            String instructionSet, String[] args) {
+        int niceArgs = niceName == null ? 0 : 1;
+        int baseArgs = 5 + niceArgs;
+        String[] argv = new String[baseArgs + args.length];
+        if (VMRuntime.is64BitInstructionSet(instructionSet)) {
+            argv[0] = "/system/bin/app_process64";
+        } else {
+            argv[0] = "/system/bin/app_process32";
+        }
+        argv[1] = "/system/bin";
+        argv[2] = "--application";
+        if (niceName != null) {
+            argv[3] = "--nice-name=" + niceName;
+        }
+        argv[3 + niceArgs] = "com.android.internal.os.ExecInit";
+        argv[4 + niceArgs] = Integer.toString(targetSdkVersion);
+        System.arraycopy(args, 0, argv, baseArgs, args.length);
+
+        WrapperInit.preserveCapabilities();
+        try {
+            Os.execv(argv[0], argv);
+        } catch (ErrnoException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * The main function called when an application is started with exec-based spawning.
+     *
+     * When the app starts, the runtime starts {@link RuntimeInit#main}
+     * which calls {@link main} which then calls this method.
+     * So we don't need to call commonInit() here.
+     *
+     * @param targetSdkVersion target SDK version
+     * @param argv arg strings
+     */
+    private static Runnable execInit(int targetSdkVersion, String[] argv) {
+        if (RuntimeInit.DEBUG) {
+            Slog.d(RuntimeInit.TAG, "RuntimeInit: Starting application from exec");
+        }
+
+        // Check whether the first argument is a "-cp" in argv, and assume the next argument is the
+        // classpath. If found, create a PathClassLoader and use it for applicationInit.
+        ClassLoader classLoader = null;
+        if (argv != null && argv.length > 2 && argv[0].equals("-cp")) {
+            classLoader = ZygoteInit.createPathClassLoader(argv[1], targetSdkVersion);
+
+            // Install this classloader as the context classloader, too.
+            Thread.currentThread().setContextClassLoader(classLoader);
+
+            // Remove the classpath from the arguments.
+            String removedArgs[] = new String[argv.length - 2];
+            System.arraycopy(argv, 2, removedArgs, 0, argv.length - 2);
+            argv = removedArgs;
+        }
+
+        // Perform the same initialization that would happen after the Zygote forks.
+        Zygote.nativePreApplicationInit();
+        return RuntimeInit.applicationInit(targetSdkVersion, /*disabledCompatChanges*/ null, argv, classLoader);
+    }
+}
diff --git a/core/java/com/android/internal/os/WrapperInit.java b/core/java/com/android/internal/os/WrapperInit.java
index 6860759eea8aeaacbc40fc45720790a1f979b5ce..a2eef62f80be2485233cba817b995bc9beb1f338 100644
--- a/core/java/com/android/internal/os/WrapperInit.java
+++ b/core/java/com/android/internal/os/WrapperInit.java
@@ -179,21 +179,21 @@ public class WrapperInit {
      * Copy current capabilities to ambient capabilities. This is required for apps using
      * capabilities, as execv will re-evaluate the capability set, and the set of sh is
      * empty. Ambient capabilities have to be set to inherit them effectively.
      *
      * Note: This is BEST EFFORT ONLY. In case capabilities can't be raised, this function
      *       will silently return. In THIS CASE ONLY, as this is a development feature, it
      *       is better to return and try to run anyways, instead of blocking the wrapped app.
      *       This is acceptable here as failure will leave the wrapped app with strictly less
      *       capabilities, which may make it crash, but not exceed its allowances.
      */
-    private static void preserveCapabilities() {
+    public static void preserveCapabilities() {
         StructCapUserHeader header = new StructCapUserHeader(
                 OsConstants._LINUX_CAPABILITY_VERSION_3, 0);
         StructCapUserData[] data;
         try {
             data = Os.capget(header);
         } catch (ErrnoException e) {
             Slog.e(RuntimeInit.TAG, "RuntimeInit: Failed capget", e);
             return;
         }
 
diff --git a/core/java/com/android/internal/os/ZygoteConnection.java b/core/java/com/android/internal/os/ZygoteConnection.java
index 993e4e7b4b3d0bb39f0afe8e60947fd3d03baded..756547706f60812a32f2057f6c3b4a3406ec7c37 100644
--- a/core/java/com/android/internal/os/ZygoteConnection.java
+++ b/core/java/com/android/internal/os/ZygoteConnection.java
@@ -22,20 +22,21 @@ import static android.system.OsConstants.POLLIN;
 
 import static com.android.internal.os.ZygoteConnectionConstants.CONNECTION_TIMEOUT_MILLIS;
 import static com.android.internal.os.ZygoteConnectionConstants.WRAPPED_PID_TIMEOUT_MILLIS;
 
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.pm.ApplicationInfo;
 import android.net.Credentials;
 import android.net.LocalSocket;
 import android.os.Parcel;
 import android.os.Process;
+import android.os.SystemProperties;
 import android.os.Trace;
 import android.system.ErrnoException;
 import android.system.Os;
 import android.system.StructPollfd;
 import android.util.Log;
 
 import dalvik.system.VMRuntime;
 import dalvik.system.ZygoteHooks;
 
 import libcore.io.IoUtils;
@@ -240,21 +241,21 @@ class ZygoteConnection {
                 if (fd != null) {
                     fdsToClose[0] = fd.getInt$();
                 }
 
                 FileDescriptor zygoteFd = zygoteServer.getZygoteSocketFileDescriptor();
 
                 if (zygoteFd != null) {
                     fdsToClose[1] = zygoteFd.getInt$();
                 }
 
-                if (parsedArgs.mInvokeWith != null || parsedArgs.mStartChildZygote
+                if (parsedArgs.mInvokeWith != null || SystemProperties.getBoolean("sys.spawn.exec", true) || parsedArgs.mStartChildZygote
                         || !multipleOK || peer.getUid() != Process.SYSTEM_UID) {
                     // Continue using old code for now. TODO: Handle these cases in the other path.
                     pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid,
                             parsedArgs.mGids, parsedArgs.mRuntimeFlags, rlimits,
                             parsedArgs.mMountExternal, parsedArgs.mSeInfo, parsedArgs.mNiceName,
                             fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote,
                             parsedArgs.mInstructionSet, parsedArgs.mAppDataDir,
                             parsedArgs.mIsTopApp, parsedArgs.mPkgDataInfoList,
                             parsedArgs.mAllowlistedDataInfoList, parsedArgs.mBindMountAppDataDirs,
                             parsedArgs.mBindMountAppStorageDirs);
@@ -528,20 +529,27 @@ class ZygoteConnection {
         if (parsedArgs.mInvokeWith != null) {
             WrapperInit.execApplication(parsedArgs.mInvokeWith,
                     parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,
                     VMRuntime.getCurrentInstructionSet(),
                     pipeFd, parsedArgs.mRemainingArgs);
 
             // Should not get here.
             throw new IllegalStateException("WrapperInit.execApplication unexpectedly returned");
         } else {
             if (!isZygote) {
+                if (SystemProperties.getBoolean("sys.spawn.exec", true)) {
+                    ExecInit.execApplication(parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,
+                            VMRuntime.getCurrentInstructionSet(), parsedArgs.mRemainingArgs);
+
+                    // Should not get here.
+                    throw new IllegalStateException("ExecInit.execApplication unexpectedly returned");
+                }
                 return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,
                         parsedArgs.mDisabledCompatChanges,
                         parsedArgs.mRemainingArgs, null /* classLoader */);
             } else {
                 return ZygoteInit.childZygoteInit(
                         parsedArgs.mRemainingArgs  /* classLoader */);
             }
         }
     }
 

commit 26824866c98890736f6e1a5a31216f1ea78fbab9
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-21 23:54:20-0400

    disable exec spawning when using debugging options
    
    The debugging options are not yet supported probably, so disable exec
    spawning when doing debugging.
---
 core/java/com/android/internal/os/ZygoteConnection.java | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/core/java/com/android/internal/os/ZygoteConnection.java b/core/java/com/android/internal/os/ZygoteConnection.java
index 756547706f60812a32f2057f6c3b4a3406ec7c37..27518dd4cdce45c6b54f3deb5d018a6706a061d8 100644
--- a/core/java/com/android/internal/os/ZygoteConnection.java
+++ b/core/java/com/android/internal/os/ZygoteConnection.java
@@ -529,21 +529,22 @@ class ZygoteConnection {
         if (parsedArgs.mInvokeWith != null) {
             WrapperInit.execApplication(parsedArgs.mInvokeWith,
                     parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,
                     VMRuntime.getCurrentInstructionSet(),
                     pipeFd, parsedArgs.mRemainingArgs);
 
             // Should not get here.
             throw new IllegalStateException("WrapperInit.execApplication unexpectedly returned");
         } else {
             if (!isZygote) {
-                if (SystemProperties.getBoolean("sys.spawn.exec", true)) {
+                if (SystemProperties.getBoolean("sys.spawn.exec", true) &&
+                        (parsedArgs.mRuntimeFlags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
                     ExecInit.execApplication(parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,
                             VMRuntime.getCurrentInstructionSet(), parsedArgs.mRemainingArgs);
 
                     // Should not get here.
                     throw new IllegalStateException("ExecInit.execApplication unexpectedly returned");
                 }
                 return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,
                         parsedArgs.mDisabledCompatChanges,
                         parsedArgs.mRemainingArgs, null /* classLoader */);
             } else {

commit 03d7c6d2afef933dc185f8b674b485508e20f874
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-14 14:24:21-0400

    add parameter for avoiding full preload with exec
---
 core/java/com/android/internal/os/ExecInit.java   | 2 +-
 core/java/com/android/internal/os/ZygoteInit.java | 6 +++++-
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/core/java/com/android/internal/os/ExecInit.java b/core/java/com/android/internal/os/ExecInit.java
index 2adcab7fdbe687f72143491b5e9a87c936431abb..830e5b562a919bf599784358f3e4a267168e7fb1 100644
--- a/core/java/com/android/internal/os/ExecInit.java
+++ b/core/java/com/android/internal/os/ExecInit.java
@@ -26,21 +26,21 @@ public class ExecInit {
      * The remaining arguments are passed to the runtime.
      *
      * @param args The command-line arguments.
      */
     public static void main(String[] args) {
         // Parse our mandatory argument.
         int targetSdkVersion = Integer.parseInt(args[0], 10);
 
         // Mimic system Zygote preloading.
         ZygoteInit.preload(new TimingsTraceLog("ExecInitTiming",
-                Trace.TRACE_TAG_DALVIK));
+                Trace.TRACE_TAG_DALVIK), false);
 
         // Launch the application.
         String[] runtimeArgs = new String[args.length - 1];
         System.arraycopy(args, 1, runtimeArgs, 0, runtimeArgs.length);
         Runnable r = execInit(targetSdkVersion, runtimeArgs);
 
         r.run();
     }
 
     /**
diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index 89b33590ab35cd38f424b85bdd288e73808d3672..fefff67a66ebddf8167a778a513c8b819f401657 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -126,21 +126,21 @@ public class ZygoteInit {
     private static final int ROOT_GID = 0;
 
     private static boolean sPreloadComplete;
 
     /**
      * Cached classloader to use for the system server. Will only be populated in the system
      * server process.
      */
     private static ClassLoader sCachedSystemServerClassLoader = null;
 
-    static void preload(TimingsTraceLog bootTimingsTraceLog) {
+    static void preload(TimingsTraceLog bootTimingsTraceLog, boolean fullPreload) {
         Log.d(TAG, "begin preload");
         bootTimingsTraceLog.traceBegin("BeginPreload");
         beginPreload();
         bootTimingsTraceLog.traceEnd(); // BeginPreload
         bootTimingsTraceLog.traceBegin("PreloadClasses");
         preloadClasses();
         bootTimingsTraceLog.traceEnd(); // PreloadClasses
         bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
         cacheNonBootClasspathClassLoaders();
         bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
@@ -158,20 +158,24 @@ public class ZygoteInit {
         // Ask the WebViewFactory to do any initialization that must run in the zygote process,
         // for memory sharing purposes.
         WebViewFactory.prepareWebViewInZygote();
         endPreload();
         warmUpJcaProviders();
         Log.d(TAG, "end preload");
 
         sPreloadComplete = true;
     }
 
+    static void preload(TimingsTraceLog bootTimingsTraceLog) {
+        preload(bootTimingsTraceLog, true);
+    }
+
     static void lazyPreload() {
         Preconditions.checkState(!sPreloadComplete);
         Log.i(TAG, "Lazily preloading resources.");
 
         preload(new TimingsTraceLog("ZygoteInitTiming_lazy", Trace.TRACE_TAG_DALVIK));
     }
 
     private static void beginPreload() {
         Log.i(TAG, "Calling ZygoteHooks.beginPreload()");
 

commit 82b8ec6dcd89b03cacbbdfd77e421f961b0696fe
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2019-09-11 06:43:55-0400

    pass through fullPreload to libcore
---
 core/java/com/android/internal/os/ZygoteInit.java | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index fefff67a66ebddf8167a778a513c8b819f401657..b07173d50b9d1a39fb5864e6178b202bd1b97747 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -129,21 +129,21 @@ public class ZygoteInit {
 
     /**
      * Cached classloader to use for the system server. Will only be populated in the system
      * server process.
      */
     private static ClassLoader sCachedSystemServerClassLoader = null;
 
     static void preload(TimingsTraceLog bootTimingsTraceLog, boolean fullPreload) {
         Log.d(TAG, "begin preload");
         bootTimingsTraceLog.traceBegin("BeginPreload");
-        beginPreload();
+        beginPreload(fullPreload);
         bootTimingsTraceLog.traceEnd(); // BeginPreload
         bootTimingsTraceLog.traceBegin("PreloadClasses");
         preloadClasses();
         bootTimingsTraceLog.traceEnd(); // PreloadClasses
         bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
         cacheNonBootClasspathClassLoaders();
         bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
         bootTimingsTraceLog.traceBegin("PreloadResources");
         preloadResources();
         bootTimingsTraceLog.traceEnd(); // PreloadResources
@@ -151,46 +151,46 @@ public class ZygoteInit {
         nativePreloadAppProcessHALs();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
         maybePreloadGraphicsDriver();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         preloadSharedLibraries();
         preloadTextResources();
         // Ask the WebViewFactory to do any initialization that must run in the zygote process,
         // for memory sharing purposes.
         WebViewFactory.prepareWebViewInZygote();
-        endPreload();
+        endPreload(fullPreload);
         warmUpJcaProviders();
         Log.d(TAG, "end preload");
 
         sPreloadComplete = true;
     }
 
     static void preload(TimingsTraceLog bootTimingsTraceLog) {
         preload(bootTimingsTraceLog, true);
     }
 
     static void lazyPreload() {
         Preconditions.checkState(!sPreloadComplete);
         Log.i(TAG, "Lazily preloading resources.");
 
         preload(new TimingsTraceLog("ZygoteInitTiming_lazy", Trace.TRACE_TAG_DALVIK));
     }
 
-    private static void beginPreload() {
+    private static void beginPreload(boolean fullPreload) {
         Log.i(TAG, "Calling ZygoteHooks.beginPreload()");
 
-        ZygoteHooks.onBeginPreload();
+        ZygoteHooks.onBeginPreload(fullPreload);
     }
 
-    private static void endPreload() {
-        ZygoteHooks.onEndPreload();
+    private static void endPreload(boolean fullPreload) {
+        ZygoteHooks.onEndPreload(fullPreload);
 
         Log.i(TAG, "Called ZygoteHooks.endPreload()");
     }
 
     private static void preloadSharedLibraries() {
         Log.i(TAG, "Preloading shared libraries...");
         System.loadLibrary("android");
         System.loadLibrary("compiler_rt");
         System.loadLibrary("jnigraphics");
     }

commit 65f68d260091ae5eccd513612201c4e1d22dd010
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-14 14:28:27-0400

    disable OpenGL preloading for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index b07173d50b9d1a39fb5864e6178b202bd1b97747..d1f7ca14501e11d15182b24bf8bb3d8e7f07f046 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -143,23 +143,25 @@ public class ZygoteInit {
         bootTimingsTraceLog.traceEnd(); // PreloadClasses
         bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
         cacheNonBootClasspathClassLoaders();
         bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
         bootTimingsTraceLog.traceBegin("PreloadResources");
         preloadResources();
         bootTimingsTraceLog.traceEnd(); // PreloadResources
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
         nativePreloadAppProcessHALs();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
-        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
-        maybePreloadGraphicsDriver();
-        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
+        if (fullPreload) {
+            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
+            maybePreloadGraphicsDriver();
+            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
+        }
         preloadSharedLibraries();
         preloadTextResources();
         // Ask the WebViewFactory to do any initialization that must run in the zygote process,
         // for memory sharing purposes.
         WebViewFactory.prepareWebViewInZygote();
         endPreload(fullPreload);
         warmUpJcaProviders();
         Log.d(TAG, "end preload");
 
         sPreloadComplete = true;

commit 0f169855b7b89686d86cfe2bfb8173f4d1e6b197
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2021-10-16 18:41:25-0400

    Revert "disable OpenGL preloading for exec spawning"
    
    This reverts commit 5a8d91b5fac0a1ae597de359128e0706776ce3a7.
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index d1f7ca14501e11d15182b24bf8bb3d8e7f07f046..b07173d50b9d1a39fb5864e6178b202bd1b97747 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -143,25 +143,23 @@ public class ZygoteInit {
         bootTimingsTraceLog.traceEnd(); // PreloadClasses
         bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
         cacheNonBootClasspathClassLoaders();
         bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
         bootTimingsTraceLog.traceBegin("PreloadResources");
         preloadResources();
         bootTimingsTraceLog.traceEnd(); // PreloadResources
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
         nativePreloadAppProcessHALs();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
-        if (fullPreload) {
-            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
-            maybePreloadGraphicsDriver();
-            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
-        }
+        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
+        maybePreloadGraphicsDriver();
+        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         preloadSharedLibraries();
         preloadTextResources();
         // Ask the WebViewFactory to do any initialization that must run in the zygote process,
         // for memory sharing purposes.
         WebViewFactory.prepareWebViewInZygote();
         endPreload(fullPreload);
         warmUpJcaProviders();
         Log.d(TAG, "end preload");
 
         sPreloadComplete = true;

commit fd0a060c05eb12b611a2212c4dc99430d24b0c82
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-14 14:28:52-0400

    disable resource preloading for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index b07173d50b9d1a39fb5864e6178b202bd1b97747..dbb1fb83f62d12556c15f7e0a13f262e3c550ac6 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -137,23 +137,25 @@ public class ZygoteInit {
         Log.d(TAG, "begin preload");
         bootTimingsTraceLog.traceBegin("BeginPreload");
         beginPreload(fullPreload);
         bootTimingsTraceLog.traceEnd(); // BeginPreload
         bootTimingsTraceLog.traceBegin("PreloadClasses");
         preloadClasses();
         bootTimingsTraceLog.traceEnd(); // PreloadClasses
         bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
         cacheNonBootClasspathClassLoaders();
         bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
-        bootTimingsTraceLog.traceBegin("PreloadResources");
-        preloadResources();
-        bootTimingsTraceLog.traceEnd(); // PreloadResources
+        if (fullPreload) {
+            bootTimingsTraceLog.traceBegin("PreloadResources");
+            preloadResources();
+            bootTimingsTraceLog.traceEnd(); // PreloadResources
+        }
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
         nativePreloadAppProcessHALs();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
         maybePreloadGraphicsDriver();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         preloadSharedLibraries();
         preloadTextResources();
         // Ask the WebViewFactory to do any initialization that must run in the zygote process,
         // for memory sharing purposes.

commit 02f95ce095e409164ab423588ce8231b9161bd4e
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-14 14:30:59-0400

    disable class preloading for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index dbb1fb83f62d12556c15f7e0a13f262e3c550ac6..2c681002eaf8934023c8dccd634b567c478c5bd4 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -131,23 +131,25 @@ public class ZygoteInit {
      * Cached classloader to use for the system server. Will only be populated in the system
      * server process.
      */
     private static ClassLoader sCachedSystemServerClassLoader = null;
 
     static void preload(TimingsTraceLog bootTimingsTraceLog, boolean fullPreload) {
         Log.d(TAG, "begin preload");
         bootTimingsTraceLog.traceBegin("BeginPreload");
         beginPreload(fullPreload);
         bootTimingsTraceLog.traceEnd(); // BeginPreload
-        bootTimingsTraceLog.traceBegin("PreloadClasses");
-        preloadClasses();
-        bootTimingsTraceLog.traceEnd(); // PreloadClasses
+        if (fullPreload) {
+            bootTimingsTraceLog.traceBegin("PreloadClasses");
+            preloadClasses();
+            bootTimingsTraceLog.traceEnd(); // PreloadClasses
+        }
         bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
         cacheNonBootClasspathClassLoaders();
         bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
         if (fullPreload) {
             bootTimingsTraceLog.traceBegin("PreloadResources");
             preloadResources();
             bootTimingsTraceLog.traceEnd(); // PreloadResources
         }
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
         nativePreloadAppProcessHALs();

commit 20f37549e8dfc54f9dadd4a516ec474c514ce06b
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-14 14:31:29-0400

    disable WebView reservation for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index 2c681002eaf8934023c8dccd634b567c478c5bd4..abef5cd171261febf118f741d6e1ba436b94353e 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -152,23 +152,25 @@ public class ZygoteInit {
             bootTimingsTraceLog.traceEnd(); // PreloadResources
         }
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
         nativePreloadAppProcessHALs();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
         maybePreloadGraphicsDriver();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         preloadSharedLibraries();
         preloadTextResources();
-        // Ask the WebViewFactory to do any initialization that must run in the zygote process,
-        // for memory sharing purposes.
-        WebViewFactory.prepareWebViewInZygote();
+        if (fullPreload) {
+            // Ask the WebViewFactory to do any initialization that must run in the zygote process,
+            // for memory sharing purposes.
+            WebViewFactory.prepareWebViewInZygote();
+        }
         endPreload(fullPreload);
         warmUpJcaProviders();
         Log.d(TAG, "end preload");
 
         sPreloadComplete = true;
     }
 
     static void preload(TimingsTraceLog bootTimingsTraceLog) {
         preload(bootTimingsTraceLog, true);
     }

commit 6faf09f97bc495b292341dd32c4b5183c0d0db78
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2019-05-14 14:34:32-0400

    disable JCA provider warm up for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 22 ++++++++++++----------
 1 file changed, 12 insertions(+), 10 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index abef5cd171261febf118f741d6e1ba436b94353e..851e5e1fb5b173696e5a210c274ef6997761235a 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -158,21 +158,21 @@ public class ZygoteInit {
         maybePreloadGraphicsDriver();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         preloadSharedLibraries();
         preloadTextResources();
         if (fullPreload) {
             // Ask the WebViewFactory to do any initialization that must run in the zygote process,
             // for memory sharing purposes.
             WebViewFactory.prepareWebViewInZygote();
         }
         endPreload(fullPreload);
-        warmUpJcaProviders();
+        warmUpJcaProviders(fullPreload);
         Log.d(TAG, "end preload");
 
         sPreloadComplete = true;
     }
 
     static void preload(TimingsTraceLog bootTimingsTraceLog) {
         preload(bootTimingsTraceLog, true);
     }
 
     static void lazyPreload() {
@@ -222,39 +222,41 @@ public class ZygoteInit {
         Hyphenator.init();
         TextView.preloadFontCache();
     }
 
     /**
      * Register AndroidKeyStoreProvider and warm up the providers that are already registered.
      *
      * By doing it here we avoid that each app does it when requesting a service from the provider
      * for the first time.
      */
-    private static void warmUpJcaProviders() {
+    private static void warmUpJcaProviders(boolean fullPreload) {
         long startTime = SystemClock.uptimeMillis();
         Trace.traceBegin(
                 Trace.TRACE_TAG_DALVIK, "Starting installation of AndroidKeyStoreProvider");
 
         AndroidKeyStoreProvider.install();
         Log.i(TAG, "Installed AndroidKeyStoreProvider in "
                 + (SystemClock.uptimeMillis() - startTime) + "ms.");
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
 
-        startTime = SystemClock.uptimeMillis();
-        Trace.traceBegin(
-                Trace.TRACE_TAG_DALVIK, "Starting warm up of JCA providers");
-        for (Provider p : Security.getProviders()) {
-            p.warmUpServiceProvision();
+        if (fullPreload) {
+            startTime = SystemClock.uptimeMillis();
+            Trace.traceBegin(
+                    Trace.TRACE_TAG_DALVIK, "Starting warm up of JCA providers");
+            for (Provider p : Security.getProviders()) {
+                p.warmUpServiceProvision();
+            }
+            Log.i(TAG, "Warmed up JCA providers in "
+                    + (SystemClock.uptimeMillis() - startTime) + "ms.");
+            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         }
-        Log.i(TAG, "Warmed up JCA providers in "
-                + (SystemClock.uptimeMillis() - startTime) + "ms.");
-        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
     }
 
     /**
      * Performs Zygote process initialization. Loads and initializes commonly used classes.
      *
      * Most classes only cause a few hundred bytes to be allocated, but a few will allocate a dozen
      * Kbytes (in one case, 500+K).
      */
     private static void preloadClasses() {
         final VMRuntime runtime = VMRuntime.getRuntime();

commit bdeb8ea9f5d54b9674394750c48648b8b05a5918
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2019-09-11 06:57:24-0400

    disable preloading classloaders for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index 851e5e1fb5b173696e5a210c274ef6997761235a..231b42ba64b961ad880cf65f465d38a77c7aa6d4 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -136,23 +136,25 @@ public class ZygoteInit {
     static void preload(TimingsTraceLog bootTimingsTraceLog, boolean fullPreload) {
         Log.d(TAG, "begin preload");
         bootTimingsTraceLog.traceBegin("BeginPreload");
         beginPreload(fullPreload);
         bootTimingsTraceLog.traceEnd(); // BeginPreload
         if (fullPreload) {
             bootTimingsTraceLog.traceBegin("PreloadClasses");
             preloadClasses();
             bootTimingsTraceLog.traceEnd(); // PreloadClasses
         }
-        bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
-        cacheNonBootClasspathClassLoaders();
-        bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
+        if (fullPreload) {
+            bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
+            cacheNonBootClasspathClassLoaders();
+            bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
+        }
         if (fullPreload) {
             bootTimingsTraceLog.traceBegin("PreloadResources");
             preloadResources();
             bootTimingsTraceLog.traceEnd(); // PreloadResources
         }
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
         nativePreloadAppProcessHALs();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
         maybePreloadGraphicsDriver();

commit 2a0f5e654e207a8d12766a10404b995642bf2051
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2019-09-11 06:58:51-0400

    disable preloading HALs for exec spawning
---
 core/java/com/android/internal/os/ZygoteInit.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index 231b42ba64b961ad880cf65f465d38a77c7aa6d4..1696d2135180ff7f94f34bbea24ddba05abb58ba 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -146,23 +146,25 @@ public class ZygoteInit {
         if (fullPreload) {
             bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
             cacheNonBootClasspathClassLoaders();
             bootTimingsTraceLog.traceEnd(); // CacheNonBootClasspathClassLoaders
         }
         if (fullPreload) {
             bootTimingsTraceLog.traceBegin("PreloadResources");
             preloadResources();
             bootTimingsTraceLog.traceEnd(); // PreloadResources
         }
-        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
-        nativePreloadAppProcessHALs();
-        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
+        if (fullPreload) {
+            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
+            nativePreloadAppProcessHALs();
+            Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
+        }
         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadGraphicsDriver");
         maybePreloadGraphicsDriver();
         Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
         preloadSharedLibraries();
         preloadTextResources();
         if (fullPreload) {
             // Ask the WebViewFactory to do any initialization that must run in the zygote process,
             // for memory sharing purposes.
             WebViewFactory.prepareWebViewInZygote();
         }

commit 4b5a3c48ef1f2ad36328eee5898e591f6a618863
Author: anupritaisno1 <www.anuprita804@gmail.com>
Date:   Fri 2020-10-30 22:26:09+0000

    pass through runtime flags for exec spawning and implement them in the child
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 core/java/com/android/internal/os/ExecInit.java    |  14 ++-
 core/java/com/android/internal/os/Zygote.java      |   9 ++
 .../com/android/internal/os/ZygoteConnection.java  |   2 +-
 core/jni/com_android_internal_os_Zygote.cpp        | 129 +++++++++++----------
 4 files changed, 89 insertions(+), 65 deletions(-)

diff --git a/core/java/com/android/internal/os/ExecInit.java b/core/java/com/android/internal/os/ExecInit.java
index 830e5b562a919bf599784358f3e4a267168e7fb1..749c67abf389dfd684972fab5b8e5b967c2634a0 100644
--- a/core/java/com/android/internal/os/ExecInit.java
+++ b/core/java/com/android/internal/os/ExecInit.java
@@ -24,57 +24,63 @@ public class ExecInit {
      * The first argument is the target SDK version for the app.
      *
      * The remaining arguments are passed to the runtime.
      *
      * @param args The command-line arguments.
      */
     public static void main(String[] args) {
         // Parse our mandatory argument.
         int targetSdkVersion = Integer.parseInt(args[0], 10);
 
+        // Parse the runtime_flags.
+        int runtimeFlags = Integer.parseInt(args[1], 10);
+
         // Mimic system Zygote preloading.
         ZygoteInit.preload(new TimingsTraceLog("ExecInitTiming",
                 Trace.TRACE_TAG_DALVIK), false);
 
         // Launch the application.
-        String[] runtimeArgs = new String[args.length - 1];
-        System.arraycopy(args, 1, runtimeArgs, 0, runtimeArgs.length);
+        String[] runtimeArgs = new String[args.length - 2];
+        System.arraycopy(args, 2, runtimeArgs, 0, runtimeArgs.length);
         Runnable r = execInit(targetSdkVersion, runtimeArgs);
 
+        Zygote.nativeHandleRuntimeFlags(runtimeFlags);
+
         r.run();
     }
 
     /**
      * Executes a runtime application with exec-based spawning.
      * This method never returns.
      *
      * @param niceName The nice name for the application, or null if none.
      * @param targetSdkVersion The target SDK version for the app.
      * @param args Arguments for {@link RuntimeInit#main}.
      */
     public static void execApplication(String niceName, int targetSdkVersion,
-            String instructionSet, String[] args) {
+            String instructionSet, int runtimeFlags, String[] args) {
         int niceArgs = niceName == null ? 0 : 1;
-        int baseArgs = 5 + niceArgs;
+        int baseArgs = 6 + niceArgs;
         String[] argv = new String[baseArgs + args.length];
         if (VMRuntime.is64BitInstructionSet(instructionSet)) {
             argv[0] = "/system/bin/app_process64";
         } else {
             argv[0] = "/system/bin/app_process32";
         }
         argv[1] = "/system/bin";
         argv[2] = "--application";
         if (niceName != null) {
             argv[3] = "--nice-name=" + niceName;
         }
         argv[3 + niceArgs] = "com.android.internal.os.ExecInit";
         argv[4 + niceArgs] = Integer.toString(targetSdkVersion);
+        argv[5 + niceArgs] = Integer.toString(runtimeFlags);
         System.arraycopy(args, 0, argv, baseArgs, args.length);
 
         WrapperInit.preserveCapabilities();
         try {
             Os.execv(argv[0], argv);
         } catch (ErrnoException e) {
             throw new RuntimeException(e);
         }
     }
 
diff --git a/core/java/com/android/internal/os/Zygote.java b/core/java/com/android/internal/os/Zygote.java
index e4e28a926ed6d03df12981eff2a5ab518a149423..42242c3d5481b4da61ab8839c42a777d935fdd61 100644
--- a/core/java/com/android/internal/os/Zygote.java
+++ b/core/java/com/android/internal/os/Zygote.java
@@ -1161,11 +1161,20 @@ public final class Zygote {
      * fully-feature Memory Tagging, rather than the static Tagged Pointers.
      */
     public static native boolean nativeSupportsTaggedPointers();
 
     /**
      * Returns the current native tagging level, as one of the
      * MEMORY_TAG_LEVEL_* constants. Returns zero if no tagging is present, or
      * we failed to determine the level.
      */
     public static native int nativeCurrentTaggingLevel();
+
+    /**
+     * Used on GrapheneOS to set up runtime flags
+     *
+     * @param runtimeFlags flags to be passed to the native method
+     *
+     * @hide
+     */
+    public static native void nativeHandleRuntimeFlags(int runtimeFlags);
 }
diff --git a/core/java/com/android/internal/os/ZygoteConnection.java b/core/java/com/android/internal/os/ZygoteConnection.java
index 27518dd4cdce45c6b54f3deb5d018a6706a061d8..a8d9400c79923848f82e4b2371638584977d8d0b 100644
--- a/core/java/com/android/internal/os/ZygoteConnection.java
+++ b/core/java/com/android/internal/os/ZygoteConnection.java
@@ -532,21 +532,21 @@ class ZygoteConnection {
                     VMRuntime.getCurrentInstructionSet(),
                     pipeFd, parsedArgs.mRemainingArgs);
 
             // Should not get here.
             throw new IllegalStateException("WrapperInit.execApplication unexpectedly returned");
         } else {
             if (!isZygote) {
                 if (SystemProperties.getBoolean("sys.spawn.exec", true) &&
                         (parsedArgs.mRuntimeFlags & ApplicationInfo.FLAG_DEBUGGABLE) == 0) {
                     ExecInit.execApplication(parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,
-                            VMRuntime.getCurrentInstructionSet(), parsedArgs.mRemainingArgs);
+                            VMRuntime.getCurrentInstructionSet(), parsedArgs.mRuntimeFlags, parsedArgs.mRemainingArgs);
 
                     // Should not get here.
                     throw new IllegalStateException("ExecInit.execApplication unexpectedly returned");
                 }
                 return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,
                         parsedArgs.mDisabledCompatChanges,
                         parsedArgs.mRemainingArgs, null /* classLoader */);
             } else {
                 return ZygoteInit.childZygoteInit(
                         parsedArgs.mRemainingArgs  /* classLoader */);
diff --git a/core/jni/com_android_internal_os_Zygote.cpp b/core/jni/com_android_internal_os_Zygote.cpp
index bed0aae074a4c274bea18d4491322cd77d22639f..69f615a8e0f4d680279e456d4dcab4136cc29edb 100644
--- a/core/jni/com_android_internal_os_Zygote.cpp
+++ b/core/jni/com_android_internal_os_Zygote.cpp
@@ -1545,20 +1545,83 @@ static void BindMountStorageDirs(JNIEnv* env, jobjectArray pkg_data_info_list,
 
   // Bind mount each package obb directory
   for (int i = 0; i < size; i += 3) {
     jstring package_str = (jstring) (env->GetObjectArrayElement(pkg_data_info_list, i));
     std::string packageName = extract_fn(package_str).value();
     BindMountStorageToLowerFs(user_id, uid, "Android/obb", packageName.c_str(), fail_fn);
     BindMountStorageToLowerFs(user_id, uid, "Android/data", packageName.c_str(), fail_fn);
   }
 }
 
+static void HandleRuntimeFlags(JNIEnv* env, jint& runtime_flags) {
+    // Set process properties to enable debugging if required.
+    if ((runtime_flags & RuntimeFlags::DEBUG_ENABLE_JDWP) != 0) {
+        EnableDebugger();
+    }
+    if ((runtime_flags & RuntimeFlags::PROFILE_FROM_SHELL) != 0) {
+        // simpleperf needs the process to be dumpable to profile it.
+        if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) == -1) {
+            ALOGE("prctl(PR_SET_DUMPABLE) failed: %s", strerror(errno));
+            RuntimeAbort(env, __LINE__, "prctl(PR_SET_DUMPABLE, 1) failed");
+        }
+    }
+
+    HeapTaggingLevel heap_tagging_level;
+    switch (runtime_flags & RuntimeFlags::MEMORY_TAG_LEVEL_MASK) {
+        case RuntimeFlags::MEMORY_TAG_LEVEL_TBI:
+            heap_tagging_level = M_HEAP_TAGGING_LEVEL_TBI;
+            break;
+        case RuntimeFlags::MEMORY_TAG_LEVEL_ASYNC:
+            heap_tagging_level = M_HEAP_TAGGING_LEVEL_ASYNC;
+            break;
+        case RuntimeFlags::MEMORY_TAG_LEVEL_SYNC:
+            heap_tagging_level = M_HEAP_TAGGING_LEVEL_SYNC;
+            break;
+        default:
+            heap_tagging_level = M_HEAP_TAGGING_LEVEL_NONE;
+            break;
+    }
+    mallopt(M_BIONIC_SET_HEAP_TAGGING_LEVEL, heap_tagging_level);
+
+    // Now that we've used the flag, clear it so that we don't pass unknown flags to the ART
+    // runtime.
+    runtime_flags &= ~RuntimeFlags::MEMORY_TAG_LEVEL_MASK;
+
+    // Avoid heap zero initialization for applications without MTE. Zero init may
+    // cause app compat problems, use more memory, or reduce performance. While it
+    // would be nice to have them for apps, we will have to wait until they are
+    // proven out, have more efficient hardware, and/or apply them only to new
+    // applications.
+    if (!(runtime_flags & RuntimeFlags::NATIVE_HEAP_ZERO_INIT)) {
+        mallopt(M_BIONIC_ZERO_INIT, 0);
+    }
+
+    // Now that we've used the flag, clear it so that we don't pass unknown flags to the ART
+    // runtime.
+    runtime_flags &= ~RuntimeFlags::NATIVE_HEAP_ZERO_INIT;
+
+    bool forceEnableGwpAsan = false;
+    switch (runtime_flags & RuntimeFlags::GWP_ASAN_LEVEL_MASK) {
+        default:
+        case RuntimeFlags::GWP_ASAN_LEVEL_NEVER:
+            break;
+        case RuntimeFlags::GWP_ASAN_LEVEL_ALWAYS:
+            forceEnableGwpAsan = true;
+            [[fallthrough]];
+        case RuntimeFlags::GWP_ASAN_LEVEL_LOTTERY:
+            android_mallopt(M_INITIALIZE_GWP_ASAN, &forceEnableGwpAsan, sizeof(forceEnableGwpAsan));
+    }
+    // Now that we've used the flag, clear it so that we don't pass unknown flags to the ART
+    // runtime.
+    runtime_flags &= ~RuntimeFlags::GWP_ASAN_LEVEL_MASK;
+}
+
 // Utility routine to specialize a zygote child process.
 static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags,
                              jobjectArray rlimits, jlong permitted_capabilities,
                              jlong effective_capabilities, jint mount_external,
                              jstring managed_se_info, jstring managed_nice_name,
                              bool is_system_server, bool is_child_zygote,
                              jstring managed_instruction_set, jstring managed_app_data_dir,
                              bool is_top_app, jobjectArray pkg_data_info_list,
                              jobjectArray allowlisted_data_info_list, bool mount_data_dirs,
                              bool mount_storage_dirs) {
@@ -1672,80 +1735,21 @@ static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids,
         RuntimeAbort(env, __LINE__, "prctl(PR_GET_DUMPABLE) failed");
     }
 
     if (dumpable == 2 && uid >= AID_APP) {
         if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) == -1) {
             ALOGE("prctl(PR_SET_DUMPABLE, 0) failed: %s", strerror(errno));
             RuntimeAbort(env, __LINE__, "prctl(PR_SET_DUMPABLE, 0) failed");
         }
     }
 
-    // Set process properties to enable debugging if required.
-    if ((runtime_flags & RuntimeFlags::DEBUG_ENABLE_JDWP) != 0) {
-        EnableDebugger();
-    }
-    if ((runtime_flags & RuntimeFlags::PROFILE_FROM_SHELL) != 0) {
-        // simpleperf needs the process to be dumpable to profile it.
-        if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) == -1) {
-            ALOGE("prctl(PR_SET_DUMPABLE) failed: %s", strerror(errno));
-            RuntimeAbort(env, __LINE__, "prctl(PR_SET_DUMPABLE, 1) failed");
-        }
-    }
-
-    HeapTaggingLevel heap_tagging_level;
-    switch (runtime_flags & RuntimeFlags::MEMORY_TAG_LEVEL_MASK) {
-        case RuntimeFlags::MEMORY_TAG_LEVEL_TBI:
-            heap_tagging_level = M_HEAP_TAGGING_LEVEL_TBI;
-            break;
-        case RuntimeFlags::MEMORY_TAG_LEVEL_ASYNC:
-            heap_tagging_level = M_HEAP_TAGGING_LEVEL_ASYNC;
-            break;
-        case RuntimeFlags::MEMORY_TAG_LEVEL_SYNC:
-            heap_tagging_level = M_HEAP_TAGGING_LEVEL_SYNC;
-            break;
-        default:
-            heap_tagging_level = M_HEAP_TAGGING_LEVEL_NONE;
-            break;
-    }
-    mallopt(M_BIONIC_SET_HEAP_TAGGING_LEVEL, heap_tagging_level);
-
-    // Now that we've used the flag, clear it so that we don't pass unknown flags to the ART
-    // runtime.
-    runtime_flags &= ~RuntimeFlags::MEMORY_TAG_LEVEL_MASK;
-
-    // Avoid heap zero initialization for applications without MTE. Zero init may
-    // cause app compat problems, use more memory, or reduce performance. While it
-    // would be nice to have them for apps, we will have to wait until they are
-    // proven out, have more efficient hardware, and/or apply them only to new
-    // applications.
-    if (!(runtime_flags & RuntimeFlags::NATIVE_HEAP_ZERO_INIT)) {
-        mallopt(M_BIONIC_ZERO_INIT, 0);
-    }
-
-    // Now that we've used the flag, clear it so that we don't pass unknown flags to the ART
-    // runtime.
-    runtime_flags &= ~RuntimeFlags::NATIVE_HEAP_ZERO_INIT;
-
-    bool forceEnableGwpAsan = false;
-    switch (runtime_flags & RuntimeFlags::GWP_ASAN_LEVEL_MASK) {
-        default:
-        case RuntimeFlags::GWP_ASAN_LEVEL_NEVER:
-            break;
-        case RuntimeFlags::GWP_ASAN_LEVEL_ALWAYS:
-            forceEnableGwpAsan = true;
-            [[fallthrough]];
-        case RuntimeFlags::GWP_ASAN_LEVEL_LOTTERY:
-            android_mallopt(M_INITIALIZE_GWP_ASAN, &forceEnableGwpAsan, sizeof(forceEnableGwpAsan));
-    }
-    // Now that we've used the flag, clear it so that we don't pass unknown flags to the ART
-    // runtime.
-    runtime_flags &= ~RuntimeFlags::GWP_ASAN_LEVEL_MASK;
+    HandleRuntimeFlags(env, runtime_flags);
 
     if (NeedsNoRandomizeWorkaround()) {
         // Work around ARM kernel ASLR lossage (http://b/5817320).
         int old_personality = personality(0xffffffff);
         int new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);
         if (new_personality == -1) {
             ALOGW("personality(%d) failed: %s", new_personality, strerror(errno));
         }
     }
 
@@ -2635,20 +2639,24 @@ static void com_android_internal_os_Zygote_nativeAllowFilesOpenedByPreload(JNIEn
     auto fail_fn = std::bind(zygote::ZygoteFailure, env, "zygote", nullptr, _1);
     std::unique_ptr<std::set<int>> current_fds = GetOpenFds(fail_fn);
     auto difference = std::make_unique<std::set<int>>();
     std::set_difference(current_fds->begin(), current_fds->end(), gPreloadFds->begin(),
                         gPreloadFds->end(), std::inserter(*difference, difference->end()));
     delete gPreloadFds;
     gPreloadFds = difference.release();
     gPreloadFdsExtracted = true;
 }
 
+static void nativeHandleRuntimeFlagsWrapper(JNIEnv* env, jclass, jint runtime_flags) {
+    HandleRuntimeFlags(env, runtime_flags);
+}
+
 static const JNINativeMethod gMethods[] = {
         {"nativeForkAndSpecialize",
          "(II[II[[IILjava/lang/String;Ljava/lang/String;[I[IZLjava/lang/String;Ljava/lang/"
          "String;Z[Ljava/lang/String;[Ljava/lang/String;ZZ)I",
          (void*)com_android_internal_os_Zygote_nativeForkAndSpecialize},
         {"nativeForkSystemServer", "(II[II[[IJJ)I",
          (void*)com_android_internal_os_Zygote_nativeForkSystemServer},
         {"nativeAllowFileAcrossFork", "(Ljava/lang/String;)V",
          (void*)com_android_internal_os_Zygote_nativeAllowFileAcrossFork},
         {"nativePreApplicationInit", "()V",
@@ -2687,20 +2695,21 @@ static const JNINativeMethod gMethods[] = {
         {"nativeSupportsMemoryTagging", "()Z",
          (void*)com_android_internal_os_Zygote_nativeSupportsMemoryTagging},
         {"nativeSupportsTaggedPointers", "()Z",
          (void*)com_android_internal_os_Zygote_nativeSupportsTaggedPointers},
         {"nativeCurrentTaggingLevel", "()I",
          (void*)com_android_internal_os_Zygote_nativeCurrentTaggingLevel},
         {"nativeMarkOpenedFilesBeforePreload", "()V",
          (void*)com_android_internal_os_Zygote_nativeMarkOpenedFilesBeforePreload},
         {"nativeAllowFilesOpenedByPreload", "()V",
          (void*)com_android_internal_os_Zygote_nativeAllowFilesOpenedByPreload},
+        {"nativeHandleRuntimeFlags", "(I)V", (void*)nativeHandleRuntimeFlagsWrapper},
 };
 
 int register_com_android_internal_os_Zygote(JNIEnv* env) {
   gZygoteClass = MakeGlobalRefOrDie(env, FindClassOrDie(env, kZygoteClassName));
   gCallPostForkSystemServerHooks = GetStaticMethodIDOrDie(env, gZygoteClass,
                                                           "callPostForkSystemServerHooks",
                                                           "(I)V");
   gCallPostForkChildHooks = GetStaticMethodIDOrDie(env, gZygoteClass, "callPostForkChildHooks",
                                                    "(IZZLjava/lang/String;)V");
 

commit ed1c07b5b284adde6d4562e8acad76ab1f422173
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2017-01-15 18:18:09-0500

    add option to scramble PIN
    
    Originally adapted from work by Adnan <adnan@cyngn.com> for CyanogenMod
    but it has substantially diverged from the original code.
    
    Change-Id: I416895210128cc0fc174201c29dc1e4dc9d14eb6
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 core/java/android/provider/Settings.java           |  7 +++++
 .../src/com/android/keyguard/KeyguardPINView.java  | 29 +++++++++++++++++++++
 .../src/com/android/keyguard/NumPadKey.java        | 30 +++++++++++++++-------
 3 files changed, 57 insertions(+), 9 deletions(-)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index a8744b512332f8decf8437913a6df2fc1c72568f..d4a333d881f96758fde2a0bfdca41afa49441729 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -4218,20 +4218,27 @@ public final class Settings {
 
         /**
          * @deprecated Use
          * {@link android.provider.Settings.Secure#LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED}
          * instead
          */
         @Deprecated
         public static final String LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED =
             "lock_pattern_tactile_feedback_enabled";
 
+        /**
+         * Whether to scramble a pin unlock layout
+         * @hide
+         */
+        public static final String SCRAMBLE_PIN_LAYOUT =
+            "lockscreen_scramble_pin_layout";
+
         /**
          * A formatted string of the next alarm that is set, or the empty string
          * if there is no alarm set.
          *
          * @deprecated Use {@link android.app.AlarmManager#getNextAlarmClock()}.
          */
         @Deprecated
         @Readable
         public static final String NEXT_ALARM_FORMATTED = "next_alarm_formatted";
 
diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java b/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
index 1efda7edee2f846011c904c8980f6eca0bd89886..8b0d565da5ea8b61615c31cdbdb72c17be9ac2cc 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
@@ -14,27 +14,33 @@
  * limitations under the License.
  */
 
 package com.android.keyguard;
 
 import static com.android.systemui.statusbar.policy.DevicePostureController.DEVICE_POSTURE_HALF_OPENED;
 import static com.android.systemui.statusbar.policy.DevicePostureController.DEVICE_POSTURE_UNKNOWN;
 
 import android.content.Context;
 import android.content.res.Configuration;
+import android.provider.Settings;
 import android.util.AttributeSet;
 import android.view.View;
 import android.view.animation.AnimationUtils;
 
 import androidx.constraintlayout.widget.ConstraintLayout;
 import androidx.constraintlayout.widget.ConstraintSet;
 
+import java.security.SecureRandom;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
 import com.android.internal.jank.InteractionJankMonitor;
 import com.android.settingslib.animation.AppearAnimationUtils;
 import com.android.settingslib.animation.DisappearAnimationUtils;
 import com.android.systemui.R;
 import com.android.systemui.statusbar.policy.DevicePostureController.DevicePostureInt;
 
 /**
  * Displays a PIN pad for unlocking.
  */
 public class KeyguardPINView extends KeyguardPinBasedInputView {
@@ -152,20 +158,43 @@ public class KeyguardPINView extends KeyguardPinBasedInputView {
                         findViewById(R.id.key7), findViewById(R.id.key8),
                         findViewById(R.id.key9)
                 },
                 new View[]{
                         findViewById(R.id.delete_button), findViewById(R.id.key0),
                         findViewById(R.id.key_enter)
                 },
                 new View[]{
                         null, mEcaView, null
                 }};
+
+        boolean scramblePin = Settings.System.getInt(getContext().getContentResolver(),
+                Settings.System.SCRAMBLE_PIN_LAYOUT, 0) == 1;
+
+        if (scramblePin) {
+            List<Integer> digits = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0);
+            Collections.shuffle(digits, new SecureRandom());
+            LinearLayout container = (LinearLayout) findViewById(R.id.pin_container);
+            int finished = 0;
+            for (int i = 0; i < container.getChildCount(); i++) {
+                if (container.getChildAt(i) instanceof LinearLayout) {
+                    LinearLayout nestedLayout = ((LinearLayout) container.getChildAt(i));
+                    for (int j = 0; j < nestedLayout.getChildCount(); j++){
+                        View view = nestedLayout.getChildAt(j);
+                        if (view.getClass() == NumPadKey.class) {
+                            NumPadKey key = (NumPadKey) view;
+                            key.setDigit(digits.get(finished));
+                            finished++;
+                        }
+                    }
+                }
+            }
+        }
     }
 
     @Override
     public int getWrongPasswordStringId() {
         return R.string.kg_wrong_pin;
     }
 
     @Override
     public void startAppearAnimation() {
         enableClipping(false);
diff --git a/packages/SystemUI/src/com/android/keyguard/NumPadKey.java b/packages/SystemUI/src/com/android/keyguard/NumPadKey.java
index e79ea9a44843e313ceabba47b53b1df1eb714c11..53191828dce6d87e54d4db1d036d0dbbb4be8109 100644
--- a/packages/SystemUI/src/com/android/keyguard/NumPadKey.java
+++ b/packages/SystemUI/src/com/android/keyguard/NumPadKey.java
@@ -15,20 +15,21 @@
  */
 package com.android.keyguard;
 
 import android.content.Context;
 import android.content.res.Configuration;
 import android.content.res.TypedArray;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.RippleDrawable;
 import android.os.PowerManager;
 import android.os.SystemClock;
+import android.provider.Settings;
 import android.util.AttributeSet;
 import android.view.HapticFeedbackConstants;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.accessibility.AccessibilityManager;
 import android.widget.TextView;
 
 import androidx.annotation.Nullable;
@@ -107,44 +108,55 @@ public class NumPadKey extends ViewGroup {
         mLockPatternUtils = new LockPatternUtils(context);
         mPM = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
         LayoutInflater inflater = (LayoutInflater) getContext().getSystemService(
                 Context.LAYOUT_INFLATER_SERVICE);
         inflater.inflate(contentResource, this, true);
 
         mDigitText = (TextView) findViewById(R.id.digit_text);
         mDigitText.setText(Integer.toString(mDigit));
         mKlondikeText = (TextView) findViewById(R.id.klondike_text);
 
+        updateText();
+
+        Drawable background = getBackground();
+        if (background instanceof RippleDrawable) {
+            mAnimator = new NumPadAnimator(context, (RippleDrawable) background,
+                    R.style.NumPadKey);
+        } else {
+            mAnimator = null;
+        }
+    }
+
+    private void updateText() {
+        boolean scramblePin = Settings.System.getInt(getContext().getContentResolver(),
+                Settings.System.SCRAMBLE_PIN_LAYOUT, 0) == 1;
         if (mDigit >= 0) {
+            mDigitText.setText(Integer.toString(mDigit));
             if (sKlondike == null) {
                 sKlondike = getResources().getStringArray(R.array.lockscreen_num_pad_klondike);
             }
             if (sKlondike != null && sKlondike.length > mDigit) {
                 String klondike = sKlondike[mDigit];
                 final int len = klondike.length();
-                if (len > 0) {
+                if (len > 0 || scramblePin) {
                     mKlondikeText.setText(klondike);
                 } else if (mKlondikeText.getVisibility() != View.GONE) {
                     mKlondikeText.setVisibility(View.INVISIBLE);
                 }
             }
         }
-
         setContentDescription(mDigitText.getText().toString());
+    }
 
-        Drawable background = getBackground();
-        if (background instanceof RippleDrawable) {
-            mAnimator = new NumPadAnimator(context, (RippleDrawable) background,
-                    R.style.NumPadKey);
-        } else {
-            mAnimator = null;
-        }
+    public void setDigit(int digit) {
+        mDigit = digit;
+        updateText();
     }
 
     @Override
     protected void onConfigurationChanged(Configuration newConfig) {
         mOrientation = newConfig.orientation;
     }
 
     /**
      * Reload colors from resources.
      **/

commit 06161a2ed6346de2d5744e9a1804ad681c0a30cb
Author: Renlord <me@renlord.com>
Date:   Tue 2020-03-03 22:55:39+1100

    use per-user settings secure table for lockscreen pin scrambling layout option
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
    Change-Id: I484405a4f2f30d23f4143597cb944e515ce6eb43
---
 core/java/android/provider/Settings.java                   | 14 +++++++-------
 .../SystemUI/src/com/android/keyguard/KeyguardPINView.java |  6 ++++--
 packages/SystemUI/src/com/android/keyguard/NumPadKey.java  |  5 +++--
 3 files changed, 14 insertions(+), 11 deletions(-)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index d4a333d881f96758fde2a0bfdca41afa49441729..8328e159b59048755a2fbd1ce58b9ff023064352 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -4218,27 +4218,20 @@ public final class Settings {
 
         /**
          * @deprecated Use
          * {@link android.provider.Settings.Secure#LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED}
          * instead
          */
         @Deprecated
         public static final String LOCK_PATTERN_TACTILE_FEEDBACK_ENABLED =
             "lock_pattern_tactile_feedback_enabled";
 
-        /**
-         * Whether to scramble a pin unlock layout
-         * @hide
-         */
-        public static final String SCRAMBLE_PIN_LAYOUT =
-            "lockscreen_scramble_pin_layout";
-
         /**
          * A formatted string of the next alarm that is set, or the empty string
          * if there is no alarm set.
          *
          * @deprecated Use {@link android.app.AlarmManager#getNextAlarmClock()}.
          */
         @Deprecated
         @Readable
         public static final String NEXT_ALARM_FORMATTED = "next_alarm_formatted";
 
@@ -9972,20 +9965,27 @@ public final class Settings {
         @Readable
         public static final String TAP_GESTURE = "tap_gesture";
 
         /**
          * Controls whether the people strip is enabled.
          * @hide
          */
         @Readable
         public static final String PEOPLE_STRIP = "people_strip";
 
+        /**
+         * Whether to scramble a pin unlock layout
+         * @hide
+         */
+        public static final String SCRAMBLE_PIN_LAYOUT =
+            "lockscreen_scramble_pin_layout";
+
         /**
          * Whether or not to enable media resumption
          * When enabled, media controls in quick settings will populate on boot and persist if
          * resumable via a MediaBrowserService.
          * @see Settings.Global#SHOW_MEDIA_ON_QUICK_SETTINGS
          * @hide
          */
         @Readable
         public static final String MEDIA_CONTROLS_RESUME = "qs_media_resumption";
 
diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java b/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
index 8b0d565da5ea8b61615c31cdbdb72c17be9ac2cc..199c9f8946df97065a1f4753b3b7a67516296d31 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
@@ -33,20 +33,22 @@ import java.security.SecureRandom;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 import com.android.internal.jank.InteractionJankMonitor;
 import com.android.settingslib.animation.AppearAnimationUtils;
 import com.android.settingslib.animation.DisappearAnimationUtils;
 import com.android.systemui.R;
 import com.android.systemui.statusbar.policy.DevicePostureController.DevicePostureInt;
 
+import android.app.ActivityManager;
+
 /**
  * Displays a PIN pad for unlocking.
  */
 public class KeyguardPINView extends KeyguardPinBasedInputView {
 
     private final AppearAnimationUtils mAppearAnimationUtils;
     private final DisappearAnimationUtils mDisappearAnimationUtils;
     private final DisappearAnimationUtils mDisappearAnimationUtilsLocked;
     private ConstraintLayout mContainer;
     private int mDisappearYTranslation;
@@ -159,22 +161,22 @@ public class KeyguardPINView extends KeyguardPinBasedInputView {
                         findViewById(R.id.key9)
                 },
                 new View[]{
                         findViewById(R.id.delete_button), findViewById(R.id.key0),
                         findViewById(R.id.key_enter)
                 },
                 new View[]{
                         null, mEcaView, null
                 }};
 
-        boolean scramblePin = Settings.System.getInt(getContext().getContentResolver(),
-                Settings.System.SCRAMBLE_PIN_LAYOUT, 0) == 1;
+        boolean scramblePin = Settings.Secure.getIntForUser(mContext.getContentResolver(),
+                Settings.Secure.SCRAMBLE_PIN_LAYOUT, 0, ActivityManager.getCurrentUser()) == 1;
 
         if (scramblePin) {
             List<Integer> digits = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0);
             Collections.shuffle(digits, new SecureRandom());
             LinearLayout container = (LinearLayout) findViewById(R.id.pin_container);
             int finished = 0;
             for (int i = 0; i < container.getChildCount(); i++) {
                 if (container.getChildAt(i) instanceof LinearLayout) {
                     LinearLayout nestedLayout = ((LinearLayout) container.getChildAt(i));
                     for (int j = 0; j < nestedLayout.getChildCount(); j++){
diff --git a/packages/SystemUI/src/com/android/keyguard/NumPadKey.java b/packages/SystemUI/src/com/android/keyguard/NumPadKey.java
index 53191828dce6d87e54d4db1d036d0dbbb4be8109..9b2783f51d5454ba078040fec493579b9744f8a9 100644
--- a/packages/SystemUI/src/com/android/keyguard/NumPadKey.java
+++ b/packages/SystemUI/src/com/android/keyguard/NumPadKey.java
@@ -8,20 +8,21 @@
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.android.keyguard;
 
+import android.app.ActivityManager;
 import android.content.Context;
 import android.content.res.Configuration;
 import android.content.res.TypedArray;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.RippleDrawable;
 import android.os.PowerManager;
 import android.os.SystemClock;
 import android.provider.Settings;
 import android.util.AttributeSet;
 import android.view.HapticFeedbackConstants;
@@ -120,22 +121,22 @@ public class NumPadKey extends ViewGroup {
         Drawable background = getBackground();
         if (background instanceof RippleDrawable) {
             mAnimator = new NumPadAnimator(context, (RippleDrawable) background,
                     R.style.NumPadKey);
         } else {
             mAnimator = null;
         }
     }
 
     private void updateText() {
-        boolean scramblePin = Settings.System.getInt(getContext().getContentResolver(),
-                Settings.System.SCRAMBLE_PIN_LAYOUT, 0) == 1;
+        boolean scramblePin = Settings.Secure. getIntForUser(mContext.getContentResolver(),
+                Settings.Secure.SCRAMBLE_PIN_LAYOUT, 0, ActivityManager.getCurrentUser()) == 1;
         if (mDigit >= 0) {
             mDigitText.setText(Integer.toString(mDigit));
             if (sKlondike == null) {
                 sKlondike = getResources().getStringArray(R.array.lockscreen_num_pad_klondike);
             }
             if (sKlondike != null && sKlondike.length > mDigit) {
                 String klondike = sKlondike[mDigit];
                 final int len = klondike.length();
                 if (len > 0 || scramblePin) {
                     mKlondikeText.setText(klondike);

commit f338a85a5e0982838d8b35e6551e2417d84266c1
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2021-10-16 19:44:59-0400

    constify JNINativeMethod tables
---
 cmds/hid/jni/com_android_commands_hid_Device.cpp           | 2 +-
 cmds/uinput/jni/com_android_commands_uinput_Device.cpp     | 2 +-
 core/jni/android_app_ActivityThread.cpp                    | 2 +-
 core/jni/android_os_HidlMemory.cpp                         | 2 +-
 core/jni/android_os_HwBinder.cpp                           | 2 +-
 core/jni/android_os_HwBlob.cpp                             | 2 +-
 core/jni/android_os_HwParcel.cpp                           | 2 +-
 core/jni/android_os_HwRemoteBinder.cpp                     | 2 +-
 libs/hwui/jni/android_graphics_DisplayListCanvas.cpp       | 2 +-
 media/jni/android_media_ImageWriter.cpp                    | 4 ++--
 media/jni/android_media_MediaSync.cpp                      | 2 +-
 media/jni/soundpool/android_media_SoundPool.cpp            | 2 +-
 services/core/jni/com_android_server_UsbMidiDevice.cpp     | 2 +-
 services/core/jni/com_android_server_tv_TvUinputBridge.cpp | 2 +-
 14 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/cmds/hid/jni/com_android_commands_hid_Device.cpp b/cmds/hid/jni/com_android_commands_hid_Device.cpp
index 2cda57dd67e9875c03ae5de7be3412a3363592a6..7613651e75c43a2650d4d45974e17e15b288c04a 100644
--- a/cmds/hid/jni/com_android_commands_hid_Device.cpp
+++ b/cmds/hid/jni/com_android_commands_hid_Device.cpp
@@ -347,21 +347,21 @@ static void sendGetFeatureReportReply(JNIEnv* env, jclass /* clazz */, jlong ptr
     }
 }
 
 static void closeDevice(JNIEnv* /* env */, jclass /* clazz */, jlong ptr) {
     uhid::Device* d = reinterpret_cast<uhid::Device*>(ptr);
     if (d) {
         delete d;
     }
 }
 
-static JNINativeMethod sMethods[] = {
+static const JNINativeMethod sMethods[] = {
         {"nativeOpenDevice",
          "(Ljava/lang/String;IIII[B"
          "Lcom/android/commands/hid/Device$DeviceCallback;)J",
          reinterpret_cast<void*>(openDevice)},
         {"nativeSendReport", "(J[B)V", reinterpret_cast<void*>(sendReport)},
         {"nativeSendGetFeatureReportReply", "(JI[B)V",
          reinterpret_cast<void*>(sendGetFeatureReportReply)},
         {"nativeCloseDevice", "(J)V", reinterpret_cast<void*>(closeDevice)},
 };
 
diff --git a/cmds/uinput/jni/com_android_commands_uinput_Device.cpp b/cmds/uinput/jni/com_android_commands_uinput_Device.cpp
index 06fa2aac2c7e551faad40d341bf0dbf5465fb957..4c20055020a4e1cd8a260c958b6fb285b92e2ece 100644
--- a/cmds/uinput/jni/com_android_commands_uinput_Device.cpp
+++ b/cmds/uinput/jni/com_android_commands_uinput_Device.cpp
@@ -294,21 +294,21 @@ static void setAbsInfo(JNIEnv* env, jclass /* clazz */, jint handle, jint axisCo
     absSetup.absinfo.maximum = info.maximum;
     absSetup.absinfo.minimum = info.minimum;
     absSetup.absinfo.value = info.value;
     absSetup.absinfo.fuzz = info.fuzz;
     absSetup.absinfo.flat = info.flat;
     absSetup.absinfo.resolution = info.resolution;
 
     ::ioctl(static_cast<int>(handle), UI_ABS_SETUP, &absSetup);
 }
 
-static JNINativeMethod sMethods[] = {
+static const JNINativeMethod sMethods[] = {
         {"nativeOpenUinputDevice",
          "(Ljava/lang/String;IIIII"
          "Lcom/android/commands/uinput/Device$DeviceCallback;)J",
          reinterpret_cast<void*>(openUinputDevice)},
         {"nativeInjectEvent", "(JIII)V", reinterpret_cast<void*>(injectEvent)},
         {"nativeConfigure", "(II[I)V", reinterpret_cast<void*>(configure)},
         {"nativeSetAbsInfo", "(IILandroid/os/Parcel;)V", reinterpret_cast<void*>(setAbsInfo)},
         {"nativeCloseUinputDevice", "(J)V", reinterpret_cast<void*>(closeUinputDevice)},
 };
 
diff --git a/core/jni/android_app_ActivityThread.cpp b/core/jni/android_app_ActivityThread.cpp
index e9d9a20c7538fabbd748d8b6768b8031da864b3d..cd285238d6e2e1e0d38d7196050745c21ff5e792 100644
--- a/core/jni/android_app_ActivityThread.cpp
+++ b/core/jni/android_app_ActivityThread.cpp
@@ -33,21 +33,21 @@ static void android_app_ActivityThread_purgePendingResources(JNIEnv* env, jobjec
 static void
 android_app_ActivityThread_dumpGraphics(JNIEnv* env, jobject clazz, jobject javaFileDescriptor) {
     int fd = jniGetFDFromFileDescriptor(env, javaFileDescriptor);
     ARenderThread_dumpGraphicsMemory(fd);
 }
 
 static void android_app_ActivityThread_initZygoteChildHeapProfiling(JNIEnv* env, jobject clazz) {
     android_mallopt(M_INIT_ZYGOTE_CHILD_PROFILING, nullptr, 0);
 }
 
-static JNINativeMethod gActivityThreadMethods[] = {
+static const JNINativeMethod gActivityThreadMethods[] = {
     // ------------ Regular JNI ------------------
     { "nPurgePendingResources",        "()V",
       (void*) android_app_ActivityThread_purgePendingResources },
     { "nDumpGraphicsInfo",        "(Ljava/io/FileDescriptor;)V",
       (void*) android_app_ActivityThread_dumpGraphics },
     { "nInitZygoteChildHeapProfiling",        "()V",
       (void*) android_app_ActivityThread_initZygoteChildHeapProfiling }
 };
 
 int register_android_app_ActivityThread(JNIEnv* env) {
diff --git a/core/jni/android_os_HidlMemory.cpp b/core/jni/android_os_HidlMemory.cpp
index 69e48184c0ad3a4fe144383d799d2d406ab3ea11..612fc95776a568bb65ba6b2170a05d8086ad2733 100644
--- a/core/jni/android_os_HidlMemory.cpp
+++ b/core/jni/android_os_HidlMemory.cpp
@@ -43,21 +43,21 @@ std::string stringFromJava(JNIEnv* env, jstring jstr) {
 jstring stringToJava(JNIEnv* env, const std::string& cstr) {
     return env->NewStringUTF(cstr.c_str());
 }
 
 static void nativeFinalize(JNIEnv* env, jobject jobj) {
     jlong jNativeContext = env->GetLongField(jobj, gFields.nativeContext);
     JHidlMemory* native = reinterpret_cast<JHidlMemory*>(jNativeContext);
     delete native;
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
         {"nativeFinalize", "()V", (void*) nativeFinalize},
 };
 
 }  // namespace
 
 JHidlMemory::~JHidlMemory() {
     if (mObj) {
         // Must manually delete the underlying handle - hidl_memory doesn't own
         // it.
         native_handle_delete(const_cast<native_handle_t*>(mObj->handle()));
diff --git a/core/jni/android_os_HwBinder.cpp b/core/jni/android_os_HwBinder.cpp
index 781895eeeabaf021e0a966538b78cfec27a1c38d..cbec79144826648e67804fd58e693b784c0b4ad1 100644
--- a/core/jni/android_os_HwBinder.cpp
+++ b/core/jni/android_os_HwBinder.cpp
@@ -345,21 +345,21 @@ void JHwBinder_native_configureRpcThreadpool(JNIEnv *, jclass,
 
 void JHwBinder_native_joinRpcThreadpool() {
     IPCThreadState::self()->joinThreadPool();
 }
 
 static void JHwBinder_report_sysprop_change(JNIEnv * /*env*/, jclass /*clazz*/)
 {
     report_sysprop_change();
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     { "native_init", "()J", (void *)JHwBinder_native_init },
     { "native_setup", "()V", (void *)JHwBinder_native_setup },
 
     { "transact",
         "(IL" PACKAGE_PATH "/HwParcel;L" PACKAGE_PATH "/HwParcel;I)V",
         (void *)JHwBinder_native_transact },
 
     { "registerService", "(Ljava/lang/String;)V",
         (void *)JHwBinder_native_registerService },
 
diff --git a/core/jni/android_os_HwBlob.cpp b/core/jni/android_os_HwBlob.cpp
index a9db91be1d5b04c352018abf83209199243ec576..ba4cf610144931c787a73932f0cf0be1fc681018 100644
--- a/core/jni/android_os_HwBlob.cpp
+++ b/core/jni/android_os_HwBlob.cpp
@@ -592,21 +592,21 @@ static jlong JHwBlob_native_handle(JNIEnv *env, jobject thiz) {
     status_t err = JHwBlob::GetNativeContext(env, thiz)->getHandle(&handle);
 
     if (err != OK) {
         signalExceptionForError(env, err);
         return 0;
     }
 
     return handle;
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     { "native_init", "()J", (void *)JHwBlob_native_init },
     { "native_setup", "(I)V", (void *)JHwBlob_native_setup },
 
     { "getBool", "(J)Z", (void *)JHwBlob_native_getBool },
     { "getInt8", "(J)B", (void *)JHwBlob_native_getInt8 },
     { "getInt16", "(J)S", (void *)JHwBlob_native_getInt16 },
     { "getInt32", "(J)I", (void *)JHwBlob_native_getInt32 },
     { "getInt64", "(J)J", (void *)JHwBlob_native_getInt64 },
     { "getFloat", "(J)F", (void *)JHwBlob_native_getFloat },
     { "getDouble", "(J)D", (void *)JHwBlob_native_getDouble },
diff --git a/core/jni/android_os_HwParcel.cpp b/core/jni/android_os_HwParcel.cpp
index 4c4443fc29c3d0bca0b378d006f17e4d9faa821e..78fd6d90691ba812af0803f023afab97534b0bf9 100644
--- a/core/jni/android_os_HwParcel.cpp
+++ b/core/jni/android_os_HwParcel.cpp
@@ -1061,21 +1061,21 @@ static void JHwParcel_native_writeBuffer(
         JHwParcel::GetNativeContext(env, thiz)->getParcel();
 
     sp<JHwBlob> blob = JHwBlob::GetNativeContext(env, blobObj);
     status_t err = blob->writeToParcel(parcel);
 
     if (err != OK) {
         signalExceptionForError(env, err);
     }
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     { "native_init", "()J", (void *)JHwParcel_native_init },
     { "native_setup", "(Z)V", (void *)JHwParcel_native_setup },
 
     { "writeInterfaceToken", "(Ljava/lang/String;)V",
         (void *)JHwParcel_native_writeInterfaceToken },
 
     { "writeBool", "(Z)V", (void *)JHwParcel_native_writeBool },
     { "writeInt8", "(B)V", (void *)JHwParcel_native_writeInt8 },
     { "writeInt16", "(S)V", (void *)JHwParcel_native_writeInt16 },
     { "writeInt32", "(I)V", (void *)JHwParcel_native_writeInt32 },
diff --git a/core/jni/android_os_HwRemoteBinder.cpp b/core/jni/android_os_HwRemoteBinder.cpp
index 3af55fe810fc6025dea93082f277053d403ed71b..feabd6a60fbfc1908f1420060f665f282d509237 100644
--- a/core/jni/android_os_HwRemoteBinder.cpp
+++ b/core/jni/android_os_HwRemoteBinder.cpp
@@ -435,21 +435,21 @@ static jboolean JHwRemoteBinder_equals(JNIEnv* env, jobject thiz, jobject other)
 
     return hardware::interfacesEqual(toIBase(env, clazz.get(), thiz), toIBase(env, clazz.get(), other));
 }
 
 static jint JHwRemoteBinder_hashCode(JNIEnv* env, jobject thiz) {
     jlong longHash = reinterpret_cast<jlong>(
             JHwRemoteBinder::GetNativeContext(env, thiz)->getBinder().get());
     return static_cast<jint>(longHash ^ (longHash >> 32)); // See Long.hashCode()
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     { "native_init", "()J", (void *)JHwRemoteBinder_native_init },
 
     { "native_setup_empty", "()V",
         (void *)JHwRemoteBinder_native_setup_empty },
 
     { "transact",
         "(IL" PACKAGE_PATH "/HwParcel;L" PACKAGE_PATH "/HwParcel;I)V",
         (void *)JHwRemoteBinder_native_transact },
 
     {"linkToDeath",
diff --git a/libs/hwui/jni/android_graphics_DisplayListCanvas.cpp b/libs/hwui/jni/android_graphics_DisplayListCanvas.cpp
index f060bb32031aa512580737f5c13d4e54d9d4f481..3ebb3553ce209281b0f6739ca2a108630d09d1e8 100644
--- a/libs/hwui/jni/android_graphics_DisplayListCanvas.cpp
+++ b/libs/hwui/jni/android_graphics_DisplayListCanvas.cpp
@@ -167,21 +167,21 @@ static void android_view_DisplayListCanvas_drawWebViewFunctor(CRITICAL_JNI_PARAM
     Canvas* canvas = reinterpret_cast<Canvas*>(canvasPtr);
     canvas->drawWebViewFunctor(functor);
 }
 
 // ----------------------------------------------------------------------------
 // JNI Glue
 // ----------------------------------------------------------------------------
 
 const char* const kClassPathName = "android/graphics/RecordingCanvas";
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
         // ------------ @CriticalNative --------------
         {"nCreateDisplayListCanvas", "(JII)J",
          (void*)android_view_DisplayListCanvas_createDisplayListCanvas},
         {"nResetDisplayListCanvas", "(JJII)V",
          (void*)android_view_DisplayListCanvas_resetDisplayListCanvas},
         {"nGetMaximumTextureWidth", "()I", (void*)android_view_DisplayListCanvas_getMaxTextureSize},
         {"nGetMaximumTextureHeight", "()I",
          (void*)android_view_DisplayListCanvas_getMaxTextureSize},
         {"nEnableZ", "(JZ)V", (void*)android_view_DisplayListCanvas_enableZ},
         {"nFinishRecording", "(JJ)V", (void*)android_view_DisplayListCanvas_finishRecording},
diff --git a/media/jni/android_media_ImageWriter.cpp b/media/jni/android_media_ImageWriter.cpp
index b291ac95bf4f56b458cb425380937c0b1b024c41..1ee25c4f6421cd7ce413d44a7bd4711047948487 100644
--- a/media/jni/android_media_ImageWriter.cpp
+++ b/media/jni/android_media_ImageWriter.cpp
@@ -1054,35 +1054,35 @@ static jobjectArray Image_createSurfacePlanes(JNIEnv* env, jobject thiz,
         env->SetObjectArrayElement(surfacePlanes, i, surfacePlane);
     }
 
     return surfacePlanes;
 }
 
 } // extern "C"
 
 // ----------------------------------------------------------------------------
 
-static JNINativeMethod gImageWriterMethods[] = {
+static const JNINativeMethod gImageWriterMethods[] = {
     {"nativeClassInit",         "()V",                        (void*)ImageWriter_classInit },
     {"nativeInit",              "(Ljava/lang/Object;Landroid/view/Surface;IIII)J",
                                                               (void*)ImageWriter_init },
     {"nativeClose",              "(J)V",                      (void*)ImageWriter_close },
     {"nativeAttachAndQueueImage", "(JJIJIIIIII)I",          (void*)ImageWriter_attachAndQueueImage },
     {"nativeAttachAndQueueGraphicBuffer",
         "(JLandroid/graphics/GraphicBuffer;IJIIIIII)I",
         (void*)ImageWriter_attachAndQueueGraphicBuffer },
     {"nativeDequeueInputImage", "(JLandroid/media/Image;)V",  (void*)ImageWriter_dequeueImage },
     {"nativeQueueInputImage",   "(JLandroid/media/Image;JIIIIII)V",  (void*)ImageWriter_queueImage },
     {"cancelImage",             "(JLandroid/media/Image;)V",   (void*)ImageWriter_cancelImage },
 };
 
-static JNINativeMethod gImageMethods[] = {
+static const JNINativeMethod gImageMethods[] = {
     {"nativeCreatePlanes",      "(II)[Landroid/media/ImageWriter$WriterSurfaceImage$SurfacePlane;",
                                                                (void*)Image_createSurfacePlanes },
     {"nativeGetWidth",          "()I",                         (void*)Image_getWidth },
     {"nativeGetHeight",         "()I",                         (void*)Image_getHeight },
     {"nativeGetFormat",         "()I",                         (void*)Image_getFormat },
     {"nativeGetHardwareBuffer", "()Landroid/hardware/HardwareBuffer;",
                                                                (void*)Image_getHardwareBuffer },
 };
 
 int register_android_media_ImageWriter(JNIEnv *env) {
diff --git a/media/jni/android_media_MediaSync.cpp b/media/jni/android_media_MediaSync.cpp
index d1ce30a3e8278b5935ad23f0ccc793aa102bc40a..d93bda166c441263766911d31058e3b5019d93b5 100644
--- a/media/jni/android_media_MediaSync.cpp
+++ b/media/jni/android_media_MediaSync.cpp
@@ -507,21 +507,21 @@ static void android_media_MediaSync_native_init(JNIEnv *env) {
 static void android_media_MediaSync_native_setup(JNIEnv *env, jobject thiz) {
     sp<JMediaSync> sync = new JMediaSync();
 
     setMediaSync(env, thiz, sync);
 }
 
 static void android_media_MediaSync_native_finalize(JNIEnv *env, jobject thiz) {
     android_media_MediaSync_release(env, thiz);
 }
 
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     { "native_setSurface",
       "(Landroid/view/Surface;)V",
       (void *)android_media_MediaSync_native_setSurface },
 
     { "native_setAudioTrack",
       "(Landroid/media/AudioTrack;)V",
       (void *)android_media_MediaSync_native_setAudioTrack },
 
     { "createInputSurface", "()Landroid/view/Surface;",
       (void *)android_media_MediaSync_createInputSurface },
diff --git a/media/jni/soundpool/android_media_SoundPool.cpp b/media/jni/soundpool/android_media_SoundPool.cpp
index a66d99fbd9f44ab94b8c1e65fa8a073bff3c267a..1665421aacd44672bc3ce3c636b21b3a9d7f0a6d 100644
--- a/media/jni/soundpool/android_media_SoundPool.cpp
+++ b/media/jni/soundpool/android_media_SoundPool.cpp
@@ -240,21 +240,21 @@ android_media_SoundPool_release(JNIEnv *env, jobject thiz)
 
         // clear native context
         env->SetLongField(thiz, fields.mNativeContext, 0);
         delete ap;
     }
 }
 
 // ----------------------------------------------------------------------------
 
 // Dalvik VM type signatures
-static JNINativeMethod gMethods[] = {
+static const JNINativeMethod gMethods[] = {
     {   "_load",
         "(Ljava/io/FileDescriptor;JJI)I",
         (void *)android_media_SoundPool_load_FD
     },
     {   "unload",
         "(I)Z",
         (void *)android_media_SoundPool_unload
     },
     {   "_play",
         "(IFFIIF)I",
diff --git a/services/core/jni/com_android_server_UsbMidiDevice.cpp b/services/core/jni/com_android_server_UsbMidiDevice.cpp
index d6b5bed173ebe59a413cbaacbfa6d97f71bbf54e..564f71daedac80d17ba8caad65ad84155981b32e 100644
--- a/services/core/jni/com_android_server_UsbMidiDevice.cpp
+++ b/services/core/jni/com_android_server_UsbMidiDevice.cpp
@@ -150,21 +150,21 @@ android_server_UsbMidiDevice_close(JNIEnv *env, jobject thiz, jobjectArray fds)
     close(pipeFD);
     env->SetIntField(thiz, sPipeFDField, -1);
 
     int count = env->GetArrayLength(fds);
     for (int i = 0; i < count; i++) {
         jobject fd = env->GetObjectArrayElement(fds, i);
         close(jniGetFDFromFileDescriptor(env, fd));
     }
 }
 
-static JNINativeMethod method_table[] = {
+static const JNINativeMethod method_table[] = {
     { "nativeGetSubdeviceCount", "(II)I", (void*)android_server_UsbMidiDevice_get_subdevice_count },
     { "nativeOpen", "(III)[Ljava/io/FileDescriptor;", (void*)android_server_UsbMidiDevice_open },
     { "nativeClose", "([Ljava/io/FileDescriptor;)V", (void*)android_server_UsbMidiDevice_close },
 };
 
 int register_android_server_UsbMidiDevice(JNIEnv *env)
 {
     jclass clazz = env->FindClass("java/io/FileDescriptor");
     if (clazz == NULL) {
         ALOGE("Can't find java/io/FileDescriptor");
diff --git a/services/core/jni/com_android_server_tv_TvUinputBridge.cpp b/services/core/jni/com_android_server_tv_TvUinputBridge.cpp
index 99deab4fd652cf45e02889a096aa66b1cf3a3a46..2cb1aaef13fa141816f90d53dea985a79ec35a5f 100644
--- a/services/core/jni/com_android_server_tv_TvUinputBridge.cpp
+++ b/services/core/jni/com_android_server_tv_TvUinputBridge.cpp
@@ -527,21 +527,21 @@ static void nativeClear(JNIEnv* env, jclass clazz, jlong ptr) {
     }
 
     // Sync pointer events
     connection->sendEvent(EV_SYN, SYN_REPORT, 0);
 }
 
 /*
  * JNI registration
  */
 
-static JNINativeMethod gUinputBridgeMethods[] = {
+static const JNINativeMethod gUinputBridgeMethods[] = {
         {"nativeOpen", "(Ljava/lang/String;Ljava/lang/String;III)J", (void*)nativeOpen},
         {"nativeGamepadOpen", "(Ljava/lang/String;Ljava/lang/String;)J", (void*)nativeGamepadOpen},
         {"nativeClose", "(J)V", (void*)nativeClose},
         {"nativeSendKey", "(JIZ)V", (void*)nativeSendKey},
         {"nativeSendPointerDown", "(JIII)V", (void*)nativeSendPointerDown},
         {"nativeSendPointerUp", "(JI)V", (void*)nativeSendPointerUp},
         {"nativeClear", "(J)V", (void*)nativeClear},
         {"nativeSendPointerSync", "(J)V", (void*)nativeSendPointerSync},
         {"nativeSendGamepadKey", "(JIZ)V", (void*)nativeSendGamepadKey},
         {"nativeSendGamepadAxisValue", "(JIF)V", (void*)nativeSendGamepadAxisValue},

commit efa910f026749555b53bd2fad6eb8545c1b0951b
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2021-10-16 22:32:37-0400

    disable long press on power assistant setting
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 7d25d4582b8f1a190594814cc4115d19597a2343..2e57f920b1a3da9bbd35ab9bf0d2d8cc010b3535 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -989,21 +989,21 @@
         <item>250</item>
         <item>350</item>
         <item>500</item>
         <item>650</item>
         <item>750</item>
     </integer-array>
 
     <!-- Whether the setting to change long press on power behaviour from default to assistant (5)
          is available in Settings.
      -->
-    <bool name="config_longPressOnPowerForAssistantSettingAvailable">true</bool>
+    <bool name="config_longPressOnPowerForAssistantSettingAvailable">false</bool>
 
     <!-- Control the behavior when the user long presses the power button for a long time.
             0 - Nothing
             1 - Global actions menu
     -->
     <integer name="config_veryLongPressOnPowerBehavior">0</integer>
 
     <!-- Control the behavior when the user presses the power and volume up buttons together.
             0 - Nothing
             1 - Mute toggle

commit bc4fb1b69fa000d11078abca47843ee5a07f6cef
Author: Renlord <me@renlord.com>
Date:   Thu 2019-11-14 23:13:15+1100

    imprecise authenticated timestamps using https
    
    added custom trust manager to bypass certificate time validation
    
    implemented a custom eternalcertificate class that ignores certification
    time checks.
    
    Signed-off-by: Renlord <me@renlord.com>
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
    Change-Id: I2befbe7023e1f9bcb929dbd59241ae5823111427
---
 core/java/android/net/SntpClient.java      | 315 ++++++++++++++++++++++++++++-
 core/java/android/provider/Settings.java   |   4 +
 core/java/android/util/NtpTrustedTime.java |  49 ++++-
 core/res/res/values/config.xml             |   5 +
 core/res/res/values/symbols.xml            |   2 +
 5 files changed, 361 insertions(+), 14 deletions(-)

diff --git a/core/java/android/net/SntpClient.java b/core/java/android/net/SntpClient.java
index f6852e6814393efe4312ced89bc89a3969d6ca46..3eec5adfa628f3ec516d60b7b0ca2424e115a3f6 100644
--- a/core/java/android/net/SntpClient.java
+++ b/core/java/android/net/SntpClient.java
@@ -15,26 +15,54 @@
  */
 
 package android.net;
 
 import android.compat.annotation.UnsupportedAppUsage;
 import android.os.SystemClock;
 import android.util.Log;
 
 import com.android.internal.util.TrafficStatsConstants;
 
+import java.net.URL;
+import java.net.URLConnection;
 import java.net.DatagramPacket;
 import java.net.DatagramSocket;
 import java.net.InetAddress;
+import java.net.MalformedURLException;
 import java.net.UnknownHostException;
 import java.util.Arrays;
 
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.HttpsURLConnection;
+
+import java.security.cert.X509Certificate;
+
+import java.util.Date;
+import java.util.Set;
+import java.math.BigInteger;
+import java.security.KeyStore;
+import java.security.Principal;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.SignatureException;
+import java.security.NoSuchProviderException;
+import java.security.InvalidKeyException;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.CertificateException;
+import java.security.cert.CertificateExpiredException;
+import java.security.cert.CertificateNotYetValidException;
+
+import static android.os.Build.TIME;
+
 /**
  * {@hide}
  *
  * Simple SNTP client class for retrieving network time.
  *
  * Sample usage:
  * <pre>SntpClient client = new SntpClient();
  * if (client.requestTime("time.foo.com")) {
  *     long now = client.getNtpTime() + SystemClock.elapsedRealtime() - client.getNtpTimeReference();
  * }
@@ -66,20 +94,23 @@ public class SntpClient {
 
     // system time computed from NTP server response
     private long mNtpTime;
 
     // value of SystemClock.elapsedRealtime() corresponding to mNtpTime
     private long mNtpTimeReference;
 
     // round trip time in milliseconds
     private long mRoundTripTime;
 
+    // SntpClient mode (http/ntp)
+    private String mNtpMode = "ntp";
+
     private static class InvalidServerReplyException extends Exception {
         public InvalidServerReplyException(String message) {
             super(message);
         }
     }
 
     @UnsupportedAppUsage
     public SntpClient() {
     }
 
@@ -89,28 +120,38 @@ public class SntpClient {
      * @param host host name of the server.
      * @param timeout network timeout in milliseconds. the timeout doesn't include the DNS lookup
      *                time, and it applies to each individual query to the resolved addresses of
      *                the NTP server.
      * @param network network over which to send the request.
      * @return true if the transaction was successful.
      */
     public boolean requestTime(String host, int timeout, Network network) {
         final Network networkForResolv = network.getPrivateDnsBypassingCopy();
         try {
-            final InetAddress[] addresses = networkForResolv.getAllByName(host);
-            for (int i = 0; i < addresses.length; i++) {
-                if (requestTime(addresses[i], NTP_PORT, timeout, networkForResolv)) return true;
+            switch (mNtpMode) {
+                case "https":
+                    URL url = new URL(host);
+                    return requestHttpTime(url, timeout, network);
+                case "ntp":
+                    final InetAddress[] addresses = networkForResolv.getAllByName(host);
+                    for (int i = 0; i < addresses.length; i++) {
+                        if (requestTime(addresses[i], NTP_PORT, timeout, networkForResolv)) return true;
+                    }
+                default:
+                    EventLogTags.writeNtpFailure(host, "unknown protocol " + mNtpMode + " provided");
+                    if (DBG) Log.d(TAG, "request time failed, wrong protocol");
+                    return false;
             }
         } catch (UnknownHostException e) {
             Log.w(TAG, "Unknown host: " + host);
             EventLogTags.writeNtpFailure(host, e.toString());
-        }
+        } catch (MalformedURLException e) {} // exception should never be reached
 
         if (DBG) Log.d(TAG, "request time failed");
         return false;
     }
 
     public boolean requestTime(InetAddress address, int port, int timeout, Network network) {
         DatagramSocket socket = null;
         final int oldTag = TrafficStats.getAndSetThreadStatsTag(
                 TrafficStatsConstants.TAG_SYSTEM_NTP);
         try {
@@ -156,21 +197,21 @@ public class SntpClient {
             // responseTime = transmitTime + transit - skew
             // clockOffset = ((receiveTime - originateTime) + (transmitTime - responseTime))/2
             //             = ((originateTime + transit + skew - originateTime) +
             //                (transmitTime - (transmitTime + transit - skew)))/2
             //             = ((transit + skew) + (transmitTime - transmitTime - transit + skew))/2
             //             = (transit + skew - transit + skew)/2
             //             = (2 * skew)/2 = skew
             long clockOffset = ((receiveTime - originateTime) + (transmitTime - responseTime))/2;
             EventLogTags.writeNtpSuccess(address.toString(), roundTripTime, clockOffset);
             if (DBG) {
-                Log.d(TAG, "round trip: " + roundTripTime + "ms, " +
+                Log.d(TAG, "default method -- round trip: " + roundTripTime + "ms, " +
                         "clock offset: " + clockOffset + "ms");
             }
 
             // save our results - use the times on this side of the network latency
             // (response rather than request time)
             mNtpTime = responseTime + clockOffset;
             mNtpTimeReference = responseTicks;
             mRoundTripTime = roundTripTime;
         } catch (Exception e) {
             EventLogTags.writeNtpFailure(address.toString(), e.toString());
@@ -179,20 +220,276 @@ public class SntpClient {
         } finally {
             if (socket != null) {
                 socket.close();
             }
             TrafficStats.setThreadStatsTag(oldTag);
         }
 
         return true;
     }
 
+    private boolean requestHttpTime(URL url, int timeout, Network network) {
+        final int oldTag = TrafficStats.getAndSetThreadStatsTag(
+                TrafficStatsConstants.TAG_SYSTEM_NTP);
+        final Network networkForResolv = network.getPrivateDnsBypassingCopy();
+        if (DBG) Log.d(TAG, "requestHttpTime() getting time using https");
+        try {
+            TrustManagerFactory tmf = TrustManagerFactory
+                .getInstance(TrustManagerFactory.getDefaultAlgorithm());
+            tmf.init((KeyStore) null);
+
+            X509TrustManager x509Tm = null;
+            for (TrustManager tm : tmf.getTrustManagers()) {
+                if (tm instanceof X509TrustManager) {
+                    x509Tm = (X509TrustManager) tm;
+                    break;
+                }
+            }
+
+            final X509TrustManager finalTm = x509Tm;
+            X509TrustManager customTm = new X509TrustManager() {
+
+                // custom eternal certificate class that ignores expired SSL certificates
+                // adapted from https://gist.github.com/divergentdave/9a68d820e3610513bd4fcdc4ae5f91a1
+                class TimeLeewayCertificate extends X509Certificate {
+                    private final X509Certificate originalCertificate;
+
+                    public TimeLeewayCertificate(X509Certificate originalCertificate) {
+                        this.originalCertificate = originalCertificate;
+                    }
+
+                    @Override
+                    public void checkValidity() throws CertificateExpiredException, CertificateNotYetValidException {
+                        // Ignore notBefore/notAfter
+                        checkValidity(new Date());
+                    }
+
+                    @Override
+                    public void checkValidity(Date date) throws CertificateExpiredException, CertificateNotYetValidException {
+                        // expiration must be set after OS build date
+                        if (getNotAfter().compareTo(new Date(TIME)) < 0) {
+                            throw new CertificateExpiredException("Certificate expired at "
+                                    + getNotAfter().toString() + " (compared to " + date.toString() + ")");
+                        }
+                    }
+
+                    @Override
+                    public int getVersion() {
+                        return originalCertificate.getVersion();
+                    }
+
+                    @Override
+                    public BigInteger getSerialNumber() {
+                        return originalCertificate.getSerialNumber();
+                    }
+
+                    @Override
+                    public Principal getIssuerDN() {
+                        return originalCertificate.getIssuerDN();
+                    }
+
+                    @Override
+                    public Principal getSubjectDN() {
+                        return originalCertificate.getSubjectDN();
+                    }
+
+                    @Override
+                    public Date getNotBefore() {
+                        return originalCertificate.getNotBefore();
+                    }
+
+                    @Override
+                    public Date getNotAfter() {
+                        return originalCertificate.getNotAfter();
+                    }
+
+                    @Override
+                    public byte[] getTBSCertificate() throws CertificateEncodingException {
+                        return originalCertificate.getTBSCertificate();
+                    }
+
+                    @Override
+                    public byte[] getSignature() {
+                        return originalCertificate.getSignature();
+                    }
+
+                    @Override
+                    public String getSigAlgName() {
+                        return originalCertificate.getSigAlgName();
+                    }
+
+                    @Override
+                    public String getSigAlgOID() {
+                        return originalCertificate.getSigAlgOID();
+                    }
+
+                    @Override
+                    public byte[] getSigAlgParams() {
+                        return originalCertificate.getSigAlgParams();
+                    }
+
+                    @Override
+                    public boolean[] getIssuerUniqueID() {
+                        return originalCertificate.getIssuerUniqueID();
+                    }
+
+                    @Override
+                    public boolean[] getSubjectUniqueID() {
+                        return originalCertificate.getSubjectUniqueID();
+                    }
+
+                    @Override
+                    public boolean[] getKeyUsage() {
+                        return originalCertificate.getKeyUsage();
+                    }
+
+                    @Override
+                    public int getBasicConstraints() {
+                        return originalCertificate.getBasicConstraints();
+                    }
+
+                    @Override
+                    public byte[] getEncoded() throws CertificateEncodingException {
+                        return originalCertificate.getEncoded();
+                    }
+
+                    @Override
+                    public void verify(PublicKey key) throws CertificateException,
+                           NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException
+                    {
+                        originalCertificate.verify(key);
+                    }
+
+                    @Override
+                    public void verify(PublicKey key, String sigProvider) throws CertificateException,
+                           NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException
+                    {
+                        originalCertificate.verify(key, sigProvider);
+                    }
+
+                    @Override
+                    public String toString() {
+                        return originalCertificate.toString();
+                    }
+
+                    @Override
+                    public PublicKey getPublicKey() {
+                        return originalCertificate.getPublicKey();
+                    }
+
+                    @Override
+                    public Set<String> getCriticalExtensionOIDs() {
+                        return originalCertificate.getCriticalExtensionOIDs();
+                    }
+
+                    @Override
+                    public byte[] getExtensionValue(String oid) {
+                        return originalCertificate.getExtensionValue(oid);
+                    }
+
+                    @Override
+                    public Set<String> getNonCriticalExtensionOIDs() {
+                        return originalCertificate.getNonCriticalExtensionOIDs();
+                    }
+
+                    @Override
+                    public boolean hasUnsupportedCriticalExtension() {
+                        return originalCertificate.hasUnsupportedCriticalExtension();
+                    }
+                }
+
+                @Override
+                public X509Certificate[] getAcceptedIssuers() {
+                    return finalTm.getAcceptedIssuers();
+                }
+
+                @Override
+                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+                        // replace the top-level certificate with a certificate validation routine that
+                        // ignores expired certificates due to clock drift.
+                        X509Certificate[] timeLeewayChain = new X509Certificate[chain.length];
+                        for (int i = 0; i < chain.length; i++) {
+                            timeLeewayChain[i] = new TimeLeewayCertificate(chain[i]);
+                        }
+                        finalTm.checkServerTrusted(timeLeewayChain, authType);
+                }
+
+                @Override
+                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
+                    // never gets used, so default to stock.
+                    finalTm.checkClientTrusted(chain, authType);
+                }
+            };
+
+            if (DBG) Log.d(TAG, "requestHttpTime() setting up URL connection");
+            URLConnection urlConnection = networkForResolv.openConnection(url);
+            SSLContext sslContext = SSLContext.getInstance("SSL");
+            sslContext.init(null, new TrustManager[] { customTm }, null);
+
+            if (urlConnection instanceof HttpsURLConnection) {
+                HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) urlConnection;
+                try {
+                    // change the SSLSocketFactory to use custom trust manager
+                    httpsUrlConnection.setSSLSocketFactory(sslContext.getSocketFactory());
+                    httpsUrlConnection.setConnectTimeout(timeout);
+                    httpsUrlConnection.setReadTimeout(timeout);
+                    httpsUrlConnection.setRequestProperty("Connection", "close");
+                    final long requestTime = System.currentTimeMillis();
+                    final long requestTicks = SystemClock.elapsedRealtime();
+                    // implicitly fires GET request.
+                    httpsUrlConnection.getInputStream();
+                    long transmitTime = urlConnection.getDate();
+                    // http servers dont log originate/receive time (imprecise offset).
+                    long receiveTime = urlConnection.getDate();
+                    final long responseTicks = SystemClock.elapsedRealtime();
+                    final long responseTime = requestTime + (responseTicks - requestTicks);
+                    long roundTripTime = responseTicks - requestTicks - (transmitTime - receiveTime);
+                    long clockOffset = ((receiveTime - requestTime) + (transmitTime - responseTime))/2;
+                    if (DBG) {
+                        Log.d(TAG, "https method -- round trip: " + roundTripTime + "ms, " +
+                                "clock offset: " + clockOffset + "ms");
+                    }
+                    if (receiveTime < TIME) {
+                        Log.w(TAG, "https method received timestamp before BUILD unix time, rejecting");
+                        return false;
+                    }
+                    EventLogTags.writeNtpSuccess(url.toString(), roundTripTime, clockOffset);
+                    // save our results - use the times on this side of the network latency
+                    // (response rather than request time)
+                    mNtpTime = responseTime + clockOffset;
+                    mNtpTimeReference = responseTicks;
+                    mRoundTripTime = roundTripTime;
+                } catch (Exception e) {
+                    Log.e(TAG, "request https time failed: " + e.toString());
+                    if (DBG) e.printStackTrace();
+                    return false;
+                } finally {
+                    httpsUrlConnection.disconnect();
+                }
+            } else {
+                EventLogTags.writeNtpFailure(url.toString(), "did not receive HttpsURLConnection from Android Network");
+                if (DBG) Log.d(TAG, "request time failed: did not receive HttpsURLConnection from Android Network");
+                return false;
+            }
+        } catch (Exception e) {
+            EventLogTags.writeNtpFailure(url.toString(), e.toString());
+            Log.e(TAG, "request time failed: " + e.toString());
+            if (DBG) {
+                e.printStackTrace();
+            }
+            return false;
+        } finally {
+            TrafficStats.setThreadStatsTag(oldTag);
+        }
+        return true;
+    }
+
     @Deprecated
     @UnsupportedAppUsage
     public boolean requestTime(String host, int timeout) {
         Log.w(TAG, "Shame on you for calling the hidden API requestTime()!");
         return false;
     }
 
     /**
      * Returns the time computed from the NTP transaction.
      *
@@ -217,20 +514,28 @@ public class SntpClient {
     /**
      * Returns the round trip time of the NTP transaction
      *
      * @return round trip time in milliseconds.
      */
     @UnsupportedAppUsage
     public long getRoundTripTime() {
         return mRoundTripTime;
     }
 
+    /**
+     * Sets the ntp mode
+     */
+    @UnsupportedAppUsage
+    public void setNtpMode(String mode) {
+        mNtpMode = mode;
+    }
+
     private static void checkValidServerReply(
             byte leap, byte mode, int stratum, long transmitTime, long referenceTime)
             throws InvalidServerReplyException {
         if (leap == NTP_LEAP_NOSYNC) {
             throw new InvalidServerReplyException("unsynchronized server");
         }
         if ((mode != NTP_MODE_SERVER) && (mode != NTP_MODE_BROADCAST)) {
             throw new InvalidServerReplyException("untrusted mode: " + mode);
         }
         if ((stratum == NTP_STRATUM_DEATH) || (stratum > NTP_STRATUM_MAX)) {
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 8328e159b59048755a2fbd1ce58b9ff023064352..7c27c5592ac6e3f44fe873b695d08f25ca0eccc2 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -11396,20 +11396,24 @@ public final class Settings {
         */
         @Readable
         public static final String NITZ_UPDATE_SPACING = "nitz_update_spacing";
 
         /** Preferred NTP server. {@hide} */
         @Readable
         public static final String NTP_SERVER = "ntp_server";
         /** Timeout in milliseconds to wait for NTP server. {@hide} */
         @Readable
         public static final String NTP_TIMEOUT = "ntp_timeout";
+       /** Preferred HTTPS time server. {@hide} */
+       public static final String HTTPS_TIME_SERVER = "https_time_server";
+       /** Prefered method to get NTP. {@hide} */
+       public static final String NTP_MODE = "ntp_mode";
 
         /** {@hide} */
         @Readable
         public static final String STORAGE_BENCHMARK_INTERVAL = "storage_benchmark_interval";
 
         /**
          * Whether or not Settings should enable psd API.
          * {@hide}
          */
         @Readable
diff --git a/core/java/android/util/NtpTrustedTime.java b/core/java/android/util/NtpTrustedTime.java
index 4ac3178ecb4cf7e2d55ad63aea4daeeec8d7cd4b..9ebc9f4cea0b832d7f09131cae5839458362b183 100644
--- a/core/java/android/util/NtpTrustedTime.java
+++ b/core/java/android/util/NtpTrustedTime.java
@@ -102,21 +102,20 @@ public class NtpTrustedTime implements TrustedTime {
     @NonNull
     private final Context mContext;
 
     /**
      * A supplier that returns the ConnectivityManager. The Supplier can return null if
      * ConnectivityService isn't running yet.
      */
     private final Supplier<ConnectivityManager> mConnectivityManagerSupplier =
             new Supplier<ConnectivityManager>() {
         private ConnectivityManager mConnectivityManager;
-
         @Nullable
         @Override
         public synchronized ConnectivityManager get() {
             // We can't do this at initialization time: ConnectivityService might not be running
             // yet.
             if (mConnectivityManager == null) {
                 mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
             }
             return mConnectivityManager;
         }
@@ -153,23 +152,23 @@ public class NtpTrustedTime implements TrustedTime {
             if (connectivityManager == null) {
                 if (LOGD) Log.d(TAG, "forceRefresh: no ConnectivityManager");
                 return false;
             }
             final Network network = connectivityManager.getActiveNetwork();
             final NetworkInfo ni = connectivityManager.getNetworkInfo(network);
             if (ni == null || !ni.isConnected()) {
                 if (LOGD) Log.d(TAG, "forceRefresh: no connectivity");
                 return false;
             }
-
             if (LOGD) Log.d(TAG, "forceRefresh() from cache miss");
             final SntpClient client = new SntpClient();
+            client.setNtpMode(connectionInfo.getNtpMode());
             final String serverName = connectionInfo.getServer();
             final int timeoutMillis = connectionInfo.getTimeoutMillis();
             if (client.requestTime(serverName, timeoutMillis, network)) {
                 long ntpCertainty = client.getRoundTripTime() / 2;
                 mTimeResult = new TimeResult(
                         client.getNtpTime(), client.getNtpTimeReference(), ntpCertainty);
                 return true;
             } else {
                 return false;
             }
@@ -253,45 +252,77 @@ public class NtpTrustedTime implements TrustedTime {
      */
     @Nullable
     public TimeResult getCachedTimeResult() {
         return mTimeResult;
     }
 
     private static class NtpConnectionInfo {
 
         @NonNull private final String mServer;
         private final int mTimeoutMillis;
+        private final String mNtpMode;
 
         NtpConnectionInfo(@NonNull String server, int timeoutMillis) {
             mServer = Objects.requireNonNull(server);
             mTimeoutMillis = timeoutMillis;
+            mNtpMode = "ntp";
+        }
+
+        NtpConnectionInfo(@NonNull String server, int timeoutMillis, @NonNull String ntpMode) {
+            mServer = Objects.requireNonNull(server);
+            mTimeoutMillis = timeoutMillis;
+            mNtpMode = ntpMode;
         }
 
         @NonNull
         public String getServer() {
             return mServer;
         }
 
+        @NonNull
+        public String getNtpMode() {
+            return mNtpMode;
+        }
+
         int getTimeoutMillis() {
             return mTimeoutMillis;
         }
     }
 
     @GuardedBy("this")
     private NtpConnectionInfo getNtpConnectionInfo() {
         final ContentResolver resolver = mContext.getContentResolver();
 
         final Resources res = mContext.getResources();
-        final String defaultServer = res.getString(
-                com.android.internal.R.string.config_ntpServer);
-        final int defaultTimeoutMillis = res.getInteger(
-                com.android.internal.R.integer.config_ntpTimeout);
+        final String defaultNtpMode = res.getString(
+                com.android.internal.R.string.config_ntpMode);
+        final String ntpMode =
+                Settings.Global.getString(resolver, Settings.Global.NTP_MODE) != null ?
+                Settings.Global.getString(resolver, Settings.Global.NTP_MODE) :
+                defaultNtpMode;
 
-        final String secureServer = Settings.Global.getString(
-                resolver, Settings.Global.NTP_SERVER);
+        String defaultServer;
+        String secureServer;
+
+        int defaultTimeoutMillis = res.getInteger(
+                com.android.internal.R.integer.config_ntpTimeout);
         final int timeoutMillis = Settings.Global.getInt(
                 resolver, Settings.Global.NTP_TIMEOUT, defaultTimeoutMillis);
 
+        switch(ntpMode) {
+            case "https":
+                defaultServer = res.getString(
+                        com.android.internal.R.string.config_httpsTimeServer);
+                secureServer = Settings.Global.getString(
+                        resolver, Settings.Global.HTTPS_TIME_SERVER);
+                break;
+            default:
+                defaultServer = res.getString(
+                        com.android.internal.R.string.config_ntpServer);
+                secureServer = Settings.Global.getString(
+                        resolver, Settings.Global.NTP_SERVER);
+                break;
+        }
         final String server = secureServer != null ? secureServer : defaultServer;
-        return TextUtils.isEmpty(server) ? null : new NtpConnectionInfo(server, timeoutMillis);
+        return TextUtils.isEmpty(server) ? null : new NtpConnectionInfo(server, timeoutMillis, ntpMode);
     }
 }
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 2e57f920b1a3da9bbd35ab9bf0d2d8cc010b3535..f9188b63af972efbda9653106c26bcd9f5620932 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2237,22 +2237,27 @@
 
     <!-- Whether a software navigation bar should be shown. NOTE: in the future this may be
          autodetected from the Configuration. -->
     <bool name="config_showNavigationBar">false</bool>
 
     <!-- Whether action menu items should be displayed in ALLCAPS or not.
          Defaults to true. If this is not appropriate for specific locales
          it should be disabled in that locale's resources. -->
     <bool name="config_actionMenuItemAllCaps">true</bool>
 
+    <!-- Network derived time preferred protocol
+         Supports "ntp" or "https" only now -->
+    <string translatable="false" name="config_ntpMode">https</string>
     <!-- Remote server that can provide NTP responses. -->
     <string translatable="false" name="config_ntpServer">time.android.com</string>
+    <!-- Remote server that can provide HTTPS time responses -->
+    <string translatable="false" name="config_httpsTimeServer">https://time.grapheneos.org/generate_204</string>
     <!-- Normal polling frequency in milliseconds -->
     <integer name="config_ntpPollingInterval">86400000</integer>
     <!-- Try-again polling interval in milliseconds, in case the network request failed -->
     <integer name="config_ntpPollingIntervalShorter">60000</integer>
     <!-- Number of times to try again with the shorter interval, before backing
          off until the normal polling interval. A value < 0 indicates infinite. -->
     <integer name="config_ntpRetry">3</integer>
     <!-- Timeout to wait for NTP server response in milliseconds. -->
     <integer name="config_ntpTimeout">5000</integer>
 
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index af2393bf3b8d594ada4129c3e8b65911edb14e3a..8a52798127c7bef359b87482be9160efd4b0d7a9 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -704,20 +704,22 @@
   <java-symbol type="array" name="config_companionDevicePackages" />
   <java-symbol type="array" name="config_companionDeviceCerts" />
   <java-symbol type="string" name="config_default_dns_server" />
   <java-symbol type="string" name="config_ethernet_iface_regex" />
   <java-symbol type="string" name="not_checked" />
   <java-symbol type="array" name="config_ethernet_interfaces" />
   <java-symbol type="bool" name="config_vehicleInternalNetworkAlwaysRequested" />
   <java-symbol type="string" name="config_forceVoiceInteractionServicePackage" />
   <java-symbol type="string" name="config_mms_user_agent" />
   <java-symbol type="string" name="config_mms_user_agent_profile_url" />
+  <java-symbol type="string" name="config_ntpMode" />
+  <java-symbol type="string" name="config_httpsTimeServer" />
   <java-symbol type="string" name="config_ntpServer" />
   <java-symbol type="string" name="config_useragentprofile_url" />
   <java-symbol type="string" name="config_appsNotReportingCrashes" />
   <java-symbol type="string" name="contentServiceSync" />
   <java-symbol type="string" name="contentServiceSyncNotificationTitle" />
   <java-symbol type="string" name="contentServiceTooManyDeletesNotificationDesc" />
   <java-symbol type="string" name="date_and_time" />
   <java-symbol type="string" name="date_picker_decrement_day_button" />
   <java-symbol type="string" name="date_picker_decrement_month_button" />
   <java-symbol type="string" name="date_picker_decrement_year_button" />

commit 5315b312ff9dc96605c1c1aaad15d15c950f6195
Author: Renlord <me@renlord.com>
Date:   Tue 2020-09-29 10:58:40+1000

    reinstate toggle for disabling NITZ time updates to prefer network time updates instead
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
    Change-Id: Ia98f919e91d87af597940431c4aa83539850d540
---
 core/res/res/values/config.xml                            |  2 ++
 core/res/res/values/symbols.xml                           |  1 +
 .../com/android/server/timedetector/EnvironmentImpl.java  |  9 +++++++++
 .../server/timedetector/TimeDetectorStrategyImpl.java     | 15 ++++++++++++---
 4 files changed, 24 insertions(+), 3 deletions(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index f9188b63af972efbda9653106c26bcd9f5620932..44ef37c9103eec75e89211595aeee25d308eaa11 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2248,20 +2248,22 @@
          Supports "ntp" or "https" only now -->
     <string translatable="false" name="config_ntpMode">https</string>
     <!-- Remote server that can provide NTP responses. -->
     <string translatable="false" name="config_ntpServer">time.android.com</string>
     <!-- Remote server that can provide HTTPS time responses -->
     <string translatable="false" name="config_httpsTimeServer">https://time.grapheneos.org/generate_204</string>
     <!-- Normal polling frequency in milliseconds -->
     <integer name="config_ntpPollingInterval">86400000</integer>
     <!-- Try-again polling interval in milliseconds, in case the network request failed -->
     <integer name="config_ntpPollingIntervalShorter">60000</integer>
+    <!-- Toggle to update timestamp using NITZ -->
+    <bool name="config_nitzTimeUpdate">false</bool>
     <!-- Number of times to try again with the shorter interval, before backing
          off until the normal polling interval. A value < 0 indicates infinite. -->
     <integer name="config_ntpRetry">3</integer>
     <!-- Timeout to wait for NTP server response in milliseconds. -->
     <integer name="config_ntpTimeout">5000</integer>
 
     <!-- Default network policy warning threshold, in megabytes. -->
     <integer name="config_networkPolicyDefaultWarning">2048</integer>
 
     <!-- Set and Unsets WiMAX -->
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 8a52798127c7bef359b87482be9160efd4b0d7a9..66516dc4bf4ff7102fcb9fd6ab6a4b921b1be482 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -449,20 +449,21 @@
   <java-symbol type="bool" name="config_allowStartActivityForLongPressOnPowerInSetup" />
   <java-symbol type="integer" name="config_keyChordPowerVolumeUp" />
   <java-symbol type="integer" name="config_wakeUpToLastStateTimeoutMillis" />
   <java-symbol type="integer" name="config_lowMemoryKillerMinFreeKbytesAdjust" />
   <java-symbol type="integer" name="config_lowMemoryKillerMinFreeKbytesAbsolute" />
   <java-symbol type="integer" name="config_max_pan_devices" />
   <java-symbol type="integer" name="config_ntpPollingInterval" />
   <java-symbol type="integer" name="config_ntpPollingIntervalShorter" />
   <java-symbol type="integer" name="config_ntpRetry" />
   <java-symbol type="integer" name="config_ntpTimeout" />
+  <java-symbol type="bool" name="config_nitzTimeUpdate" />
   <java-symbol type="integer" name="config_shortPressOnPowerBehavior" />
   <java-symbol type="integer" name="config_toastDefaultGravity" />
   <java-symbol type="integer" name="config_triplePressOnPowerBehavior" />
   <java-symbol type="integer" name="config_shortPressOnSleepBehavior" />
   <java-symbol type="integer" name="config_windowOutsetBottom" />
   <java-symbol type="integer" name="db_connection_pool_size" />
   <java-symbol type="integer" name="db_journal_size_limit" />
   <java-symbol type="integer" name="db_wal_autocheckpoint" />
   <java-symbol type="integer" name="db_default_idle_connection_timeout" />
   <java-symbol type="integer" name="config_soundEffectVolumeDb" />
diff --git a/services/core/java/com/android/server/timedetector/EnvironmentImpl.java b/services/core/java/com/android/server/timedetector/EnvironmentImpl.java
index 7649958fe6c996298dba889265647ef1bec1dc00..205ade9ed82fe75b3318b950443367fc7a64fa2a 100644
--- a/services/core/java/com/android/server/timedetector/EnvironmentImpl.java
+++ b/services/core/java/com/android/server/timedetector/EnvironmentImpl.java
@@ -43,20 +43,21 @@ final class EnvironmentImpl implements TimeDetectorStrategyImpl.Environment {
 
     private static final String LOG_TAG = TimeDetectorService.TAG;
 
     @NonNull private final Context mContext;
     @NonNull private final Handler mHandler;
     @NonNull private final ServiceConfigAccessor mServiceConfigAccessor;
     @NonNull private final ContentResolver mContentResolver;
     @NonNull private final PowerManager.WakeLock mWakeLock;
     @NonNull private final AlarmManager mAlarmManager;
     @NonNull private final UserManager mUserManager;
+    @NonNull private final boolean mNitzTimeDetectionToggle;
 
     // @NonNull after setConfigChangeListener() is called.
     @GuardedBy("this")
     private ConfigurationChangeListener mConfigChangeListener;
 
     EnvironmentImpl(@NonNull Context context, @NonNull Handler handler,
             @NonNull ServiceConfigAccessor serviceConfigAccessor) {
         mContext = Objects.requireNonNull(context);
         mContentResolver = Objects.requireNonNull(context.getContentResolver());
         mHandler = Objects.requireNonNull(handler);
@@ -78,20 +79,23 @@ final class EnvironmentImpl implements TimeDetectorStrategyImpl.Environment {
                 Settings.Global.getUriFor(Settings.Global.AUTO_TIME), true,
                 new ContentObserver(mHandler) {
                     @Override
                     public void onChange(boolean selfChange) {
                         handleAutoTimeDetectionChangedOnHandlerThread();
                     }
                 });
         mServiceConfigAccessor.addListener(
                 () -> mHandler.post(
                         EnvironmentImpl.this::handleAutoTimeDetectionChangedOnHandlerThread));
+        mNitzTimeDetectionToggle =
+            mContext.getResources().getBoolean(
+                    com.android.internal.R.bool.config_nitzTimeUpdate);
     }
 
     /** Internal method for handling the auto time setting being changed. */
     private void handleAutoTimeDetectionChangedOnHandlerThread() {
         synchronized (this) {
             if (mConfigChangeListener == null) {
                 Slog.wtf(LOG_TAG, "mConfigChangeListener is unexpectedly null");
             }
             mConfigChangeListener.onChange();
         }
@@ -129,20 +133,25 @@ final class EnvironmentImpl implements TimeDetectorStrategyImpl.Environment {
     }
 
     @Override
     public ConfigurationInternal configurationInternal(@UserIdInt int userId) {
         return new ConfigurationInternal.Builder(userId)
                 .setUserConfigAllowed(isUserConfigAllowed(userId))
                 .setAutoDetectionEnabled(isAutoTimeDetectionEnabled())
                 .build();
     }
 
+    @Override
+    public boolean isNITZTimeDetectionEnabled() {
+        return mNitzTimeDetectionToggle;
+    }
+
     @Override
     public void acquireWakeLock() {
         if (mWakeLock.isHeld()) {
             Slog.wtf(LOG_TAG, "WakeLock " + mWakeLock + " already held");
         }
         mWakeLock.acquire();
     }
 
     @Override
     public long elapsedRealtimeMillis() {
diff --git a/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java b/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java
index 357c232226582f6d0a85f152b4fe3697a74307c7..5c95d02a34de3b810fa9e4ad4d0019ac134af1eb 100644
--- a/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java
+++ b/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java
@@ -48,21 +48,21 @@ import java.util.Objects;
 
 /**
  * An implementation of {@link TimeDetectorStrategy} that passes telephony and manual suggestions to
  * {@link AlarmManager}. When there are multiple telephony sources, the one with the lowest ID is
  * used unless the data becomes too stale.
  *
  * <p>Most public methods are marked synchronized to ensure thread safety around internal state.
  */
 public final class TimeDetectorStrategyImpl implements TimeDetectorStrategy {
 
-    private static final boolean DBG = false;
+    private static final boolean DBG = true;
     private static final String LOG_TAG = TimeDetectorService.TAG;
 
     /** A score value used to indicate "no score", either due to validation failure or age. */
     private static final int TELEPHONY_INVALID_SCORE = -1;
     /** The number of buckets telephony suggestions can be put in by age. */
     private static final int TELEPHONY_BUCKET_COUNT = 24;
     /** Each bucket is this size. All buckets are equally sized. */
     @VisibleForTesting
     static final int TELEPHONY_BUCKET_SIZE_MILLIS = 60 * 60 * 1000;
     /**
@@ -178,20 +178,24 @@ public final class TimeDetectorStrategyImpl implements TimeDetectorStrategy {
         long elapsedRealtimeMillis();
 
         /** Returns the system clock value. */
         long systemClockMillis();
 
         /** Sets the device system clock. The WakeLock must be held. */
         void setSystemClock(long newTimeMillis);
 
         /** Release the wake lock acquired by a call to {@link #acquireWakeLock()}. */
         void releaseWakeLock();
+
+        /** Returns true if NITZ time updates is enabled. */
+        boolean isNITZTimeDetectionEnabled();
+
     }
 
     static TimeDetectorStrategy create(
             @NonNull Context context, @NonNull Handler handler,
             @NonNull ServiceConfigAccessor serviceConfigAccessor) {
 
         TimeDetectorStrategyImpl.Environment environment =
                 new EnvironmentImpl(context, handler, serviceConfigAccessor);
         return new TimeDetectorStrategyImpl(environment);
     }
@@ -237,21 +241,21 @@ public final class TimeDetectorStrategyImpl implements TimeDetectorStrategy {
         if (!validateSuggestionTime(newUtcTime, suggestion)) {
             return false;
         }
 
         String cause = "Manual time suggestion received: suggestion=" + suggestion;
         return setSystemClockIfRequired(ORIGIN_MANUAL, newUtcTime, cause);
     }
 
     @Override
     public synchronized void suggestNetworkTime(@NonNull NetworkTimeSuggestion timeSuggestion) {
-        if (!validateAutoSuggestionTime(timeSuggestion.getUtcTime(), timeSuggestion)) {
+        if (timeSuggestion == null || !validateAutoSuggestionTime(timeSuggestion.getUtcTime(), timeSuggestion)) {
             return;
         }
 
         // The caller submits suggestions with the best available information when there are network
         // changes. The best available information may have been cached and if they were all stored
         // this would lead to duplicates showing up in the suggestion history. The suggestions may
         // be made for different reasons but there is not a significant benefit to storing the same
         // suggestion information again. doAutoTimeDetection() should still be called: this ensures
         // the suggestion and device state are always re-evaluated, which might produce a different
         // detected time if, for example, the age of all suggestions are considered.
@@ -261,20 +265,25 @@ public final class TimeDetectorStrategyImpl implements TimeDetectorStrategy {
         }
 
         // Now perform auto time detection. The new suggestion may be used to modify the system
         // clock.
         String reason = "New network time suggested. timeSuggestion=" + timeSuggestion;
         doAutoTimeDetection(reason);
     }
 
     @Override
     public synchronized void suggestTelephonyTime(@NonNull TelephonyTimeSuggestion timeSuggestion) {
+        // is config_nitzUpdate is set to false, we disallow telephony time suggestions.
+        if (!mEnvironment.isNITZTimeDetectionEnabled()) {
+            return;
+        }
+
         // Empty time suggestion means that telephony network connectivity has been lost.
         // The passage of time is relentless, and we don't expect our users to use a time machine,
         // so we can continue relying on previous suggestions when we lose connectivity. This is
         // unlike time zone, where a user may lose connectivity when boarding a flight and where we
         // do want to "forget" old signals. Suggestions that are too old are discarded later in the
         // detection algorithm.
         if (timeSuggestion.getUtcTime() == null) {
             return;
         }
 
@@ -441,21 +450,21 @@ public final class TimeDetectorStrategyImpl implements TimeDetectorStrategy {
         if (!mEnvironment.isAutoTimeDetectionEnabled()) {
             // Avoid doing unnecessary work with this (race-prone) check.
             return;
         }
 
         // Try the different origins one at a time.
         int[] originPriorities = mEnvironment.autoOriginPriorities();
         for (int origin : originPriorities) {
             TimestampedValue<Long> newUtcTime = null;
             String cause = null;
-            if (origin == ORIGIN_TELEPHONY) {
+            if (mEnvironment.isNITZTimeDetectionEnabled() && origin == ORIGIN_TELEPHONY) {
                 TelephonyTimeSuggestion bestTelephonySuggestion = findBestTelephonySuggestion();
                 if (bestTelephonySuggestion != null) {
                     newUtcTime = bestTelephonySuggestion.getUtcTime();
                     cause = "Found good telephony suggestion."
                             + ", bestTelephonySuggestion=" + bestTelephonySuggestion
                             + ", detectionReason=" + detectionReason;
                 }
             } else if (origin == ORIGIN_NETWORK) {
                 NetworkTimeSuggestion networkSuggestion = findLatestValidNetworkSuggestion();
                 if (networkSuggestion != null) {

commit 5bb44e357b1310dc79a687a72710531cbcee5f8a
Author: Renlord <me@renlord.com>
Date:   Tue 2020-06-30 11:52:43+1000

    dont ping server when nitz time update is toggled off
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
---
 core/java/android/util/NtpTrustedTime.java | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/core/java/android/util/NtpTrustedTime.java b/core/java/android/util/NtpTrustedTime.java
index 9ebc9f4cea0b832d7f09131cae5839458362b183..be78084b7ea9c98d8b4c98976a6d7127110bd1b5 100644
--- a/core/java/android/util/NtpTrustedTime.java
+++ b/core/java/android/util/NtpTrustedTime.java
@@ -134,20 +134,29 @@ public class NtpTrustedTime implements TrustedTime {
         if (sSingleton == null) {
             Context appContext = context.getApplicationContext();
             sSingleton = new NtpTrustedTime(appContext);
         }
         return sSingleton;
     }
 
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     public boolean forceRefresh() {
         synchronized (this) {
+            final ContentResolver resolver = mContext.getContentResolver();
+
+            final boolean networkPollTime = Settings.Global.getInt(resolver,
+                    Settings.Global.AUTO_TIME, 1) != 0;
+            if (!networkPollTime) {
+                Log.d(TAG, "forceRefresh: nitzTimeUpdate disabled bailing early");
+                return false;
+            }
+
             NtpConnectionInfo connectionInfo = getNtpConnectionInfo();
             if (connectionInfo == null) {
                 // missing server config, so no trusted time available
                 if (LOGD) Log.d(TAG, "forceRefresh: invalid server config");
                 return false;
             }
 
             ConnectivityManager connectivityManager = mConnectivityManagerSupplier.get();
             if (connectivityManager == null) {
                 if (LOGD) Log.d(TAG, "forceRefresh: no ConnectivityManager");

commit 7d3892b3060b12ad7c1ce17188321c402578a8bf
Author: anupritaisno1 <www.anuprita804@gmail.com>
Date:   Mon 2021-10-18 04:05:40+0530

    automatically reboot device after timeout if set
    
    Signed-off-by: anupritaisno1 <www.anuprita804@gmail.com>
    Change-Id: If891bfbcc144c9336ba013260bad2b7c7a59c054
---
 core/java/android/provider/Settings.java           |  7 +++++
 data/etc/com.android.systemui.xml                  |  1 +
 packages/SystemUI/AndroidManifest.xml              |  3 ++
 .../systemui/keyguard/KeyguardViewMediator.java    | 35 ++++++++++++++++++++++
 4 files changed, 46 insertions(+)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 7c27c5592ac6e3f44fe873b695d08f25ca0eccc2..3b017ab78ccf7ef501e4022ec95b4d0bb8395ca9 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -16327,20 +16327,27 @@ public final class Settings {
         /**
          * Used to enable / disable the Restricted Networking Mode in which network access is
          * restricted to apps holding the CONNECTIVITY_USE_RESTRICTED_NETWORKS permission.
          *
          * Values are:
          * 0: disabled
          * 1: enabled
          * @hide
          */
         public static final String RESTRICTED_NETWORKING_MODE = "restricted_networking_mode";
+
+        /**
+         * Whether to automatically reboot the device after a user defined timeout
+         *
+         * @hide
+         */
+        public static final String SETTINGS_REBOOT_AFTER_TIMEOUT = "settings_reboot_after_timeout";
     }
 
     /**
      * Configuration system settings, containing settings which are applied identically for all
      * defined users. Only Android can read these and only a specific configuration service can
      * write these.
      *
      * @hide
      */
     public static final class Config extends NameValueTable {
diff --git a/data/etc/com.android.systemui.xml b/data/etc/com.android.systemui.xml
index f2a33de008d6863d1996c85ab2f08be9853679e4..354fd82f3a0ddcaeec7af9e8c5b75484b98aa7d2 100644
--- a/data/etc/com.android.systemui.xml
+++ b/data/etc/com.android.systemui.xml
@@ -41,20 +41,21 @@
         <permission name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/>
         <permission name="android.permission.OBSERVE_NETWORK_POLICY"/>
         <permission name="android.permission.OBSERVE_GRANT_REVOKE_PERMISSIONS" />
         <permission name="android.permission.OVERRIDE_WIFI_CONFIG"/>
         <permission name="android.permission.PACKAGE_USAGE_STATS" />
         <permission name="android.permission.READ_DREAM_STATE"/>
         <permission name="android.permission.READ_FRAME_BUFFER"/>
         <permission name="android.permission.READ_NETWORK_USAGE_HISTORY"/>
         <permission name="android.permission.READ_PRIVILEGED_PHONE_STATE"/>
         <permission name="android.permission.REAL_GET_TASKS"/>
+        <permission name="android.permission.REBOOT"/>
         <permission name="android.permission.REQUEST_NETWORK_SCORES"/>
         <permission name="android.permission.RECEIVE_MEDIA_RESOURCE_USAGE"/>
         <permission name="android.permission.START_ACTIVITIES_FROM_BACKGROUND" />
         <permission name="android.permission.START_ACTIVITY_AS_CALLER"/>
         <permission name="android.permission.START_TASKS_FROM_RECENTS"/>
         <permission name="android.permission.STATUS_BAR"/>
         <permission name="android.permission.STOP_APP_SWITCHES"/>
         <permission name="android.permission.SUBSTITUTE_NOTIFICATION_APP_NAME"/>
         <permission name="android.permission.TETHER_PRIVILEGED"/>
         <permission name="android.permission.UPDATE_APP_OPS_STATS"/>
diff --git a/packages/SystemUI/AndroidManifest.xml b/packages/SystemUI/AndroidManifest.xml
index 9a530af375d91e8a3d41a9a0ccd6179198dceefa..63307dc68ba4c784f6e11ede5f4c86ded5dd8755 100644
--- a/packages/SystemUI/AndroidManifest.xml
+++ b/packages/SystemUI/AndroidManifest.xml
@@ -283,20 +283,23 @@
     <uses-permission android:name="android.permission.MODIFY_SETTINGS_OVERRIDEABLE_BY_RESTORE" />
 
     <!-- Permission to make accessibility service access Bubbles -->
     <uses-permission android:name="android.permission.ADD_TRUSTED_DISPLAY" />
 
     <!-- Permission for Smartspace. -->
     <uses-permission android:name="android.permission.MANAGE_SMARTSPACE" />
 
     <uses-permission android:name="android.permission.READ_PEOPLE_DATA" />
 
+    <!-- Permission to allow rebooting the device after a user configurable amount of time -->
+    <uses-permission android:name="android.permission.REBOOT" />
+
     <protected-broadcast android:name="com.android.settingslib.action.REGISTER_SLICE_RECEIVER" />
     <protected-broadcast android:name="com.android.settingslib.action.UNREGISTER_SLICE_RECEIVER" />
     <protected-broadcast android:name="com.android.settings.flashlight.action.FLASHLIGHT_CHANGED" />
 
     <application
         android:name=".SystemUIApplication"
         android:persistent="true"
         android:allowClearUserData="false"
         android:backupAgent=".backup.BackupHelper"
         android:killAfterRestore="false"
diff --git a/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java b/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
index e9f288d51317b755db31d787e9c04bc75e4512d4..55878a0ed05257248481f296a762943ea51d68e3 100644
--- a/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
+++ b/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java
@@ -179,20 +179,22 @@ import dagger.Lazy;
 public class KeyguardViewMediator extends SystemUI implements Dumpable,
         StatusBarStateController.StateListener {
     private static final int KEYGUARD_DISPLAY_TIMEOUT_DELAY_DEFAULT = 30000;
     private static final long KEYGUARD_DONE_PENDING_TIMEOUT_MS = 3000;
 
     private static final boolean DEBUG = KeyguardConstants.DEBUG;
     private static final boolean DEBUG_SIM_STATES = KeyguardConstants.DEBUG_SIM_STATES;
 
     private final static String TAG = "KeyguardViewMediator";
 
+    private static final String DELAYED_REBOOT_ACTION =
+        "com.android.internal.policy.impl.PhoneWindowManager.DELAYED_REBOOT";
     private static final String DELAYED_KEYGUARD_ACTION =
         "com.android.internal.policy.impl.PhoneWindowManager.DELAYED_KEYGUARD";
     private static final String DELAYED_LOCK_PROFILE_ACTION =
             "com.android.internal.policy.impl.PhoneWindowManager.DELAYED_LOCK";
 
     private static final String SYSTEMUI_PERMISSION = "com.android.systemui.permission.SELF";
 
     // used for handler messages
     private static final int SHOW = 1;
     private static final int HIDE = 2;
@@ -306,20 +308,25 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
      * Helps remember whether the screen has turned on since the last time
      * it turned off due to timeout. see {@link #onScreenTurnedOff(int)}
      */
     private int mDelayedShowingSequence;
 
     /**
      * Simiar to {@link #mDelayedProfileShowingSequence}, but it is for profile case.
      */
     private int mDelayedProfileShowingSequence;
 
+    /**
+     * Same as {@link #mDelayedProfileShowingSequence}, but used for our reboot implementation
+     */
+    private int mDelayedRebootSequence;
+
     /**
      * If the user has disabled the keyguard, then requests to exit, this is
      * how we'll ultimately let them know whether it was successful.  We use this
      * var being non-null as an indicator that there is an in progress request.
      */
     private IKeyguardExitCallback mExitSecureCallback;
     private final DismissCallbackRegistry mDismissCallbackRegistry;
 
     // the properties of the keyguard
 
@@ -898,20 +905,21 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
         mShowKeyguardWakeLock = mPM.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "show keyguard");
         mShowKeyguardWakeLock.setReferenceCounted(false);
 
         IntentFilter filter = new IntentFilter();
         filter.addAction(Intent.ACTION_SHUTDOWN);
         mBroadcastDispatcher.registerReceiver(mBroadcastReceiver, filter);
 
         final IntentFilter delayedActionFilter = new IntentFilter();
         delayedActionFilter.addAction(DELAYED_KEYGUARD_ACTION);
         delayedActionFilter.addAction(DELAYED_LOCK_PROFILE_ACTION);
+        delayedActionFilter.addAction(DELAYED_REBOOT_ACTION);
         mContext.registerReceiver(mDelayedLockBroadcastReceiver, delayedActionFilter,
                 SYSTEMUI_PERMISSION, null /* scheduler */);
 
         mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
 
         KeyguardUpdateMonitor.setCurrentUser(ActivityManager.getCurrentUser());
 
         // Assume keyguard is showing (unless it's disabled) until we know for sure, unless Keyguard
         // is disabled.
         if (isKeyguardServiceEnabled()) {
@@ -1199,37 +1207,53 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
                     lockIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
                     PendingIntent lockSender = PendingIntent.getBroadcast(
                             mContext, 0, lockIntent, PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_MUTABLE_UNAUDITED);
                     mAlarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP,
                             userWhen, lockSender);
                 }
             }
         }
     }
 
+    private void doRebootForOwnerAfterTimeoutIfEnabled(long rebootAfterTimeout) {
+        long when = SystemClock.elapsedRealtime() + rebootAfterTimeout;
+        Intent rebootIntent = new Intent(DELAYED_REBOOT_ACTION);
+        rebootIntent.putExtra("seq", mDelayedRebootSequence);
+        rebootIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
+        PendingIntent sender = PendingIntent.getBroadcast(mContext,
+                0, rebootIntent, PendingIntent.FLAG_CANCEL_CURRENT |  PendingIntent.FLAG_IMMUTABLE);
+        mAlarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, when, sender);
+        if (DEBUG) Log.d(TAG, "setting alarm to reboot device, timeout = "
+                         + String.valueOf(rebootAfterTimeout));
+    }
+
     private void doKeyguardForChildProfilesLocked() {
         UserManager um = UserManager.get(mContext);
         for (int profileId : um.getEnabledProfileIds(UserHandle.myUserId())) {
             if (mLockPatternUtils.isSeparateProfileChallengeEnabled(profileId)) {
                 lockProfile(profileId);
             }
         }
     }
 
     private void cancelDoKeyguardLaterLocked() {
         mDelayedShowingSequence++;
     }
 
     private void cancelDoKeyguardForChildProfilesLocked() {
         mDelayedProfileShowingSequence++;
     }
 
+    private void cancelDoRebootForOwnerAfterTimeoutIfEnabled() {
+        mDelayedRebootSequence++;
+    }
+
     /**
      * Let's us know when the device is waking up.
      */
     public void onStartedWakingUp(boolean cameraGestureTriggered) {
         Trace.beginSection("KeyguardViewMediator#onStartedWakingUp");
 
         // TODO: Rename all screen off/on references to interactive/sleeping
         synchronized (this) {
             mDeviceInteractive = true;
             if (mPendingLock && !cameraGestureTriggered) {
@@ -1578,20 +1602,24 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
                 if (DEBUG) Log.d(TAG, "Not showing lock screen since just decrypted");
                 // Without this, settings is not enabled until the lock screen first appears
                 setShowingLocked(false);
                 hideLocked();
                 return;
             }
         }
 
         if (DEBUG) Log.d(TAG, "doKeyguard: showing the lock screen");
         showLocked(options);
+        final long rebootAfterTimeout = Settings.Global.getLong(mContext.getContentResolver(), Settings.Global.SETTINGS_REBOOT_AFTER_TIMEOUT, 0);
+        if (rebootAfterTimeout >= 1) {
+            doRebootForOwnerAfterTimeoutIfEnabled(rebootAfterTimeout);
+        }
     }
 
     private void lockProfile(int userId) {
         mTrustManager.setDeviceLockedForUser(userId, true);
     }
 
     private boolean shouldWaitForProvisioning() {
         return !mUpdateMonitor.isDeviceProvisioned() && !isSecure();
     }
 
@@ -1777,20 +1805,26 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
             } else if (DELAYED_LOCK_PROFILE_ACTION.equals(intent.getAction())) {
                 final int sequence = intent.getIntExtra("seq", 0);
                 int userId = intent.getIntExtra(Intent.EXTRA_USER_ID, 0);
                 if (userId != 0) {
                     synchronized (KeyguardViewMediator.this) {
                         if (mDelayedProfileShowingSequence == sequence) {
                             lockProfile(userId);
                         }
                     }
                 }
+            } else if (DELAYED_REBOOT_ACTION.equals(intent.getAction())) {
+                final int sequence = intent.getIntExtra("seq", 0);
+                if (sequence == mDelayedRebootSequence) {
+                    PowerManager pm = mContext.getSystemService(PowerManager.class);
+                    pm.reboot(null);
+                }
             }
         }
     };
 
     private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
             if (Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
                 synchronized (KeyguardViewMediator.this){
                     mShuttingDown = true;
@@ -2363,20 +2397,21 @@ public class KeyguardViewMediator extends SystemUI implements Dumpable,
             playSounds(false);
         }
 
         setShowingLocked(false);
         mWakeAndUnlocking = false;
         mDismissCallbackRegistry.notifyDismissSucceeded();
         resetKeyguardDonePendingLocked();
         mHideAnimationRun = false;
         adjustStatusBarLocked();
         sendUserPresentBroadcast();
+        cancelDoRebootForOwnerAfterTimeoutIfEnabled();
     }
 
     private Configuration.Builder createInteractionJankMonitorConf(String tag) {
         return Configuration.Builder.withView(CUJ_LOCKSCREEN_UNLOCK_ANIMATION,
                 mKeyguardViewControllerLazy.get().getViewRootImpl().getView())
                 .setTag(tag);
     }
 
     /**
      * Whether we're currently animating between the keyguard and the app/launcher surface behind

commit aaf7188d05a9f151fe972cd688e1285ca9bb8029
Author: flawedworld <flawedworld@flawed.world>
Date:   Tue 2021-09-28 15:25:03+0100

    Always show APN settings on CDMA carriers
---
 telephony/java/android/telephony/CarrierConfigManager.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/telephony/java/android/telephony/CarrierConfigManager.java b/telephony/java/android/telephony/CarrierConfigManager.java
index b8a14b8ea72e8105f1fad9630fd4088b66f94924..51cbd880af77067ec1fa549349c881d592793ab5 100644
--- a/telephony/java/android/telephony/CarrierConfigManager.java
+++ b/telephony/java/android/telephony/CarrierConfigManager.java
@@ -5335,21 +5335,21 @@ public class CarrierConfigManager {
         sDefaults.putBoolean(KEY_CALL_FORWARDING_WHEN_UNREACHABLE_SUPPORTED_BOOL, true);
         sDefaults.putBoolean(KEY_CALL_FORWARDING_WHEN_UNANSWERED_SUPPORTED_BOOL, true);
         sDefaults.putBoolean(KEY_CALL_FORWARDING_WHEN_BUSY_SUPPORTED_BOOL, true);
         sDefaults.putBoolean(KEY_ADDITIONAL_SETTINGS_CALLER_ID_VISIBILITY_BOOL, true);
         sDefaults.putBoolean(KEY_ADDITIONAL_SETTINGS_CALL_WAITING_VISIBILITY_BOOL, true);
         sDefaults.putBoolean(KEY_DISABLE_SUPPLEMENTARY_SERVICES_IN_AIRPLANE_MODE_BOOL, false);
         sDefaults.putBoolean(KEY_IGNORE_SIM_NETWORK_LOCKED_EVENTS_BOOL, false);
         sDefaults.putBoolean(KEY_MDN_IS_ADDITIONAL_VOICEMAIL_NUMBER_BOOL, false);
         sDefaults.putBoolean(KEY_OPERATOR_SELECTION_EXPAND_BOOL, true);
         sDefaults.putBoolean(KEY_PREFER_2G_BOOL, true);
-        sDefaults.putBoolean(KEY_SHOW_APN_SETTING_CDMA_BOOL, false);
+        sDefaults.putBoolean(KEY_SHOW_APN_SETTING_CDMA_BOOL, true);
         sDefaults.putBoolean(KEY_SHOW_CDMA_CHOICES_BOOL, false);
         sDefaults.putBoolean(KEY_SMS_REQUIRES_DESTINATION_NUMBER_CONVERSION_BOOL, false);
         sDefaults.putBoolean(KEY_SUPPORT_EMERGENCY_SMS_OVER_IMS_BOOL, false);
         sDefaults.putBoolean(KEY_SHOW_ONSCREEN_DIAL_BUTTON_BOOL, true);
         sDefaults.putBoolean(KEY_SIM_NETWORK_UNLOCK_ALLOW_DISMISS_BOOL, true);
         sDefaults.putBoolean(KEY_SUPPORT_PAUSE_IMS_VIDEO_CALLS_BOOL, false);
         sDefaults.putBoolean(KEY_SUPPORT_SWAP_AFTER_MERGE_BOOL, true);
         sDefaults.putBoolean(KEY_USE_HFA_FOR_PROVISIONING_BOOL, false);
         sDefaults.putBoolean(KEY_EDITABLE_VOICEMAIL_NUMBER_SETTING_BOOL, true);
         sDefaults.putBoolean(KEY_EDITABLE_VOICEMAIL_NUMBER_BOOL, false);

commit b1adc562add423fdad768e2413a4d5343dcce1e2
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2016-06-16 01:19:53-0400

    implement dynamic deny_new_usb toggle mode
---
 .../com/android/server/policy/keyguard/KeyguardStateMonitor.java     | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/services/core/java/com/android/server/policy/keyguard/KeyguardStateMonitor.java b/services/core/java/com/android/server/policy/keyguard/KeyguardStateMonitor.java
index e6511372d62cabf311be637dbc1b352083c54392..c20ac81a9f56e9caf1366d67d9dd240b3ff1c1a6 100644
--- a/services/core/java/com/android/server/policy/keyguard/KeyguardStateMonitor.java
+++ b/services/core/java/com/android/server/policy/keyguard/KeyguardStateMonitor.java
@@ -12,20 +12,21 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.android.server.policy.keyguard;
 
 import android.app.ActivityManager;
 import android.content.Context;
 import android.os.RemoteException;
+import android.os.SystemProperties;
 import android.util.Slog;
 
 import com.android.internal.policy.IKeyguardService;
 import com.android.internal.policy.IKeyguardStateCallback;
 import com.android.internal.widget.LockPatternUtils;
 
 import java.io.PrintWriter;
 
 /**
  * Maintains a cached copy of Keyguard's state.
@@ -76,20 +77,24 @@ public class KeyguardStateMonitor extends IKeyguardStateCallback.Stub {
 
     public boolean isTrusted() {
         return mTrusted;
     }
 
     @Override // Binder interface
     public void onShowingStateChanged(boolean showing) {
         mIsShowing = showing;
 
         mCallback.onShowingChanged();
+
+        if ("dynamic".equals(SystemProperties.get("persist.security.deny_new_usb"))) {
+            SystemProperties.set("security.deny_new_usb", showing ? "1" : "0");
+        }
     }
 
     @Override // Binder interface
     public void onSimSecureStateChanged(boolean simSecure) {
         mSimSecure = simSecure;
     }
 
     public synchronized void setCurrentUser(int userId) {
         mCurrentUserId = userId;
     }

commit 1179ca02dcaa16c19e30fa5c307734dc3884d8ac
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2017-07-25 11:22:33-0400

    add system property for disabling keyguard camera
    
    Change-Id: I0b65cac3c3d2fc495b339c34add742bd698b107c
---
 .../android/systemui/statusbar/phone/KeyguardBottomAreaView.java  | 4 +++-
 services/core/java/com/android/server/GestureLauncherService.java | 8 ++++++++
 2 files changed, 11 insertions(+), 1 deletion(-)

diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java
index aeef8cd433abba7b2a23442f7025a106c8fee8ad..a20019badaf7b0301f2a370214bd83114f611771 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBottomAreaView.java
@@ -43,20 +43,21 @@ import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
 import android.content.res.ColorStateList;
 import android.content.res.Configuration;
 import android.graphics.drawable.Drawable;
 import android.os.AsyncTask;
 import android.os.Bundle;
 import android.os.IBinder;
 import android.os.Message;
 import android.os.Messenger;
 import android.os.RemoteException;
+import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.provider.MediaStore;
 import android.service.media.CameraPrewarmService;
 import android.service.quickaccesswallet.GetWalletCardsError;
 import android.service.quickaccesswallet.GetWalletCardsResponse;
 import android.service.quickaccesswallet.QuickAccessWalletClient;
 import android.telecom.TelecomManager;
 import android.text.TextUtils;
 import android.util.AttributeSet;
 import android.util.Log;
@@ -990,21 +991,22 @@ public class KeyguardBottomAreaView extends FrameLayout implements View.OnClickL
     private class DefaultRightButton implements IntentButton {
 
         private IconState mIconState = new IconState();
 
         @Override
         public IconState getIcon() {
             boolean isCameraDisabled = (mStatusBar != null) && !mStatusBar.isCameraAllowedByAdmin();
             mIconState.isVisible = !isCameraDisabled
                     && mShowCameraAffordance
                     && mUserSetupComplete
-                    && resolveCameraIntent() != null;
+                    && resolveCameraIntent() != null
+                    && SystemProperties.getBoolean("persist.keyguard.camera", true);
             mIconState.drawable = mContext.getDrawable(R.drawable.ic_camera_alt_24dp);
             mIconState.contentDescription =
                     mContext.getString(R.string.accessibility_camera_button);
             return mIconState;
         }
 
         @Override
         public Intent getIntent() {
             boolean canDismissLs = mKeyguardStateController.canDismissLockScreen();
             boolean secure = mKeyguardStateController.isMethodSecure();
diff --git a/services/core/java/com/android/server/GestureLauncherService.java b/services/core/java/com/android/server/GestureLauncherService.java
index d04698cb5aeb6d70d7457f2c691d30e348dd40a9..0ba4f550c5f400d1c04e8f48f594640bf24edc6f 100644
--- a/services/core/java/com/android/server/GestureLauncherService.java
+++ b/services/core/java/com/android/server/GestureLauncherService.java
@@ -10,20 +10,21 @@
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.android.server;
 
 import android.app.ActivityManager;
+import android.app.KeyguardManager;
 import android.app.StatusBarManager;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.res.Resources;
 import android.database.ContentObserver;
 import android.hardware.Sensor;
 import android.hardware.SensorEvent;
 import android.hardware.SensorEventListener;
@@ -519,20 +520,27 @@ public class GestureLauncherService extends SystemService {
         // user has completed setup.
         return intercept && isUserSetupComplete();
     }
     /**
      * @return true if camera was launched, false otherwise.
      */
     @VisibleForTesting
     boolean handleCameraGesture(boolean useWakelock, int source) {
         Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "GestureLauncher:handleCameraGesture");
         try {
+            if (!SystemProperties.getBoolean("persist.keyguard.camera", true)) {
+                final KeyguardManager manager = (KeyguardManager) getContext().getSystemService(
+                        Context.KEYGUARD_SERVICE);
+                if (manager.inKeyguardRestrictedInputMode()) {
+                    return false;
+                }
+            }
             boolean userSetupComplete = isUserSetupComplete();
             if (!userSetupComplete) {
                 if (DBG) {
                     Slog.d(TAG, String.format(
                             "userSetupComplete = %s, ignoring camera gesture.",
                             userSetupComplete));
                 }
                 return false;
             }
             if (DBG) {

commit 8c04422193b7c782e2388b64389c736ee285a654
Author: Pratyush <39559233+empratyush@users.noreply.github.com>
Date:   Sun 2021-05-02 00:36:30+0000

    enable backup service for non-owner users
---
 .../server/backup/BackupManagerService.java        | 48 ++++++++++++++++++++++
 1 file changed, 48 insertions(+)

diff --git a/services/backup/java/com/android/server/backup/BackupManagerService.java b/services/backup/java/com/android/server/backup/BackupManagerService.java
index 38275f7cd34838b14f1e07999ff82ed2d56dcc06..1014f5dab3e723e37be43c3bcaaf94e755ea5659 100644
--- a/services/backup/java/com/android/server/backup/BackupManagerService.java
+++ b/services/backup/java/com/android/server/backup/BackupManagerService.java
@@ -35,32 +35,35 @@ import android.app.backup.ISelectBackupTransportCallback;
 import android.app.compat.CompatChanges;
 import android.app.job.JobParameters;
 import android.app.job.JobScheduler;
 import android.app.job.JobService;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
+import android.content.pm.UserInfo;
 import android.os.Binder;
 import android.os.FileUtils;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.IBinder;
 import android.os.ParcelFileDescriptor;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.SystemProperties;
 import android.os.Trace;
 import android.os.UserHandle;
 import android.os.UserManager;
+import android.provider.Settings;
+import android.util.Log;
 import android.util.Slog;
 import android.util.SparseArray;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.DumpUtils;
 import com.android.server.SystemConfig;
 import com.android.server.SystemService;
 import com.android.server.backup.utils.RandomAccessFileUtils;
 
@@ -148,41 +151,86 @@ public class BackupManagerService extends IBackupManager.Stub {
         public void onReceive(Context context, Intent intent) {
             if (Intent.ACTION_USER_REMOVED.equals(intent.getAction())) {
                 int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);
                 if (userId > 0) { // for only non system users
                     mHandler.post(() -> onRemovedNonSystemUser(userId));
                 }
             }
         }
     };
 
+    
+    private final BroadcastReceiver mUserAddedReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (Intent.ACTION_USER_ADDED.equals(intent.getAction())) {
+                int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);
+                Log.d(TAG, "new user added User ID : " + userId);
+                if (userId > 0) {
+                mHandler.post(() -> setBackupServiceActive(userId, true));
+                }
+            }
+        }
+    };
+    
     public BackupManagerService(Context context) {
         this(context, new SparseArray<>());
     }
 
     @VisibleForTesting
     BackupManagerService(Context context, SparseArray<UserBackupManagerService> userServices) {
         mContext = context;
         mGlobalDisable = isBackupDisabled();
         HandlerThread handlerThread =
                 new HandlerThread(BACKUP_THREAD, Process.THREAD_PRIORITY_BACKGROUND);
         handlerThread.start();
         mHandler = new Handler(handlerThread.getLooper());
         mUserManager = UserManager.get(context);
         mUserServices = userServices;
         Set<ComponentName> transportWhitelist =
                 SystemConfig.getInstance().getBackupTransportWhitelist();
         mTransportWhitelist = (transportWhitelist == null) ? emptySet() : transportWhitelist;
         mContext.registerReceiver(
                 mUserRemovedReceiver, new IntentFilter(Intent.ACTION_USER_REMOVED));
+        
+        
+        mContext.registerReceiver(
+                mUserAddedReceiver, new IntentFilter(Intent.ACTION_USER_ADDED));
+        
+        if (shouldMigrateExistingUser(context)) {
+            List<UserInfo> managerUsers = mUserManager.getUsers();
+                for (UserInfo userInfo : managerUsers) {
+                    setBackupServiceActive(
+                        userInfo.getUserHandle().getIdentifier(),
+                        true
+                    );
+            }
+
+            markExistingUserMigrated(context);
+        }
+        
     }
 
+    private static final String PROFILE_MIGRATION_COMPLETED = "graphene_existing_users_migration";
+    
+    private boolean markExistingUserMigrated(Context context) {
+        return Settings.Global.putInt(context.getContentResolver(), PROFILE_MIGRATION_COMPLETED, 1);
+    }
+    
+    private boolean shouldMigrateExistingUser(Context context) {
+        return Settings.Global.getInt(
+                context.getContentResolver(),
+                PROFILE_MIGRATION_COMPLETED,
+                0
+            ) != 1;
+    }
+    
     // TODO: Remove this when we implement DI by injecting in the construtor.
     @VisibleForTesting
     Handler getBackupHandler() {
         return mHandler;
     }
 
     protected boolean isBackupDisabled() {
         return SystemProperties.getBoolean(BACKUP_DISABLE_PROPERTY, false);
     }
 

commit 508cfd82b9e3b7ae8379a6e21cae110508d30b4b
Author: Rusty Bird <rustybird@net-c.com>
Date:   Wed 2020-04-22 18:28:33+0000

    disable safe volume everywhere, not just the US
    
    Safe Volume has many false alarms. And if overridden by the user, at
    every 20 hours of accumulated(!) audio playback it will intentionally
    reset - even while the audio is playing. This can ruin the listening
    experience, and ironically pose a safety hazard when e.g. the user is
    operating a vehicle...
    
    AOSP already opted out of Safe Volume in the overlays for Mobile Country
    Code 310-316 (= US). Make this universal.
    
    Signed-off-by: Rusty Bird <rustybird@net-c.com>
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 44ef37c9103eec75e89211595aeee25d308eaa11..f3cef664adec6461f0021d30fd5e8353970b0674 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2638,21 +2638,21 @@
              0 - COLOR_MODE_DEFAULT
              7 - COLOR_MODE_SRGB
     -->
     <integer name="config_defaultDisplayDefaultColorMode">0</integer>
 
     <!-- When true use the linux /dev/input/event subsystem to detect the switch changes
          on the headphone/microphone jack. When false use the older uevent framework. -->
     <bool name="config_useDevInputEventForAudioJack">false</bool>
 
     <!-- Whether safe headphone volume is enabled or not (country specific). -->
-    <bool name="config_safe_media_volume_enabled">true</bool>
+    <bool name="config_safe_media_volume_enabled">false</bool>
 
     <!-- Whether safe headphone volume warning dialog is disabled on Vol+ (operator specific). -->
     <bool name="config_safe_media_disable_on_volume_up">true</bool>
 
     <!-- Set to true if the wifi display supports compositing content stored
          in gralloc protected buffers.  For this to be true, there must exist
          a protected hardware path for surface flinger to composite and send
          protected buffers to the wifi display video encoder.
 
          If this flag is false, we advise applications not to use protected

commit 8a15775ec39f977ee6465e71ac53e4bf0d574152
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2019-03-17 19:11:12-0400

    SystemUI: enable NFC quick settings tile
---
 packages/SystemUI/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/packages/SystemUI/res/values/config.xml b/packages/SystemUI/res/values/config.xml
index e00b9410a8a7849a49d2b9f5f06a49b9a2b31d09..5ef87d077f22b0e78635bc1197252bf72c19c2b8 100644
--- a/packages/SystemUI/res/values/config.xml
+++ b/packages/SystemUI/res/values/config.xml
@@ -75,21 +75,21 @@
     <!-- The default tiles to display in QuickSettings -->
     <string name="quick_settings_tiles_default" translatable="false">
         internet,bt,flashlight,dnd,alarm,airplane,controls,wallet,rotation,battery,cast,screenrecord,mictoggle,cameratoggle
     </string>
 
     <!-- The minimum number of tiles to display in QuickSettings -->
     <integer name="quick_settings_min_num_tiles">6</integer>
 
     <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default" -->
     <string name="quick_settings_tiles_stock" translatable="false">
-        internet,bt,flashlight,dnd,alarm,airplane,controls,wallet,rotation,battery,cast,screenrecord,mictoggle,cameratoggle,location,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness
+        internet,bt,flashlight,dnd,alarm,airplane,controls,wallet,rotation,battery,cast,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness
     </string>
 
     <!-- The tiles to display in QuickSettings -->
     <string name="quick_settings_tiles" translatable="false">default</string>
 
     <!-- The tiles to display in QuickSettings in retail mode -->
     <string name="quick_settings_tiles_retail_mode" translatable="false">
         night,dark,dnd,flashlight,rotation,location
     </string>
 

commit e0e425dfd6e82e29b2326e98819737b7e6ead3df
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Mon 2017-01-02 18:51:57-0500

    hide sensitive information while locked by default
---
 packages/SettingsProvider/res/values/defaults.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/packages/SettingsProvider/res/values/defaults.xml b/packages/SettingsProvider/res/values/defaults.xml
index 93efe5060a2f642841b4d662225d30935e9b48b7..26ae277751730765f7ecdd688b9d824b00bccbe4 100644
--- a/packages/SettingsProvider/res/values/defaults.xml
+++ b/packages/SettingsProvider/res/values/defaults.xml
@@ -156,21 +156,21 @@
          Override to disable immersive mode confirmation for certain packages. -->
     <string name="def_immersive_mode_confirmations" translatable="false"></string>
 
     <!-- Default for Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE -->
     <integer name="def_wifi_scan_always_available">0</integer>
 
     <!-- Default for Settings.Secure.LOCK_SCREEN_SHOW_NOTIFICATIONS, 1==on -->
     <integer name="def_lock_screen_show_notifications">1</integer>
 
     <!-- Default for Settings.Secure.LOCK_SCREEN_ALLOW_PRIVATE_NOTIFICATIONS -->
-    <bool name="def_lock_screen_allow_private_notifications">true</bool>
+    <bool name="def_lock_screen_allow_private_notifications">false</bool>
 
     <!-- Default for Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED, 1==on -->
     <integer name="def_heads_up_enabled">1</integer>
 
     <!-- Default for Settings.Global.DEVICE_NAME $1=MANUFACTURER $2=MODEL-->
     <string name="def_device_name">%1$s %2$s</string>
 
     <!-- Default for Settings.Global.DEVICE_NAME $1=MODEL-->
     <string name="def_device_name_simple">%1$s</string>
 

commit 9a9f31ebc7a4a8e98ad1e90ee73ecb3fec40976e
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2017-02-03 06:53:00-0500

    set TEXT_SHOW_PASSWORD to false by default
---
 packages/SettingsProvider/res/values/defaults.xml                      | 2 ++
 .../src/com/android/providers/settings/DatabaseHelper.java             | 3 +++
 2 files changed, 5 insertions(+)

diff --git a/packages/SettingsProvider/res/values/defaults.xml b/packages/SettingsProvider/res/values/defaults.xml
index 26ae277751730765f7ecdd688b9d824b00bccbe4..5eea681b8566f9268fad65428c50e05fc46925f7 100644
--- a/packages/SettingsProvider/res/values/defaults.xml
+++ b/packages/SettingsProvider/res/values/defaults.xml
@@ -252,11 +252,13 @@
 
     <!-- Default for Settings.Global.DEVELOPMENT_ENABLE_NON_RESIZABLE_MULTI_WINDOW -->
     <bool name="def_enable_non_resizable_multi_window">false</bool>
 
     <!-- Default for Settings.Secure.ACCESSIBILITY_BUTTON_MODE -->
     <integer name="def_accessibility_button_mode">1</integer>
 
     <!-- Default for Settings.Secure.ONE_HANDED_MODE_ACTIVATED -->
     <bool name="def_one_handed_mode_activated">false</bool>
 
+    <bool name="def_text_show_password">false</bool>
+
 </resources>
diff --git a/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java b/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
index 268603fa8b0d71d87aca4527ecd807fef82bae59..537090b83e94b58fa35e28d795b9b9335a52c023 100644
--- a/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
+++ b/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
@@ -2270,20 +2270,23 @@ class DatabaseHelper extends SQLiteOpenHelper {
             loadDefaultHapticSettings(stmt);
 
             loadBooleanSetting(stmt, Settings.System.NOTIFICATION_LIGHT_PULSE,
                     R.bool.def_notification_pulse);
 
             loadUISoundEffectsSettings(stmt);
 
             loadIntegerSetting(stmt, Settings.System.POINTER_SPEED,
                     R.integer.def_pointer_speed);
 
+            loadBooleanSetting(stmt, Settings.System.TEXT_SHOW_PASSWORD,
+                    R.bool.def_text_show_password);
+
             /*
              * IMPORTANT: Do not add any more upgrade steps here as the global,
              * secure, and system settings are no longer stored in a database
              * but are kept in memory and persisted to XML.
              *
              * See: SettingsProvider.UpgradeController#onUpgradeLocked
              */
         } finally {
             if (stmt != null) stmt.close();
         }

commit ec05336b893a1299d01bb95dc52d8ff78801f6fe
Author: inthewaves <inthewaves@pm.me>
Date:   Sun 2020-09-20 14:59:10-0700

    have NfcTile get an NfcAdapter directly
    
    This changes the NfcTile to not be dependent on an NfcManager giving the
    NfcTile an NfcAdapter.
    
    The problem with NfcTile is that the NfcService doesn't start until the
    device is unlocked after a reboot, but NfcTile can be created and have
    its state updated before the device is unlocked.
    
    The state of NfcTile depends on an NfcAdapter. The tile gets an
    NfcAdapter from a call to NfcAdapter#getDefaultAdapter, which gets an
    adapter from an NfcManager via Context#getSystemService, and NfcManager
    tries to get an adapter in its constructor via NfcAdapter#getNfcAdapter.
    
    If this is done before unlock, NfcService isn't started, so the
    constructor of NfcManager fails to get an adapter, opting to just store
    null. This means that the NfcManager that's _cached_ by the NfcTile's
    application context holds a null NfcAdapter, so subsequent calls in
    NfcTile to get the NfcAdapter will keep returning null.
    
    We can just have NfcTile get the NfcAdapter directly via
    NfcAdapter#getNfcAdapter instead of relying on an NfcManager to call the
    same method for us to get its default adapter. We just have to make sure
    we use the application context for NfcAdapter#getNfcAdapter, as per the
    doc comments for getNfcAdapter. This means that there's no longer an
    NfcManager associated with the NfcTile's application context.
    
    It doesn't look like NfcManager does anything special with the
    NfcAdapter anyway. It seems to just be some middle man for NfcAdapters:
    * The NfcAdapter field in NfcManager is final, and it doesn't do
    anything else with it besides have a getter method for returning it. The
    NfcManager seems to be a way to force third-party apps that want to get
    an NfcAdapter to use the application context.
    * NfcAdapter#getNfcAdapter manages the caching of NfcAdapters by
    application context in a static HashMap. NfcManager doesn't manage
    caching; it just calls NfcAdapter#getNfcAdapter.
---
 packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java
index cd2e27a41f1e75eb974c16878a9692b225aa9c54..b9bc0e5ca814756708a38ec0b35ac2994ebb7353 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java
@@ -152,21 +152,21 @@ public class NfcTile extends QSTileImpl<BooleanState> {
         if (mState.value) {
             return mContext.getString(R.string.quick_settings_nfc_on);
         } else {
             return mContext.getString(R.string.quick_settings_nfc_off);
         }
     }
 
     private NfcAdapter getAdapter() {
         if (mAdapter == null) {
             try {
-                mAdapter = NfcAdapter.getDefaultAdapter(mContext);
+                mAdapter = NfcAdapter.getNfcAdapter(mContext.getApplicationContext());
             } catch (UnsupportedOperationException e) {
                 mAdapter = null;
             }
         }
         return mAdapter;
     }
 
     private BroadcastReceiver mNfcReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {

commit 3097eeff5fbf0e0a09baf76373a8b5e6c1a64ab5
Author: flawedworld <flawedworld@flawed.world>
Date:   Fri 2021-10-15 17:07:13+0100

    enable secondary user logout support by default
    
    Ported from 11, 12 moved the isLogoutEnabled boolean to ActiveAdmin.java
---
 .../java/com/android/server/devicepolicy/ActiveAdmin.java             | 2 +-
 .../com/android/server/devicepolicy/DevicePolicyManagerService.java   | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/services/devicepolicy/java/com/android/server/devicepolicy/ActiveAdmin.java b/services/devicepolicy/java/com/android/server/devicepolicy/ActiveAdmin.java
index 37a84f3698c13d880cbdd37e9486a54633c3d856..0ae88276ebda6b13e890a219cfa9067e66f7b3fd 100644
--- a/services/devicepolicy/java/com/android/server/devicepolicy/ActiveAdmin.java
+++ b/services/devicepolicy/java/com/android/server/devicepolicy/ActiveAdmin.java
@@ -190,21 +190,21 @@ class ActiveAdmin {
     boolean encryptionRequested = false;
     boolean testOnlyAdmin = false;
     boolean disableCamera = false;
     boolean disableCallerId = false;
     boolean disableContactsSearch = false;
     boolean disableBluetoothContactSharing = true;
     boolean disableScreenCapture = false;
     boolean requireAutoTime = false;
     boolean forceEphemeralUsers = false;
     boolean isNetworkLoggingEnabled = false;
-    boolean isLogoutEnabled = false;
+    boolean isLogoutEnabled = true;
 
     // one notification after enabling + one more after reboots
     static final int DEF_MAXIMUM_NETWORK_LOGGING_NOTIFICATIONS_SHOWN = 2;
     int numNetworkLoggingNotifications = 0;
     long lastNetworkLoggingNotificationTimeMs = 0; // Time in milliseconds since epoch
 
     ActiveAdmin parentAdmin;
     final boolean isParent;
 
     static class TrustAgentInfo {
diff --git a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java
index 774a485aac6bec600ddc96c56cb88a04cebd3d65..a2702faa4010935fd647a0fcc34e6c5e572758a3 100644
--- a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java
+++ b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java
@@ -15762,25 +15762,25 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
                 return;
             }
             deviceOwner.isLogoutEnabled = enabled;
             saveSettingsLocked(caller.getUserId());
         }
     }
 
     @Override
     public boolean isLogoutEnabled() {
         if (!mHasFeature) {
-            return false;
+            return true;
         }
         synchronized (getLockObject()) {
             ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();
-            return (deviceOwner != null) && deviceOwner.isLogoutEnabled;
+            return (deviceOwner == null) || deviceOwner.isLogoutEnabled;
         }
     }
 
     @Override
     public List<String> getDisallowedSystemApps(ComponentName admin, int userId,
             String provisioningAction) throws RemoteException {
         Preconditions.checkCallAuthorization(
                 hasCallingOrSelfPermission(permission.MANAGE_PROFILE_AND_DEVICE_OWNERS));
 
         return new ArrayList<>(

commit 64b3a67fd43cb0497059a73687624f4b5879d4c7
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sun 2020-12-20 15:53:52-0500

    add check for empty TTS engine name
---
 core/java/android/speech/tts/TtsEngines.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/java/android/speech/tts/TtsEngines.java b/core/java/android/speech/tts/TtsEngines.java
index a8aea7c1eb599bcf8d66f0ef25099691c32eb8a2..3697b9494949d93a83c6fe1136140f465d3b3863 100644
--- a/core/java/android/speech/tts/TtsEngines.java
+++ b/core/java/android/speech/tts/TtsEngines.java
@@ -491,21 +491,21 @@ public class TtsEngines {
         }
     }
 
     /**
      * Parses a comma separated list of engine locale preferences. The list is of the
      * form {@code "engine_name_1:locale_1,engine_name_2:locale2"} and so on and
      * so forth. Returns null if the list is empty, malformed or if there is no engine
      * specific preference in the list.
      */
     private static String parseEnginePrefFromList(String prefValue, String engineName) {
-        if (TextUtils.isEmpty(prefValue)) {
+        if (TextUtils.isEmpty(prefValue) || TextUtils.isEmpty(engineName)) {
             return null;
         }
 
         String[] prefValues = prefValue.split(",");
 
         for (String value : prefValues) {
             final int delimiter = value.indexOf(':');
             if (delimiter > 0) {
                 if (engineName.equals(value.substring(0, delimiter))) {
                     return value.substring(delimiter + 1);

commit 3890ef5d03c29a3c15f26b1d931bb75f776bc7b7
Author: inthewaves <inthewaves@pm.me>
Date:   Thu 2021-05-06 20:42:26-0700

    use more loadDrawableAsUser in MediaDataManager
---
 packages/SystemUI/src/com/android/systemui/media/MediaDataManager.kt | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/packages/SystemUI/src/com/android/systemui/media/MediaDataManager.kt b/packages/SystemUI/src/com/android/systemui/media/MediaDataManager.kt
index 7c0f7fc2967e436be57cdda66ee14f7fa1ac2aa1..7ef81d158ecd0150e9556ff92565a4673f115b52 100644
--- a/packages/SystemUI/src/com/android/systemui/media/MediaDataManager.kt
+++ b/packages/SystemUI/src/com/android/systemui/media/MediaDataManager.kt
@@ -552,21 +552,22 @@ class MediaDataManager(
         } else {
             Icon.createWithBitmap(artworkBitmap)
         }
         if (artWorkIcon != null) {
             // If we have art, get colors from that
             if (artworkBitmap == null) {
                 if (artWorkIcon.type == Icon.TYPE_BITMAP ||
                         artWorkIcon.type == Icon.TYPE_ADAPTIVE_BITMAP) {
                     artworkBitmap = artWorkIcon.bitmap
                 } else {
-                    val drawable: Drawable = artWorkIcon.loadDrawable(context)
+                    val drawable: Drawable = artWorkIcon.loadDrawableAsUser(context,
+                            sbn.user.identifier)
                     artworkBitmap = Bitmap.createBitmap(
                             drawable.intrinsicWidth,
                             drawable.intrinsicHeight,
                             Bitmap.Config.ARGB_8888)
                     val canvas = Canvas(artworkBitmap)
                     drawable.setBounds(0, 0, drawable.intrinsicWidth, drawable.intrinsicHeight)
                     drawable.draw(canvas)
                 }
             }
         }

commit 1b52be28f49223ec3d14759bc0862ff201f0e187
Author: pratyush <codelab@pratyush.dev>
Date:   Thu 2021-07-01 12:26:49+0530

    Bluetooth auto turn off
---
 core/java/android/provider/Settings.java           |  6 ++
 .../android/server/BluetoothManagerService.java    | 76 ++++++++++++++++++++++
 2 files changed, 82 insertions(+)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 3b017ab78ccf7ef501e4022ec95b4d0bb8395ca9..722fe7c081131ab51f722cff040a06da11e8da24 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -16334,20 +16334,26 @@ public final class Settings {
          * @hide
          */
         public static final String RESTRICTED_NETWORKING_MODE = "restricted_networking_mode";
 
         /**
          * Whether to automatically reboot the device after a user defined timeout
          *
          * @hide
          */
         public static final String SETTINGS_REBOOT_AFTER_TIMEOUT = "settings_reboot_after_timeout";
+        
+        /**
+         * The amount of time in milliseconds before bluetooth is turned off
+         * @hide
+         */
+        public static final String BLUETOOTH_OFF_TIMEOUT = "bluetooth_off_timeout";
     }
 
     /**
      * Configuration system settings, containing settings which are applied identically for all
      * defined users. Only Android can read these and only a specific configuration service can
      * write these.
      *
      * @hide
      */
     public static final class Config extends NameValueTable {
diff --git a/services/core/java/com/android/server/BluetoothManagerService.java b/services/core/java/com/android/server/BluetoothManagerService.java
index ff24c6f16c422de9f5ec395334f0055b420585ec..9a96285deb3e686bf7f8e49423f6ebfe8d31e72d 100644
--- a/services/core/java/com/android/server/BluetoothManagerService.java
+++ b/services/core/java/com/android/server/BluetoothManagerService.java
@@ -22,20 +22,21 @@ import static android.content.PermissionChecker.PID_UNKNOWN;
 import static android.content.pm.PackageManager.MATCH_SYSTEM_ONLY;
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.os.PowerExemptionManager.TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_ALLOWED;
 import static android.os.UserHandle.USER_SYSTEM;
 
 import android.Manifest;
 import android.annotation.NonNull;
 import android.annotation.RequiresPermission;
 import android.annotation.SuppressLint;
 import android.app.ActivityManager;
+import android.app.AlarmManager;
 import android.app.AppGlobals;
 import android.app.AppOpsManager;
 import android.app.BroadcastOptions;
 import android.bluetooth.BluetoothA2dp;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothHearingAid;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.BluetoothProtoEnums;
 import android.bluetooth.IBluetooth;
 import android.bluetooth.IBluetoothCallback;
@@ -542,20 +543,95 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
             systemUiUid = pm.getPackageUid(pm.getSystemUiServiceComponent().getPackageName(),
                     MATCH_SYSTEM_ONLY, USER_SYSTEM);
         }
         if (systemUiUid >= 0) {
             Slog.d(TAG, "Detected SystemUiUid: " + Integer.toString(systemUiUid));
         } else {
             // Some platforms, such as wearables do not have a system ui.
             Slog.w(TAG, "Unable to resolve SystemUI's UID.");
         }
         mSystemUiUid = systemUiUid;
+
+        /*
+        * System sends ACTION_STATE_CHANGED broadcast soon as any state
+        * changes. what it means in action is we don't have to take care if
+        * device reboot while BT has not been turned off automatically.
+        *
+        * A word of warning though it does not check if device as been
+        * unlocked or not what it means in real life is if you have sometime
+        * like tile ble tracker configured it will turn off BT. As result tile
+        * tracking will fail because of auto timeout. this behaviour can be
+        * changed with UserManager.isUnlocked()
+        * */
+        IntentFilter btFilter = new IntentFilter();
+        btFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
+        btFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
+        btFilter.addAction(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
+        context.registerReceiver(new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context broadcastContext, Intent intent) {
+                reconfigureBtTimeoutListener();
+            }
+        }, btFilter);
+
+        context.getContentResolver().registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.BLUETOOTH_OFF_TIMEOUT),
+                false,
+                new ContentObserver(new Handler(context.getMainLooper())) {
+                    @Override
+                    public void onChange(boolean selfChange) {
+                        super.onChange(selfChange);
+                        reconfigureBtTimeoutListener();
+                    }
+                });
+    }
+
+    private static final AlarmManager.OnAlarmListener listener = () -> {
+        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+        if (isBtOnAndDisconnected() && bluetoothAdapter != null) {
+            bluetoothAdapter.disable();
+        }
+    };
+
+    // If device is still connected cancel timeout for now and wait for disconnected signal
+    private void reconfigureBtTimeoutListener() {
+        AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
+        if (isTimeoutEnabled(mContext) && isBtOnAndDisconnected()) {
+            final long timeout = SystemClock.elapsedRealtime() + btTimeoutDurationInMilli(mContext);
+            alarmManager.cancel(listener);
+            alarmManager.setExact(
+                    AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                    timeout,
+                    "BT Idle Timeout",
+                    listener,
+                    new Handler(mContext.getMainLooper())
+            );
+        } else {
+            alarmManager.cancel(listener);
+        }
+    }
+
+    private static boolean isBtOnAndDisconnected() {
+        BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+        return bluetoothAdapter != null && bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON
+                && bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON &&
+                bluetoothAdapter.getConnectionState() == BluetoothAdapter.STATE_DISCONNECTED;
+    }
+
+    private static long btTimeoutDurationInMilli(Context context) {
+        return Settings.Global.getLong(context.getContentResolver(),
+                Settings.Global.BLUETOOTH_OFF_TIMEOUT, 0);
+    }
+
+    /** Zero is default and means disabled */
+    private static boolean isTimeoutEnabled(Context context) {
+        return 0 != btTimeoutDurationInMilli(context);
     }
 
     /**
      *  Returns true if airplane mode is currently on
      */
     private boolean isAirplaneModeOn() {
         return Settings.Global.getInt(mContext.getContentResolver(),
                 Settings.Global.AIRPLANE_MODE_ON, 0) == 1;
     }
 

commit 9513bfa6ae686385b2510bef5b3f7feff389efa5
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Mon 2018-04-02 12:59:51-0400

    use Cloudflare DNS as the default fallback
    
    Cloudflare DNS has a better privacy policy than Google Public DNS while
    still supporting DNS over TLS.
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index f3cef664adec6461f0021d30fd5e8353970b0674..1502ae7b922e607c147cc158f6e5acccb0a665ee 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2033,21 +2033,21 @@
     <string name="config_systemTelevisionRemoteService" translatable="false">@string/config_tvRemoteServicePackage</string>
 
     <!-- The name of the package that will be allowed to change its components' label/icon. -->
     <string name="config_overrideComponentUiPackage" translatable="false">com.android.stk</string>
 
     <!-- Enable/disable default bluetooth profiles:
         HSP_AG, ObexObjectPush, Audio, NAP -->
     <bool name="config_bluetooth_default_profiles">true</bool>
 
     <!-- IP address of the dns server to use if nobody else suggests one -->
-    <string name="config_default_dns_server" translatable="false">8.8.8.8</string>
+    <string name="config_default_dns_server" translatable="false">1.0.0.1</string>
 
     <!-- The default mobile provisioning apn. Empty by default, maybe overridden by
          an mcc/mnc specific config.xml -->
     <string name="mobile_provisioning_apn" translatable="false"></string>
 
     <!-- The default mobile provisioning url. Empty by default, maybe overridden by
          an mcc/mnc specific config.xml -->
     <string name="mobile_provisioning_url" translatable="false"></string>
 
     <!-- The default character set for GsmAlphabet -->

commit c832700a4a0cc2836b4d38454fdc95c6bcc62283
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Mon 2018-04-02 10:37:46-0400

    SettingsLib: use Cloudflare DNS servers as hints
    
    Cloudflare DNS has a better privacy policy than Google Public DNS while
    still supporting DNS over TLS.
---
 packages/SettingsLib/res/values/strings.xml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/packages/SettingsLib/res/values/strings.xml b/packages/SettingsLib/res/values/strings.xml
index 6b840bd7901d382522c82678f550a5cc2938d6a0..b5006f34c628d1f960b286f6da063d62b4403c9f 100644
--- a/packages/SettingsLib/res/values/strings.xml
+++ b/packages/SettingsLib/res/values/strings.xml
@@ -1180,23 +1180,23 @@
 
     <!-- Label for length of time since the battery graph started [CHAR LIMIT=20] -->
     <string name="charge_length_format"><xliff:g name="time" example="3 hours">%1$s</xliff:g> ago</string>
 
     <!-- Label for length of time until battery is charged [CHAR LIMIT=20] -->
     <string name="remaining_length_format"><xliff:g name="time" example="3 hours">%1$s</xliff:g> left</string>
 
     <!-- Hint text for the IP address -->
     <string name="wifi_ip_address_hint" translatable="false">192.168.1.128</string>
     <!-- Hint text for DNS -->
-    <string name="wifi_dns1_hint" translatable="false">8.8.8.8</string>
+    <string name="wifi_dns1_hint" translatable="false">1.0.0.1</string>
     <!-- Hint text for DNS -->
-    <string name="wifi_dns2_hint" translatable="false">8.8.4.4</string>
+    <string name="wifi_dns2_hint" translatable="false">1.1.1.1</string>
     <!-- Hint text for the gateway -->
     <string name="wifi_gateway_hint" translatable="false">192.168.1.1</string>
     <!-- Hint text for network prefix length -->
     <string name="wifi_network_prefix_length_hint" translatable="false">24</string>
     <!-- HTTP proxy settings. The hint text field for port. -->
     <string name="proxy_port_hint" translatable="false">8080</string>
     <!-- HTTP proxy settings. Hint for Proxy-Auto Config URL. -->
     <string name="proxy_url_hint" translatable="false">https://www.example.com/proxy.pac</string>
     <!-- HTTP proxy settings. The hint text for proxy exclusion list. -->
     <string name="proxy_exclusionlist_hint" translatable="false">example.com,mycomp.test.com,localhost</string>

commit 455116289f31e3c1fa96044f64dc6e47cee05423
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2019-05-16 11:47:02-0400

    raise maximum users to 16
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 1502ae7b922e607c147cc158f6e5acccb0a665ee..8666f57977d6ae3223a6d3ed2fa13217fddc5ad8 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2511,21 +2511,21 @@
     <integer-array translatable="false" name="config_oemUsbModeOverride">
     </integer-array>
 
     <!-- Set to true to add links to Cell Broadcast app from Settings and MMS app. -->
     <bool name="config_cellBroadcastAppLinks">true</bool>
 
     <!-- The default value if the SyncStorageEngine should sync automatically or not -->
     <bool name="config_syncstorageengine_masterSyncAutomatically">true</bool>
 
     <!--  Maximum number of supported users -->
-    <integer name="config_multiuserMaximumUsers">4</integer>
+    <integer name="config_multiuserMaximumUsers">16</integer>
 
     <!-- Maximum number of users we allow to be running at a time -->
     <integer name="config_multiuserMaxRunningUsers">3</integer>
 
     <!-- Whether to delay user data locking for background user.
          If false, user switched-out from user switching will still be in running state until
          config_multiuserMaxRunningUsers is reached. Once config_multiuserMaxRunningUsers is
          reached, user will be stopped and user data is locked.
          If true, user switched out from user switching will always be stopped but its user data
          is not locked. Total number of unlocked users will be limited by

commit fa86d2bcace88e20a0209383ac7cd1009a20723c
Author: Pratyush <codelab@pratyush.dev>
Date:   Tue 2021-07-06 18:18:06+0530

    Wi-Fi auto turn off
---
 core/java/android/provider/Settings.java           |  6 ++
 .../android/server/net/NetworkStatsService.java    | 69 ++++++++++++++++++++++
 2 files changed, 75 insertions(+)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 722fe7c081131ab51f722cff040a06da11e8da24..4a4f99dde28d0b645c2f1ffba34a08a459d67888 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -16328,20 +16328,26 @@ public final class Settings {
          * Used to enable / disable the Restricted Networking Mode in which network access is
          * restricted to apps holding the CONNECTIVITY_USE_RESTRICTED_NETWORKS permission.
          *
          * Values are:
          * 0: disabled
          * 1: enabled
          * @hide
          */
         public static final String RESTRICTED_NETWORKING_MODE = "restricted_networking_mode";
 
+        /**
+         * The amount of time in milliseconds before Wi-Fi is turned off
+         * @hide
+         */
+        public static final String WIFI_OFF_TIMEOUT = "wifi_off_timeout";
+
         /**
          * Whether to automatically reboot the device after a user defined timeout
          *
          * @hide
          */
         public static final String SETTINGS_REBOOT_AFTER_TIMEOUT = "settings_reboot_after_timeout";
         
         /**
          * The amount of time in milliseconds before bluetooth is turned off
          * @hide
diff --git a/services/core/java/com/android/server/net/NetworkStatsService.java b/services/core/java/com/android/server/net/NetworkStatsService.java
index 097b0711eff7813448ef7ae872421f8d6179e51d..0a4fca3ec09d53199397713d9e8c437fb696ce83 100644
--- a/services/core/java/com/android/server/net/NetworkStatsService.java
+++ b/services/core/java/com/android/server/net/NetworkStatsService.java
@@ -89,36 +89,39 @@ import android.content.IntentFilter;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageManager;
 import android.database.ContentObserver;
 import android.net.DataUsageRequest;
 import android.net.INetworkManagementEventObserver;
 import android.net.INetworkStatsService;
 import android.net.INetworkStatsSession;
 import android.net.Network;
 import android.net.NetworkCapabilities;
 import android.net.NetworkIdentity;
+import android.net.NetworkInfo;
 import android.net.NetworkSpecifier;
 import android.net.NetworkStack;
 import android.net.NetworkStateSnapshot;
 import android.net.NetworkStats;
 import android.net.NetworkStats.NonMonotonicObserver;
 import android.net.NetworkStatsHistory;
 import android.net.NetworkTemplate;
 import android.net.TelephonyNetworkSpecifier;
 import android.net.TrafficStats;
 import android.net.UnderlyingNetworkInfo;
 import android.net.Uri;
 import android.net.netstats.provider.INetworkStatsProvider;
 import android.net.netstats.provider.INetworkStatsProviderCallback;
 import android.net.netstats.provider.NetworkStatsProvider;
+import android.net.wifi.WifiManager;
 import android.os.BestClock;
 import android.os.Binder;
+import android.os.Bundle;
 import android.os.DropBoxManager;
 import android.os.Environment;
 import android.os.Handler;
 import android.os.HandlerExecutor;
 import android.os.HandlerThread;
 import android.os.IBinder;
 import android.os.INetworkManagementService;
 import android.os.Looper;
 import android.os.Message;
 import android.os.Messenger;
@@ -442,20 +445,86 @@ public class NetworkStatsService extends INetworkStatsService.Stub {
         mDeps = Objects.requireNonNull(deps, "missing Dependencies");
 
         final HandlerThread handlerThread = mDeps.makeHandlerThread();
         handlerThread.start();
         mHandler = new NetworkStatsHandler(handlerThread.getLooper());
         mNetworkStatsSubscriptionsMonitor = deps.makeSubscriptionsMonitor(mContext,
                 mHandler.getLooper(), new HandlerExecutor(mHandler), this);
         mContentResolver = mContext.getContentResolver();
         mContentObserver = mDeps.makeContentObserver(mHandler, mSettings,
                 mNetworkStatsSubscriptionsMonitor);
+        IntentFilter wifiFilter = new IntentFilter();
+        wifiFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
+        wifiFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
+
+        context.registerReceiver(
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                        if (WifiManager.NETWORK_STATE_CHANGED_ACTION.equals(intent.getAction())) {
+                            Bundle bundle = intent.getExtras();
+                            NetworkInfo networkInfo = bundle.getParcelable(WifiManager.EXTRA_NETWORK_INFO);
+                            isWifiConnected = networkInfo != null && networkInfo.isConnected();
+                        }
+                        reconfigureWiFiTimeoutListener();
+                    }
+                }, wifiFilter
+        );
+
+        context.getContentResolver().registerContentObserver(
+                Global.getUriFor(Global.WIFI_OFF_TIMEOUT),
+                false,
+                new ContentObserver(new Handler(context.getMainLooper())) {
+                    @Override
+                    public void onChange(boolean selfChange) {
+                        super.onChange(selfChange);
+                        reconfigureWiFiTimeoutListener();
+                    }
+                });
+    }
+
+    private static boolean isWifiConnected = false;
+    private final AlarmManager.OnAlarmListener listener = this::turnOffWifi;
+
+    private void turnOffWifi() {
+        WifiManager wifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
+        if (isWifiTimeoutEnabled(mContext) && wifiManager.isWifiEnabled()) {
+            // setWifiEnabled(enabled) is deprecated, though AOSP still uses
+            // it internally and system apps/services are exempted
+            wifiManager.setWifiEnabled(false);
+        }
+    }
+
+    private void reconfigureWiFiTimeoutListener() {
+        if (isWifiTimeoutEnabled(mContext) && !isWifiConnected) {
+            final long timeout = SystemClock.elapsedRealtime() + wifiTimeoutDurationInMilli(mContext);
+            mAlarmManager.cancel(listener);
+            mAlarmManager.setExact(
+                    AlarmManager.ELAPSED_REALTIME_WAKEUP,
+                    timeout,
+                    "Wi-Fi Idle Timeout",
+                    listener,
+                    new Handler(mContext.getMainLooper())
+            );
+        } else {
+            mAlarmManager.cancel(listener);
+        }
+    }
+
+    private static long wifiTimeoutDurationInMilli(Context mContext) {
+        return Settings.Global.getLong(mContext.getContentResolver(),
+                Global.WIFI_OFF_TIMEOUT, 0);
+    }
+
+    /** Zero is default and means disabled */
+    private static boolean isWifiTimeoutEnabled(Context mContext) {
+        return 0 != wifiTimeoutDurationInMilli(mContext);
     }
 
     /**
      * Dependencies of NetworkStatsService, for injection in tests.
      */
     // TODO: Move more stuff into dependencies object.
     @VisibleForTesting
     public static class Dependencies {
         /**
          * Create a HandlerThread to use in NetworkStatsService.

commit 57868a42dea2386fb0e77438c50da526a9191776
Author: flawedworld <flawedworld@flawed.world>
Date:   Tue 2021-10-19 00:46:21+0100

    Migration for legacy fingerprint keyguard toggle to modern biometric keyguard toggle
---
 .../src/com/android/providers/settings/SettingsProvider.java | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java b/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java
index 4c9500cf909a7a4c14e96bc0d61b7f9b31ad6c8e..4c9a7a5724e74f3c7f2d47607e44ff01a5accec9 100644
--- a/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java
+++ b/packages/SettingsProvider/src/com/android/providers/settings/SettingsProvider.java
@@ -5237,20 +5237,32 @@ public class SettingsProvider extends ContentProvider {
                             tiles.remove("wifi");
                             tiles.remove("cell");
                         }
                         secureSettings.insertSettingOverrideableByRestoreLocked(
                                 Secure.QS_TILES,
                                 TextUtils.join(",", tiles),
                                 null /* tag */,
                                 true /* makeDefault */,
                                 SettingsState.SYSTEM_PACKAGE_NAME);
                     }
+                    // Migrate legacy fingerprint keyguard toggle to new unified
+                    // biometric api toggle
+                    final Setting oldFingerSetting = secureSettings.getSettingLocked("fingerprint_unlock_keyguard_enabled");
+                    if (!oldFingerSetting.isNull()) {
+                        secureSettings.insertSettingLocked(
+                                Secure.BIOMETRIC_KEYGUARD_ENABLED,
+                                oldFingerSetting.getValue(),
+                                null,
+                                false,
+                                SettingsState.SYSTEM_PACKAGE_NAME);
+                        secureSettings.deleteSettingLocked("fingerprint_unlock_keyguard_enabled");
+                    }
                     currentVersion = 204;
                 }
 
                 if (currentVersion == 204) {
                     // Version 204: Reset the
                     // Secure#ACCESSIBILITY_FLOATING_MENU_MIGRATION_TOOLTIP_PROMPT as enabled
                     // status for showing the tooltips.
                     final SettingsState secureSettings = getSecureSettingsLocked(userId);
                     final Setting accessibilityButtonMode = secureSettings.getSettingLocked(
                             Secure.ACCESSIBILITY_BUTTON_MODE);

commit 7fe51aa54dbc8e366462daeb57103e848ef96f4c
Author: randomhydrosol <randomhydrosol@glassrom.org>
Date:   Tue 2021-10-19 01:31:34+0100

    Only use GNSS provided time when NITZ is enabled
---
 .../java/com/android/server/timedetector/TimeDetectorStrategyImpl.java  | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java b/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java
index 5c95d02a34de3b810fa9e4ad4d0019ac134af1eb..0508789251927ebca9e6780531814d278680fd87 100644
--- a/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java
+++ b/services/core/java/com/android/server/timedetector/TimeDetectorStrategyImpl.java
@@ -466,21 +466,21 @@ public final class TimeDetectorStrategyImpl implements TimeDetectorStrategy {
                             + ", detectionReason=" + detectionReason;
                 }
             } else if (origin == ORIGIN_NETWORK) {
                 NetworkTimeSuggestion networkSuggestion = findLatestValidNetworkSuggestion();
                 if (networkSuggestion != null) {
                     newUtcTime = networkSuggestion.getUtcTime();
                     cause = "Found good network suggestion."
                             + ", networkSuggestion=" + networkSuggestion
                             + ", detectionReason=" + detectionReason;
                 }
-            } else if (origin == ORIGIN_GNSS) {
+            } else if (mEnvironment.isNITZTimeDetectionEnabled() && origin == ORIGIN_GNSS) {
                 GnssTimeSuggestion gnssTimeSuggestion = findLatestValidGnssSuggestion();
                 if (gnssTimeSuggestion != null) {
                     newUtcTime = gnssTimeSuggestion.getUtcTime();
                     cause = "Found good gnss suggestion."
                             + ", gnssTimeSuggestion=" + gnssTimeSuggestion
                             + ", detectionReason=" + detectionReason;
                 }
             } else if (origin == ORIGIN_EXTERNAL) {
                 ExternalTimeSuggestion externalTimeSuggestion = findLatestValidExternalSuggestion();
                 if (externalTimeSuggestion != null) {

commit 64ba9a4e294fdd63372e538cd131d41251f9b118
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2021-10-19 08:05:17-0400

    change default quick tiles and quick tile order
---
 packages/SystemUI/res/values/config.xml | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/packages/SystemUI/res/values/config.xml b/packages/SystemUI/res/values/config.xml
index 5ef87d077f22b0e78635bc1197252bf72c19c2b8..9e9a285b3faa87b9612d66669cdad501ae123b94 100644
--- a/packages/SystemUI/res/values/config.xml
+++ b/packages/SystemUI/res/values/config.xml
@@ -67,29 +67,29 @@
     <!-- The number of columns in the QuickSettings -->
     <integer name="quick_settings_num_columns">2</integer>
 
     <!-- The number of rows in the QuickSettings -->
     <integer name="quick_settings_max_rows">4</integer>
 
     <!-- The number of columns that the top level tiles span in the QuickSettings -->
 
     <!-- The default tiles to display in QuickSettings -->
     <string name="quick_settings_tiles_default" translatable="false">
-        internet,bt,flashlight,dnd,alarm,airplane,controls,wallet,rotation,battery,cast,screenrecord,mictoggle,cameratoggle
+        internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location
     </string>
 
     <!-- The minimum number of tiles to display in QuickSettings -->
     <integer name="quick_settings_min_num_tiles">6</integer>
 
     <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default" -->
     <string name="quick_settings_tiles_stock" translatable="false">
-        internet,bt,flashlight,dnd,alarm,airplane,controls,wallet,rotation,battery,cast,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness
+        internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness,controls,wallet,cast
     </string>
 
     <!-- The tiles to display in QuickSettings -->
     <string name="quick_settings_tiles" translatable="false">default</string>
 
     <!-- The tiles to display in QuickSettings in retail mode -->
     <string name="quick_settings_tiles_retail_mode" translatable="false">
         night,dark,dnd,flashlight,rotation,location
     </string>
 

commit 9dbe1d53e9c5708c88b638563f3892ef64a95077
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Mon 2021-03-15 23:57:54-0400

    set GrapheneOS launcher as notification listener
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 8666f57977d6ae3223a6d3ed2fa13217fddc5ad8..fb7abb632c15c44300d08c954a5f8bac9d2fffd3 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -3858,21 +3858,21 @@
          and followed the pertinent sections of the escrow tokens section of the CDD <link>-->
     <!-- TODO(b/35230407) complete the link field -->
     <bool name="config_allowEscrowTokenForTrustAgent">false</bool>
 
     <!-- A flattened ComponentName which corresponds to the only trust agent that should be enabled
          by default. If the default value is used, or set to an empty string, the restriction will
          not be applied. -->
     <string name="config_defaultTrustAgent" translatable="false"></string>
 
     <!-- Colon separated list of package names that should be granted Notification Listener access -->
-    <string name="config_defaultListenerAccessPackages" translatable="false"></string>
+    <string name="config_defaultListenerAccessPackages" translatable="false">com.android.launcher3</string>
 
     <!-- Maximum size, specified in pixels, to restrain the display space width to. Height and
          density will be scaled accordingly to maintain aspect ratio. A value of 0 indicates no
          constraint will be enforced. -->
     <integer name="config_maxUiWidth">0</integer>
 
     <!-- Whether the device supports quick settings and its associated APIs -->
     <bool name="config_quickSettingsSupported">true</bool>
 
     <!-- The component name, flattened to a string, for the default autofill service

commit 0d6c2d03e3f4b5e7291c86a2458d3305fcb59509
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2021-10-26 01:31:20-0400

    add missing display cutout overlays
---
 packages/overlays/Android.mk | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/packages/overlays/Android.mk b/packages/overlays/Android.mk
index a6bb258bccb0d907557854d710ab90a18264d3ee..a93b3c72b50b240cd28855014f21d8cfd529b991 100644
--- a/packages/overlays/Android.mk
+++ b/packages/overlays/Android.mk
@@ -13,33 +13,37 @@
 # limitations under the License.
 
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
 LOCAL_MODULE := frameworks-base-overlays
 LOCAL_LICENSE_KINDS := SPDX-license-identifier-Apache-2.0
 LOCAL_LICENSE_CONDITIONS := notice
 LOCAL_NOTICE_FILE := $(LOCAL_PATH)/../../NOTICE
 LOCAL_REQUIRED_MODULES := \
+	AvoidAppsInCutoutOverlay \
 	DisplayCutoutEmulationCornerOverlay \
 	DisplayCutoutEmulationDoubleOverlay \
-    DisplayCutoutEmulationHoleOverlay \
+	DisplayCutoutEmulationHoleOverlay \
+	DisplayCutoutEmulationNarrowOverlay \
 	DisplayCutoutEmulationTallOverlay \
 	DisplayCutoutEmulationWaterfallOverlay \
+	DisplayCutoutEmulationWideOverlay \
 	FontNotoSerifSourceOverlay \
 	NavigationBarMode3ButtonOverlay \
 	NavigationBarMode2ButtonOverlay \
 	NavigationBarModeGesturalOverlay \
 	NavigationBarModeGesturalOverlayNarrowBack \
 	NavigationBarModeGesturalOverlayWideBack \
 	NavigationBarModeGesturalOverlayExtraWideBack \
-        OneHandedModeGesturalOverlay \
+	NoCutoutOverlay \
+	OneHandedModeGesturalOverlay \
 	preinstalled-packages-platform-overlays.xml
 
 include $(BUILD_PHONY_PACKAGE)
 include $(CLEAR_VARS)
 
 LOCAL_MODULE := frameworks-base-overlays-debug
 LOCAL_LICENSE_KINDS := SPDX-license-identifier-Apache-2.0
 LOCAL_LICENSE_CONDITIONS := notice
 LOCAL_NOTICE_FILE := $(LOCAL_PATH)/../../NOTICE
 

commit ef830a26ae1cf17325cf7f77563b51c3b9dcdec8
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2021-10-21 14:41:10-0400

    support using the legacy wifi/cell quick tiles
---
 packages/SystemUI/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/packages/SystemUI/res/values/config.xml b/packages/SystemUI/res/values/config.xml
index 9e9a285b3faa87b9612d66669cdad501ae123b94..1b953d1022be5f6ec72ecb2e7681d73f7ff40cec 100644
--- a/packages/SystemUI/res/values/config.xml
+++ b/packages/SystemUI/res/values/config.xml
@@ -75,21 +75,21 @@
     <!-- The default tiles to display in QuickSettings -->
     <string name="quick_settings_tiles_default" translatable="false">
         internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location
     </string>
 
     <!-- The minimum number of tiles to display in QuickSettings -->
     <integer name="quick_settings_min_num_tiles">6</integer>
 
     <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default" -->
     <string name="quick_settings_tiles_stock" translatable="false">
-        internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness,controls,wallet,cast
+        internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness,controls,wallet,cast,wifi,cell
     </string>
 
     <!-- The tiles to display in QuickSettings -->
     <string name="quick_settings_tiles" translatable="false">default</string>
 
     <!-- The tiles to display in QuickSettings in retail mode -->
     <string name="quick_settings_tiles_retail_mode" translatable="false">
         night,dark,dnd,flashlight,rotation,location
     </string>
 

commit 811c0ff8e0b90a65c5db30e1c5e3b0b53b9665e4
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2021-10-22 20:51:50-0400

    Revert "support using the legacy wifi/cell quick tiles"
    
    This reverts commit 9d3ff5bd0b5fd8ef16f1dd8cbc172332512f6385.
---
 packages/SystemUI/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/packages/SystemUI/res/values/config.xml b/packages/SystemUI/res/values/config.xml
index 1b953d1022be5f6ec72ecb2e7681d73f7ff40cec..9e9a285b3faa87b9612d66669cdad501ae123b94 100644
--- a/packages/SystemUI/res/values/config.xml
+++ b/packages/SystemUI/res/values/config.xml
@@ -75,21 +75,21 @@
     <!-- The default tiles to display in QuickSettings -->
     <string name="quick_settings_tiles_default" translatable="false">
         internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location
     </string>
 
     <!-- The minimum number of tiles to display in QuickSettings -->
     <integer name="quick_settings_min_num_tiles">6</integer>
 
     <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default" -->
     <string name="quick_settings_tiles_stock" translatable="false">
-        internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness,controls,wallet,cast,wifi,cell
+        internet,bt,airplane,flashlight,dnd,alarm,rotation,battery,screenrecord,mictoggle,cameratoggle,location,nfc,hotspot,inversion,saver,dark,work,night,reverse,reduce_brightness,controls,wallet,cast
     </string>
 
     <!-- The tiles to display in QuickSettings -->
     <string name="quick_settings_tiles" translatable="false">default</string>
 
     <!-- The tiles to display in QuickSettings in retail mode -->
     <string name="quick_settings_tiles_retail_mode" translatable="false">
         night,dark,dnd,flashlight,rotation,location
     </string>
 

commit f865765c2c6030c0399ef042ad73034236433cdb
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Wed 2021-10-20 19:40:42-0400

    [temporary] don't report statementservice crashes
    
    There's a known issue in AOSP 12 caused by it creating overly large
    intents for the work manager. It's not caused by anything done by end
    users and they can't work around it so avoid reporting it to them since
    they get a message each time it tries again.
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index fb7abb632c15c44300d08c954a5f8bac9d2fffd3..5965635c73716d4464808356d7b9cfe92bc23de1 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -3596,21 +3596,21 @@
              2 - 1 snap target: 1:1
     -->
     <integer name="config_dockedStackDividerSnapMode">0</integer>
 
     <!-- The maximum aspect ratio (longerSide/shorterSide) that is treated as close-to-square. The
          orientation requests from apps would be ignored if the display is close-to-square. -->
     <item name="config_closeToSquareDisplayMaxAspectRatio" format="float" type="dimen">1.333</item>
 
     <!-- List of comma separated package names for which we the system will not show crash, ANR,
          etc. dialogs. -->
-    <string translatable="false" name="config_appsNotReportingCrashes"></string>
+    <string translatable="false" name="config_appsNotReportingCrashes">com.android.statementservice</string>
 
     <!-- Inactivity threshold (in milliseconds) used in JobScheduler. JobScheduler will consider
          the device to be "idle" after being inactive for this long. -->
     <integer name="config_jobSchedulerInactivityIdleThreshold">1860000</integer>
     <!-- The alarm window (in milliseconds) that JobScheduler uses to enter the idle state -->
     <integer name="config_jobSchedulerIdleWindowSlop">300000</integer>
 
     <!-- If true, jobs from background user will be restricted -->
     <bool name="config_jobSchedulerRestrictBackgroundUser">false</bool>
     <!-- The length of grace period after user becomes background user -->

commit 56c8641237c4c9ba4ec9d6a70da4aad9df5a5c04
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2021-10-26 09:15:42-0400

    [temporary] disable broken AvoidAppsInCutoutOverlay
---
 packages/overlays/Android.mk | 1 -
 1 file changed, 1 deletion(-)

diff --git a/packages/overlays/Android.mk b/packages/overlays/Android.mk
index a93b3c72b50b240cd28855014f21d8cfd529b991..c7a3d40ccf36d04ca971009ebd41885620941ec9 100644
--- a/packages/overlays/Android.mk
+++ b/packages/overlays/Android.mk
@@ -13,21 +13,20 @@
 # limitations under the License.
 
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
 LOCAL_MODULE := frameworks-base-overlays
 LOCAL_LICENSE_KINDS := SPDX-license-identifier-Apache-2.0
 LOCAL_LICENSE_CONDITIONS := notice
 LOCAL_NOTICE_FILE := $(LOCAL_PATH)/../../NOTICE
 LOCAL_REQUIRED_MODULES := \
-	AvoidAppsInCutoutOverlay \
 	DisplayCutoutEmulationCornerOverlay \
 	DisplayCutoutEmulationDoubleOverlay \
 	DisplayCutoutEmulationHoleOverlay \
 	DisplayCutoutEmulationNarrowOverlay \
 	DisplayCutoutEmulationTallOverlay \
 	DisplayCutoutEmulationWaterfallOverlay \
 	DisplayCutoutEmulationWideOverlay \
 	FontNotoSerifSourceOverlay \
 	NavigationBarMode3ButtonOverlay \
 	NavigationBarMode2ButtonOverlay \

commit 955bfcc9904d001a842a5c3b71499890be5565b7
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2021-11-13 18:38:39-0500

    gmscompat: use new API for long-running AppOps
    
    Android 12 added startProxyOpNoThrow and finishProxyOp so we no longer
    need to use noteProxyOpNoThrow as an approximation.
---
 core/java/android/app/AppOpsManager.java | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java
index f0b749c40a5ff65cf14e394795cd3fea4d1723b8..968af357a46252aba32b22eaf4b95d9a47001f95 100644
--- a/core/java/android/app/AppOpsManager.java
+++ b/core/java/android/app/AppOpsManager.java
@@ -8775,21 +8775,21 @@ public class AppOpsManager {
 
     /**
      * @see #startOpNoThrow(String, int, String, String, String)
      *
      * @hide
      */
     public int startOpNoThrow(@NonNull IBinder token, int op, int uid, @NonNull String packageName,
             boolean startIfModeDefault, @Nullable String attributionTag, @Nullable String message,
             @AttributionFlags int attributionFlags, int attributionChainId) {
         if (GmsCompat.isEnabled() && uid != Process.myUid()) {
-            return noteProxyOpNoThrow(op, packageName, uid, attributionTag, message);
+            return startProxyOpNoThrow(opToPublicName(op), uid, packageName, attributionTag, message);
         }
 
         try {
             collectNoteOpCallsForValidation(op);
             int collectionMode = getNotedOpCollectionMode(uid, packageName, op);
             boolean shouldCollectMessage = Process.myUid() == Process.SYSTEM_UID;
             if (collectionMode == COLLECT_ASYNC) {
                 if (message == null) {
                     // Set stack trace as default message
                     message = getFormattedStackTrace();
@@ -9002,20 +9002,21 @@ public class AppOpsManager {
     }
 
     /**
      * @see #finishOp(String, int, String, String)
      *
      * @hide
      */
     public void finishOp(IBinder token, int op, int uid, @NonNull String packageName,
             @Nullable String attributionTag) {
         if (GmsCompat.isEnabled() && uid != Process.myUid()) {
+            finishProxyOp(opToPublicName(op), uid, packageName, attributionTag);
             return;
         }
 
         try {
             mService.finishOperation(token, op, uid, packageName, attributionTag);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 

commit a8ea6beeaf3524afe23a0fe5a6a74589c67f2d20
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Tue 2021-11-16 18:54:30+0200

    gmscompat: improve Play Store compatibility
    
    Implements package (un)installation confirmation handling and
    enables unattended app updates.
---
 .../android/app/ApplicationPackageManager.java     |   5 +
 core/java/android/app/LoadedApk.java               |   4 -
 core/java/android/app/compat/gms/GmsCompat.java    |  18 +-
 core/java/android/content/pm/PackageInstaller.java |  12 ++
 core/java/android/content/pm/PackageParser.java    |   4 +
 .../com/android/internal/gmscompat/GmsHooks.java   | 101 ++++------
 .../internal/gmscompat/PlayStoreHooks.java (new)   | 217 +++++++++++++++++++++
 core/res/res/values/strings.xml                    |   6 +-
 core/res/res/values/symbols.xml                    |   3 +-
 9 files changed, 298 insertions(+), 72 deletions(-)

diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index 4dabe78f2f737c12314bd4697a839b9f44f39d7b..0f1d8dfc023006f17d6a21b3f06d9d344ff03f6c 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -115,20 +115,21 @@ import android.system.StructStat;
 import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.LauncherIcons;
 import android.util.Log;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.Immutable;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.gmscompat.PlayStoreHooks;
 import com.android.internal.os.SomeArgs;
 import com.android.internal.util.UserIcons;
 
 import dalvik.system.VMRuntime;
 
 import libcore.util.EmptyArray;
 
 import java.io.File;
 import java.lang.ref.WeakReference;
 import java.security.cert.Certificate;
@@ -2506,20 +2507,24 @@ public class ApplicationPackageManager extends PackageManager {
             return false;
         }
 
         // We can move to any private volume
         return (vol.getType() == VolumeInfo.TYPE_PRIVATE);
     }
 
     @Override
     @UnsupportedAppUsage
     public void deletePackage(String packageName, IPackageDeleteObserver observer, int flags) {
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.deletePackage(mContext, this, packageName, observer, flags);
+            return;
+        }
         deletePackageAsUser(packageName, observer, flags, getUserId());
     }
 
     @Override
     public void deletePackageAsUser(String packageName, IPackageDeleteObserver observer,
             int flags, int userId) {
         try {
             mPM.deletePackageAsUser(packageName, VERSION_CODE_HIGHEST,
                     observer, userId, flags);
         } catch (RemoteException e) {
diff --git a/core/java/android/app/LoadedApk.java b/core/java/android/app/LoadedApk.java
index d4032729d68376616b7c1fb5cf3344c6571c6847..c398b73a6e9f9cca9cf08e7736957fa2e3b81c20 100644
--- a/core/java/android/app/LoadedApk.java
+++ b/core/java/android/app/LoadedApk.java
@@ -1566,24 +1566,20 @@ public final class LoadedApk {
             final LoadedApk.ReceiverDispatcher mStrongRef;
 
             InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) {
                 mDispatcher = new WeakReference<LoadedApk.ReceiverDispatcher>(rd);
                 mStrongRef = strong ? rd : null;
             }
 
             @Override
             public void performReceive(Intent intent, int resultCode, String data,
                     Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
-                if (GmsHooks.performReceive(intent)) {
-                    return;
-                }
-
                 final LoadedApk.ReceiverDispatcher rd;
                 if (intent == null) {
                     Log.wtf(TAG, "Null intent received");
                     rd = null;
                 } else {
                     rd = mDispatcher.get();
                 }
                 if (ActivityThread.DEBUG_BROADCAST) {
                     int seq = intent.getIntExtra("seq", -1);
                     Slog.i(ActivityThread.TAG, "Receiving broadcast " + intent.getAction()
diff --git a/core/java/android/app/compat/gms/GmsCompat.java b/core/java/android/app/compat/gms/GmsCompat.java
index 15ee23822299bee53065b4e2267a9db8df8819d2..524a6f3a09bf67d83aa4acfd4aed45e5f8b5602d 100644
--- a/core/java/android/app/compat/gms/GmsCompat.java
+++ b/core/java/android/app/compat/gms/GmsCompat.java
@@ -11,20 +11,21 @@
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package android.app.compat.gms;
 
 import android.annotation.SystemApi;
 import android.app.ActivityThread;
+import android.app.Application;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.Disabled;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageManager;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.Signature;
 import android.os.Binder;
 import android.os.Process;
@@ -69,35 +70,42 @@ public final class GmsCompat {
 
     /**
      * Whether to enable hooks for this app to load Dynamite modules from unprivileged GMS.
      * This is for CLIENT apps, not GMS itself.
      */
     @ChangeId
     @Disabled // Overridden as a special case in CompatChange
     private static final long GMS_UNPRIVILEGED_DYNAMITE_CLIENT = 7528921493777479941L;
 
     // Some hooks are in (potentially) hot paths, so cache the change enable states.
-    private static volatile boolean isGmsCompatEnabled = false;
-    private static volatile boolean isDynamiteClientEnabled = false;
+    // no need to declare these fields as volatile, they are written when app has only the main thread
+    private static boolean isGmsCompatEnabled;
+    private static boolean isDynamiteClientEnabled;
+    private static boolean isPlayStore;
 
     // Static only
     private GmsCompat() { }
 
     public static boolean isEnabled() {
         return isGmsCompatEnabled;
     }
 
     /** @hide */
     public static boolean isDynamiteClient() {
         return isDynamiteClientEnabled;
     }
 
+    /** @hide */
+    public static boolean isPlayStore() {
+        return isPlayStore;
+    }
+
     private static void logEnabled(String changeName, boolean enabled) {
         if (!DEBUG_VERBOSE) {
             return;
         }
 
         String pkg = ActivityThread.currentPackageName();
         if (pkg == null) {
             pkg = (Process.myUid() == Process.SYSTEM_UID) ? "system_server" : "[unknown]";
         }
 
@@ -116,23 +124,27 @@ public final class GmsCompat {
 
         logEnabled(changeName, enabled);
         return enabled;
     }
 
     /**
      * Must be called to initialize the compatibility change enable states before any hooks run.
      *
      * @hide
      */
-    public static void initChangeEnableStates() {
+    public static void initChangeEnableStates(Application app) {
         isGmsCompatEnabled = isChangeEnabled("GMS_UNPRIVILEGED_COMPAT", GMS_UNPRIVILEGED_COMPAT);
         isDynamiteClientEnabled = isChangeEnabled("GMS_UNPRIVILEGED_DYNAMITE_CLIENT", GMS_UNPRIVILEGED_DYNAMITE_CLIENT);
+        if (isGmsCompatEnabled) {
+            // certificate is already checked if isGmsCompatEnabled is set
+            isPlayStore = GmsInfo.PACKAGE_PLAY_STORE.equals(app.getPackageName());
+        }
     }
 
     private static boolean validateCerts(Signature[] signatures) {
         for (Signature signature : signatures) {
             if (signature.toCharsString().equals(GmsInfo.SIGNING_CERT)) {
                 return true;
             }
         }
 
         return false;
diff --git a/core/java/android/content/pm/PackageInstaller.java b/core/java/android/content/pm/PackageInstaller.java
index 3f8aedb31ea9c99c3737b6e174442ae0675ef155..6071d4e5a98c698b4e5c2a1053c12a4291d5890e 100644
--- a/core/java/android/content/pm/PackageInstaller.java
+++ b/core/java/android/content/pm/PackageInstaller.java
@@ -25,20 +25,21 @@ import android.annotation.CurrentTimeMillisLong;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.app.ActivityManager;
 import android.app.AppGlobals;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Intent;
 import android.content.IntentSender;
 import android.content.pm.PackageManager.DeleteFlags;
 import android.content.pm.PackageManager.InstallReason;
 import android.content.pm.PackageManager.InstallScenario;
 import android.graphics.Bitmap;
 import android.net.Uri;
 import android.os.Build;
 import android.os.FileBridge;
@@ -50,20 +51,21 @@ import android.os.Parcelable;
 import android.os.ParcelableException;
 import android.os.RemoteException;
 import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.system.ErrnoException;
 import android.system.Os;
 import android.text.TextUtils;
 import android.util.ArraySet;
 import android.util.ExceptionUtils;
 
+import com.android.internal.gmscompat.PlayStoreHooks;
 import com.android.internal.util.IndentingPrintWriter;
 import com.android.internal.util.Preconditions;
 import com.android.internal.util.function.pooled.PooledLambda;
 
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -683,20 +685,23 @@ public class PackageInstaller {
      * @param statusReceiver Where to deliver the result.
      *
      * @hide
      */
     @RequiresPermission(anyOf = {
             Manifest.permission.DELETE_PACKAGES,
             Manifest.permission.REQUEST_DELETE_PACKAGES})
     public void uninstall(@NonNull VersionedPackage versionedPackage, @DeleteFlags int flags,
             @NonNull IntentSender statusReceiver) {
         Objects.requireNonNull(versionedPackage, "versionedPackage cannot be null");
+        if (GmsCompat.isPlayStore()) {
+            statusReceiver = PlayStoreHooks.wrapPackageInstallerStatusReceiver(statusReceiver);
+        }
         try {
             mInstaller.uninstall(versionedPackage, mInstallerPackageName,
                     flags, statusReceiver, mUserId);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Install the given package, which already exists on the device, for the user for which this
@@ -1302,20 +1307,23 @@ public class PackageInstaller {
          * @param statusReceiver Called when the state of the session changes. Intents
          *                       sent to this receiver contain {@link #EXTRA_STATUS}. Refer to the
          *                       individual status codes on how to handle them.
          *
          * @throws SecurityException if streams opened through
          *             {@link #openWrite(String, long, long)} are still open.
          *
          * @see android.app.admin.DevicePolicyManager
          */
         public void commit(@NonNull IntentSender statusReceiver) {
+            if (GmsCompat.isPlayStore()) {
+                statusReceiver = PlayStoreHooks.wrapPackageInstallerStatusReceiver(statusReceiver);
+            }
             try {
                 mSession.commit(statusReceiver, false);
             } catch (RemoteException e) {
                 throw e.rethrowFromSystemServer();
             }
         }
 
         /**
          * Attempt to commit a session that has been {@link #transfer(String) transferred}.
          *
@@ -1624,20 +1632,24 @@ public class PackageInstaller {
 
         /**
          * Construct parameters for a new package install session.
          *
          * @param mode one of {@link #MODE_FULL_INSTALL} or
          *            {@link #MODE_INHERIT_EXISTING} describing how the session
          *            should interact with an existing app.
          */
         public SessionParams(int mode) {
             this.mode = mode;
+            if (GmsCompat.isPlayStore()) {
+                // called here instead of in createSession() to give Play Store a chance to override
+                setRequireUserAction(USER_ACTION_NOT_REQUIRED);
+            }
         }
 
         /** {@hide} */
         public SessionParams(Parcel source) {
             mode = source.readInt();
             installFlags = source.readInt();
             installLocation = source.readInt();
             installReason = source.readInt();
             installScenario = source.readInt();
             sizeBytes = source.readLong();
diff --git a/core/java/android/content/pm/PackageParser.java b/core/java/android/content/pm/PackageParser.java
index 1eca93ab2886f534afb2a294df4c6a97f2210818..de6804e72ef0a9ac4c800b84c3c0e78241377715 100644
--- a/core/java/android/content/pm/PackageParser.java
+++ b/core/java/android/content/pm/PackageParser.java
@@ -283,20 +283,24 @@ public class PackageParser {
      * If sdkVersion is 0, then this is not a permission that we want to
      * automatically add to older apps, but we do want to allow it to be
      * granted during a platform update.
      * @hide
      */
     @UnsupportedAppUsage
     public static final PackageParser.NewPermissionInfo NEW_PERMISSIONS[] =
         new PackageParser.NewPermissionInfo[] {
             new PackageParser.NewPermissionInfo(android.Manifest.permission.REQUEST_INSTALL_PACKAGES,
                     android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0, GmsInfo.PACKAGE_PLAY_STORE),
+            new PackageParser.NewPermissionInfo(android.Manifest.permission.REQUEST_DELETE_PACKAGES,
+                    android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0, GmsInfo.PACKAGE_PLAY_STORE),
+            new PackageParser.NewPermissionInfo(android.Manifest.permission.UPDATE_PACKAGES_WITHOUT_USER_ACTION,
+                    android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0, GmsInfo.PACKAGE_PLAY_STORE),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.OTHER_SENSORS,
                     android.os.Build.VERSION_CODES.CUR_DEVELOPMENT + 1, 0),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.WRITE_EXTERNAL_STORAGE,
                     android.os.Build.VERSION_CODES.DONUT, 0),
             new PackageParser.NewPermissionInfo(android.Manifest.permission.READ_PHONE_STATE,
                     android.os.Build.VERSION_CODES.DONUT, 0)
     };
 
     /**
      * @deprecated callers should move to explicitly passing around source path.
diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
index 620bb7e46fa0a065692dbf6082ae1c6af02578a0..9150bdf03d3571d75dd777d7a27befff017832c5 100644
--- a/core/java/com/android/internal/gmscompat/GmsHooks.java
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -36,114 +36,126 @@ import android.os.Build;
 import android.os.Process;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.provider.Settings;
 import android.util.Log;
 import android.webkit.WebView;
 
 import com.android.internal.R;
 import com.android.internal.gmscompat.dynamite.GmsDynamiteHooks;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
 /**
  * API shims for Google Play Services compatibility. Hooks that are more complicated than a simple
  * constant return value should be delegated to this class for easier maintenance.
  *
  * @hide
  */
 public final class GmsHooks {
     private static final String TAG = "GmsCompat/Hooks";
 
     // Foreground service notifications
-    private static final String FGS_GROUP_ID = "gmscompat_fgs_group";
+    // id was chosen when fgs was the only channel
+    static final String COMPAT_GROUP_ID = "gmscompat_fgs_group";
     private static final String FGS_CHANNEL_ID = "gmscompat_fgs_channel";
     private static final int FGS_NOTIFICATION_ID = 529977835;
-    private static boolean fgsChannelCreated = false;
+    private static boolean notificationChannelsCreated;
 
     // Static only
     private GmsHooks() { }
 
 
     /*
      * Foreground service notifications to keep GMS services alive
      */
 
     // Make all services foreground to keep them alive
     // ContextImpl#startService(Intent)
     public static ComponentName startService(Context context, Intent service) {
         return context.startForegroundService(service);
     }
 
-    private static void createFgsChannel(Context context) {
-        if (fgsChannelCreated) {
-            return;
+    static Notification.Builder obtainNotificationBuilder(Context context, String channelId) {
+        if (!notificationChannelsCreated) {
+            createNotificationChannels(context);
+            notificationChannelsCreated = true;
         }
+        return new Notification.Builder(context, channelId);
+    }
 
-        NotificationManager notificationManager = (NotificationManager)
-                context.getSystemService(Context.NOTIFICATION_SERVICE);
-
-        NotificationChannelGroup group = new NotificationChannelGroup(FGS_GROUP_ID,
-                context.getText(R.string.foreground_service_gmscompat_group));
-        notificationManager.createNotificationChannelGroup(group);
+    private static void createNotificationChannels(Context context) {
+        NotificationManager manager = context.getSystemService(NotificationManager.class);
+        NotificationChannelGroup group = new NotificationChannelGroup(COMPAT_GROUP_ID,
+                context.getText(R.string.gmscompat_channel_group));
+        manager.createNotificationChannelGroup(group);
+
+        ArrayList<NotificationChannel> channels = new ArrayList<>(7);
+        {
+            CharSequence name = context.getText(R.string.foreground_service_gmscompat_channel);
+            NotificationChannel c = new NotificationChannel(FGS_CHANNEL_ID, name,
+                    NotificationManager.IMPORTANCE_LOW);
+            c.setDescription(context.getString(R.string.foreground_service_gmscompat_channel_desc));
+            c.setShowBadge(false);
+            channels.add(c);
+        }
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.createNotificationChannel(context, channels);
+        }
 
-        CharSequence name = context.getText(R.string.foreground_service_gmscompat_channel);
-        NotificationChannel channel = new NotificationChannel(FGS_CHANNEL_ID, name,
-                NotificationManager.IMPORTANCE_LOW);
-        channel.setGroup(FGS_GROUP_ID);
-        channel.setDescription(context.getString(R.string.foreground_service_gmscompat_channel_desc));
-        channel.setShowBadge(false);
-        notificationManager.createNotificationChannel(channel);
+        for (int i = 0; i < channels.size(); ++i) {
+            channels.get(i).setGroup(COMPAT_GROUP_ID);
+        }
 
-        fgsChannelCreated = true;
+        manager.createNotificationChannels(channels);
     }
 
     // Post notification on foreground service start
     // ActivityThread#handleCreateService(CreateServiceData)
     public static void attachService(Service service) {
         // Isolated processes (e.g. WebView) don't have access to NotificationManager. They don't
         // need a foreground notification anyway, so bail out early.
         if (!GmsCompat.isEnabled() || Process.isIsolated()) {
             return;
         }
 
-        // Channel
-        createFgsChannel(service);
-
         // Intent: notification channel settings
         Intent intent = new Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);
         intent.putExtra(Settings.EXTRA_APP_PACKAGE, service.getPackageName());
         intent.putExtra(Settings.EXTRA_CHANNEL_ID, FGS_CHANNEL_ID);
         PendingIntent pi = PendingIntent.getActivity(service, 0, intent, PendingIntent.FLAG_IMMUTABLE);
 
         // Notification
         CharSequence appName = service.getApplicationInfo().loadLabel(service.getPackageManager());
-        Notification notification = new Notification.Builder(service, FGS_CHANNEL_ID)
+        Notification notification = obtainNotificationBuilder(service, FGS_CHANNEL_ID)
                 .setSmallIcon(service.getApplicationInfo().icon)
                 .setContentTitle(service.getString(R.string.app_running_notification_title, appName))
                 .setContentText(service.getText(R.string.foreground_service_gmscompat_notif_desc))
                 .setContentIntent(pi)
                 .build();
 
         Log.d(TAG, "Posting notification for service: " + service.getClass().getName());
         service.startForeground(FGS_NOTIFICATION_ID, notification);
     }
 
     // GMS tries to clean up its own notification channels periodically.
-    // Don't let it delete the FGS shim channel because that throws an exception and crashes GMS.
+    // Don't let it delete any of compat channels because that throws an exception and crashes GMS.
     // NotificationManager#deleteNotificationChannel(String)
     public static boolean skipDeleteNotificationChannel(String channelId) {
-        return GmsCompat.isEnabled() && FGS_CHANNEL_ID.equals(channelId);
+        if (! GmsCompat.isEnabled()) {
+            return false;
+        }
+        return FGS_CHANNEL_ID.equals(channelId) || PlayStoreHooks.PUA_CHANNEL_ID.equals(channelId);
     }
 
-
     /**
      * API shims
      */
 
     // Report a single user on the system
     // UserManager#getSerialNumbersOfUsers(boolean)
     public static long[] getSerialNumbersOfUsers(UserManager userManager) {
         return new long[] { userManager.getSerialNumberForUser(Process.myUserHandle()) };
     }
 
@@ -191,66 +203,31 @@ public final class GmsHooks {
         }
 
         // Remove MATCH_ANY_USER flag to avoid permission denial
         return flags & ~PackageManager.MATCH_ANY_USER;
     }
 
     // Fix RuntimeException: Using WebView from more than one process at once with the same data
     // directory is not supported. https://crbug.com/558377
     // Instrumentation#newApplication(ClassLoader, String, Context)
     public static void initApplicationBeforeOnCreate(Application app) {
-        GmsCompat.initChangeEnableStates();
+        GmsCompat.initChangeEnableStates(app);
 
         if (GmsCompat.isEnabled()) {
             String processName = Application.getProcessName();
             if (!app.getPackageName().equals(processName)) {
                 WebView.setDataDirectorySuffix("process-shim--" + processName);
             }
 
             GmsDynamiteHooks.initGmsServerApp(app);
         } else if (GmsCompat.isDynamiteClient()) {
             GmsDynamiteHooks.initClientApp();
         }
     }
 
-    // Request user action for package install sessions
-    // LoadedApk.ReceiverDispatcher.InnerReceiver#performReceive(Intent, int, String, Bundle, boolean, boolean, int)
-    public static boolean performReceive(Intent intent) {
-        if (!GmsCompat.isEnabled()) {
-            return false;
-        }
-
-        // Validate - we only want to handle user action requests
-        if (!(intent.hasExtra(PackageInstaller.EXTRA_SESSION_ID) &&
-                intent.hasExtra(PackageInstaller.EXTRA_STATUS) &&
-                intent.hasExtra(Intent.EXTRA_INTENT))) {
-            return false;
-        }
-        if (intent.getIntExtra(PackageInstaller.EXTRA_STATUS, 0) !=
-                PackageInstaller.STATUS_PENDING_USER_ACTION) {
-            return false;
-        }
-
-        Application app = ActivityThread.currentApplication();
-        if (app == null) {
-            return false;
-        }
-
-        // Use the intent
-        Log.i(TAG, "Requesting user confirmation for package install session");
-        Intent confirmIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
-        // Make it work with the Application context
-        confirmIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        // TODO: post notification if app is in the background
-        app.startActivity(confirmIntent);
-
-        // Don't dispatch it, otherwise Play Store abandons the session
-        return true;
-    }
-
     // Redirect cross-user interactions to current user
     // ContextImpl#sendOrderedBroadcastAsUser
     // ContextImpl#sendBroadcastAsUser
     public static UserHandle getUserHandle(UserHandle user) {
         return GmsCompat.isEnabled() ? Process.myUserHandle() : user;
     }
 }
diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
new file mode 100644
index 0000000000000000000000000000000000000000..85f14b531bac25056088b3d6caec6635a0c099fb
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+import android.app.ActivityManager;
+import android.app.ActivityThread;
+import android.app.IActivityManager;
+import android.app.Notification;
+import android.app.NotificationChannel;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.IntentSender;
+import android.content.pm.IPackageDeleteObserver;
+import android.content.pm.PackageInstaller;
+import android.content.pm.PackageManager;
+import android.os.Process;
+import android.os.RemoteException;
+
+import com.android.internal.R;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicLong;
+
+import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
+
+public final class PlayStoreHooks {
+
+    private static final String TAG = "GmsCompat/PlayStore";
+
+    // Pending user action notifications
+    static final String PUA_CHANNEL_ID = "gmscompat_playstore_pua_channel";
+    private static final int PUA_NOTIFICATION_ID = 429825706;
+
+    private PlayStoreHooks() {}
+
+    static void createNotificationChannel(Context context, ArrayList<NotificationChannel> dest) {
+        CharSequence name = context.getText(R.string.gmscompat_notif_channel_action_required);
+        NotificationChannel c = new NotificationChannel(PUA_CHANNEL_ID, name,
+                NotificationManager.IMPORTANCE_LOW);
+        c.setShowBadge(false);
+
+        dest.add(c);
+    }
+
+    // Play Store doesn't handle PENDING_USER_ACTION status from PackageInstaller
+    // PackageInstaller.Session#commit(IntentSender)
+    // PackageInstaller#uninstall(VersionedPackage, int, IntentSender)
+    public static IntentSender wrapPackageInstallerStatusReceiver(IntentSender statusReceiver) {
+        Context context = ActivityThread.currentApplication();
+        Objects.requireNonNull(context);
+        return PackageInstallerStatusForwarder.wrap(context, statusReceiver).getIntentSender();
+    }
+
+    static class PackageInstallerStatusForwarder extends BroadcastReceiver {
+        private Context context;
+        private IntentSender target;
+
+        private static final AtomicLong lastId = new AtomicLong();
+
+        static PendingIntent wrap(Context context, IntentSender target) {
+            PackageInstallerStatusForwarder sf = new PackageInstallerStatusForwarder();
+            sf.context = context;
+            sf.target = target;
+
+            String intentAction = context.getPackageName()
+                + "." + PackageInstallerStatusForwarder.class.getName() + "."
+                + lastId.getAndIncrement();
+            context.registerReceiver(sf, new IntentFilter(intentAction));
+
+            return PendingIntent.getBroadcast(context, 0, new Intent(intentAction),
+                    PendingIntent.FLAG_CANCEL_CURRENT |
+                        PendingIntent.FLAG_MUTABLE);
+        }
+
+        public void onReceive(Context br_context, Intent intent) {
+            String statusKey = PackageInstaller.EXTRA_STATUS;
+            if (! intent.hasExtra(statusKey)) {
+                throw new IllegalStateException("no EXTRA_STATUS in intent " + intent);
+            }
+            int status = intent.getIntExtra(statusKey, 0);
+
+            if (status == PackageInstaller.STATUS_PENDING_USER_ACTION) {
+                Intent confirmationIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
+                confirmationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+                boolean foreground = isForeground(Process.myUid(), Process.myPid());
+
+                if (foreground) {
+                    context.startActivity(confirmationIntent);
+                } else {
+                    // allow multiple PUA notifications
+                    int id = PUA_NOTIFICATION_ID + (((int) lastId.get()) & 0xffff);
+
+                    PendingIntent pi = PendingIntent.getActivity(context, id, confirmationIntent,
+                        PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT);
+
+                    Notification notification =
+                        GmsHooks.obtainNotificationBuilder(context, PUA_CHANNEL_ID)
+                        // TODO better icon
+                        .setSmallIcon(context.getApplicationInfo().icon)
+                        .setContentTitle(context.getText(R.string.gmscompat_notif_channel_action_required))
+                        .setContentIntent(pi)
+                        .setAutoCancel(true)
+                        .build();
+
+                    NotificationManager nm = context.getSystemService(NotificationManager.class);
+                    nm.notify(id, notification);
+                }
+                // confirmationIntent has a PendingIntent to this instance, don't unregister yet
+                return;
+            }
+
+            context.unregisterReceiver(this);
+
+            try {
+                target.sendIntent(context, 0, intent, null, null);
+            } catch (IntentSender.SendIntentException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    static boolean isForeground(int uid, int pid) {
+        final List<ActivityManager.RunningAppProcessInfo> procs;
+        try {
+            // returns only processes that belong to the current app
+            procs = ActivityManager.getService().getRunningAppProcesses();
+            Objects.requireNonNull(procs);
+        } catch (RemoteException e) {
+            throw e.rethrowAsRuntimeException();
+        }
+        for (int i = 0; i < procs.size(); i++) {
+            ActivityManager.RunningAppProcessInfo proc = procs.get(i);
+            if (proc.pid == pid && proc.uid == uid
+                    && proc.importance == IMPORTANCE_FOREGROUND) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    // Request user action to uninstall a package
+    // ApplicationPackageManager#deletePackage(String, IPackageDeleteObserver, int)
+    public static void deletePackage(Context context, PackageManager pm, String packageName, IPackageDeleteObserver observer, int flags) {
+        if (flags != 0) {
+            throw new IllegalStateException("unexpected flags: " + flags);
+        }
+        PendingIntent pi = UninstallStatusForwarder.getPendingIntent(context, packageName, observer);
+        // will call PackageInstallerStatusForwarder,
+        // no need to handle confirmation in UninstallStatusForwarder
+        pm.getPackageInstaller().uninstall(packageName, pi.getIntentSender());
+    }
+
+    static class UninstallStatusForwarder extends BroadcastReceiver {
+        private Context context;
+        private String packageName;
+        private IPackageDeleteObserver target;
+
+        private static final AtomicLong lastId = new AtomicLong();
+
+        static PendingIntent getPendingIntent(Context context, String packageName, IPackageDeleteObserver target) {
+            UninstallStatusForwarder sf = new UninstallStatusForwarder();
+            sf.context = context;
+            sf.packageName = packageName;
+            sf.target = target;
+
+            String intentAction = context.getPackageName()
+                + "." + UninstallStatusForwarder.class.getName() + "."
+                + lastId.getAndIncrement();
+
+            context.registerReceiver(sf, new IntentFilter(intentAction));
+
+            return PendingIntent.getBroadcast(context, 0, new Intent(intentAction),
+                    PendingIntent.FLAG_CANCEL_CURRENT |
+                        PendingIntent.FLAG_ONE_SHOT |
+                        PendingIntent.FLAG_MUTABLE);
+        }
+
+        public void onReceive(Context br_context, Intent intent) {
+            context.unregisterReceiver(this);
+
+            // EXTRA_STATUS returns PackageInstaller constant,
+            // EXTRA_LEGACY_STATUS returns PackageManager constant
+            String statusKey = PackageInstaller.EXTRA_LEGACY_STATUS;
+            if (!intent.hasExtra(statusKey)) {
+                throw new IllegalStateException("no EXTRA_LEGACY_STATUS in intent " + intent);
+            }
+
+            int status = intent.getIntExtra(statusKey, 0);
+            try {
+                target.packageDeleted(packageName, status);
+            } catch (RemoteException e) {
+                throw e.rethrowAsRuntimeException();
+            }
+        }
+    }
+}
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index 00b1bbfb52f180923370130deb4498cf67a83543..c9df9033da6e062df84d3df7cb4f29b1042414fc 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -757,34 +757,36 @@
         data usage</string>
 
     <!-- Separator for foreground service notification content listing all apps when there
         are multiple apps running.  The left and right side may both already be compound
         (constructed using this separator).  Should be kept as short as possible, this is
         for summary text in the notification where there is not a lot of space.
         [CHAR LIMIT=NONE] -->
     <string name="foreground_service_multiple_separator"><xliff:g id="left_side">%1$s</xliff:g>,
         <xliff:g id="right_side">%2$s</xliff:g></string>
 
-    <!-- Name for foreground service notification channel group created by GmsCompat  -->
-    <string name="foreground_service_gmscompat_group">Compatibility</string>
+    <!-- Name for GmsCompat notification channel group -->
+    <string name="gmscompat_channel_group">Compatibility</string>
 
     <!-- Name for foreground service notification channel created by GmsCompat  -->
     <string name="foreground_service_gmscompat_channel">Services</string>
 
     <!-- Description for foreground service notification channel created by GmsCompat  -->
     <string name="foreground_service_gmscompat_channel_desc">These notifications are created by the
         Google Play Services compatibility layer in order to keep services running in the
         background.\n\nDisable this category to hide the unnecessary notifications.</string>
 
     <!-- Description for foreground service notifications created by GmsCompat  -->
     <string name="foreground_service_gmscompat_notif_desc">Tap to hide</string>
 
+    <string name="gmscompat_notif_channel_action_required">Action required</string>
+
     <!-- Displayed to the user to tell them that they have started up the phone in "safe mode" -->
     <string name="safeMode">Safe mode</string>
 
     <!-- Label for the Android system components when they are shown to the user. -->
     <string name="android_system_label">Android System</string>
 
     <!-- "Switch" is a verb; it means to change user profile by tapping another user profile name. -->
     <string name="user_owner_label">Switch to personal profile</string>
 
     <!-- "Switch" is a verb; it means to change user profile by tapping another user profile name. -->
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 66516dc4bf4ff7102fcb9fd6ab6a4b921b1be482..c48eaccaa3b56bf18b803ae3ea07957953f2ca0f 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -3634,24 +3634,25 @@
   <java-symbol type="string" name="config_defaultSystemCaptionsManagerService" />
   <java-symbol type="string" name="config_retailDemoPackage" />
   <java-symbol type="string" name="config_retailDemoPackageSignature" />
 
   <java-symbol type="string" name="notification_channel_foreground_service" />
   <java-symbol type="string" name="foreground_service_app_in_background" />
   <java-symbol type="string" name="foreground_service_apps_in_background" />
   <java-symbol type="string" name="foreground_service_tap_for_details" />
   <java-symbol type="string" name="foreground_service_multiple_separator" />
 
-  <java-symbol type="string" name="foreground_service_gmscompat_group" />
+  <java-symbol type="string" name="gmscompat_channel_group" />
   <java-symbol type="string" name="foreground_service_gmscompat_channel" />
   <java-symbol type="string" name="foreground_service_gmscompat_channel_desc" />
   <java-symbol type="string" name="foreground_service_gmscompat_notif_desc" />
+  <java-symbol type="string" name="gmscompat_notif_channel_action_required" />
 
   <java-symbol type="bool" name="config_enableCredentialFactoryResetProtection" />
 
   <!-- ETWS primary messages -->
   <java-symbol type="string" name="etws_primary_default_message_earthquake" />
   <java-symbol type="string" name="etws_primary_default_message_tsunami" />
   <java-symbol type="string" name="etws_primary_default_message_earthquake_and_tsunami" />
   <java-symbol type="string" name="etws_primary_default_message_test" />
   <java-symbol type="string" name="etws_primary_default_message_others" />
 

commit 4d38ba991ebad849563abbed7b2f457733e5fb99
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Thu 2021-11-18 12:04:59-0500

    minor style fix
---
 core/java/com/android/internal/gmscompat/GmsHooks.java       | 2 +-
 core/java/com/android/internal/gmscompat/PlayStoreHooks.java | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
index 9150bdf03d3571d75dd777d7a27befff017832c5..345a8b1619e68b62b8d17464d3f711b3421d8dd6 100644
--- a/core/java/com/android/internal/gmscompat/GmsHooks.java
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -136,21 +136,21 @@ public final class GmsHooks {
                 .build();
 
         Log.d(TAG, "Posting notification for service: " + service.getClass().getName());
         service.startForeground(FGS_NOTIFICATION_ID, notification);
     }
 
     // GMS tries to clean up its own notification channels periodically.
     // Don't let it delete any of compat channels because that throws an exception and crashes GMS.
     // NotificationManager#deleteNotificationChannel(String)
     public static boolean skipDeleteNotificationChannel(String channelId) {
-        if (! GmsCompat.isEnabled()) {
+        if (!GmsCompat.isEnabled()) {
             return false;
         }
         return FGS_CHANNEL_ID.equals(channelId) || PlayStoreHooks.PUA_CHANNEL_ID.equals(channelId);
     }
 
     /**
      * API shims
      */
 
     // Report a single user on the system
diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
index 85f14b531bac25056088b3d6caec6635a0c099fb..938cb4c67291039ae46517b5a977d49b0b137389 100644
--- a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -87,21 +87,21 @@ public final class PlayStoreHooks {
                 + lastId.getAndIncrement();
             context.registerReceiver(sf, new IntentFilter(intentAction));
 
             return PendingIntent.getBroadcast(context, 0, new Intent(intentAction),
                     PendingIntent.FLAG_CANCEL_CURRENT |
                         PendingIntent.FLAG_MUTABLE);
         }
 
         public void onReceive(Context br_context, Intent intent) {
             String statusKey = PackageInstaller.EXTRA_STATUS;
-            if (! intent.hasExtra(statusKey)) {
+            if (!intent.hasExtra(statusKey)) {
                 throw new IllegalStateException("no EXTRA_STATUS in intent " + intent);
             }
             int status = intent.getIntExtra(statusKey, 0);
 
             if (status == PackageInstaller.STATUS_PENDING_USER_ACTION) {
                 Intent confirmationIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
                 confirmationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
 
                 boolean foreground = isForeground(Process.myUid(), Process.myPid());
 

commit 898ee8d401896bf8115e91f54cba0a177d093873
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Fri 2021-11-19 13:48:41+0200

    gmscompat: compatibility with Play Store self-update
---
 .../android/app/ApplicationPackageManager.java     |  4 ++
 core/java/android/content/ContentResolver.java     |  5 +++
 .../android/internal/gmscompat/PlayStoreHooks.java | 47 ++++++++++++++++++++++
 3 files changed, 56 insertions(+)

diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index 0f1d8dfc023006f17d6a21b3f06d9d344ff03f6c..1dff532256e8a361b7fe6fdeacbc2d40cac28076 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -2557,20 +2557,24 @@ public class ApplicationPackageManager extends PackageManager {
         try {
             mPM.deleteApplicationCacheFilesAsUser(packageName, userId, observer);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public void freeStorageAndNotify(String volumeUuid, long idealStorageSize,
             IPackageDataObserver observer) {
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.freeStorageAndNotify(mContext, volumeUuid, idealStorageSize, observer);
+            return;
+        }
         try {
             mPM.freeStorageAndNotify(volumeUuid, idealStorageSize, 0, observer);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public void freeStorage(String volumeUuid, long freeStorageSize, IntentSender pi) {
         try {
diff --git a/core/java/android/content/ContentResolver.java b/core/java/android/content/ContentResolver.java
index 265ff331ffa06398b7e68f396cbf86c238303f54..65e8f48a3c6eb8d748e3d693df38c2fd3aceef7a 100644
--- a/core/java/android/content/ContentResolver.java
+++ b/core/java/android/content/ContentResolver.java
@@ -24,20 +24,21 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.annotation.UserIdInt;
 import android.app.ActivityManager;
 import android.app.ActivityThread;
 import android.app.AppGlobals;
 import android.app.UriGrantsManager;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.res.AssetFileDescriptor;
 import android.content.res.Resources;
 import android.database.ContentObserver;
 import android.database.CrossProcessCursorWrapper;
 import android.database.Cursor;
 import android.database.IContentObserver;
 import android.graphics.Bitmap;
@@ -64,20 +65,21 @@ import android.os.ServiceManager;
 import android.os.SystemClock;
 import android.os.UserHandle;
 import android.system.Int64Ref;
 import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
 import android.util.Size;
 import android.util.SparseArray;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.PlayStoreHooks;
 import com.android.internal.util.MimeIconUtils;
 
 import dalvik.system.CloseGuard;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -2170,20 +2172,23 @@ public abstract class ContentResolver implements ContentInterface {
      *            which arguments they support.
      * @return the URL of the newly created row. May return <code>null</code> if the underlying
      *         content provider returns <code>null</code>, or if it crashes.
      * @throws IllegalArgumentException if the provider doesn't support one of
      *             the requested Bundle arguments.
      */
     @Override
     public final @Nullable Uri insert(@RequiresPermission.Write @NonNull Uri url,
             @Nullable ContentValues values, @Nullable Bundle extras) {
         Objects.requireNonNull(url, "url");
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.filterContentValues(url, values);
+        }
 
         try {
             if (mWrapped != null) return mWrapped.insert(url, values, extras);
         } catch (RemoteException e) {
             return null;
         }
 
         IContentProvider provider = acquireProvider(url);
         if (provider == null) {
             throw new IllegalArgumentException("Unknown URL " + url);
diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
index 938cb4c67291039ae46517b5a977d49b0b137389..f197ee2da3e14c25dc91e84cd431fdd82e137c0f 100644
--- a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -17,32 +17,38 @@
 package com.android.internal.gmscompat;
 
 import android.app.ActivityManager;
 import android.app.ActivityThread;
 import android.app.IActivityManager;
 import android.app.Notification;
 import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.content.BroadcastReceiver;
+import android.content.ContentValues;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.IntentSender;
+import android.content.pm.IPackageDataObserver;
 import android.content.pm.IPackageDeleteObserver;
 import android.content.pm.PackageInstaller;
 import android.content.pm.PackageManager;
+import android.net.Uri;
 import android.os.Process;
 import android.os.RemoteException;
+import android.os.storage.StorageManager;
+import android.provider.Downloads;
 
 import com.android.internal.R;
 
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicLong;
 
 import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
 
 public final class PlayStoreHooks {
 
     private static final String TAG = "GmsCompat/PlayStore";
@@ -207,11 +213,52 @@ public final class PlayStoreHooks {
             }
 
             int status = intent.getIntExtra(statusKey, 0);
             try {
                 target.packageDeleted(packageName, status);
             } catch (RemoteException e) {
                 throw e.rethrowAsRuntimeException();
             }
         }
     }
+
+    // Called during self-update sequence because PackageManager requires
+    // the restricted CLEAR_APP_CACHE permission
+    // ApplicationPackageManager#freeStorageAndNotify(String, long, IPackageDataObserver)
+    public static void freeStorageAndNotify(Context context, String volumeUuid, long idealStorageSize,
+            IPackageDataObserver observer) {
+        if (volumeUuid != null) {
+            throw new IllegalStateException("unexpected volumeUuid " + volumeUuid);
+        }
+        StorageManager sm = context.getSystemService(StorageManager.class);
+        boolean success = false;
+        try {
+            sm.allocateBytes(StorageManager.UUID_DEFAULT, idealStorageSize);
+            success = true;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        try {
+            // same behavior as PackageManagerService#freeStorageAndNotify()
+            String packageName = null;
+            observer.onRemoveCompleted(packageName, success);
+        } catch (RemoteException e) {
+            throw e.rethrowAsRuntimeException();
+        }
+    }
+
+    // Called during self-update sequence
+    // ContentResolver#insert(Uri, ContentValues, Bundle)
+    public static void filterContentValues(Uri url, ContentValues values) {
+        if (values != null && "content://downloads/my_downloads".equals(url.toString())) {
+            // gated by the restricted ACCESS_DOWNLOAD_MANAGER_ADVANCED permission
+            String otherUid = Downloads.Impl.COLUMN_OTHER_UID;
+            if (values.containsKey(otherUid)) {
+                int v = values.getAsInteger(otherUid).intValue();
+                if (v != 1000) {
+                    throw new IllegalStateException("unexpected COLUMN_OTHER_UID " + v);
+                }
+                values.remove(otherUid);
+            }
+        }
+    }
 }

commit 8bf2b6996c76d05bb9a1123d039ce86fd18fda1b
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Mon 2021-11-22 17:56:16+0200

    gmscompat: mark confirmation notification from Play Store as ongoing
    
    Play Store will wait for confirmation indefinitely if notification is dismissed.
    Ongoing notifications can't be dismissed (swiped away) by the user.
---
 core/java/com/android/internal/gmscompat/PlayStoreHooks.java | 1 +
 1 file changed, 1 insertion(+)

diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
index f197ee2da3e14c25dc91e84cd431fdd82e137c0f..659a5a0c40503b909cb78f5f94338dd6492aca9b 100644
--- a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -119,20 +119,21 @@ public final class PlayStoreHooks {
 
                     PendingIntent pi = PendingIntent.getActivity(context, id, confirmationIntent,
                         PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT);
 
                     Notification notification =
                         GmsHooks.obtainNotificationBuilder(context, PUA_CHANNEL_ID)
                         // TODO better icon
                         .setSmallIcon(context.getApplicationInfo().icon)
                         .setContentTitle(context.getText(R.string.gmscompat_notif_channel_action_required))
                         .setContentIntent(pi)
+                        .setOngoing(true)
                         .setAutoCancel(true)
                         .build();
 
                     NotificationManager nm = context.getSystemService(NotificationManager.class);
                     nm.notify(id, notification);
                 }
                 // confirmationIntent has a PendingIntent to this instance, don't unregister yet
                 return;
             }
 

commit 3bcbbfd77d41a4982e9c67a2b820834cf9c02706
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Tue 2021-11-23 21:02:26+0200

    gmscompat: fix push notifications in secondary user profiles
    
    UserManager.isUserUnlocked(userId) returns whether a user exited the Direct Boot mode.
    This method requires a restricted permission if userId parameter differs from the current userId.
    GMS called this method with userId 0 in both primary (userId == 0) and secondary (userId != 0)
    profiles. userId was always 0 likely because of the stubbed out
    UserManager.getUserSerialNumber(userId),
    which always returned 0 as a workaround to a different issue.
---
 core/java/android/os/UserManager.java | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/core/java/android/os/UserManager.java b/core/java/android/os/UserManager.java
index d1f0d12e039a98fc7430b5c1869245e58ce8c710..b8179c8c3dc5b1161b00c981c3bfd2d6e0725df6 100644
--- a/core/java/android/os/UserManager.java
+++ b/core/java/android/os/UserManager.java
@@ -2520,20 +2520,23 @@ public class UserManager {
                         throw re.rethrowFromSystemServer();
                     }
                 }
             };
 
     /** {@hide} */
     @UnsupportedAppUsage
     @RequiresPermission(anyOf = {Manifest.permission.MANAGE_USERS,
             Manifest.permission.INTERACT_ACROSS_USERS}, conditional = true)
     public boolean isUserUnlocked(@UserIdInt int userId) {
+        if (GmsCompat.isEnabled()) {
+            return mIsUserUnlockedCache.query(mUserId);
+        }
         return mIsUserUnlockedCache.query(userId);
     }
 
     /** {@hide} */
     public void disableIsUserUnlockedCache() {
         mIsUserUnlockedCache.disableLocal();
         mIsUserUnlockingOrUnlockedCache.disableLocal();
     }
 
     /** {@hide} */

commit 859354b0410cc08ae0ac731306c14e5a73cbe7c6
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Thu 2021-11-25 21:46:42+0200

    gmscompat: make sure PackageInstaller UI returns a result
---
 .../android/packageinstaller/PackageInstallerActivity.java   | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java b/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java
index 9c6113ce4b47935d36ae29430e91d943ddf82df5..9f4fb4cabf3a467e31685ac44988d4bd6ace4289 100644
--- a/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java
+++ b/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java
@@ -122,20 +122,21 @@ public class PackageInstallerActivity extends AlertActivity {
     private static final int DLG_ANONYMOUS_SOURCE = DLG_BASE + 6;
     private static final int DLG_NOT_SUPPORTED_ON_WEAR = DLG_BASE + 7;
     private static final int DLG_EXTERNAL_SOURCE_BLOCKED = DLG_BASE + 8;
     private static final int DLG_INSTALL_APPS_RESTRICTED_FOR_USER = DLG_BASE + 9;
 
     // If unknown sources are temporary allowed
     private boolean mAllowUnknownSources;
 
     // Would the mOk button be enabled if this activity would be resumed
     private boolean mEnableOk = false;
+    private boolean mPermissionResultWasSet;
 
     private void startInstallConfirm() {
         View viewToEnable;
 
         if (mAppInfo != null) {
             viewToEnable = requireViewById(R.id.install_confirm_question_update);
             mOk.setText(R.string.update);
         } else {
             // This is a new application with no permissions.
             viewToEnable = requireViewById(R.id.install_confirm_question);
@@ -291,20 +292,21 @@ public class PackageInstallerActivity extends AlertActivity {
         Intent result = new Intent();
         result.putExtra(Intent.EXTRA_INSTALL_RESULT, pmResult);
         setResult(pmResult == PackageManager.INSTALL_SUCCEEDED
                 ? RESULT_OK : RESULT_FIRST_USER, result);
     }
 
     @Override
     protected void onCreate(Bundle icicle) {
         if (mLocalLOGV) Log.i(TAG, "creating for user " + getUserId());
         getWindow().addSystemFlags(SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS);
+        getWindow().setCloseOnTouchOutside(false);
 
         super.onCreate(null);
 
         if (icicle != null) {
             mAllowUnknownSources = icicle.getBoolean(ALLOW_UNKNOWN_SOURCES_KEY);
         }
 
         mPm = getPackageManager();
         mIpm = AppGlobals.getPackageManager();
         mAppOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);
@@ -383,20 +385,27 @@ public class PackageInstallerActivity extends AlertActivity {
     }
 
     @Override
     protected void onPause() {
         super.onPause();
 
         if (mOk != null) {
             // Don't allow the install button to be clicked as there might be overlays
             mOk.setEnabled(false);
         }
+        // sometimes this activity becomes hidden after onPause(),
+        // and the user is unable to bring it back
+        if (!mPermissionResultWasSet && mSessionId != -1) {
+            mInstaller.setPermissionsResult(mSessionId, false);
+            mPermissionResultWasSet = true;
+            finish();
+        }
     }
 
     @Override
     protected void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
 
         outState.putBoolean(ALLOW_UNKNOWN_SOURCES_KEY, mAllowUnknownSources);
     }
 
     @Override
@@ -409,32 +418,34 @@ public class PackageInstallerActivity extends AlertActivity {
 
     private void bindUi() {
         mAlert.setIcon(mAppSnippet.icon);
         mAlert.setTitle(mAppSnippet.label);
         mAlert.setView(R.layout.install_content_view);
         mAlert.setButton(DialogInterface.BUTTON_POSITIVE, getString(R.string.install),
                 (ignored, ignored2) -> {
                     if (mOk.isEnabled()) {
                         if (mSessionId != -1) {
                             mInstaller.setPermissionsResult(mSessionId, true);
+                            mPermissionResultWasSet = true;
                             finish();
                         } else {
                             startInstall();
                         }
                     }
                 }, null);
         mAlert.setButton(DialogInterface.BUTTON_NEGATIVE, getString(R.string.cancel),
                 (ignored, ignored2) -> {
                     // Cancel and finish
                     setResult(RESULT_CANCELED);
                     if (mSessionId != -1) {
                         mInstaller.setPermissionsResult(mSessionId, false);
+                        mPermissionResultWasSet = true;
                     }
                     finish();
                 }, null);
         setupAlert();
 
         mOk = mAlert.getButton(DialogInterface.BUTTON_POSITIVE);
         mOk.setEnabled(false);
 
         if (!mOk.isInTouchMode()) {
             mAlert.getButton(DialogInterface.BUTTON_NEGATIVE).requestFocus();
@@ -592,20 +603,21 @@ public class PackageInstallerActivity extends AlertActivity {
             }
         }
 
         return true;
     }
 
     @Override
     public void onBackPressed() {
         if (mSessionId != -1) {
             mInstaller.setPermissionsResult(mSessionId, false);
+            mPermissionResultWasSet = true;
         }
         super.onBackPressed();
     }
 
     private void startInstall() {
         // Start subactivity to actually install the application
         Intent newIntent = new Intent();
         newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,
                 mPkgInfo.applicationInfo);
         newIntent.setData(mPackageURI);

commit 4feae1287a4efb79b4a3e22f7d5e2a0c80e92f40
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Thu 2021-11-25 21:53:44+0200

    gmscompat: use a reliable "is app foreground" check
    
    Previous check returned a false positive shortly after activity was paused,
    which led to startActivity() silently failing.
---
 core/java/android/app/ActivityThread.java          | 11 ++++++++
 .../android/internal/gmscompat/PlayStoreHooks.java | 29 +++-------------------
 2 files changed, 14 insertions(+), 26 deletions(-)

diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index f6336956b35b9c65ab85c5ecc8c74d0cf24f8ac2..666e832acb294b5869fe7f0b8f2ccda295809205 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -7953,11 +7953,22 @@ public final class ActivityThread extends ClientTransactionHandler
 
     @Override
     public boolean isInDensityCompatMode() {
         return mDensityCompatMode;
     }
 
     // ------------------ Regular JNI ------------------------
     private native void nPurgePendingResources();
     private native void nDumpGraphicsInfo(FileDescriptor fd);
     private native void nInitZygoteChildHeapProfiling();
+
+    public boolean hasAtLeastOneResumedActivity() {
+        synchronized (mResourcesManager) {
+            for (int i = 0; i < mActivities.size(); ++i) {
+                if (mActivities.valueAt(i).getLifecycleState() == ActivityLifecycleItem.ON_RESUME) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
 }
diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
index 659a5a0c40503b909cb78f5f94338dd6492aca9b..34832a6ee6f6c94174fd0f9c59a3b03959e53dcb 100644
--- a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -9,21 +9,20 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.android.internal.gmscompat;
 
-import android.app.ActivityManager;
 import android.app.ActivityThread;
 import android.app.IActivityManager;
 import android.app.Notification;
 import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.content.BroadcastReceiver;
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.Intent;
@@ -36,26 +35,23 @@ import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.storage.StorageManager;
 import android.provider.Downloads;
 
 import com.android.internal.R;
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicLong;
 
-import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
-
 public final class PlayStoreHooks {
 
     private static final String TAG = "GmsCompat/PlayStore";
 
     // Pending user action notifications
     static final String PUA_CHANNEL_ID = "gmscompat_playstore_pua_channel";
     private static final int PUA_NOTIFICATION_ID = 429825706;
 
     private PlayStoreHooks() {}
 
@@ -102,23 +98,23 @@ public final class PlayStoreHooks {
             String statusKey = PackageInstaller.EXTRA_STATUS;
             if (!intent.hasExtra(statusKey)) {
                 throw new IllegalStateException("no EXTRA_STATUS in intent " + intent);
             }
             int status = intent.getIntExtra(statusKey, 0);
 
             if (status == PackageInstaller.STATUS_PENDING_USER_ACTION) {
                 Intent confirmationIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
                 confirmationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
 
-                boolean foreground = isForeground(Process.myUid(), Process.myPid());
-
-                if (foreground) {
+                // there is no public API that I'm aware of (as of API 31)
+                // that would allow to *reliably* find this out
+                if (ActivityThread.currentActivityThread().hasAtLeastOneResumedActivity()) {
                     context.startActivity(confirmationIntent);
                 } else {
                     // allow multiple PUA notifications
                     int id = PUA_NOTIFICATION_ID + (((int) lastId.get()) & 0xffff);
 
                     PendingIntent pi = PendingIntent.getActivity(context, id, confirmationIntent,
                         PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_IMMUTABLE | PendingIntent.FLAG_CANCEL_CURRENT);
 
                     Notification notification =
                         GmsHooks.obtainNotificationBuilder(context, PUA_CHANNEL_ID)
@@ -140,39 +136,20 @@ public final class PlayStoreHooks {
             context.unregisterReceiver(this);
 
             try {
                 target.sendIntent(context, 0, intent, null, null);
             } catch (IntentSender.SendIntentException e) {
                 e.printStackTrace();
             }
         }
     }
 
-    static boolean isForeground(int uid, int pid) {
-        final List<ActivityManager.RunningAppProcessInfo> procs;
-        try {
-            // returns only processes that belong to the current app
-            procs = ActivityManager.getService().getRunningAppProcesses();
-            Objects.requireNonNull(procs);
-        } catch (RemoteException e) {
-            throw e.rethrowAsRuntimeException();
-        }
-        for (int i = 0; i < procs.size(); i++) {
-            ActivityManager.RunningAppProcessInfo proc = procs.get(i);
-            if (proc.pid == pid && proc.uid == uid
-                    && proc.importance == IMPORTANCE_FOREGROUND) {
-                return true;
-            }
-        }
-        return false;
-    }
-
     // Request user action to uninstall a package
     // ApplicationPackageManager#deletePackage(String, IPackageDeleteObserver, int)
     public static void deletePackage(Context context, PackageManager pm, String packageName, IPackageDeleteObserver observer, int flags) {
         if (flags != 0) {
             throw new IllegalStateException("unexpected flags: " + flags);
         }
         PendingIntent pi = UninstallStatusForwarder.getPendingIntent(context, packageName, observer);
         // will call PackageInstallerStatusForwarder,
         // no need to handle confirmation in UninstallStatusForwarder
         pm.getPackageInstaller().uninstall(packageName, pi.getIntentSender());

commit d1ac1e92a7547d54935c4878b34e959c8e2b679f
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Thu 2021-11-25 21:56:12+0200

    gmscompat: System.exit(1) if package uninstallation is declined
---
 core/java/com/android/internal/gmscompat/PlayStoreHooks.java | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
index 34832a6ee6f6c94174fd0f9c59a3b03959e53dcb..b854ac439b1e6c84aff516f56a8bd7e4883967d1 100644
--- a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -184,20 +184,29 @@ public final class PlayStoreHooks {
             context.unregisterReceiver(this);
 
             // EXTRA_STATUS returns PackageInstaller constant,
             // EXTRA_LEGACY_STATUS returns PackageManager constant
             String statusKey = PackageInstaller.EXTRA_LEGACY_STATUS;
             if (!intent.hasExtra(statusKey)) {
                 throw new IllegalStateException("no EXTRA_LEGACY_STATUS in intent " + intent);
             }
 
             int status = intent.getIntExtra(statusKey, 0);
+            if (status != PackageManager.DELETE_SUCCEEDED) {
+                // Play Store doesn't expect uninstallation to fail and ends up in an inconsistent UI state,
+                // which requires user-initiated "Force stop" as a workaround
+                // Most likely cause of a failure is accidental rejection of the second confirmation prompt:
+                // Play Store shows its own confirmation UI before PackageInstaller confirmation UI
+                // is shown. It is unlikely that the user deliberately accepted the first prompt and
+                // rejected the second one
+                System.exit(1);
+            }
             try {
                 target.packageDeleted(packageName, status);
             } catch (RemoteException e) {
                 throw e.rethrowAsRuntimeException();
             }
         }
     }
 
     // Called during self-update sequence because PackageManager requires
     // the restricted CLEAR_APP_CACHE permission

commit 4f79b2a9d0940bf9567a7f7cddebb5a4fab640df
Author: Diab Neiroukh <lazerl0rd@thezest.dev>
Date:   Wed 2021-06-30 09:57:06+0100

    Add a config to state whether a device supports increased touch sensitivity. (#2)
    
    This is the partner commit to the addition of an option in Settings for
    the same feature. This config can be enabled by an overlay for devices
    that support increased touch sensitivity (otherwise known as "Glove
    Mode") via the persist.vendor.touch_sensitivity_mode system property.
    
    Signed-off-by: Diab Neiroukh <lazerl0rd@thezest.dev>
---
 core/res/res/values/config.xml  | 3 +++
 core/res/res/values/symbols.xml | 1 +
 2 files changed, 4 insertions(+)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 5965635c73716d4464808356d7b9cfe92bc23de1..51e8b02d93a8984589f854549ddd274839e683e6 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -3357,20 +3357,23 @@
     <!-- This config is used to force VoiceInteractionService to start on certain low ram devices.
          It declares the package name of VoiceInteractionService that should be started. -->
     <string translatable="false" name="config_forceVoiceInteractionServicePackage"></string>
 
     <!-- This config is ued to determine whether animations are allowed in low power mode. -->
     <bool name="config_allowAnimationsInLowPowerMode">false</bool>
 
     <!-- Whether device supports double tap to wake -->
     <bool name="config_supportDoubleTapWake">false</bool>
 
+    <!-- Whether device supports increased touch sensitvity -->
+    <bool name="config_supportGloveMode">false</bool>
+
     <!-- The RadioAccessFamilies supported by the device.
          Empty is viewed as "all".  Only used on devices which
          don't support RIL_REQUEST_GET_RADIO_CAPABILITY
          format is UMTS|LTE|... -->
     <string translatable="false" name="config_radio_access_family"></string>
 
     <!-- Whether the main built-in display is round. This will affect
          Configuration.screenLayout's SCREENLAYOUT_ROUND_MASK flags for Configurations on the
          main built-in display. Change this in device-specific overlays.
          Defaults to the older, deprecated config_windowIsRound already used in
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index c48eaccaa3b56bf18b803ae3ea07957953f2ca0f..c85c256d7bbdd594cb4854ad345953dee7917844 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -2879,20 +2879,21 @@
   <java-symbol type="layout" name="resolve_grid_item" />
   <java-symbol type="id" name="day_picker_view_pager" />
   <java-symbol type="layout" name="day_picker_content_material" />
   <java-symbol type="drawable" name="scroll_indicator_material" />
 
   <java-symbol type="layout" name="chooser_row" />
   <java-symbol type="layout" name="chooser_profile_row" />
   <java-symbol type="color" name="chooser_row_divider" />
   <java-symbol type="layout" name="chooser_row_direct_share" />
   <java-symbol type="bool" name="config_supportDoubleTapWake" />
+  <java-symbol type="bool" name="config_supportGloveMode" />
   <java-symbol type="drawable" name="ic_perm_device_info" />
   <java-symbol type="string" name="config_radio_access_family" />
   <java-symbol type="string" name="notification_inbox_ellipsis" />
   <java-symbol type="bool" name="config_mainBuiltInDisplayIsRound" />
 
   <java-symbol type="id" name="actions_container" />
   <java-symbol type="id" name="actions_container_layout" />
   <java-symbol type="id" name="smart_reply_container" />
   <java-symbol type="id" name="remote_input_tag" />
   <java-symbol type="id" name="pending_intent_tag" />

commit bc5997fa9505f7bfdefeff0eaae7e7816f3aefc3
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Wed 2021-12-08 19:54:15+0200

    gmscompat: set foregroundServiceType of location services
    
    Without it, location access gets throttled after a few minutes.
---
 .../android/content/pm/parsing/component/ParsedServiceUtils.java    | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/core/java/android/content/pm/parsing/component/ParsedServiceUtils.java b/core/java/android/content/pm/parsing/component/ParsedServiceUtils.java
index ae107ce65bf8aa5936580929bfe0d4c06757d7c3..df6b2dd8d28edf71f42aad03e4e46c6b36909541 100644
--- a/core/java/android/content/pm/parsing/component/ParsedServiceUtils.java
+++ b/core/java/android/content/pm/parsing/component/ParsedServiceUtils.java
@@ -25,20 +25,21 @@ import android.content.pm.parsing.ParsingPackage;
 import android.content.pm.parsing.ParsingUtils;
 import android.content.pm.parsing.result.ParseInput;
 import android.content.pm.parsing.result.ParseInput.DeferredError;
 import android.content.pm.parsing.result.ParseResult;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
 import android.content.res.XmlResourceParser;
 import android.os.Build;
 
 import com.android.internal.R;
+import com.android.internal.gmscompat.GmsInfo;
 
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 
 import java.io.IOException;
 import java.util.Objects;
 
 /** @hide */
 public class ParsedServiceUtils {
 
@@ -83,20 +84,25 @@ public class ParsedServiceUtils {
             }
 
             String permission = sa.getNonConfigurationString(
                     R.styleable.AndroidManifestService_permission, 0);
             service.setPermission(permission != null ? permission : pkg.getPermission());
 
             service.foregroundServiceType = sa.getInt(
                     R.styleable.AndroidManifestService_foregroundServiceType,
                     ServiceInfo.FOREGROUND_SERVICE_TYPE_NONE);
 
+            if (GmsInfo.PACKAGE_GMS.equals(packageName)) {
+                if (service.getName().startsWith("com.google.android.location")) {
+                    service.foregroundServiceType |= ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION;
+                }
+            }
             service.flags |= flag(ServiceInfo.FLAG_STOP_WITH_TASK,
                     R.styleable.AndroidManifestService_stopWithTask, sa)
                     | flag(ServiceInfo.FLAG_ISOLATED_PROCESS,
                     R.styleable.AndroidManifestService_isolatedProcess, sa)
                     | flag(ServiceInfo.FLAG_EXTERNAL_SERVICE,
                     R.styleable.AndroidManifestService_externalService, sa)
                     | flag(ServiceInfo.FLAG_USE_APP_ZYGOTE,
                     R.styleable.AndroidManifestService_useAppZygote, sa)
                     | flag(ServiceInfo.FLAG_SINGLE_USER,
                     R.styleable.AndroidManifestService_singleUser, sa);

commit 598396880ee313e9cba290636a713b8239c692fd
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Thu 2022-01-06 17:29:47+0200

    Allow PackageInstaller UI to become hidden if it starts another activity
    
    In some cases, most commonly when the caller doesn't yet have the
    REQUEST_INSTALL_PACKAGES permission, PackageInstaller UI gets paused as
    it calls startActivity() as part of the confirmation process.
    Previous change failed to take this into account, which caused callers to
    receive the "confirmation declined" result immediately.
---
 .../packageinstaller/PackageInstallerActivity.java  | 21 ++++++++++++++++++---
 1 file changed, 18 insertions(+), 3 deletions(-)

diff --git a/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java b/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java
index 9f4fb4cabf3a467e31685ac44988d4bd6ace4289..10eefebadeffd96f78979283dcde101ef78896c2 100644
--- a/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java
+++ b/packages/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java
@@ -123,20 +123,21 @@ public class PackageInstallerActivity extends AlertActivity {
     private static final int DLG_NOT_SUPPORTED_ON_WEAR = DLG_BASE + 7;
     private static final int DLG_EXTERNAL_SOURCE_BLOCKED = DLG_BASE + 8;
     private static final int DLG_INSTALL_APPS_RESTRICTED_FOR_USER = DLG_BASE + 9;
 
     // If unknown sources are temporary allowed
     private boolean mAllowUnknownSources;
 
     // Would the mOk button be enabled if this activity would be resumed
     private boolean mEnableOk = false;
     private boolean mPermissionResultWasSet;
+    private boolean mAllowNextOnPause;
 
     private void startInstallConfirm() {
         View viewToEnable;
 
         if (mAppInfo != null) {
             viewToEnable = requireViewById(R.id.install_confirm_question_update);
             mOk.setText(R.string.update);
         } else {
             // This is a new application with no permissions.
             viewToEnable = requireViewById(R.id.install_confirm_question);
@@ -388,39 +389,53 @@ public class PackageInstallerActivity extends AlertActivity {
     protected void onPause() {
         super.onPause();
 
         if (mOk != null) {
             // Don't allow the install button to be clicked as there might be overlays
             mOk.setEnabled(false);
         }
         // sometimes this activity becomes hidden after onPause(),
         // and the user is unable to bring it back
         if (!mPermissionResultWasSet && mSessionId != -1) {
-            mInstaller.setPermissionsResult(mSessionId, false);
-            mPermissionResultWasSet = true;
-            finish();
+            if (mAllowNextOnPause) {
+                mAllowNextOnPause = false;
+            } else {
+                if (!isFinishing()) {
+                    finish();
+                }
+            }
         }
     }
 
+    // handles startActivity() calls too
+    @Override
+    public void startActivityForResult(Intent intent, int requestCode, Bundle options) {
+        mAllowNextOnPause = true;
+        super.startActivityForResult(intent, requestCode, options);
+    }
+
     @Override
     protected void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
 
         outState.putBoolean(ALLOW_UNKNOWN_SOURCES_KEY, mAllowUnknownSources);
     }
 
     @Override
     protected void onDestroy() {
         super.onDestroy();
         while (!mActiveUnknownSourcesListeners.isEmpty()) {
             unregister(mActiveUnknownSourcesListeners.get(0));
         }
+        if (!mPermissionResultWasSet) {
+            mInstaller.setPermissionsResult(mSessionId, false);
+        }
     }
 
     private void bindUi() {
         mAlert.setIcon(mAppSnippet.icon);
         mAlert.setTitle(mAppSnippet.label);
         mAlert.setView(R.layout.install_content_view);
         mAlert.setButton(DialogInterface.BUTTON_POSITIVE, getString(R.string.install),
                 (ignored, ignored2) -> {
                     if (mOk.isEnabled()) {
                         if (mSessionId != -1) {

commit bd4dfacca77dfac39ec6cc133c65a24a79db7792
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Tue 2021-12-14 17:33:44+0200

    gmscompat: add recently bound pids to getRunningAppProcesses() result
    
    Play Games Services relies on ActivityManager.getRunningAppProcesses()
    to figure out whether its client is running.
    Unprivileged apps see only their own processes.
---
 core/java/android/app/ActivityManager.java         |   6 +-
 core/java/android/app/compat/gms/GmsCompat.java    |  10 +-
 core/java/android/os/Binder.java                   |  11 +++
 .../com/android/internal/gmscompat/GmsHooks.java   | 102 ++++++++++++++++++++-
 4 files changed, 126 insertions(+), 3 deletions(-)

diff --git a/core/java/android/app/ActivityManager.java b/core/java/android/app/ActivityManager.java
index c9992424f36ae4b56f4a051128783674842ab5f7..cecddefdacfeb3fdf53d0387e64fbe922d828460 100644
--- a/core/java/android/app/ActivityManager.java
+++ b/core/java/android/app/ActivityManager.java
@@ -3366,21 +3366,25 @@ public class ActivityManager {
      *
      * <p><b>Note: this method is only intended for debugging or building
      * a user-facing process management UI.</b></p>
      *
      * @return Returns a list of RunningAppProcessInfo records, or null if there are no
      * running processes (it will not return an empty list).  This list ordering is not
      * specified.
      */
     public List<RunningAppProcessInfo> getRunningAppProcesses() {
         try {
-            return getService().getRunningAppProcesses();
+            List<RunningAppProcessInfo> res = getService().getRunningAppProcesses();
+            if (GmsCompat.isPlayServices()) {
+                res = GmsHooks.addRecentlyBoundPids(mContext, res);
+            }
+            return res;
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Return a list of {@link ApplicationExitInfo} records containing the reasons for the most
      * recent app deaths.
      *
      * <p class="note"> Note: System stores this historical information in a ring buffer and only
diff --git a/core/java/android/app/compat/gms/GmsCompat.java b/core/java/android/app/compat/gms/GmsCompat.java
index 524a6f3a09bf67d83aa4acfd4aed45e5f8b5602d..ec368ad21a2626b0af1258779cfdb13f6bb6d65f 100644
--- a/core/java/android/app/compat/gms/GmsCompat.java
+++ b/core/java/android/app/compat/gms/GmsCompat.java
@@ -73,34 +73,40 @@ public final class GmsCompat {
      * This is for CLIENT apps, not GMS itself.
      */
     @ChangeId
     @Disabled // Overridden as a special case in CompatChange
     private static final long GMS_UNPRIVILEGED_DYNAMITE_CLIENT = 7528921493777479941L;
 
     // Some hooks are in (potentially) hot paths, so cache the change enable states.
     // no need to declare these fields as volatile, they are written when app has only the main thread
     private static boolean isGmsCompatEnabled;
     private static boolean isDynamiteClientEnabled;
+    private static boolean isPlayServices;
     private static boolean isPlayStore;
 
     // Static only
     private GmsCompat() { }
 
     public static boolean isEnabled() {
         return isGmsCompatEnabled;
     }
 
     /** @hide */
     public static boolean isDynamiteClient() {
         return isDynamiteClientEnabled;
     }
 
+    /** @hide */
+    public static boolean isPlayServices() {
+        return isPlayServices;
+    }
+
     /** @hide */
     public static boolean isPlayStore() {
         return isPlayStore;
     }
 
     private static void logEnabled(String changeName, boolean enabled) {
         if (!DEBUG_VERBOSE) {
             return;
         }
 
@@ -129,21 +135,23 @@ public final class GmsCompat {
     /**
      * Must be called to initialize the compatibility change enable states before any hooks run.
      *
      * @hide
      */
     public static void initChangeEnableStates(Application app) {
         isGmsCompatEnabled = isChangeEnabled("GMS_UNPRIVILEGED_COMPAT", GMS_UNPRIVILEGED_COMPAT);
         isDynamiteClientEnabled = isChangeEnabled("GMS_UNPRIVILEGED_DYNAMITE_CLIENT", GMS_UNPRIVILEGED_DYNAMITE_CLIENT);
         if (isGmsCompatEnabled) {
             // certificate is already checked if isGmsCompatEnabled is set
-            isPlayStore = GmsInfo.PACKAGE_PLAY_STORE.equals(app.getPackageName());
+            String pkg = app.getPackageName();
+            isPlayServices = GmsInfo.PACKAGE_GMS.equals(pkg);
+            isPlayStore = GmsInfo.PACKAGE_PLAY_STORE.equals(pkg);
         }
     }
 
     private static boolean validateCerts(Signature[] signatures) {
         for (Signature signature : signatures) {
             if (signature.toCharsString().equals(GmsInfo.SIGNING_CERT)) {
                 return true;
             }
         }
 
diff --git a/core/java/android/os/Binder.java b/core/java/android/os/Binder.java
index 635f58182b346ae449a1fa75d817807edd735974..95dfd98b61aa253e436ee088dc4b5bd21316300d 100644
--- a/core/java/android/os/Binder.java
+++ b/core/java/android/os/Binder.java
@@ -13,25 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package android.os;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SystemApi;
 import android.app.AppOpsManager;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.util.ExceptionUtils;
 import android.util.Log;
 import android.util.Slog;
 
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.BinderCallHeavyHitterWatcher;
 import com.android.internal.os.BinderCallHeavyHitterWatcher.BinderCallHeavyHitterListener;
 import com.android.internal.os.BinderInternal;
 import com.android.internal.os.BinderInternal.CallSession;
 import com.android.internal.util.FastPrintWriter;
 import com.android.internal.util.FunctionalUtils.ThrowingRunnable;
 import com.android.internal.util.FunctionalUtils.ThrowingSupplier;
 
 import dalvik.annotation.optimization.CriticalNative;
 
@@ -1124,27 +1126,36 @@ public class Binder implements IBinder {
      * <li>Never execute another binder transaction inside the callback.
      * @hide
      */
     public static void setWorkSourceProvider(BinderInternal.WorkSourceProvider workSourceProvider) {
         if (workSourceProvider == null) {
             throw new IllegalArgumentException("workSourceProvider cannot be null");
         }
         sWorkSourceProvider = workSourceProvider;
     }
 
+    private volatile int mPreviousUid;
+
     // Entry point from android_util_Binder.cpp's onTransact
     @UnsupportedAppUsage
     private boolean execTransact(int code, long dataObj, long replyObj,
             int flags) {
         // At that point, the parcel request headers haven't been parsed so we do not know what
         // WorkSource the caller has set. Use calling uid as the default.
         final int callingUid = Binder.getCallingUid();
+        if (GmsCompat.isPlayServices()) {
+            if (callingUid >= Process.FIRST_APPLICATION_UID && callingUid != mPreviousUid) {
+                // harmless race
+                mPreviousUid = callingUid;
+                GmsHooks.onBinderTransaction(Binder.getCallingPid(), callingUid);
+            }
+        }
         final long origWorkSource = ThreadLocalWorkSource.setUid(callingUid);
         try {
             return execTransactInternal(code, dataObj, replyObj, flags, callingUid);
         } finally {
             ThreadLocalWorkSource.restore(origWorkSource);
         }
     }
 
     private boolean execTransactInternal(int code, long dataObj, long replyObj, int flags,
             int callingUid) {
diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
index 345a8b1619e68b62b8d17464d3f711b3421d8dd6..732881761466604b74a465ab6ef75709f8665510 100644
--- a/core/java/com/android/internal/gmscompat/GmsHooks.java
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -10,47 +10,50 @@
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.android.internal.gmscompat;
 
 import android.annotation.SuppressLint;
+import android.app.ActivityManager.RunningAppProcessInfo;
 import android.app.ActivityThread;
 import android.app.Application;
 import android.app.Notification;
 import android.app.NotificationChannel;
 import android.app.NotificationChannelGroup;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.Service;
 import android.app.compat.gms.GmsCompat;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.content.pm.PackageInstaller;
 import android.content.pm.PackageManager;
 import android.content.pm.SharedLibraryInfo;
 import android.os.Build;
 import android.os.Process;
+import android.os.SystemClock;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.provider.Settings;
 import android.util.Log;
+import android.util.SparseArray;
 import android.webkit.WebView;
 
 import com.android.internal.R;
 import com.android.internal.gmscompat.dynamite.GmsDynamiteHooks;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 /**
  * API shims for Google Play Services compatibility. Hooks that are more complicated than a simple
  * constant return value should be delegated to this class for easier maintenance.
  *
  * @hide
  */
 public final class GmsHooks {
@@ -223,11 +226,108 @@ public final class GmsHooks {
             GmsDynamiteHooks.initClientApp();
         }
     }
 
     // Redirect cross-user interactions to current user
     // ContextImpl#sendOrderedBroadcastAsUser
     // ContextImpl#sendBroadcastAsUser
     public static UserHandle getUserHandle(UserHandle user) {
         return GmsCompat.isEnabled() ? Process.myUserHandle() : user;
     }
+
+    static class RecentBinderPid implements Comparable<RecentBinderPid> {
+        int pid;
+        int uid;
+        long lastSeen;
+        volatile String[] packageNames; // lazily inited
+
+        static final int MAX_MAP_SIZE = 50;
+        static final int MAP_SIZE_TRIM_TO = 40;
+        static final SparseArray<RecentBinderPid> map = new SparseArray(MAX_MAP_SIZE + 1);
+
+        public int compareTo(RecentBinderPid b) {
+            return Long.compare(b.lastSeen, lastSeen); // newest come first
+        }
+    }
+
+    // Remember recent Binder peers to include them in the result of ActivityManager.getRunningAppProcesses()
+    // Binder#execTransact(int, long, long, int)
+    public static void onBinderTransaction(int pid, int uid) {
+        SparseArray<RecentBinderPid> map = RecentBinderPid.map;
+        synchronized (map) {
+            RecentBinderPid rbp = map.get(pid);
+            if (rbp != null) {
+                if (rbp.uid != uid) { // pid was reused
+                    rbp = null;
+                }
+            }
+            if (rbp == null) {
+                rbp = new RecentBinderPid();
+                rbp.pid = pid;
+                rbp.uid = uid;
+                map.put(pid, rbp);
+            }
+            rbp.lastSeen = SystemClock.uptimeMillis();
+
+            int mapSize = map.size();
+            if (mapSize <= RecentBinderPid.MAX_MAP_SIZE) {
+                return;
+            }
+            RecentBinderPid[] arr = new RecentBinderPid[mapSize];
+            for (int i = 0; i < mapSize; ++i) {
+                arr[i] = map.valueAt(i);
+            }
+            // sorted by lastSeen field in reverse order
+            Arrays.sort(arr);
+            map.clear();
+            for (int i = 0; i < RecentBinderPid.MAP_SIZE_TRIM_TO; ++i) {
+                RecentBinderPid e = arr[i];
+                map.put(e.pid, e);
+            }
+        }
+    }
+
+    // Play Games Services relies on getRunningAppProcesses() to figure out whether its client is running.
+    // This workaround is racy, because unprivileged apps don't know whether arbitrary pid is alive.
+    // ActivityManager#getRunningAppProcesses()
+    public static ArrayList<RunningAppProcessInfo> addRecentlyBoundPids(Context context,
+                                                                        List<RunningAppProcessInfo> orig) {
+        final RecentBinderPid[] binderPids;
+        final int binderPidsCount;
+        // copy to array to avoid long lock contention with Binder.execTransact(),
+        // there are expensive getPackagesForUid() calls below
+        {
+            SparseArray<RecentBinderPid> map = RecentBinderPid.map;
+            synchronized (map) {
+                binderPidsCount = map.size();
+                binderPids = new RecentBinderPid[binderPidsCount];
+                for (int i = 0; i < binderPidsCount; ++i) {
+                    binderPids[i] = map.valueAt(i);
+                }
+            }
+        }
+        PackageManager pm = context.getPackageManager();
+        ArrayList<RunningAppProcessInfo> res = new ArrayList<>(orig.size() + binderPidsCount);
+        res.addAll(orig);
+        for (int i = 0; i < binderPidsCount; ++i) {
+            RecentBinderPid rbp = binderPids[i];
+            String[] pkgs = rbp.packageNames;
+            if (pkgs == null) {
+                pkgs = pm.getPackagesForUid(rbp.uid);
+                if (pkgs == null || pkgs.length == 0) {
+                    continue;
+                }
+                // this field is volatile
+                rbp.packageNames = pkgs;
+            }
+            RunningAppProcessInfo pi = new RunningAppProcessInfo();
+            // these fields are immutable after publication
+            pi.pid = rbp.pid;
+            pi.uid = rbp.uid;
+            pi.processName = pkgs[0];
+            pi.pkgList = pkgs;
+            pi.importance = RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
+            res.add(pi);
+        }
+        return res;
+    }
 }

commit 52f6f02621a5bd23ea93dcd9f415d971173eebd0
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Mon 2022-01-10 10:05:02+0200

    gmscompat: improve account sign-in UI
    
    GMS tries to access BackupService after sign-in, but doesn't have the permission
    to do so. This manifests itself in the UI as a never-ending spinner.
---
 core/java/android/app/backup/BackupManager.java | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/core/java/android/app/backup/BackupManager.java b/core/java/android/app/backup/BackupManager.java
index 67f631f98f0b90ec89bf2db48fa8ad8174887ad2..8da7a112fae24f9e7ee56a12edd6101b394531d2 100644
--- a/core/java/android/app/backup/BackupManager.java
+++ b/core/java/android/app/backup/BackupManager.java
@@ -15,20 +15,21 @@
  */
 
 package android.app.backup;
 
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
 import android.app.compat.CompatChanges;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
@@ -453,20 +454,23 @@ public class BackupManager {
     /**
      * Report whether the backup mechanism is currently active.
      * When it is inactive, the device will not perform any backup operations, nor will it
      * deliver data for restore, although clients can still safely call BackupManager methods.
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(android.Manifest.permission.BACKUP)
     public boolean isBackupServiceActive(UserHandle user) {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
         if (!CompatChanges.isChangeEnabled(
                 IS_BACKUP_SERVICE_ACTIVE_ENFORCE_PERMISSION_IN_SERVICE)) {
             mContext.enforceCallingOrSelfPermission(android.Manifest.permission.BACKUP,
                     "isBackupServiceActive");
         }
         checkServiceBinder();
         if (sService != null) {
             try {
                 return sService.isBackupServiceActive(user.getIdentifier());
             } catch (RemoteException e) {

commit db3ef415d96b6acf01ad16d707d87166a9d7ab5f
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Mon 2022-01-10 10:21:40+0200

    gmscompat: don't check whether Google account removal is allowed
    
    When user profile is protected by PIN or password ("keyguard is secure"),
    GMS tries to access privileged APIs when asked whether account removal is allowed,
    which leads to a negative reply and unremovable account (unless GMS itself is removed).
---
 .../java/com/android/server/accounts/AccountManagerService.java     | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java
index 400b084ee96672c870e212fc3d7873f4b0b1922b..5b20a29fe23cbb309b263aefbdb6f1b837c638ba 100644
--- a/services/core/java/com/android/server/accounts/AccountManagerService.java
+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java
@@ -2331,20 +2331,26 @@ public class AccountManagerService
         }
 
         @Override
         protected String toDebugString(long now) {
             return super.toDebugString(now) + ", removeAccount"
                     + ", account " + mAccount;
         }
 
         @Override
         public void run() throws RemoteException {
+            if ("com.google".equals(mAccount.type)) {
+                Bundle result = new Bundle();
+                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, true);
+                onResult(result);
+                return;
+            }
             mAuthenticator.getAccountRemovalAllowed(this, mAccount);
         }
 
         @Override
         public void onResult(Bundle result) {
             Bundle.setDefusable(result, true);
             if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)
                     && !result.containsKey(AccountManager.KEY_INTENT)) {
                 final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);
                 if (removalAllowed) {

commit 9c2fc56d04561bc8f170c3262fa3131b6be76d30
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Wed 2022-01-12 21:52:27+0200

    gmscompat: enable Play {Asset, Feature} Delivery
    
    Play Store uses a similar getRunningAppProcesses()-based "is client foreground"
    check as Play Services does, so enable the same workaround for it as well.
---
 core/java/android/app/ActivityManager.java | 2 +-
 core/java/android/os/Binder.java           | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/core/java/android/app/ActivityManager.java b/core/java/android/app/ActivityManager.java
index cecddefdacfeb3fdf53d0387e64fbe922d828460..0275d02aff7643123db5893a247d57f9dc284eb4 100644
--- a/core/java/android/app/ActivityManager.java
+++ b/core/java/android/app/ActivityManager.java
@@ -3367,21 +3367,21 @@ public class ActivityManager {
      * <p><b>Note: this method is only intended for debugging or building
      * a user-facing process management UI.</b></p>
      *
      * @return Returns a list of RunningAppProcessInfo records, or null if there are no
      * running processes (it will not return an empty list).  This list ordering is not
      * specified.
      */
     public List<RunningAppProcessInfo> getRunningAppProcesses() {
         try {
             List<RunningAppProcessInfo> res = getService().getRunningAppProcesses();
-            if (GmsCompat.isPlayServices()) {
+            if (GmsCompat.isEnabled()) {
                 res = GmsHooks.addRecentlyBoundPids(mContext, res);
             }
             return res;
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Return a list of {@link ApplicationExitInfo} records containing the reasons for the most
diff --git a/core/java/android/os/Binder.java b/core/java/android/os/Binder.java
index 95dfd98b61aa253e436ee088dc4b5bd21316300d..56a12377b9a1454b919f34f9ccf16b0e5bcff140 100644
--- a/core/java/android/os/Binder.java
+++ b/core/java/android/os/Binder.java
@@ -1135,21 +1135,21 @@ public class Binder implements IBinder {
 
     private volatile int mPreviousUid;
 
     // Entry point from android_util_Binder.cpp's onTransact
     @UnsupportedAppUsage
     private boolean execTransact(int code, long dataObj, long replyObj,
             int flags) {
         // At that point, the parcel request headers haven't been parsed so we do not know what
         // WorkSource the caller has set. Use calling uid as the default.
         final int callingUid = Binder.getCallingUid();
-        if (GmsCompat.isPlayServices()) {
+        if (GmsCompat.isEnabled()) {
             if (callingUid >= Process.FIRST_APPLICATION_UID && callingUid != mPreviousUid) {
                 // harmless race
                 mPreviousUid = callingUid;
                 GmsHooks.onBinderTransaction(Binder.getCallingPid(), callingUid);
             }
         }
         final long origWorkSource = ThreadLocalWorkSource.setUid(callingUid);
         try {
             return execTransactInternal(code, dataObj, replyObj, flags, callingUid);
         } finally {

commit 79fd54c3efa95ce4660d17cec062908d424c754c
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Thu 2022-01-13 21:38:26+0200

    gmscompat: don't stub out PackageManager.getSharedLibraries()
    
    Play Store uses list of shared libraries to filter out apps with missing dependencies.
---
 core/java/android/app/ApplicationPackageManager.java   | 8 ++++----
 core/java/com/android/internal/gmscompat/GmsHooks.java | 7 -------
 2 files changed, 4 insertions(+), 11 deletions(-)

diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index 1dff532256e8a361b7fe6fdeacbc2d40cac28076..c911cd9cedba112ee66898943efc1c6bf7495669 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -572,31 +572,31 @@ public class ApplicationPackageManager extends PackageManager {
         try {
             return mPM.getSystemSharedLibraryNames();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /** @hide */
     @Override
     public @NonNull List<SharedLibraryInfo> getSharedLibraries(int flags) {
+        if (GmsCompat.isEnabled()) {
+            // MATCH_ANY_USER requires privileged INTERACT_ACROSS_USERS permission
+            flags &= ~MATCH_ANY_USER;
+        }
         return getSharedLibrariesAsUser(flags, getUserId());
     }
 
     /** @hide */
     @Override
     @SuppressWarnings("unchecked")
     public @NonNull List<SharedLibraryInfo> getSharedLibrariesAsUser(int flags, int userId) {
-        if (GmsCompat.isEnabled()) {
-            return GmsHooks.getSharedLibrariesAsUser();
-        }
-
         try {
             ParceledListSlice<SharedLibraryInfo> sharedLibs = mPM.getSharedLibraries(
                     mContext.getOpPackageName(), flags, userId);
             if (sharedLibs == null) {
                 return Collections.emptyList();
             }
             return sharedLibs.getList();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
index 732881761466604b74a465ab6ef75709f8665510..58b9da738faf13bd6d237ed284cd7c263b218049 100644
--- a/core/java/com/android/internal/gmscompat/GmsHooks.java
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -183,27 +183,20 @@ public final class GmsHooks {
             return Build.UNKNOWN;
         }
 
         String ssaid = Settings.Secure.getString(app.getContentResolver(),
                 Settings.Secure.ANDROID_ID);
         String serial = ssaid.toUpperCase();
         Log.d(TAG, "Generating serial number from SSAID: " + serial);
         return serial;
     }
 
-    // Report no shared libraries
-    // ApplicationPackageManager#getSharedLibrariesAsUser(int, int)
-    public static List<SharedLibraryInfo> getSharedLibrariesAsUser() {
-        // TODO: Report standard Pixel libraries?
-        return Collections.emptyList();
-    }
-
     // Only get package info for current user
     // ApplicationPackageManager#getPackageInfo(VersionedPackage, int)
     // ApplicationPackageManager#getPackageInfoAsUser(String, int, int)
     public static int getPackageInfoFlags(int flags) {
         if (!GmsCompat.isEnabled()) {
             return flags;
         }
 
         // Remove MATCH_ANY_USER flag to avoid permission denial
         return flags & ~PackageManager.MATCH_ANY_USER;

commit be30e907b6143a4988f7d194ea6d3eaff8e3f7bb
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Sat 2022-01-29 01:23:35-0500

    Revert "gmscompat: set foregroundServiceType of location services"
    
    This reverts commit 8ec949adf42a16360f23e2986c05316dbf99bf16.
---
 .../android/content/pm/parsing/component/ParsedServiceUtils.java    | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/core/java/android/content/pm/parsing/component/ParsedServiceUtils.java b/core/java/android/content/pm/parsing/component/ParsedServiceUtils.java
index df6b2dd8d28edf71f42aad03e4e46c6b36909541..ae107ce65bf8aa5936580929bfe0d4c06757d7c3 100644
--- a/core/java/android/content/pm/parsing/component/ParsedServiceUtils.java
+++ b/core/java/android/content/pm/parsing/component/ParsedServiceUtils.java
@@ -25,21 +25,20 @@ import android.content.pm.parsing.ParsingPackage;
 import android.content.pm.parsing.ParsingUtils;
 import android.content.pm.parsing.result.ParseInput;
 import android.content.pm.parsing.result.ParseInput.DeferredError;
 import android.content.pm.parsing.result.ParseResult;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
 import android.content.res.XmlResourceParser;
 import android.os.Build;
 
 import com.android.internal.R;
-import com.android.internal.gmscompat.GmsInfo;
 
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 
 import java.io.IOException;
 import java.util.Objects;
 
 /** @hide */
 public class ParsedServiceUtils {
 
@@ -84,25 +83,20 @@ public class ParsedServiceUtils {
             }
 
             String permission = sa.getNonConfigurationString(
                     R.styleable.AndroidManifestService_permission, 0);
             service.setPermission(permission != null ? permission : pkg.getPermission());
 
             service.foregroundServiceType = sa.getInt(
                     R.styleable.AndroidManifestService_foregroundServiceType,
                     ServiceInfo.FOREGROUND_SERVICE_TYPE_NONE);
 
-            if (GmsInfo.PACKAGE_GMS.equals(packageName)) {
-                if (service.getName().startsWith("com.google.android.location")) {
-                    service.foregroundServiceType |= ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION;
-                }
-            }
             service.flags |= flag(ServiceInfo.FLAG_STOP_WITH_TASK,
                     R.styleable.AndroidManifestService_stopWithTask, sa)
                     | flag(ServiceInfo.FLAG_ISOLATED_PROCESS,
                     R.styleable.AndroidManifestService_isolatedProcess, sa)
                     | flag(ServiceInfo.FLAG_EXTERNAL_SERVICE,
                     R.styleable.AndroidManifestService_externalService, sa)
                     | flag(ServiceInfo.FLAG_USE_APP_ZYGOTE,
                     R.styleable.AndroidManifestService_useAppZygote, sa)
                     | flag(ServiceInfo.FLAG_SINGLE_USER,
                     R.styleable.AndroidManifestService_singleUser, sa);

commit 37af6e06f26942604fa4da6fb06884ca0d861924
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Mon 2022-01-10 15:50:33+0200

    make DownloadManager.enqueue() a no-op when INTERNET permission is revoked
---
 core/java/android/app/DownloadManager.java | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/core/java/android/app/DownloadManager.java b/core/java/android/app/DownloadManager.java
index 35509237827953f06bf87054650cad6984da9cac..cb4a16641953b206747363fab7d9a875f8c90876 100644
--- a/core/java/android/app/DownloadManager.java
+++ b/core/java/android/app/DownloadManager.java
@@ -9,35 +9,37 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package android.app;
 
+import android.Manifest;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ClipDescription;
 import android.content.ContentProviderClient;
 import android.content.ContentResolver;
 import android.content.ContentUris;
 import android.content.ContentValues;
 import android.content.Context;
+import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.database.CursorWrapper;
 import android.database.DatabaseUtils;
 import android.net.ConnectivityManager;
 import android.net.NetworkPolicyManager;
 import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Environment;
 import android.os.FileUtils;
@@ -1108,20 +1110,26 @@ public class DownloadManager {
 
     /**
      * Enqueue a new download.  The download will start automatically once the download manager is
      * ready to execute it and connectivity is available.
      *
      * @param request the parameters specifying this download
      * @return an ID for the download, unique across the system.  This ID is used to make future
      * calls related to this download.
      */
     public long enqueue(Request request) {
+        // don't crash apps that expect INTERNET permission to be always granted
+        Context ctx = ActivityThread.currentApplication();
+        if (ctx != null && ctx.checkSelfPermission(Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) {
+            // invalid id (DownloadProvider uses SQLite and returns a row id)
+            return -1;
+        }
         ContentValues values = request.toContentValues(mPackageName);
         Uri downloadUri = mResolver.insert(Downloads.Impl.CONTENT_URI, values);
         long id = Long.parseLong(downloadUri.getLastPathSegment());
         return id;
     }
 
     /**
      * Marks the specified download as 'to be deleted'. This is done when a completed download
      * is to be removed but the row was stored without enough info to delete the corresponding
      * metadata from Mediaprovider database. Actual cleanup of this row is done in DownloadService.

commit c029343a676143a350a9748895d9000d153f4ab6
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Fri 2022-01-21 21:40:07+0200

    gmscompat: improve location services compatibility
---
 .../framework/java/android/app/AlarmManager.java   |  9 +++++---
 core/java/android/app/ActivityManager.java         |  4 ++++
 core/java/android/app/BroadcastOptions.java        |  6 ++++++
 core/java/android/app/ContextImpl.java             |  8 ++++++++
 .../hardware/location/ContextHubManager.java       | 10 ---------
 core/java/android/net/NetworkScoreManager.java     | 24 ++++++++++++----------
 .../com/android/internal/gmscompat/GmsHooks.java   |  8 ++++----
 .../java/android/location/LocationManager.java     | 11 ++++++++++
 8 files changed, 52 insertions(+), 28 deletions(-)

diff --git a/apex/jobscheduler/framework/java/android/app/AlarmManager.java b/apex/jobscheduler/framework/java/android/app/AlarmManager.java
index d6f3f42d10ab488b1c947a694e9d76a721bf4ec6..a56f70d4969a0af2d5f3f5c348c330c01ad43b02 100644
--- a/apex/jobscheduler/framework/java/android/app/AlarmManager.java
+++ b/apex/jobscheduler/framework/java/android/app/AlarmManager.java
@@ -906,23 +906,26 @@ public class AlarmManager {
             AlarmClockInfo alarmClock) {
         final Handler handlerToUse = (targetHandler != null) ? targetHandler : mMainThreadHandler;
         setImpl(type, triggerAtMillis, windowMillis, intervalMillis, flags, operation, listener,
                 listenerTag, new HandlerExecutor(handlerToUse), workSource, alarmClock);
     }
 
     private void setImpl(@AlarmType int type, long triggerAtMillis, long windowMillis,
             long intervalMillis, int flags, PendingIntent operation, final OnAlarmListener listener,
             String listenerTag, Executor targetExecutor, WorkSource workSource,
             AlarmClockInfo alarmClock) {
-        if (GmsCompat.isEnabled() && windowMillis == WINDOW_EXACT &&
-                !canScheduleExactAlarms()) {
-            windowMillis = WINDOW_HEURISTIC;
+        if (GmsCompat.isEnabled()) {
+            if (windowMillis == WINDOW_EXACT && !canScheduleExactAlarms()) {
+                windowMillis = WINDOW_HEURISTIC;
+            }
+            // non-null WorkSource requires privileged UPDATE_DEVICE_STATS permission
+            workSource = null;
         }
 
         if (triggerAtMillis < 0) {
             /* NOTYET
             if (mAlwaysExact) {
                 // Fatal error for KLP+ apps to use negative trigger times
                 throw new IllegalArgumentException("Invalid alarm trigger time "
                         + triggerAtMillis);
             }
             */
diff --git a/core/java/android/app/ActivityManager.java b/core/java/android/app/ActivityManager.java
index 0275d02aff7643123db5893a247d57f9dc284eb4..a00e3eae01463e7bab90d30696bcb226ede89ab9 100644
--- a/core/java/android/app/ActivityManager.java
+++ b/core/java/android/app/ActivityManager.java
@@ -4284,20 +4284,24 @@ public class ActivityManager {
      * Return whether the given user is actively running.  This means that
      * the user is in the "started" state, not "stopped" -- it is currently
      * allowed to run code through scheduled alarms, receiving broadcasts,
      * etc.  A started user may be either the current foreground user or a
      * background user; the result here does not distinguish between the two.
      * @param userId the user's id. Zero indicates the default user.
      * @hide
      */
     @UnsupportedAppUsage
     public boolean isUserRunning(int userId) {
+        if (GmsCompat.isEnabled()) {
+            // GMS sees only the current user
+            return true;
+        }
         try {
             return getService().isUserRunning(userId, 0);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /** {@hide} */
     public boolean isVrModePackageEnabled(ComponentName component) {
         try {
diff --git a/core/java/android/app/BroadcastOptions.java b/core/java/android/app/BroadcastOptions.java
index bd7162c1bf3b6a3c5be77e7d3a7194a2c130c7f4..52caaa8d971ec50bf9885f006595ef7b946eac9e 100644
--- a/core/java/android/app/BroadcastOptions.java
+++ b/core/java/android/app/BroadcastOptions.java
@@ -14,20 +14,21 @@
  * limitations under the License.
  */
 
 package android.app;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
+import android.app.compat.gms.GmsCompat;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.PowerExemptionManager;
 import android.os.PowerExemptionManager.ReasonCode;
 import android.os.PowerExemptionManager.TempAllowListType;
 
 /**
  * Helper class for building an options Bundle that can be used with
  * {@link android.content.Context#sendBroadcast(android.content.Intent)
  * Context.sendBroadcast(Intent)} and related methods.
@@ -160,20 +161,25 @@ public class BroadcastOptions {
      * @param reasonCode one of {@link ReasonCode}, use
      *                  {@link PowerExemptionManager#REASON_UNKNOWN} if not sure.
      * @param reason A human-readable reason explaining why the app is temp allowlisted. Only
      *               used for logging purposes. Could be null or empty string.
      */
     @RequiresPermission(anyOf = {android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,
             android.Manifest.permission.START_ACTIVITIES_FROM_BACKGROUND,
             android.Manifest.permission.START_FOREGROUND_SERVICES_FROM_BACKGROUND})
     public void setTemporaryAppAllowlist(long duration, @TempAllowListType int type,
             @ReasonCode int reasonCode, @Nullable String reason) {
+        if (GmsCompat.isEnabled()) {
+            // otherwise, broadcasts (e.g. location updates via PendingIntent) from GMS fail
+            // due to lack of any of these privileged permission
+            return;
+        }
         mTemporaryAppAllowlistDuration = duration;
         mTemporaryAppAllowlistType = type;
         mTemporaryAppAllowlistReasonCode = reasonCode;
         mTemporaryAppAllowlistReason = reason;
 
         if (!isTemporaryAppAllowlistSet()) {
             resetTemporaryAppAllowlist();
         }
     }
 
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 078c3d639430295fba7654a8ff4da50ef37d717c..c3b3a474f2bf6672a16e875c7fbed6c3a362b9d1 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -2069,20 +2069,28 @@ class ContextImpl extends Context {
             return ActivityManager.getService().startInstrumentation(
                     className, profileFile, 0, arguments, null, null, getUserId(),
                     null /* ABI override */);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public Object getSystemService(String name) {
+        if (GmsCompat.isEnabled()) {
+            switch (name) {
+                case Context.CONTEXTHUB_SERVICE:
+                case Context.WIFI_SCANNING_SERVICE:
+                    // these privileged services are null-checked by GMS
+                    return null;
+            }
+        }
         if (vmIncorrectContextUseEnabled()) {
             // Check incorrect Context usage.
             if (WINDOW_SERVICE.equals(name) && !isUiContext()) {
                 final String errorMessage = "Tried to access visual service "
                         + SystemServiceRegistry.getSystemServiceClassName(name)
                         + " from a non-visual Context:" + getOuterContext();
                 final String message = "WindowManager should be accessed from Activity or other "
                         + "visual Context. Use an Activity or a Context created with "
                         + "Context#createWindowContext(int, Bundle), which are adjusted to "
                         + "the configuration and visual bounds of an area on screen.";
diff --git a/core/java/android/hardware/location/ContextHubManager.java b/core/java/android/hardware/location/ContextHubManager.java
index 271f24c4f127efac9bd79abccda53f844aaa6f53..29bd2234b206b436eeecf4748189e43d87796ce7 100644
--- a/core/java/android/hardware/location/ContextHubManager.java
+++ b/core/java/android/hardware/location/ContextHubManager.java
@@ -19,21 +19,20 @@ import android.annotation.CallbackExecutor;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresFeature;
 import android.annotation.RequiresPermission;
 import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.app.ActivityThread;
 import android.app.PendingIntent;
-import android.app.compat.gms.GmsCompat;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.os.Handler;
 import android.os.HandlerExecutor;
 import android.os.Looper;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.ServiceManager.ServiceNotFoundException;
 import android.util.Log;
@@ -467,24 +466,20 @@ public final class ContextHubManager {
      *
      * @return the list of ContextHubInfo objects
      *
      * @see ContextHubInfo
      */
     @RequiresPermission(anyOf = {
             android.Manifest.permission.LOCATION_HARDWARE,
             android.Manifest.permission.ACCESS_CONTEXT_HUB
     })
     @NonNull public List<ContextHubInfo> getContextHubs() {
-        if (GmsCompat.isEnabled()) {
-            return Collections.emptyList();
-        }
-
         try {
             return mService.getContextHubs();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Helper function to generate a stub for a non-query transaction callback.
      *
@@ -1061,22 +1056,17 @@ public final class ContextHubManager {
             }
         }
     };
 
     /** @throws ServiceNotFoundException
      * @hide */
     public ContextHubManager(Context context, Looper mainLooper) throws ServiceNotFoundException {
         mMainLooper = mainLooper;
         mService = IContextHubService.Stub.asInterface(
                 ServiceManager.getServiceOrThrow(Context.CONTEXTHUB_SERVICE));
-
-        if (GmsCompat.isEnabled()) {
-            return;
-        }
-
         try {
             mService.registerCallback(mClientCallback);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 }
diff --git a/core/java/android/net/NetworkScoreManager.java b/core/java/android/net/NetworkScoreManager.java
index 6367926c22179aaeaadadab428f1e7f086a34170..0e6e5d5c35f09967c916b8cb22b8ee1f2e1fcb15 100644
--- a/core/java/android/net/NetworkScoreManager.java
+++ b/core/java/android/net/NetworkScoreManager.java
@@ -222,41 +222,45 @@ public class NetworkScoreManager {
      * @hide
      */
     public static final int RECOMMENDATIONS_ENABLED_ON = 1;
 
     private final Context mContext;
     private final INetworkScoreService mService;
 
     /** @hide */
     public NetworkScoreManager(Context context) throws ServiceNotFoundException {
         mContext = context;
-        mService = INetworkScoreService.Stub
-                .asInterface(ServiceManager.getServiceOrThrow(Context.NETWORK_SCORE_SERVICE));
+        if (GmsCompat.isEnabled()) {
+            mService = null;
+        } else {
+            mService = INetworkScoreService.Stub
+                    .asInterface(ServiceManager.getServiceOrThrow(Context.NETWORK_SCORE_SERVICE));
+        }
     }
 
     /**
      * Obtain the package name of the current active network scorer.
      *
      * <p>At any time, only one scorer application will receive {@link #ACTION_SCORE_NETWORKS}
      * broadcasts and be allowed to call {@link #updateScores}. Applications may use this method to
      * determine the current scorer and offer the user the ability to select a different scorer via
      * the {@link #ACTION_CHANGE_ACTIVE} intent.
      * @return the full package name of the current active scorer, or null if there is no active
      *         scorer.
      * @throws SecurityException if the caller doesn't hold either {@link permission#SCORE_NETWORKS}
      *                           or {@link permission#REQUEST_NETWORK_SCORES} permissions.
      */
     @RequiresPermission(anyOf = {android.Manifest.permission.SCORE_NETWORKS,
                                  android.Manifest.permission.REQUEST_NETWORK_SCORES})
     public String getActiveScorerPackage() {
         if (GmsCompat.isEnabled()) {
-            return null;
+            return mContext.getPackageName();
         }
 
         try {
             return mService.getActiveScorerPackage();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
@@ -299,20 +303,23 @@ public class NetworkScoreManager {
      * <p>This may be called at any time to re-score active networks. Scores will generally be
      * updated quickly, but if this method is called too frequently, the scores may be held and
      * applied at a later time.
      *
      * @param networks the networks which have been scored by the scorer.
      * @return whether the update was successful.
      * @throws SecurityException if the caller is not the active scorer.
      */
     @RequiresPermission(android.Manifest.permission.SCORE_NETWORKS)
     public boolean updateScores(@NonNull ScoredNetwork[] networks) throws SecurityException {
+        if (GmsCompat.isEnabled()) {
+            return true;
+        }
         try {
             return mService.updateScores(networks);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Clear network scores.
      *
@@ -322,20 +329,23 @@ public class NetworkScoreManager {
      * <p>Note that scores will be cleared automatically when the active scorer changes, as scores
      * from one scorer cannot be compared to those from another scorer.
      *
      * @return whether the clear was successful.
      * @throws SecurityException if the caller is not the active scorer or if the caller doesn't
      *                           hold the {@link permission#REQUEST_NETWORK_SCORES} permission.
      */
     @RequiresPermission(anyOf = {android.Manifest.permission.SCORE_NETWORKS,
                                  android.Manifest.permission.REQUEST_NETWORK_SCORES})
     public boolean clearScores() throws SecurityException {
+        if (GmsCompat.isEnabled()) {
+            return true;
+        }
         try {
             return mService.clearScores();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Set the active scorer to a new package and clear existing scores.
      *
@@ -446,47 +456,39 @@ public class NetworkScoreManager {
      * @param scoreCache implementation of {@link INetworkScoreCache} to store the scores
      * @param filterType the {@link ScoreUpdateFilter} to apply
      * @throws SecurityException if the caller does not hold the
      *         {@link permission#REQUEST_NETWORK_SCORES} permission.
      * @throws IllegalArgumentException if a score cache is already registered for this type.
      * @hide
      */
     @RequiresPermission(android.Manifest.permission.REQUEST_NETWORK_SCORES)
     public void registerNetworkScoreCache(int networkType, INetworkScoreCache scoreCache,
             @ScoreUpdateFilter int filterType) {
-        if (GmsCompat.isEnabled()) {
-            return;
-        }
-
         try {
             mService.registerNetworkScoreCache(networkType, scoreCache, filterType);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Unregister a network score cache.
      *
      * @param networkType the type of network this cache can handle. See {@link NetworkKey#type}.
      * @param scoreCache implementation of {@link INetworkScoreCache} to store the scores.
      * @throws SecurityException if the caller does not hold the
      *         {@link permission#REQUEST_NETWORK_SCORES} permission.
      * @throws IllegalArgumentException if a score cache is already registered for this type.
      * @hide
      */
     @RequiresPermission(android.Manifest.permission.REQUEST_NETWORK_SCORES)
     public void unregisterNetworkScoreCache(int networkType, INetworkScoreCache scoreCache) {
-        if (GmsCompat.isEnabled()) {
-            return;
-        }
-
         try {
             mService.unregisterNetworkScoreCache(networkType, scoreCache);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Base class for network score cache callback. Should be extended by applications and set
      * when calling {@link #registerNetworkScoreCallback(int, int, Executor, NetworkScoreCallback)}.
diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
index 58b9da738faf13bd6d237ed284cd7c263b218049..23968b65adc30ad5bf760e2a9fdbee395ff8e8d8 100644
--- a/core/java/com/android/internal/gmscompat/GmsHooks.java
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -21,40 +21,40 @@ import android.app.ActivityManager.RunningAppProcessInfo;
 import android.app.ActivityThread;
 import android.app.Application;
 import android.app.Notification;
 import android.app.NotificationChannel;
 import android.app.NotificationChannelGroup;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.Service;
 import android.app.compat.gms.GmsCompat;
 import android.content.ComponentName;
+import android.content.ContentValues;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
-import android.content.pm.SharedLibraryInfo;
+import android.net.Uri;
 import android.os.Build;
 import android.os.Process;
 import android.os.SystemClock;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.provider.Settings;
 import android.util.Log;
 import android.util.SparseArray;
 import android.webkit.WebView;
 
 import com.android.internal.R;
 import com.android.internal.gmscompat.dynamite.GmsDynamiteHooks;
 
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
 
 /**
  * API shims for Google Play Services compatibility. Hooks that are more complicated than a simple
  * constant return value should be delegated to this class for easier maintenance.
  *
  * @hide
  */
 public final class GmsHooks {
     private static final String TAG = "GmsCompat/Hooks";
@@ -195,29 +195,29 @@ public final class GmsHooks {
     // ApplicationPackageManager#getPackageInfoAsUser(String, int, int)
     public static int getPackageInfoFlags(int flags) {
         if (!GmsCompat.isEnabled()) {
             return flags;
         }
 
         // Remove MATCH_ANY_USER flag to avoid permission denial
         return flags & ~PackageManager.MATCH_ANY_USER;
     }
 
-    // Fix RuntimeException: Using WebView from more than one process at once with the same data
-    // directory is not supported. https://crbug.com/558377
     // Instrumentation#newApplication(ClassLoader, String, Context)
     public static void initApplicationBeforeOnCreate(Application app) {
         GmsCompat.initChangeEnableStates(app);
 
         if (GmsCompat.isEnabled()) {
             String processName = Application.getProcessName();
             if (!app.getPackageName().equals(processName)) {
+                // Fix RuntimeException: Using WebView from more than one process at once with the same data
+                // directory is not supported. https://crbug.com/558377
                 WebView.setDataDirectorySuffix("process-shim--" + processName);
             }
 
             GmsDynamiteHooks.initGmsServerApp(app);
         } else if (GmsCompat.isDynamiteClient()) {
             GmsDynamiteHooks.initClientApp();
         }
     }
 
     // Redirect cross-user interactions to current user
diff --git a/location/java/android/location/LocationManager.java b/location/java/android/location/LocationManager.java
index c427a9dec87c4ededfd6f37e9305a43c97667573..f5c79980e166321040d1a1110aa39834ced2df65 100644
--- a/location/java/android/location/LocationManager.java
+++ b/location/java/android/location/LocationManager.java
@@ -513,20 +513,23 @@ public class LocationManager {
     }
 
     /**
      * Set the extra location controller package for location services on the device.
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(Manifest.permission.LOCATION_HARDWARE)
     public void setExtraLocationControllerPackage(@Nullable String packageName) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
         try {
             mService.setExtraLocationControllerPackage(packageName);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
      * Set whether the extra location controller package is currently enabled on the device.
      *
@@ -1478,20 +1481,28 @@ public class LocationManager {
      * @throws IllegalArgumentException if provider is null or doesn't exist
      * @throws IllegalArgumentException if locationRequest is null
      * @throws IllegalArgumentException if listener is null
      * @throws SecurityException if no suitable permission is present
      */
     @RequiresPermission(anyOf = {ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION})
     public void requestLocationUpdates(@NonNull String provider,
             @NonNull LocationRequest locationRequest,
             @NonNull @CallbackExecutor Executor executor,
             @NonNull LocationListener listener) {
+        if (GmsCompat.isEnabled()) {
+            // requires privileged UPDATE_APP_OPS_STATS permission
+            locationRequest.setHideFromAppOps(false);
+            // requires privileged WRITE_SECURE_SETTINGS permission
+            locationRequest.setLocationSettingsIgnored(false);
+            // requires privileged UPDATE_DEVICE_STATS permission
+            locationRequest.setWorkSource(null);
+        }
         Preconditions.checkArgument(provider != null, "invalid null provider");
         Preconditions.checkArgument(locationRequest != null, "invalid null location request");
 
         try {
             synchronized (sLocationListeners) {
                 WeakReference<LocationListenerTransport> reference = sLocationListeners.get(
                         listener);
                 LocationListenerTransport transport = reference != null ? reference.get() : null;
                 if (transport == null) {
                     transport = new LocationListenerTransport(listener, executor);

commit 3ccf114ba113106684c4bdade35f9f23d8502837
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Fri 2022-01-21 21:44:14+0200

    gmscompat: don't make all services foreground
    
    Instead, rely on an external foreground app to bind to GMS, which
    allows GMS to start regular services.
---
 core/java/android/app/ActivityThread.java          |  2 -
 core/java/android/app/ContextImpl.java             |  4 --
 core/java/android/app/compat/gms/GmsCompat.java    |  2 +-
 .../internal/gmscompat/GmsCompatApp.java (new)     | 37 ++++++++++
 .../com/android/internal/gmscompat/GmsHooks.java   | 83 ++++++----------------
 core/res/res/values/strings.xml                    | 11 ---
 core/res/res/values/symbols.xml                    |  3 -
 .../java/com/android/server/pm/AppsFilter.java     |  2 +
 8 files changed, 62 insertions(+), 82 deletions(-)

diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index 666e832acb294b5869fe7f0b8f2ccda295809205..db6b6d4a1683c631ed4de3c4a04ba148a30cada7 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -191,21 +191,20 @@ import android.view.translation.UiTranslationSpec;
 import android.webkit.WebView;
 import android.window.SizeConfigurationBuckets;
 import android.window.SplashScreen;
 import android.window.SplashScreenView;
 import android.window.WindowProviderService;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.app.IVoiceInteractor;
 import com.android.internal.content.ReferrerIntent;
-import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.BinderInternal;
 import com.android.internal.os.RuntimeInit;
 import com.android.internal.os.SomeArgs;
 import com.android.internal.policy.DecorView;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.FastPrintWriter;
 import com.android.internal.util.Preconditions;
 import com.android.internal.util.function.pooled.PooledLambda;
 import com.android.org.conscrypt.OpenSSLSocketImpl;
 import com.android.org.conscrypt.TrustedCertificateStore;
@@ -4545,21 +4544,20 @@ public final class ActivityThread extends ClientTransactionHandler
                 context = (ContextImpl) context.createAttributionContext(attributionTag);
             }
             // Service resources must be initialized with the same loaders as the application
             // context.
             context.getResources().addLoaders(
                     app.getResources().getLoaders().toArray(new ResourcesLoader[0]));
 
             context.setOuterContext(service);
             service.attach(context, this, data.info.name, data.token, app,
                     ActivityManager.getService());
-            GmsHooks.attachService(service);
             service.onCreate();
             mServicesData.put(data.token, data);
             mServices.put(data.token, service);
             try {
                 ActivityManager.getService().serviceDoneExecuting(
                         data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0);
             } catch (RemoteException e) {
                 throw e.rethrowFromSystemServer();
             }
         } catch (Exception e) {
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index c3b3a474f2bf6672a16e875c7fbed6c3a362b9d1..7dff88fa2fe2356905f410f20ef6daac102644ff 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -1824,24 +1824,20 @@ class ContextImpl extends Context {
                 throw ex;
             } else {
                 Log.w(TAG, "Implicit intents with startService are not safe: " + service
                         + " " + Debug.getCallers(2, 3));
             }
         }
     }
 
     @Override
     public ComponentName startService(Intent service) {
-        if (GmsCompat.isEnabled()) {
-            return GmsHooks.startService(this, service);
-        }
-
         warnIfCallingFromSystemProcess();
         return startServiceCommon(service, false, mUser);
     }
 
     @Override
     public ComponentName startForegroundService(Intent service) {
         warnIfCallingFromSystemProcess();
         return startServiceCommon(service, true, mUser);
     }
 
diff --git a/core/java/android/app/compat/gms/GmsCompat.java b/core/java/android/app/compat/gms/GmsCompat.java
index ec368ad21a2626b0af1258779cfdb13f6bb6d65f..780e50a5f623b825aafe1973e95a9430c2bd0d0c 100644
--- a/core/java/android/app/compat/gms/GmsCompat.java
+++ b/core/java/android/app/compat/gms/GmsCompat.java
@@ -30,21 +30,21 @@ import android.content.pm.Signature;
 import android.os.Binder;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.UserHandle;
 import android.util.Log;
 
 import com.android.internal.compat.CompatibilityChangeInfo;
 import com.android.internal.gmscompat.GmsInfo;
 
 /**
- * This class provides helpers for Google Play Services compatibility. It allows the following apps
+ * This class provides helpers for Google Play compatibility. It allows the following apps
  * to work as regular, unprivileged user apps:
  *     - Google Play Services (Google Mobile Services, aka "GMS")
  *     - Google Services Framework
  *     - Google Play Store
  *     - All apps depending on Google Play Services
  *
  * All GMS compatibility hooks should call methods on GmsCompat. Hooks that are more complicated
  * than returning a simple constant value should also be implemented in GmsHooks to reduce
  * maintenance overhead.
  *
diff --git a/core/java/com/android/internal/gmscompat/GmsCompatApp.java b/core/java/com/android/internal/gmscompat/GmsCompatApp.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7de640d53cff4fc170246550e0d72341bd562d3
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmsCompatApp.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+import android.content.Context;
+import android.content.Intent;
+
+public final class GmsCompatApp {
+    private static final String TAG = "GmsCompat/App";
+
+    public static final String PKG_NAME = "app.grapheneos.gmscompat";
+
+    private GmsCompatApp() {}
+
+    // this service binds to Play Services and Play Store, thereby raising their priority and
+    // allowing them to start their own services
+    static void startPersistentFgService(Context ctx) {
+        Intent i = new Intent(ctx.getPackageName());
+        i.setClassName(PKG_NAME,
+            PKG_NAME + ".PersistentFgService");
+        ctx.startForegroundService(i);
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
index 23968b65adc30ad5bf760e2a9fdbee395ff8e8d8..db78427b6db40bb0798aaf6161964840c2432753 100644
--- a/core/java/com/android/internal/gmscompat/GmsHooks.java
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -17,146 +17,94 @@
 package com.android.internal.gmscompat;
 
 import android.annotation.SuppressLint;
 import android.app.ActivityManager.RunningAppProcessInfo;
 import android.app.ActivityThread;
 import android.app.Application;
 import android.app.Notification;
 import android.app.NotificationChannel;
 import android.app.NotificationChannelGroup;
 import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.app.Service;
 import android.app.compat.gms.GmsCompat;
-import android.content.ComponentName;
 import android.content.ContentValues;
 import android.content.Context;
-import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Build;
 import android.os.Process;
 import android.os.SystemClock;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.provider.Settings;
 import android.util.Log;
 import android.util.SparseArray;
 import android.webkit.WebView;
 
 import com.android.internal.R;
 import com.android.internal.gmscompat.dynamite.GmsDynamiteHooks;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
 /**
- * API shims for Google Play Services compatibility. Hooks that are more complicated than a simple
+ * API shims for Google Play compatibility. Hooks that are more complicated than a simple
  * constant return value should be delegated to this class for easier maintenance.
  *
  * @hide
  */
 public final class GmsHooks {
     private static final String TAG = "GmsCompat/Hooks";
 
     // Foreground service notifications
     // id was chosen when fgs was the only channel
     static final String COMPAT_GROUP_ID = "gmscompat_fgs_group";
-    private static final String FGS_CHANNEL_ID = "gmscompat_fgs_channel";
-    private static final int FGS_NOTIFICATION_ID = 529977835;
-    private static boolean notificationChannelsCreated;
+    private static volatile boolean notificationChannelsCreated;
 
     // Static only
     private GmsHooks() { }
 
-
-    /*
-     * Foreground service notifications to keep GMS services alive
-     */
-
-    // Make all services foreground to keep them alive
-    // ContextImpl#startService(Intent)
-    public static ComponentName startService(Context context, Intent service) {
-        return context.startForegroundService(service);
-    }
-
     static Notification.Builder obtainNotificationBuilder(Context context, String channelId) {
         if (!notificationChannelsCreated) {
             createNotificationChannels(context);
             notificationChannelsCreated = true;
         }
         return new Notification.Builder(context, channelId);
     }
 
     private static void createNotificationChannels(Context context) {
+        if (!GmsCompat.isPlayStore()) {
+            return;
+        }
         NotificationManager manager = context.getSystemService(NotificationManager.class);
         NotificationChannelGroup group = new NotificationChannelGroup(COMPAT_GROUP_ID,
                 context.getText(R.string.gmscompat_channel_group));
         manager.createNotificationChannelGroup(group);
 
         ArrayList<NotificationChannel> channels = new ArrayList<>(7);
-        {
-            CharSequence name = context.getText(R.string.foreground_service_gmscompat_channel);
-            NotificationChannel c = new NotificationChannel(FGS_CHANNEL_ID, name,
-                    NotificationManager.IMPORTANCE_LOW);
-            c.setDescription(context.getString(R.string.foreground_service_gmscompat_channel_desc));
-            c.setShowBadge(false);
-            channels.add(c);
-        }
-        if (GmsCompat.isPlayStore()) {
-            PlayStoreHooks.createNotificationChannel(context, channels);
-        }
+        PlayStoreHooks.createNotificationChannel(context, channels);
 
         for (int i = 0; i < channels.size(); ++i) {
             channels.get(i).setGroup(COMPAT_GROUP_ID);
         }
 
         manager.createNotificationChannels(channels);
     }
 
-    // Post notification on foreground service start
-    // ActivityThread#handleCreateService(CreateServiceData)
-    public static void attachService(Service service) {
-        // Isolated processes (e.g. WebView) don't have access to NotificationManager. They don't
-        // need a foreground notification anyway, so bail out early.
-        if (!GmsCompat.isEnabled() || Process.isIsolated()) {
-            return;
-        }
-
-        // Intent: notification channel settings
-        Intent intent = new Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);
-        intent.putExtra(Settings.EXTRA_APP_PACKAGE, service.getPackageName());
-        intent.putExtra(Settings.EXTRA_CHANNEL_ID, FGS_CHANNEL_ID);
-        PendingIntent pi = PendingIntent.getActivity(service, 0, intent, PendingIntent.FLAG_IMMUTABLE);
-
-        // Notification
-        CharSequence appName = service.getApplicationInfo().loadLabel(service.getPackageManager());
-        Notification notification = obtainNotificationBuilder(service, FGS_CHANNEL_ID)
-                .setSmallIcon(service.getApplicationInfo().icon)
-                .setContentTitle(service.getString(R.string.app_running_notification_title, appName))
-                .setContentText(service.getText(R.string.foreground_service_gmscompat_notif_desc))
-                .setContentIntent(pi)
-                .build();
-
-        Log.d(TAG, "Posting notification for service: " + service.getClass().getName());
-        service.startForeground(FGS_NOTIFICATION_ID, notification);
-    }
-
     // GMS tries to clean up its own notification channels periodically.
     // Don't let it delete any of compat channels because that throws an exception and crashes GMS.
     // NotificationManager#deleteNotificationChannel(String)
     public static boolean skipDeleteNotificationChannel(String channelId) {
         if (!GmsCompat.isEnabled()) {
             return false;
         }
-        return FGS_CHANNEL_ID.equals(channelId) || PlayStoreHooks.PUA_CHANNEL_ID.equals(channelId);
+        return PlayStoreHooks.PUA_CHANNEL_ID.equals(channelId);
     }
 
     /**
      * API shims
      */
 
     // Report a single user on the system
     // UserManager#getSerialNumbersOfUsers(boolean)
     public static long[] getSerialNumbersOfUsers(UserManager userManager) {
         return new long[] { userManager.getSerialNumberForUser(Process.myUserHandle()) };
@@ -207,21 +155,33 @@ public final class GmsHooks {
         GmsCompat.initChangeEnableStates(app);
 
         if (GmsCompat.isEnabled()) {
             String processName = Application.getProcessName();
             if (!app.getPackageName().equals(processName)) {
                 // Fix RuntimeException: Using WebView from more than one process at once with the same data
                 // directory is not supported. https://crbug.com/558377
                 WebView.setDataDirectorySuffix("process-shim--" + processName);
             }
 
-            GmsDynamiteHooks.initGmsServerApp(app);
+            if (GmsCompat.isPlayServices()) {
+                GmsDynamiteHooks.initGmsServerApp(app);
+
+                if ("com.google.android.gms.persistent".equals(processName)) {
+                    // BOOT_COMPLETED receiver runs in this process
+                    GmsCompatApp.startPersistentFgService(app);
+                }
+            } else if (GmsCompat.isPlayStore()) {
+                if (GmsInfo.PACKAGE_PLAY_STORE.equals(processName)) {
+                    // BOOT_COMPLETED receiver runs in this process
+                    GmsCompatApp.startPersistentFgService(app);
+                }
+            }
         } else if (GmsCompat.isDynamiteClient()) {
             GmsDynamiteHooks.initClientApp();
         }
     }
 
     // Redirect cross-user interactions to current user
     // ContextImpl#sendOrderedBroadcastAsUser
     // ContextImpl#sendBroadcastAsUser
     public static UserHandle getUserHandle(UserHandle user) {
         return GmsCompat.isEnabled() ? Process.myUserHandle() : user;
@@ -272,21 +232,22 @@ public final class GmsHooks {
             // sorted by lastSeen field in reverse order
             Arrays.sort(arr);
             map.clear();
             for (int i = 0; i < RecentBinderPid.MAP_SIZE_TRIM_TO; ++i) {
                 RecentBinderPid e = arr[i];
                 map.put(e.pid, e);
             }
         }
     }
 
-    // Play Games Services relies on getRunningAppProcesses() to figure out whether its client is running.
+    // In some cases (Play Games Services, Play {Asset, Feature} Delivery)
+    // GMS relies on getRunningAppProcesses() to figure out whether its client is running.
     // This workaround is racy, because unprivileged apps don't know whether arbitrary pid is alive.
     // ActivityManager#getRunningAppProcesses()
     public static ArrayList<RunningAppProcessInfo> addRecentlyBoundPids(Context context,
                                                                         List<RunningAppProcessInfo> orig) {
         final RecentBinderPid[] binderPids;
         final int binderPidsCount;
         // copy to array to avoid long lock contention with Binder.execTransact(),
         // there are expensive getPackagesForUid() calls below
         {
             SparseArray<RecentBinderPid> map = RecentBinderPid.map;
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index c9df9033da6e062df84d3df7cb4f29b1042414fc..21f9da4ea977e404dc27044b6cc9eb5edf50f886 100644
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -760,31 +760,20 @@
         are multiple apps running.  The left and right side may both already be compound
         (constructed using this separator).  Should be kept as short as possible, this is
         for summary text in the notification where there is not a lot of space.
         [CHAR LIMIT=NONE] -->
     <string name="foreground_service_multiple_separator"><xliff:g id="left_side">%1$s</xliff:g>,
         <xliff:g id="right_side">%2$s</xliff:g></string>
 
     <!-- Name for GmsCompat notification channel group -->
     <string name="gmscompat_channel_group">Compatibility</string>
 
-    <!-- Name for foreground service notification channel created by GmsCompat  -->
-    <string name="foreground_service_gmscompat_channel">Services</string>
-
-    <!-- Description for foreground service notification channel created by GmsCompat  -->
-    <string name="foreground_service_gmscompat_channel_desc">These notifications are created by the
-        Google Play Services compatibility layer in order to keep services running in the
-        background.\n\nDisable this category to hide the unnecessary notifications.</string>
-
-    <!-- Description for foreground service notifications created by GmsCompat  -->
-    <string name="foreground_service_gmscompat_notif_desc">Tap to hide</string>
-
     <string name="gmscompat_notif_channel_action_required">Action required</string>
 
     <!-- Displayed to the user to tell them that they have started up the phone in "safe mode" -->
     <string name="safeMode">Safe mode</string>
 
     <!-- Label for the Android system components when they are shown to the user. -->
     <string name="android_system_label">Android System</string>
 
     <!-- "Switch" is a verb; it means to change user profile by tapping another user profile name. -->
     <string name="user_owner_label">Switch to personal profile</string>
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index c85c256d7bbdd594cb4854ad345953dee7917844..36cbfb5015ff2aa7baf54c9bb8e572e98550515d 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -3636,23 +3636,20 @@
   <java-symbol type="string" name="config_retailDemoPackage" />
   <java-symbol type="string" name="config_retailDemoPackageSignature" />
 
   <java-symbol type="string" name="notification_channel_foreground_service" />
   <java-symbol type="string" name="foreground_service_app_in_background" />
   <java-symbol type="string" name="foreground_service_apps_in_background" />
   <java-symbol type="string" name="foreground_service_tap_for_details" />
   <java-symbol type="string" name="foreground_service_multiple_separator" />
 
   <java-symbol type="string" name="gmscompat_channel_group" />
-  <java-symbol type="string" name="foreground_service_gmscompat_channel" />
-  <java-symbol type="string" name="foreground_service_gmscompat_channel_desc" />
-  <java-symbol type="string" name="foreground_service_gmscompat_notif_desc" />
   <java-symbol type="string" name="gmscompat_notif_channel_action_required" />
 
   <java-symbol type="bool" name="config_enableCredentialFactoryResetProtection" />
 
   <!-- ETWS primary messages -->
   <java-symbol type="string" name="etws_primary_default_message_earthquake" />
   <java-symbol type="string" name="etws_primary_default_message_tsunami" />
   <java-symbol type="string" name="etws_primary_default_message_earthquake_and_tsunami" />
   <java-symbol type="string" name="etws_primary_default_message_test" />
   <java-symbol type="string" name="etws_primary_default_message_others" />
diff --git a/services/core/java/com/android/server/pm/AppsFilter.java b/services/core/java/com/android/server/pm/AppsFilter.java
index 7d1d1224348d6647298ae5604837e9dd446511e6..eb8adc305ab950143ea7e0bc8720f4a57edf606e 100644
--- a/services/core/java/com/android/server/pm/AppsFilter.java
+++ b/services/core/java/com/android/server/pm/AppsFilter.java
@@ -45,20 +45,21 @@ import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.Slog;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 import android.util.SparseSetArray;
 
 import com.android.internal.R;
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.gmscompat.GmsCompatApp;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.function.QuadFunction;
 import com.android.server.FgThread;
 import com.android.server.compat.CompatChange;
 import com.android.server.om.OverlayReferenceMapper;
 import com.android.server.pm.parsing.pkg.AndroidPackage;
 import com.android.server.utils.Snappable;
 import com.android.server.utils.SnapshotCache;
 import com.android.server.utils.Snapshots;
 import com.android.server.utils.Watchable;
@@ -744,20 +745,21 @@ public class AppsFilter implements Watchable, Snappable {
         final boolean isGmsApp = GmsCompat.isGmsApp(newPkg.getPackageName(),
                 newPkg.getSigningDetails().signatures,
                 newPkg.getSigningDetails().pastSigningCertificates,
                 newPkg.isPrivileged(),
                 newPkgSetting.sharedUser != null ? newPkgSetting.sharedUser.name : null);
         final boolean newIsForceQueryable =
                 mForceQueryable.contains(newPkgSetting.appId)
                         /* shared user that is already force queryable */
                         || newPkgSetting.forceQueryableOverride /* adb override */
                         || isGmsApp
+                        || GmsCompatApp.PKG_NAME.equals(newPkg.getPackageName())
                         || (newPkgSetting.isSystem() && (mSystemAppsQueryable
                         || newPkg.isForceQueryable()
                         || ArrayUtils.contains(mForceQueryableByDevicePackageNames,
                         newPkg.getPackageName())));
         if (newIsForceQueryable
                 || (mSystemSigningDetails != null
                 && isSystemSigned(mSystemSigningDetails, newPkgSetting))) {
             mForceQueryable.add(newPkgSetting.appId);
         }
 

commit fa1c98ac0eca7ef31c7a67105dc9b2eeb2da214d
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Mon 2022-01-24 18:54:25+0200

    gmscompat: make connection to GmsCompatApp unbreakable
---
 .../android/internal/gmscompat/GmsCompatApp.java   | 53 ++++++++++++++++++----
 .../com/android/internal/gmscompat/GmsHooks.java   | 15 ++----
 2 files changed, 48 insertions(+), 20 deletions(-)

diff --git a/core/java/com/android/internal/gmscompat/GmsCompatApp.java b/core/java/com/android/internal/gmscompat/GmsCompatApp.java
index a7de640d53cff4fc170246550e0d72341bd562d3..45a3138b2b28e5c9e852e1c44cd19d99a5b3320c 100644
--- a/core/java/com/android/internal/gmscompat/GmsCompatApp.java
+++ b/core/java/com/android/internal/gmscompat/GmsCompatApp.java
@@ -10,28 +10,61 @@
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.android.internal.gmscompat;
 
 import android.content.Context;
-import android.content.Intent;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.Log;
 
 public final class GmsCompatApp {
-    private static final String TAG = "GmsCompat/App";
-
+    private static final String TAG = "GmsCompat/GCA";
     public static final String PKG_NAME = "app.grapheneos.gmscompat";
+    private static final String KEY_BINDER = "binder";
+
+    // needed to establish bidirectional IBinder.linkToDeath()
+    @SuppressWarnings("FieldCanBeLocal")
+    private static Binder localBinder;
+    @SuppressWarnings("FieldCanBeLocal")
+    private static IBinder remoteBinder;
 
     private GmsCompatApp() {}
 
-    // this service binds to Play Services and Play Store, thereby raising their priority and
-    // allowing them to start their own services
-    static void startPersistentFgService(Context ctx) {
-        Intent i = new Intent(ctx.getPackageName());
-        i.setClassName(PKG_NAME,
-            PKG_NAME + ".PersistentFgService");
-        ctx.startForegroundService(i);
+    static IBinder connect(Context ctx) {
+        Binder local = new Binder();
+        localBinder = local;
+        Bundle extras = new Bundle();
+        extras.putBinder(KEY_BINDER, local);
+
+        Bundle res = null;
+        String provider = PKG_NAME + ".BinderProvider";
+        try {
+            res = ctx.getContentResolver().call(provider, ctx.getPackageName(), null, extras);
+        } catch (Throwable t) {
+            Log.e(TAG, "call to " + provider + " failed", t);
+            System.exit(1);
+        }
+        IBinder b = res.getBinder(KEY_BINDER);
+        try {
+            b.linkToDeath(new DeathRecipient(), 0);
+        } catch (RemoteException e) {
+            Log.e(TAG, PKG_NAME + " already died", e);
+            System.exit(1);
+        }
+        remoteBinder = b;
+        return b;
+    }
+
+    static class DeathRecipient implements IBinder.DeathRecipient {
+        public void binderDied() {
+            Log.e(TAG, PKG_NAME + " died");
+            System.exit(1);
+        }
     }
 }
diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
index db78427b6db40bb0798aaf6161964840c2432753..694d622f394d58944b32a5b076dc5fa23758a420 100644
--- a/core/java/com/android/internal/gmscompat/GmsHooks.java
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -157,30 +157,25 @@ public final class GmsHooks {
         if (GmsCompat.isEnabled()) {
             String processName = Application.getProcessName();
             if (!app.getPackageName().equals(processName)) {
                 // Fix RuntimeException: Using WebView from more than one process at once with the same data
                 // directory is not supported. https://crbug.com/558377
                 WebView.setDataDirectorySuffix("process-shim--" + processName);
             }
 
             if (GmsCompat.isPlayServices()) {
                 GmsDynamiteHooks.initGmsServerApp(app);
-
-                if ("com.google.android.gms.persistent".equals(processName)) {
-                    // BOOT_COMPLETED receiver runs in this process
-                    GmsCompatApp.startPersistentFgService(app);
-                }
-            } else if (GmsCompat.isPlayStore()) {
-                if (GmsInfo.PACKAGE_PLAY_STORE.equals(processName)) {
-                    // BOOT_COMPLETED receiver runs in this process
-                    GmsCompatApp.startPersistentFgService(app);
-                }
+            }
+            if (!Process.isIsolated()) {
+                GmsCompatApp.connect(app);
+            } else {
+                Log.d(TAG, "initApplicationBeforeOnCreate: isolated process " + Application.getProcessName());
             }
         } else if (GmsCompat.isDynamiteClient()) {
             GmsDynamiteHooks.initClientApp();
         }
     }
 
     // Redirect cross-user interactions to current user
     // ContextImpl#sendOrderedBroadcastAsUser
     // ContextImpl#sendBroadcastAsUser
     public static UserHandle getUserHandle(UserHandle user) {

commit b5e376d9e3f5571a385ce319cb9ca0ad3092564f
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Mon 2022-01-10 13:33:38+0200

    don't auto-grant special runtime permissions after update
---
 .../com/android/server/pm/permission/PermissionManagerService.java | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
index 60dc0a0277254b6cf1cd2539e1cca36c58305499..c0567a446e48752a498d219ff9290da134616431 100644
--- a/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
+++ b/services/core/java/com/android/server/pm/permission/PermissionManagerService.java
@@ -2683,20 +2683,22 @@ public class PermissionManagerService extends IPermissionManager.Stub {
             for (final int userId : userIds) {
                 if (mPermissionPolicyInternal.isInitialized(userId)) {
                     isPermissionPolicyInitialized.put(userId, true);
                 }
             }
         }
 
         synchronized (mLock) {
             for (final int userId : userIds) {
                 final UserPermissionState userState = mState.getOrCreateUserState(userId);
+                // "replace" parameter is set to true even when the app is first installed
+                final boolean uidStateWasPresent = userState.getUidState(ps.getAppId()) != null;
                 final UidPermissionState uidState = userState.getOrCreateUidState(ps.getAppId());
 
                 if (uidState.isMissing()) {
                     Collection<String> uidRequestedPermissions;
                     int targetSdkVersion;
                     if (!ps.isSharedUser()) {
                         uidRequestedPermissions = pkg.getRequestedPermissions();
                         targetSdkVersion = pkg.getTargetSdkVersion();
                     } else {
                         uidRequestedPermissions = new ArraySet<>();
@@ -2969,21 +2971,24 @@ public class PermissionManagerService extends IPermissionManager.Stub {
                                     || (!hardRestricted || restrictionExempt)) {
                                 if ((origPermState != null && origPermState.isGranted())
                                         || legacyActivityRecognitionPermission != null) {
                                     if (!uidState.grantPermission(bp)) {
                                         wasChanged = true;
                                     }
                                 }
                             }
 
                             if (isSpecialRuntimePermission(permName) &&
-                                    origPermState == null) {
+                                    origPermState == null &&
+                                    // don't grant special runtime permission after update,
+                                    // unless app comes from the system image
+                                    (!uidStateWasPresent || ps.isSystem())) {
                                 if (uidState.grantPermission(bp)) {
                                     wasChanged = true;
                                 }
                             }
                         } else {
                             if (origPermState == null) {
                                 // New permission
                                 if (PLATFORM_PACKAGE_NAME.equals(
                                         bp.getPackageName())) {
                                     if (!bp.isRemoved()) {

commit fea5dc00165f89a8b2394b7f713bd550b95432a3
Author: flawedworld <flawedworld@flawed.world>
Date:   Wed 2022-02-09 22:23:12+0000

    Do not mark dun APN types as read only
    
    Previously I set this to null, but this can cause a NPE
---
 telephony/java/android/telephony/CarrierConfigManager.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/telephony/java/android/telephony/CarrierConfigManager.java b/telephony/java/android/telephony/CarrierConfigManager.java
index 51cbd880af77067ec1fa549349c881d592793ab5..500eb7ae99dd3ac1620dff9ab3f352c3609f6ce5 100644
--- a/telephony/java/android/telephony/CarrierConfigManager.java
+++ b/telephony/java/android/telephony/CarrierConfigManager.java
@@ -5375,21 +5375,21 @@ public class CarrierConfigManager {
         sDefaults.putStringArray(KEY_CARRIER_VVM_PACKAGE_NAME_STRING_ARRAY, null);
         sDefaults.putBoolean(KEY_SHOW_ICCID_IN_SIM_STATUS_BOOL, false);
         sDefaults.putBoolean(KEY_SHOW_SIGNAL_STRENGTH_IN_SIM_STATUS_BOOL, true);
         sDefaults.putBoolean(KEY_INFLATE_SIGNAL_STRENGTH_BOOL, false);
         sDefaults.putBoolean(KEY_CI_ACTION_ON_SYS_UPDATE_BOOL, false);
         sDefaults.putString(KEY_CI_ACTION_ON_SYS_UPDATE_INTENT_STRING, "");
         sDefaults.putString(KEY_CI_ACTION_ON_SYS_UPDATE_EXTRA_STRING, "");
         sDefaults.putString(KEY_CI_ACTION_ON_SYS_UPDATE_EXTRA_VAL_STRING, "");
         sDefaults.putBoolean(KEY_CSP_ENABLED_BOOL, false);
         sDefaults.putBoolean(KEY_ALLOW_ADDING_APNS_BOOL, true);
-        sDefaults.putStringArray(KEY_READ_ONLY_APN_TYPES_STRING_ARRAY, new String[] {"dun"});
+        sDefaults.putStringArray(KEY_READ_ONLY_APN_TYPES_STRING_ARRAY, new String[] {""});
         sDefaults.putStringArray(KEY_READ_ONLY_APN_FIELDS_STRING_ARRAY, null);
         sDefaults.putStringArray(KEY_APN_SETTINGS_DEFAULT_APN_TYPES_STRING_ARRAY, null);
         sDefaults.putAll(Apn.getDefaults());
 
         sDefaults.putBoolean(KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL, false);
         sDefaults.putBoolean(KEY_ALWAYS_SHOW_EMERGENCY_ALERT_ONOFF_BOOL, false);
         sDefaults.putStringArray(KEY_CARRIER_DATA_CALL_RETRY_CONFIG_STRINGS, new String[]{
                 "default:default_randomization=2000,5000,10000,20000,40000,80000:5000,160000:5000,"
                         + "320000:5000,640000:5000,1280000:5000,1800000:5000",
                 "mms:default_randomization=2000,5000,10000,20000,40000,80000:5000,160000:5000,"

commit 3ab55d5a2dcdba13078bbd2868fbc08b4bb9e3b5
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Sat 2022-01-08 14:17:27+0200

    stop Microsoft apps from crashing without INTERNET permission
    
    Crash is caused by checks in
    com.microsoft.aad.adal.AuthenticationContext.checkInternetPermission() and
    com.microsoft.identity.client.PublicClientApplication.checkInternetPermission()
---
 core/java/android/app/ApplicationPackageManager.java | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)

diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index c911cd9cedba112ee66898943efc1c6bf7495669..71cfc431712c05aa568033093de6c47dca018526 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -17,20 +17,21 @@
 package android.app;
 
 import static android.content.pm.Checksum.TYPE_PARTIAL_MERKLE_ROOT_1M_SHA256;
 import static android.content.pm.Checksum.TYPE_PARTIAL_MERKLE_ROOT_1M_SHA512;
 import static android.content.pm.Checksum.TYPE_WHOLE_MD5;
 import static android.content.pm.Checksum.TYPE_WHOLE_MERKLE_ROOT_4K_SHA256;
 import static android.content.pm.Checksum.TYPE_WHOLE_SHA1;
 import static android.content.pm.Checksum.TYPE_WHOLE_SHA256;
 import static android.content.pm.Checksum.TYPE_WHOLE_SHA512;
 
+import android.Manifest;
 import android.annotation.CallbackExecutor;
 import android.annotation.DrawableRes;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.StringRes;
 import android.annotation.UserIdInt;
 import android.annotation.XmlRes;
 import android.app.compat.gms.GmsCompat;
 import android.app.role.RoleManager;
 import android.compat.annotation.UnsupportedAppUsage;
@@ -729,21 +730,34 @@ public class ApplicationPackageManager extends PackageManager {
         mHasSystemFeatureCache.disableLocal();
     }
 
     /** @hide */
     public static void invalidateHasSystemFeatureCache() {
         mHasSystemFeatureCache.invalidateCache();
     }
 
     @Override
     public int checkPermission(String permName, String pkgName) {
-        return PermissionManager.checkPackageNamePermission(permName, pkgName, getUserId());
+        int res = PermissionManager.checkPackageNamePermission(permName, pkgName, getUserId());
+        if (res != PERMISSION_GRANTED) {
+            // some Microsoft apps crash when INTERNET permission check fails, see
+            // com.microsoft.aad.adal.AuthenticationContext.checkInternetPermission() and
+            // com.microsoft.identity.client.PublicClientApplication.checkInternetPermission()
+            if (Manifest.permission.INTERNET.equals(permName)
+                    // don't rely on Context.getPackageName(), may be different from process package name
+                    && pkgName.equals(ActivityThread.currentPackageName())
+                    && pkgName.startsWith("com.microsoft"))
+            {
+                return PERMISSION_GRANTED;
+            }
+        }
+        return res;
     }
 
     @Override
     public boolean isPermissionRevokedByPolicy(String permName, String pkgName) {
         return getPermissionManager().isPermissionRevokedByPolicy(pkgName, permName);
     }
 
     /**
      * @hide
      */

commit c4117eaa8f337450ed3cd0626bb6463da731497b
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2022-02-04 03:02:19-0500

    [temporary] suppress SystemUI ANRs
    
    The screenshot service in SystemUI has a bug triggered an ANR later on
    after taking a screenshot due to missing events. This is an AOSP bug
    occurring elsewhere too and will hopefully get fixed in Android 12L.
---
 core/res/res/values/config.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 51e8b02d93a8984589f854549ddd274839e683e6..c7d6c94045a40bdcc6b4c51bb0cdd2675e78b2f3 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -3599,21 +3599,21 @@
              2 - 1 snap target: 1:1
     -->
     <integer name="config_dockedStackDividerSnapMode">0</integer>
 
     <!-- The maximum aspect ratio (longerSide/shorterSide) that is treated as close-to-square. The
          orientation requests from apps would be ignored if the display is close-to-square. -->
     <item name="config_closeToSquareDisplayMaxAspectRatio" format="float" type="dimen">1.333</item>
 
     <!-- List of comma separated package names for which we the system will not show crash, ANR,
          etc. dialogs. -->
-    <string translatable="false" name="config_appsNotReportingCrashes">com.android.statementservice</string>
+    <string translatable="false" name="config_appsNotReportingCrashes">com.android.statementservice,com.android.systemui</string>
 
     <!-- Inactivity threshold (in milliseconds) used in JobScheduler. JobScheduler will consider
          the device to be "idle" after being inactive for this long. -->
     <integer name="config_jobSchedulerInactivityIdleThreshold">1860000</integer>
     <!-- The alarm window (in milliseconds) that JobScheduler uses to enter the idle state -->
     <integer name="config_jobSchedulerIdleWindowSlop">300000</integer>
 
     <!-- If true, jobs from background user will be restricted -->
     <bool name="config_jobSchedulerRestrictBackgroundUser">false</bool>
     <!-- The length of grace period after user becomes background user -->

commit 681effac7e5a73e4f0410060de0498584436d43a
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Tue 2021-12-21 17:32:33-0800

    AppErrors: Respect appsNotReportingCrashes for ANRs
    
    We want to use config_appsNotReportingCrashes to silence benign System
    UI ANRs seemingly caused by an AOSP bug related to freezing the
    screenshot process, until Google fixes it:
    
    E ActivityManager: ANR in com.android.systemui:screenshot
    E ActivityManager: Reason: Input dispatching timed out (Screenshot (server) is not responding. Waited 5002ms for MotionEvent)
    E ActivityManager: Frozen: true
    
    Change-Id: I213c1d99d35fb80016e5a72136c99b5fb2cde4a6
---
 services/core/java/com/android/server/am/AppErrors.java | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/services/core/java/com/android/server/am/AppErrors.java b/services/core/java/com/android/server/am/AppErrors.java
index 0bf0fe2be246b61417b0d3304372d800cd925321..e1ac0d0319f304b549baf0aba9f3bd05e3f4bf50 100644
--- a/services/core/java/com/android/server/am/AppErrors.java
+++ b/services/core/java/com/android/server/am/AppErrors.java
@@ -1066,21 +1066,24 @@ class AppErrors {
             if (errState.getDialogController().hasAnrDialogs()) {
                 Slog.e(TAG, "App already has anr dialog: " + proc);
                 MetricsLogger.action(mContext, MetricsProto.MetricsEvent.ACTION_APP_ANR,
                         AppNotRespondingDialog.ALREADY_SHOWING);
                 return;
             }
 
             boolean showBackground = Settings.Secure.getIntForUser(mContext.getContentResolver(),
                     Settings.Secure.ANR_SHOW_BACKGROUND, 0,
                     mService.mUserController.getCurrentUserId()) != 0;
-            if (mService.mAtmInternal.canShowErrorDialogs() || showBackground) {
+            final boolean anrSilenced = mAppsNotReportingCrashes != null
+                    && mAppsNotReportingCrashes.contains(proc.info.packageName);
+            if (!anrSilenced &&
+                    (mService.mAtmInternal.canShowErrorDialogs() || showBackground)) {
                 AnrController anrController = errState.getDialogController().getAnrController();
                 if (anrController == null) {
                     errState.getDialogController().showAnrDialogs(data);
                 } else {
                     String packageName = proc.info.packageName;
                     int uid = proc.info.uid;
                     boolean showDialog = anrController.onAnrDelayCompleted(packageName, uid);
 
                     if (showDialog) {
                         Slog.d(TAG, "ANR delay completed. Showing ANR dialog for package: "
@@ -1091,21 +1094,21 @@ class AppErrors {
                                 + packageName);
                         errState.setNotResponding(false);
                         errState.setNotRespondingReport(null);
                         errState.getDialogController().clearAnrDialogs();
                     }
                 }
             } else {
                 MetricsLogger.action(mContext, MetricsProto.MetricsEvent.ACTION_APP_ANR,
                         AppNotRespondingDialog.CANT_SHOW);
                 // Just kill the app if there is no dialog to be shown.
-                doKill = true;
+                doKill = !anrSilenced;
             }
         }
         if (doKill) {
             mService.killAppAtUsersRequest(proc);
         }
         // Notify PackageWatchdog without the lock held
         if (packageList != null) {
             mPackageWatchdog.onPackageFailure(packageList,
                     PackageWatchdog.FAILURE_REASON_APP_NOT_RESPONDING);
         }

commit 40f27aee17047c60073703eaad6e9b6014b14586
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Fri 2022-02-11 00:04:02-0500

    stop enforcing camera sound for certain carriers
    
    India, Japan and Korea have either industry standards or regulations for
    phones sold within the country enforcing camera sounds. It's trivially
    bypassed by taking out the SIM card, using video, using a headset or
    turning off the volume. It doesn't make sense for us to enforce this.
---
 core/res/res/values-mcc404/config.xml        |  2 --
 core/res/res/values-mcc405/config.xml        |  2 --
 core/res/res/values-mcc440/config.xml (gone) | 25 -------------------------
 core/res/res/values-mcc450/config.xml (gone) | 24 ------------------------
 4 files changed, 53 deletions(-)

diff --git a/core/res/res/values-mcc404/config.xml b/core/res/res/values-mcc404/config.xml
index 4cadef7893d3d5976ed6ea4336a2c31f6dd01bcc..0cb1029626b1e38bdde3440608c391eca0b2495e 100644
--- a/core/res/res/values-mcc404/config.xml
+++ b/core/res/res/values-mcc404/config.xml
@@ -11,15 +11,13 @@
 **
 ** Unless required by applicable law or agreed to in writing, software
 ** distributed under the License is distributed on an "AS IS" BASIS,
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
 */
 -->
 
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <!-- Whether camera shutter sound is forced or not  (country specific). -->
-    <bool name="config_camera_sound_forced">true</bool>
     <!-- Show area update info settings in CellBroadcastReceiver and information in SIM status in Settings app -->
     <bool name="config_showAreaUpdateInfoSettings">true</bool>
 </resources>
diff --git a/core/res/res/values-mcc405/config.xml b/core/res/res/values-mcc405/config.xml
index 4cadef7893d3d5976ed6ea4336a2c31f6dd01bcc..0cb1029626b1e38bdde3440608c391eca0b2495e 100644
--- a/core/res/res/values-mcc405/config.xml
+++ b/core/res/res/values-mcc405/config.xml
@@ -11,15 +11,13 @@
 **
 ** Unless required by applicable law or agreed to in writing, software
 ** distributed under the License is distributed on an "AS IS" BASIS,
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
 */
 -->
 
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <!-- Whether camera shutter sound is forced or not  (country specific). -->
-    <bool name="config_camera_sound_forced">true</bool>
     <!-- Show area update info settings in CellBroadcastReceiver and information in SIM status in Settings app -->
     <bool name="config_showAreaUpdateInfoSettings">true</bool>
 </resources>
diff --git a/core/res/res/values-mcc440/config.xml b/core/res/res/values-mcc440/config.xml
deleted file mode 100644
index 4ca1677fdd8da6fd445df9e047d78499cbbde28b..0000000000000000000000000000000000000000
--- a/core/res/res/values-mcc440/config.xml
+++ /dev/null
@@ -1,25 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-/*
-** Copyright 2012, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
--->
-
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-
-    <!-- Whether camera shutter sound is forced or not  (country specific). -->
-    <bool name="config_camera_sound_forced">true</bool>
-
-</resources>
diff --git a/core/res/res/values-mcc450/config.xml b/core/res/res/values-mcc450/config.xml
deleted file mode 100644
index 2a2bd760207236e37808197c686587bb8cdb5d80..0000000000000000000000000000000000000000
--- a/core/res/res/values-mcc450/config.xml
+++ /dev/null
@@ -1,24 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-/*
-** Copyright 2012, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
--->
-<resources>
-
-    <!-- Whether camera shutter sound is forced or not  (country specific). -->
-    <bool name="config_camera_sound_forced">true</bool>
-
-</resources>

commit ab35fb1789fb840588bcbb6cbf35dc2c85406824
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Mon 2022-01-31 19:55:48+0200

    gmscompat: simplify initialization
---
 core/java/android/app/compat/gms/GmsCompat.java    | 143 ++++++++-------------
 .../com/android/internal/gmscompat/GmsHooks.java   |   2 +-
 .../com/android/server/compat/CompatChange.java    |   4 -
 3 files changed, 54 insertions(+), 95 deletions(-)

diff --git a/core/java/android/app/compat/gms/GmsCompat.java b/core/java/android/app/compat/gms/GmsCompat.java
index 780e50a5f623b825aafe1973e95a9430c2bd0d0c..3096742de6f4214882af2d1ff1c93b289e7072a1 100644
--- a/core/java/android/app/compat/gms/GmsCompat.java
+++ b/core/java/android/app/compat/gms/GmsCompat.java
@@ -12,35 +12,32 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package android.app.compat.gms;
 
 import android.annotation.SystemApi;
 import android.app.ActivityThread;
 import android.app.Application;
-import android.compat.Compatibility;
-import android.compat.annotation.ChangeId;
-import android.compat.annotation.Disabled;
+import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageManager;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.Signature;
+import android.content.pm.SigningInfo;
 import android.os.Binder;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.UserHandle;
-import android.util.Log;
 
-import com.android.internal.compat.CompatibilityChangeInfo;
 import com.android.internal.gmscompat.GmsInfo;
 
 /**
  * This class provides helpers for Google Play compatibility. It allows the following apps
  * to work as regular, unprivileged user apps:
  *     - Google Play Services (Google Mobile Services, aka "GMS")
  *     - Google Services Framework
  *     - Google Play Store
  *     - All apps depending on Google Play Services
  *
@@ -48,47 +45,29 @@ import com.android.internal.gmscompat.GmsInfo;
  * than returning a simple constant value should also be implemented in GmsHooks to reduce
  * maintenance overhead.
  *
  * @hide
  */
 @SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)
 public final class GmsCompat {
     private static final String TAG = "GmsCompat/Core";
     private static final boolean DEBUG_VERBOSE = false;
 
-    /**
-     * Whether to enable Google Play Services compatibility for this app.
-     *
-     * This compatibility change is special because the system enables it automatically for certain
-     * apps, but it still needs to be declared with a change ID.
-     *
-     * We don't have a bug for this in Google's issue tracker, so the change ID is a
-     * randomly-generated long.
-     */
-    @ChangeId
-    @Disabled // Overridden as a special case in CompatChange
-    private static final long GMS_UNPRIVILEGED_COMPAT = 1531297613045645771L;
-
+    private static boolean isGmsCompatEnabled;
     /**
      * Whether to enable hooks for this app to load Dynamite modules from unprivileged GMS.
      * This is for CLIENT apps, not GMS itself.
      */
-    @ChangeId
-    @Disabled // Overridden as a special case in CompatChange
-    private static final long GMS_UNPRIVILEGED_DYNAMITE_CLIENT = 7528921493777479941L;
-
-    // Some hooks are in (potentially) hot paths, so cache the change enable states.
-    // no need to declare these fields as volatile, they are written when app has only the main thread
-    private static boolean isGmsCompatEnabled;
     private static boolean isDynamiteClientEnabled;
     private static boolean isPlayServices;
     private static boolean isPlayStore;
+    private static boolean isBinderRedirectionAllowed;
 
     // Static only
     private GmsCompat() { }
 
     public static boolean isEnabled() {
         return isGmsCompatEnabled;
     }
 
     /** @hide */
     public static boolean isDynamiteClient() {
@@ -98,80 +77,69 @@ public final class GmsCompat {
     /** @hide */
     public static boolean isPlayServices() {
         return isPlayServices;
     }
 
     /** @hide */
     public static boolean isPlayStore() {
         return isPlayStore;
     }
 
-    private static void logEnabled(String changeName, boolean enabled) {
-        if (!DEBUG_VERBOSE) {
-            return;
-        }
-
-        String pkg = ActivityThread.currentPackageName();
-        if (pkg == null) {
-            pkg = (Process.myUid() == Process.SYSTEM_UID) ? "system_server" : "[unknown]";
-        }
-
-        Log.d(TAG, changeName + " enabled for " + pkg + " (" + Process.myPid() + ") = " + enabled);
-    }
-
-    private static boolean isChangeEnabled(String changeName, long changeId) {
-        boolean enabled = Compatibility.isChangeEnabled(changeId);
-
-        // Compatibility changes aren't available in the system process, but this should never be
-        // enabled for it or other core "android" system processes (such as the android:ui process
-        // used for chooser and resolver activities).
-        if (UserHandle.getAppId(Process.myUid()) == Process.SYSTEM_UID) {
-            enabled = false;
-        }
-
-        logEnabled(changeName, enabled);
-        return enabled;
+    /** @hide */
+    public static boolean isBinderRedirectionAllowed() {
+        return isBinderRedirectionAllowed;
     }
 
     /**
-     * Must be called to initialize the compatibility change enable states before any hooks run.
+     * Called before Application.onCreate()
      *
      * @hide
      */
-    public static void initChangeEnableStates(Application app) {
-        isGmsCompatEnabled = isChangeEnabled("GMS_UNPRIVILEGED_COMPAT", GMS_UNPRIVILEGED_COMPAT);
-        isDynamiteClientEnabled = isChangeEnabled("GMS_UNPRIVILEGED_DYNAMITE_CLIENT", GMS_UNPRIVILEGED_DYNAMITE_CLIENT);
+    public static void maybeEnable(Application app) {
+        if (!Process.isApplicationUid(Process.myUid())) {
+            return;
+        }
+        ApplicationInfo appInfo = app.getApplicationInfo();
+        String pkg = appInfo.packageName;
+        boolean isGmsApp = isGmsApp(appInfo);
+        isGmsCompatEnabled = isGmsApp;
+
+        if (!(isGmsApp && GmsInfo.PACKAGE_GMS.equals(pkg))) {
+            if (isGmsInstalled(app)) {
+                // Client apps can't be GMS itself, but GMS must be installed in the same user
+                isDynamiteClientEnabled = true;
+                isBinderRedirectionAllowed = !isGmsApp;
+            }
+        }
         if (isGmsCompatEnabled) {
             // certificate is already checked if isGmsCompatEnabled is set
-            String pkg = app.getPackageName();
             isPlayServices = GmsInfo.PACKAGE_GMS.equals(pkg);
             isPlayStore = GmsInfo.PACKAGE_PLAY_STORE.equals(pkg);
         }
     }
 
     private static boolean validateCerts(Signature[] signatures) {
         for (Signature signature : signatures) {
             if (signature.toCharsString().equals(GmsInfo.SIGNING_CERT)) {
                 return true;
             }
         }
-
         return false;
     }
 
     /**
      * Check whether the given app is unprivileged and part of the Google Play Services family.
      *
      * @hide
      */
     public static boolean isGmsApp(String packageName, Signature[] signatures,
-            Signature[] signatures2, boolean isPrivileged, String sharedUserId) {
+                                   Signature[] pastSignatures, boolean isPrivileged, String sharedUserId) {
         // Privileged GMS doesn't need any compatibility changes
         if (isPrivileged) {
             return false;
         }
 
         if (GmsInfo.PACKAGE_GMS.equals(packageName) || GmsInfo.PACKAGE_GSF.equals(packageName)) {
             // Check the shared user ID to avoid affecting microG with a spoofed signature. This is a
             // reliable indicator because apps can't change their shared user ID after shipping with it.
             if (!GmsInfo.SHARED_USER_ID.equals(sharedUserId)) {
                 return false;
@@ -181,70 +149,65 @@ public final class GmsCompat {
         }
 
         // Validate signature to avoid affecting apps like microG and Gcam Services Provider.
         // This isn't actually necessary from a security perspective because GMS doesn't get any
         // special privileges, but it's a failsafe to avoid unintentional compatibility issues.
         boolean validCert = validateCerts(signatures);
 
         // Try past signing certificates if necessary. We iterate through two separate arrays here
         // instead of concatenating them beforehand because this method gets called for every
         // package installed in the system.
-        if (!validCert && signatures2 != null) {
-            validCert = validateCerts(signatures2);
+        if (!validCert && pastSignatures != null) {
+            validCert = validateCerts(pastSignatures);
         }
-
         return validCert;
     }
 
     /** @hide */
     public static boolean isGmsApp(ApplicationInfo app) {
+        String packageName = app.packageName;
+        if (!(GmsInfo.PACKAGE_GMS.equals(packageName)
+            || GmsInfo.PACKAGE_PLAY_STORE.equals(packageName)
+            || GmsInfo.PACKAGE_GSF.equals(packageName))) {
+            return false;
+        }
         int userId = UserHandle.getUserId(app.uid);
         IPackageManager pm = ActivityThread.getPackageManager();
 
         // Fetch PackageInfo to get signing certificates
         PackageInfo pkg;
         long token = Binder.clearCallingIdentity();
         try {
-            pkg = pm.getPackageInfo(app.packageName, PackageManager.GET_SIGNING_CERTIFICATES, userId);
+            pkg = pm.getPackageInfo(packageName, PackageManager.GET_SIGNING_CERTIFICATES, userId);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         } finally {
             Binder.restoreCallingIdentity(token);
         }
-
-        // Get all applicable certificates, even if GMS switches to multiple signing certificates
-        // in the future
-        Signature[] signatures = pkg.signingInfo.hasMultipleSigners() ?
-                pkg.signingInfo.getApkContentsSigners() :
-                pkg.signingInfo.getSigningCertificateHistory();
-        return isGmsApp(app.packageName, signatures, null, app.isPrivilegedApp(), pkg.sharedUserId);
+        return isGmsApp(pkg);
     }
 
-    private static boolean isGmsInstalled(ApplicationInfo relatedApp) {
-        int userId = UserHandle.getUserId(relatedApp.uid);
-        IPackageManager pm = ActivityThread.getPackageManager();
-
-        ApplicationInfo gmsApp;
-        try {
-            gmsApp = pm.getApplicationInfo(GmsInfo.PACKAGE_GMS, 0, userId);
-        } catch (RemoteException e) {
-            throw e.rethrowFromSystemServer();
+    private static boolean isGmsApp(PackageInfo pkg) {
+        ApplicationInfo app = pkg.applicationInfo;
+        if (app == null) {
+            return false;
         }
-
-        // Check signature to avoid breaking microG's implementation of Dynamite
-        return gmsApp != null && isGmsApp(gmsApp);
+        SigningInfo si = pkg.signingInfo;
+        return isGmsApp(app.packageName,
+            si.getApkContentsSigners(), si.getSigningCertificateHistory(),
+            app.isPrivilegedApp(), pkg.sharedUserId);
     }
 
-    /** @hide */
-    // CompatChange#isEnabled(ApplicationInfo)
-    public static boolean isChangeEnabled(CompatibilityChangeInfo change, ApplicationInfo app) {
-        if (change.getId() == GMS_UNPRIVILEGED_COMPAT) {
-            return isGmsApp(app);
-        } else if (change.getId() == GMS_UNPRIVILEGED_DYNAMITE_CLIENT) {
-            // Client apps can't be GMS itself, but GMS must be installed in the same user
-            return !(GmsInfo.PACKAGE_GMS.equals(app.packageName) && isGmsApp(app)) &&
-                    isGmsInstalled(app);
-        } else {
+    private static boolean isGmsInstalled(Context ctx) {
+        try {
+            PackageInfo gmsPkg = ctx.getPackageManager()
+                .getPackageInfo(GmsInfo.PACKAGE_GMS, PackageManager.GET_SIGNING_CERTIFICATES);
+            // Check signature to avoid breaking microG's implementation of Dynamite
+            return isGmsApp(gmsPkg);
+        } catch (Exception e) {
+            if (!(e instanceof PackageManager.NameNotFoundException)) {
+                e.printStackTrace();
+            }
             return false;
         }
     }
 }
diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
index 694d622f394d58944b32a5b076dc5fa23758a420..e53055385894371046e770fa41a814267c1c1e38 100644
--- a/core/java/com/android/internal/gmscompat/GmsHooks.java
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -145,21 +145,21 @@ public final class GmsHooks {
         if (!GmsCompat.isEnabled()) {
             return flags;
         }
 
         // Remove MATCH_ANY_USER flag to avoid permission denial
         return flags & ~PackageManager.MATCH_ANY_USER;
     }
 
     // Instrumentation#newApplication(ClassLoader, String, Context)
     public static void initApplicationBeforeOnCreate(Application app) {
-        GmsCompat.initChangeEnableStates(app);
+        GmsCompat.maybeEnable(app);
 
         if (GmsCompat.isEnabled()) {
             String processName = Application.getProcessName();
             if (!app.getPackageName().equals(processName)) {
                 // Fix RuntimeException: Using WebView from more than one process at once with the same data
                 // directory is not supported. https://crbug.com/558377
                 WebView.setDataDirectorySuffix("process-shim--" + processName);
             }
 
             if (GmsCompat.isPlayServices()) {
diff --git a/services/core/java/com/android/server/compat/CompatChange.java b/services/core/java/com/android/server/compat/CompatChange.java
index 33f872489d8a1fa49ed8ae5c94a68b8ba3017086..b5846b555747579b4be3028579deb07e8161e1aa 100644
--- a/services/core/java/com/android/server/compat/CompatChange.java
+++ b/services/core/java/com/android/server/compat/CompatChange.java
@@ -15,21 +15,20 @@
  */
 
 package com.android.server.compat;
 
 import static android.app.compat.PackageOverride.VALUE_DISABLED;
 import static android.app.compat.PackageOverride.VALUE_ENABLED;
 import static android.app.compat.PackageOverride.VALUE_UNDEFINED;
 
 import android.annotation.Nullable;
 import android.app.compat.PackageOverride;
-import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.Disabled;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.Overridable;
 import android.content.pm.ApplicationInfo;
 
 import com.android.internal.compat.AndroidBuildClassifier;
 import com.android.internal.compat.CompatibilityChangeInfo;
 import com.android.internal.compat.OverrideAllowedState;
 import com.android.server.compat.config.Change;
@@ -239,23 +238,20 @@ public final class CompatChange extends CompatibilityChangeInfo {
     boolean isEnabled(ApplicationInfo app, AndroidBuildClassifier buildClassifier) {
         if (app == null) {
             return defaultValue();
         }
         if (app.packageName != null) {
             final Boolean enabled = mEvaluatedOverrides.get(app.packageName);
             if (enabled != null) {
                 return enabled;
             }
         }
-        if (GmsCompat.isChangeEnabled(this, app)) {
-            return true;
-        }
         if (getDisabled()) {
             return false;
         }
         if (getEnableSinceTargetSdk() != -1) {
             // If the change is gated by a platform version newer than the one currently installed
             // on the device, disregard the app's target sdk version.
             int compareSdk = Math.min(app.targetSdkVersion, buildClassifier.platformTargetSdk());
             if (compareSdk != app.targetSdkVersion) {
                 compareSdk = app.targetSdkVersion;
             }

commit 0802fc14993d89e6573372da4b0539838ab7f7eb
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Wed 2022-02-09 15:06:30+0200

    gmscompat: add HybridBinder
---
 .../internal/gmscompat/HybridBinder.java (new)     | 121 +++++++++++++++++++++
 1 file changed, 121 insertions(+)

diff --git a/core/java/com/android/internal/gmscompat/HybridBinder.java b/core/java/com/android/internal/gmscompat/HybridBinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..d2f2861c443f822ca68d6a031584cd96b9c39081
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/HybridBinder.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.Parcel;
+import android.os.RemoteException;
+import android.os.ResultReceiver;
+import android.os.ShellCallback;
+import android.util.Log;
+
+import java.io.FileDescriptor;
+import java.util.Arrays;
+
+/**
+ * Fuses two binders together.
+ * Transaction routing decisions are made by looking at transaction codes.
+ * The rest of operations are forwarded to the first ("original") binder.
+ */
+public final class HybridBinder implements IBinder {
+    private static final String TAG = "HybridBinder";
+    private static final boolean DEBUG = false;
+
+    private final IBinder original;
+    private final BinderRedirector redirector;
+
+    public static HybridBinder maybeCreate(IBinder original) {
+        String interface_ = null;
+        try {
+            interface_ = original.getInterfaceDescriptor();
+        } catch (RemoteException ignored) {
+        }
+        if (DEBUG) {
+            Log.d(TAG, "interface " + interface_ + "|");
+        }
+        if (interface_ == null) {
+            return null;
+        }
+        BinderRedirector rd = BinderRedirector.maybeGet(interface_);
+        if (rd == null) {
+            return null;
+        }
+        return new HybridBinder(original, rd);
+    }
+
+    private HybridBinder(IBinder original, BinderRedirector redirector) {
+        this.original = original;
+        this.redirector = redirector;
+    }
+
+    public boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException {
+        if (DEBUG) {
+            Log.d(TAG, "call " + (code - IBinder.FIRST_CALL_TRANSACTION));
+        }
+        BinderRedirector rd = redirector;
+        if (Arrays.binarySearch(rd.transactionCodes, code) >= 0) {
+            return rd.destination.transact(code, data, reply, flags);
+        }
+        return original.transact(code, data, reply, flags);
+    }
+
+    @Nullable
+    public IInterface queryLocalInterface(@NonNull String descriptor) {
+        return null;
+    }
+
+    @Nullable
+    public String getInterfaceDescriptor() throws RemoteException {
+        return original.getInterfaceDescriptor();
+    }
+
+    public boolean pingBinder() {
+        return original.pingBinder();
+    }
+
+    public boolean isBinderAlive() {
+        return original.isBinderAlive();
+    }
+
+    public void dump(@NonNull FileDescriptor fd, @Nullable String[] args) throws RemoteException {
+        original.dump(fd, args);
+    }
+
+    public void dumpAsync(@NonNull FileDescriptor fd, @Nullable String[] args) throws RemoteException {
+        original.dumpAsync(fd, args);
+    }
+
+    public void shellCommand(@Nullable FileDescriptor in, @Nullable FileDescriptor out, @Nullable FileDescriptor err, @NonNull String[] args, @Nullable ShellCallback shellCallback, @NonNull ResultReceiver resultReceiver) throws RemoteException {
+        original.shellCommand(in, out, err, args, shellCallback, resultReceiver);
+    }
+
+    public void linkToDeath(@NonNull DeathRecipient recipient, int flags) throws RemoteException {
+        original.linkToDeath(recipient, flags);
+    }
+
+    public boolean unlinkToDeath(@NonNull DeathRecipient recipient, int flags) {
+        return original.unlinkToDeath(recipient, flags);
+    }
+
+    @Nullable
+    public IBinder getExtension() throws RemoteException {
+        return original.getExtension();
+    }
+}

commit afd66c4181c67259e1798f47834f2d4e821476eb
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Wed 2022-02-09 15:25:29+0200

    gmscompat: add BinderRedirector
---
 .../internal/gmscompat/BinderRedirector.java (new) | 115 +++++++++++++++++++++
 .../android/internal/gmscompat/GmsCompatApp.java   |  71 ++++++++++---
 2 files changed, 173 insertions(+), 13 deletions(-)

diff --git a/core/java/com/android/internal/gmscompat/BinderRedirector.java b/core/java/com/android/internal/gmscompat/BinderRedirector.java
new file mode 100644
index 0000000000000000000000000000000000000000..11141a253997191920252b9b0aaaaaa689c81535
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/BinderRedirector.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+import android.app.ActivityThread;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.IBinder;
+import android.util.Log;
+
+import java.util.Arrays;
+
+/**
+ * Obtains from GmsCompatApp objects that are needed to create HybridBinder
+ * and handles redirection state changes.
+ */
+public final class BinderRedirector {
+    private static final String TAG = "BinderRedirector";
+
+    private static volatile String[] redirectableInterfaces;
+
+    private static RedirectionStateListener redirectionStateListener;
+    private static BinderRedirector[] cache;
+
+    public final IBinder destination;
+    public final int[] transactionCodes;
+
+    public BinderRedirector(IBinder destination, int[] transactionCodes) {
+        this.destination = destination;
+        this.transactionCodes = transactionCodes;
+    }
+
+    public static void maybeInit() {
+        if (redirectableInterfaces == null) {
+            redirectableInterfaces = GmsCompatApp.getRedirectableInterfaces();
+        }
+    }
+
+    public static BinderRedirector maybeGet(String interface_) {
+        int id = Arrays.binarySearch(redirectableInterfaces, interface_);
+        if (id >= 0) {
+            BinderRedirector rd = obtain(id);
+            if (rd.destination != null) {
+                return rd;
+            } // else this redirection is disabled
+        }
+        return null;
+    }
+
+    private static BinderRedirector obtain(int id) {
+        BinderRedirector[] cache = BinderRedirector.cache;
+        if (cache != null) {
+            BinderRedirector cached = cache[id];
+            if (cached != null) {
+                return cached;
+            }
+        }
+        synchronized (BinderRedirector.class) {
+            if (redirectionStateListener == null) {
+                redirectionStateListener = RedirectionStateListener.register();
+                BinderRedirector.cache = new BinderRedirector[redirectableInterfaces.length];
+            }
+            redirectionStateListener.usedRedirections |= (1L << id);
+        }
+        BinderRedirector rd = GmsCompatApp.getBinderRedirector(id);
+        // all BinderRedirector fields are final, this is thread-safe
+        BinderRedirector.cache[id] = rd;
+
+        IBinder dest = rd.destination;
+        if (dest != null) {
+            GmsCompatApp.DeathRecipient.register(dest);
+        }
+        return rd;
+    }
+
+    static class RedirectionStateListener extends BroadcastReceiver {
+        private static final String INTENT_ACTION = GmsCompatApp.PKG_NAME + ".ACTION_REDIRECTION_STATE_CHANGED";
+        private static final String PERMISSION = GmsCompatApp.PKG_NAME + ".permission.REDIRECTION_STATE_CHANGED_BROADCAST";
+        private static final String KEY_REDIRECTION_ID = "id";
+
+        volatile long usedRedirections;
+
+        static RedirectionStateListener register() {
+            Context ctx = ActivityThread.currentApplication();
+            RedirectionStateListener l = new RedirectionStateListener();
+            ctx.registerReceiver(l, new IntentFilter(INTENT_ACTION), PERMISSION, null);
+            return l;
+        }
+
+        public void onReceive(Context context, Intent intent) {
+            int id = intent.getIntExtra(KEY_REDIRECTION_ID, 0);
+            if ((usedRedirections & (1L << id)) != 0) {
+                // it's infeasible to enable / disable redirection without starting over
+                Log.d(TAG, "state of redirection (id " + id + ") changed, calling System.exit(0)");
+                System.exit(0);
+            }
+        }
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/GmsCompatApp.java b/core/java/com/android/internal/gmscompat/GmsCompatApp.java
index 45a3138b2b28e5c9e852e1c44cd19d99a5b3320c..13ca6971fadf1cec130973370825ed4b59cece23 100644
--- a/core/java/com/android/internal/gmscompat/GmsCompatApp.java
+++ b/core/java/com/android/internal/gmscompat/GmsCompatApp.java
@@ -9,62 +9,107 @@
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package com.android.internal.gmscompat;
 
+import android.app.ActivityThread;
 import android.content.Context;
 import android.os.Binder;
 import android.os.Bundle;
 import android.os.IBinder;
 import android.os.RemoteException;
 import android.util.Log;
 
 public final class GmsCompatApp {
     private static final String TAG = "GmsCompat/GCA";
     public static final String PKG_NAME = "app.grapheneos.gmscompat";
     private static final String KEY_BINDER = "binder";
+    private static final String KEY_BINDER_TRANSACTION_CODES = "binder_txn_codes";
+    private static final String KEY_RESULT = "result";
 
     // needed to establish bidirectional IBinder.linkToDeath()
     @SuppressWarnings("FieldCanBeLocal")
     private static Binder localBinder;
     @SuppressWarnings("FieldCanBeLocal")
     private static IBinder remoteBinder;
 
     private GmsCompatApp() {}
 
+    // called by GSF, Play services, Play Store during startup
     static IBinder connect(Context ctx) {
         Binder local = new Binder();
         localBinder = local;
         Bundle extras = new Bundle();
         extras.putBinder(KEY_BINDER, local);
 
-        Bundle res = null;
-        String provider = PKG_NAME + ".BinderProvider";
-        try {
-            res = ctx.getContentResolver().call(provider, ctx.getPackageName(), null, extras);
-        } catch (Throwable t) {
-            Log.e(TAG, "call to " + provider + " failed", t);
-            System.exit(1);
+        String authority = PKG_NAME + ".BinderProvider";
+        Bundle res = call(ctx, authority, ctx.getPackageName(), null, extras);
+
+        IBinder remote = res.getBinder(KEY_BINDER);
+        DeathRecipient.register(remote);
+        remoteBinder = remote;
+        return remote;
+    }
+
+    // region | GMS client section
+
+    private static final int METHOD_GET_REDIRECTABLE_INTERFACES = 0;
+    private static final int METHOD_GET_REDIRECTOR = 1;
+
+    public static String[] getRedirectableInterfaces() {
+        Bundle b = gmsClientProviderCall(METHOD_GET_REDIRECTABLE_INTERFACES, null, null);
+        return b.getStringArray(KEY_RESULT);
+    }
+
+    public static BinderRedirector getBinderRedirector(int id) {
+        Bundle b = gmsClientProviderCall(METHOD_GET_REDIRECTOR, Integer.toString(id), null);
+        if (b == null) {
+            // redirector is disabled
+            return new BinderRedirector(null, null);
         }
-        IBinder b = res.getBinder(KEY_BINDER);
+        IBinder binder = b.getBinder(KEY_BINDER);
+        int[] txnCodes = b.getIntArray(KEY_BINDER_TRANSACTION_CODES);
+        return new BinderRedirector(binder, txnCodes);
+    }
+
+    private static Bundle gmsClientProviderCall(int method, String arg, Bundle bundleArg) {
+        String authority = PKG_NAME + ".GmsClientProvider";
+        Context ctx = ActivityThread.currentApplication();
+        return call(ctx, authority, Integer.toString(method), arg, bundleArg);
+    }
+    // endregion
+
+    private static Bundle call(Context ctx, String authority, String method, String arg, Bundle bundleArg) {
         try {
-            b.linkToDeath(new DeathRecipient(), 0);
-        } catch (RemoteException e) {
-            Log.e(TAG, PKG_NAME + " already died", e);
+            return ctx.getContentResolver().call(authority, method, arg, bundleArg);
+        } catch (Throwable t) {
+            // content provider calls are infallible unless something goes very wrong, better fail fast in that case
+            Log.e(TAG, "call to " + authority + " failed", t);
             System.exit(1);
+            return null;
         }
-        remoteBinder = b;
-        return b;
     }
 
     static class DeathRecipient implements IBinder.DeathRecipient {
+        private static final DeathRecipient INSTANCE = new DeathRecipient();
+        private DeathRecipient() {}
+
+        static void register(IBinder b) {
+            try {
+                b.linkToDeath(INSTANCE, 0);
+            } catch (RemoteException e) {
+                // binder already died
+                INSTANCE.binderDied();
+            }
+        }
+
         public void binderDied() {
             Log.e(TAG, PKG_NAME + " died");
             System.exit(1);
         }
     }
 }

commit a3cb358d5c2c6f36fad503ad634e4930ebfab28f
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Wed 2022-02-09 15:30:10+0200

    gmscompat: perform binder redirection check in IGmsCallbacks interface
---
 core/java/android/os/Binder.java | 11 +++++++++++
 core/java/android/os/Parcel.java | 13 ++++++++++++-
 2 files changed, 23 insertions(+), 1 deletion(-)

diff --git a/core/java/android/os/Binder.java b/core/java/android/os/Binder.java
index 56a12377b9a1454b919f34f9ccf16b0e5bcff140..a04f7a611facfb8a17b338a766e79ce980f8a099 100644
--- a/core/java/android/os/Binder.java
+++ b/core/java/android/os/Binder.java
@@ -19,20 +19,21 @@ package android.os;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SystemApi;
 import android.app.AppOpsManager;
 import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.util.ExceptionUtils;
 import android.util.Log;
 import android.util.Slog;
 
+import com.android.internal.gmscompat.BinderRedirector;
 import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.BinderCallHeavyHitterWatcher;
 import com.android.internal.os.BinderCallHeavyHitterWatcher.BinderCallHeavyHitterListener;
 import com.android.internal.os.BinderInternal;
 import com.android.internal.os.BinderInternal.CallSession;
 import com.android.internal.util.FastPrintWriter;
 import com.android.internal.util.FunctionalUtils.ThrowingRunnable;
 import com.android.internal.util.FunctionalUtils.ThrowingSupplier;
 
 import dalvik.annotation.optimization.CriticalNative;
@@ -633,22 +634,30 @@ public class Binder implements IBinder {
 
     /**
      * Convenience method for associating a specific interface with the Binder.
      * After calling, queryLocalInterface() will be implemented for you
      * to return the given owner IInterface when the corresponding
      * descriptor is requested.
      */
     public void attachInterface(@Nullable IInterface owner, @Nullable String descriptor) {
         mOwner = owner;
         mDescriptor = descriptor;
+        if (GmsCompat.isBinderRedirectionAllowed()) {
+            mPerformRedirectionCheck = "com.google.android.gms.common.internal.IGmsCallbacks".equals(descriptor);
+            if (mPerformRedirectionCheck) {
+                BinderRedirector.maybeInit();
+            }
+        }
     }
 
+    private boolean mPerformRedirectionCheck;
+
     /**
      * Default implementation returns an empty interface name.
      */
     public @Nullable String getInterfaceDescriptor() {
         return mDescriptor;
     }
 
     /**
      * Default implementation always returns true -- if you got here,
      * the object is alive.
@@ -1165,20 +1174,21 @@ public class Binder implements IBinder {
                 observer != null ? observer.callStarted(this, code, UNSET_WORKSOURCE) : null;
         Parcel data = Parcel.obtain(dataObj);
         Parcel reply = Parcel.obtain(replyObj);
         // theoretically, we should call transact, which will call onTransact,
         // but all that does is rewind it, and we just got these from an IPC,
         // so we'll just call it directly.
         boolean res;
         // Log any exceptions as warnings, don't silently suppress them.
         // If the call was FLAG_ONEWAY then these exceptions disappear into the ether.
         final boolean tracingEnabled = Binder.isTracingEnabled();
+        data.mPerformBinderRedirectionCheck = mPerformRedirectionCheck;
         try {
             final BinderCallHeavyHitterWatcher heavyHitterWatcher = sHeavyHitterWatcher;
             if (heavyHitterWatcher != null) {
                 // Notify the heavy hitter watcher, if it's enabled
                 heavyHitterWatcher.onTransaction(callingUid, getClass(), code);
             }
             if (tracingEnabled) {
                 final String transactionName = getTransactionName(code);
                 Trace.traceBegin(Trace.TRACE_TAG_ALWAYS, getClass().getName() + ":"
                         + (transactionName != null ? transactionName : code));
@@ -1208,20 +1218,21 @@ public class Binder implements IBinder {
                     Log.w(TAG, "Caught a RuntimeException from the binder stub implementation.", e);
                 }
             } else {
                 // Clear the parcel before writing the exception
                 reply.setDataSize(0);
                 reply.setDataPosition(0);
                 reply.writeException(e);
             }
             res = true;
         } finally {
+            data.mPerformBinderRedirectionCheck = false;
             if (tracingEnabled) {
                 Trace.traceEnd(Trace.TRACE_TAG_ALWAYS);
             }
             if (observer != null) {
                 // The parcel RPC headers have been called during onTransact so we can now access
                 // the worksource uid from the parcel.
                 final int workSourceUid = sWorkSourceProvider.resolveWorkSourceUid(
                         data.readCallingWorkSourceUid());
                 observer.callEnded(callSession, data.dataSize(), reply.dataSize(), workSourceUid);
             }
diff --git a/core/java/android/os/Parcel.java b/core/java/android/os/Parcel.java
index e06e7b6be90a95486ca8d0adcb806f7ca8ea2fda..6c05159a397b479eefeeb4a0fb1fd42b9beaa0e5 100644
--- a/core/java/android/os/Parcel.java
+++ b/core/java/android/os/Parcel.java
@@ -27,20 +27,21 @@ import android.util.ArraySet;
 import android.util.ExceptionUtils;
 import android.util.Log;
 import android.util.Size;
 import android.util.SizeF;
 import android.util.Slog;
 import android.util.SparseArray;
 import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.HybridBinder;
 import com.android.internal.util.ArrayUtils;
 
 import dalvik.annotation.optimization.CriticalNative;
 import dalvik.annotation.optimization.FastNative;
 
 import libcore.util.SneakyThrow;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.FileDescriptor;
@@ -2521,25 +2522,35 @@ public final class Parcel {
     /**
      * Read a CharSequence value from the parcel at the current dataPosition().
      * @hide
      */
     @UnsupportedAppUsage
     @Nullable
     public final CharSequence readCharSequence() {
         return TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(this);
     }
 
+    /** {@hide} */
+    public boolean mPerformBinderRedirectionCheck;
+
     /**
      * Read an object from the parcel at the current dataPosition().
      */
     public final IBinder readStrongBinder() {
-        return nativeReadStrongBinder(mNativePtr);
+        IBinder b = nativeReadStrongBinder(mNativePtr);
+        if (mPerformBinderRedirectionCheck && b != null) {
+            HybridBinder hb = HybridBinder.maybeCreate(b);
+            if (hb != null) {
+                return hb;
+            }
+        }
+        return b;
     }
 
     /**
      * Read a FileDescriptor from the parcel at the current dataPosition().
      */
     public final ParcelFileDescriptor readFileDescriptor() {
         FileDescriptor fd = nativeReadFileDescriptor(mNativePtr);
         return fd != null ? new ParcelFileDescriptor(fd) : null;
     }
 

commit 84afa667875771b7c52f3f1152b09aab0053acbe
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Sun 2022-02-13 18:20:25+0200

    grant Location permission to GmsCompatApp by default
---
 .../com/android/server/pm/permission/DefaultPermissionGrantPolicy.java  | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java b/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
index 77ae50533f42f8dc3c6d7955805d4687431c7549..1474856c93b2894d0fb1762be532d6926ef69298 100644
--- a/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
+++ b/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
@@ -59,20 +59,21 @@ import android.telephony.TelephonyManager;
 import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.Log;
 import android.util.Slog;
 import android.util.SparseArray;
 import android.util.TypedXmlPullParser;
 import android.util.Xml;
 
 import com.android.internal.R;
+import com.android.internal.gmscompat.GmsCompatApp;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.XmlUtils;
 import com.android.server.LocalServices;
 import com.android.server.ServiceThread;
 import com.android.server.pm.permission.LegacyPermissionManagerInternal.PackagesProvider;
 import com.android.server.pm.permission.LegacyPermissionManagerInternal.SyncAdapterPackagesProvider;
 
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
 
@@ -744,20 +745,21 @@ final class DefaultPermissionGrantPolicy {
         }
         if (locationExtraPackageNames != null) {
             // Also grant location and activity recognition permission to location extra packages.
             for (String packageName : locationExtraPackageNames) {
                 grantPermissionsToSystemPackage(pm, packageName, userId,
                         ALWAYS_LOCATION_PERMISSIONS, NEARBY_DEVICES_PERMISSIONS);
                 grantSystemFixedPermissionsToSystemPackage(pm, packageName, userId,
                         ACTIVITY_RECOGNITION_PERMISSIONS);
             }
         }
+        grantPermissionsToSystemPackage(pm, GmsCompatApp.PKG_NAME, userId, ALWAYS_LOCATION_PERMISSIONS);
 
         // Music
         Intent musicIntent = new Intent(Intent.ACTION_VIEW)
                 .addCategory(Intent.CATEGORY_DEFAULT)
                 .setDataAndType(Uri.fromFile(new File("foo.mp3")), AUDIO_MIME_TYPE);
         grantPermissionsToSystemPackage(pm,
                 getDefaultSystemHandlerActivityPackage(pm, musicIntent, userId), userId,
                 STORAGE_PERMISSIONS);
 
         // Home

commit a06b7ef93281c37bab81571b71a00445ad3ca72f
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Tue 2022-02-15 18:57:25+0200

    gmscompat: enable on-demand Dynamite modules
---
 core/java/android/app/ApplicationPackageManager.java | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index 71cfc431712c05aa568033093de6c47dca018526..37dad798432c9f1aeb0e6fdc716d1155e652f54e 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -116,20 +116,21 @@ import android.system.StructStat;
 import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.LauncherIcons;
 import android.util.Log;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.Immutable;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.gmscompat.GmsInfo;
 import com.android.internal.gmscompat.PlayStoreHooks;
 import com.android.internal.os.SomeArgs;
 import com.android.internal.util.UserIcons;
 
 import dalvik.system.VMRuntime;
 
 import libcore.util.EmptyArray;
 
 import java.io.File;
 import java.lang.ref.WeakReference;
@@ -452,20 +453,26 @@ public class ApplicationPackageManager extends PackageManager {
     @Override
     public ApplicationInfo getApplicationInfoAsUser(String packageName, int flags, int userId)
             throws NameNotFoundException {
         ApplicationInfo ai = getApplicationInfoAsUserCached(
                         packageName,
                         updateFlagsForApplication(flags, userId),
                         userId);
         if (ai == null) {
             throw new NameNotFoundException(packageName);
         }
+        if (GmsCompat.isPlayServices()) {
+            if (GmsInfo.PACKAGE_GMS.equals(packageName)) {
+                // checked when on-demand Dynamite modules are requested
+                ai.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
+            }
+        }
         return maybeAdjustApplicationInfo(ai);
     }
 
     private static ApplicationInfo maybeAdjustApplicationInfo(ApplicationInfo info) {
         // If we're dealing with a multi-arch application that has both
         // 32 and 64 bit shared libraries, we might need to choose the secondary
         // depending on what the current runtime's instruction set is.
         if (info.primaryCpuAbi != null && info.secondaryCpuAbi != null) {
             final String runtimeIsa = VMRuntime.getRuntime().vmInstructionSet();
 

commit 1d743adb369d22a0a2a09d7065bcaf2b857e5128
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Tue 2022-02-15 19:27:06+0200

    gmscompat: compatibility with updated Dynamite module loading sequence
    
    There's now additional File.lastModified() checks that happen outside
    the main module loading sequence.
---
 .../gmscompat/dynamite/GmsDynamiteHooks.java       | 26 +++++++++++++---------
 1 file changed, 15 insertions(+), 11 deletions(-)

diff --git a/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java b/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java
index 937613790d770f23006f50be35eee1d9f4e78397..5b83bb0d0b56eddef4bf06df51c23e4a8aefd0df 100644
--- a/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java
+++ b/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java
@@ -123,39 +123,43 @@ public final class GmsDynamiteHooks {
         // Undo path init and re-initialize with the ByteBuffers
         return buffers;
     }
 
     // To fix false-positive "Module APK has been modified" check
     // File#lastModified()
     private static Long getFileLastModified(File file) {
         if (!GmsCompat.isDynamiteClient()) {
             return null;
         }
+        DynamiteContext dynamiteCtx = getClientContext();
+        final String path = file.getAbsolutePath();
 
-        ModuleLoadState state = getClientContext().getState();
-        if (state == null || !state.modulePath.equals(file.getPath())) {
+        if (!path.startsWith(dynamiteCtx.gmsDataPrefix)) {
             return null;
         }
-
         long lastModified;
         try {
-            lastModified = getClientContext().getService().getLastModified(file.getPath());
+            lastModified = dynamiteCtx.getService().getLastModified(path);
         } catch (RemoteException e) {
             throw e.rethrowAsRuntimeException();
         }
-        Log.d(DynamiteContext.TAG, "File " + file.getPath() + " lastModified=" + lastModified);
-
-        // This is the final hook in the module loading process, so clear the state.
-        getClientContext().setState(null);
-
-        Log.d(DynamiteContext.TAG, "Finished loading module " + state.modulePath);
-        return lastModified;
+        Log.d(DynamiteContext.TAG, "File " + path + " lastModified=" + lastModified);
+
+        ModuleLoadState state = dynamiteCtx.getState();
+        if (state != null && state.modulePath.equals(path)) {
+            Log.d(DynamiteContext.TAG, "Finished loading module " + state.modulePath);
+            // This is the final hook in the module loading process, so clear the state.
+            dynamiteCtx.setState(null);
+        } else {
+            Log.d(DynamiteContext.TAG, "lastModified check outside the main module loading sequence");
+        }
+        return Long.valueOf(lastModified);
     }
 
     // To start the module loading process and map native library paths to fd from remote
     public static String mapRemoteLibraryPaths(String librarySearchPath) {
         if (!GmsCompat.isDynamiteClient() || librarySearchPath == null) {
             return librarySearchPath;
         }
 
         String[] searchPaths = librarySearchPath.split(Pattern.quote(File.pathSeparator));
 

commit fb3d33b4e579da3f23d4158bb7322a20574a6a3a
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Thu 2022-02-17 22:20:38+0200

    gmscompat: hide UWB system feature
---
 core/java/android/app/ApplicationPackageManager.java | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index 37dad798432c9f1aeb0e6fdc716d1155e652f54e..019857fd0b218219b0ebf9fbdd9573858f05a6fa 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -722,20 +722,26 @@ public class ApplicationPackageManager extends PackageManager {
                         return ActivityThread.currentActivityThread().getPackageManager().
                             hasSystemFeature(query.name, query.version);
                     } catch (RemoteException e) {
                         throw e.rethrowFromSystemServer();
                     }
                 }
             };
 
     @Override
     public boolean hasSystemFeature(String name, int version) {
+        if (GmsCompat.isEnabled()) {
+            if ("android.hardware.uwb".equals(name)) {
+                // otherwise, GMS tries to access privileged UwbManager and crashes
+                return false;
+            }
+        }
         return mHasSystemFeatureCache.query(new HasSystemFeatureQuery(name, version));
     }
 
     /** @hide */
     public void disableHasSystemFeatureCache() {
         mHasSystemFeatureCache.disableLocal();
     }
 
     /** @hide */
     public static void invalidateHasSystemFeatureCache() {

commit d5f29eaa93b1a2d93af74bcdb6a2cee77f3cdb2c
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Thu 2022-02-17 21:59:01-0800

    gmscompat: Minor code style fixes
    
    Change-Id: I88b5e87ab429c409bca4226f7566c56eb87af8ff
---
 core/java/com/android/internal/gmscompat/GmsHooks.java       | 6 ++++--
 core/java/com/android/internal/gmscompat/PlayStoreHooks.java | 4 ++--
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
index e53055385894371046e770fa41a814267c1c1e38..f52199d72596d82e11ca5415954ed1643ac94f2f 100644
--- a/core/java/com/android/internal/gmscompat/GmsHooks.java
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -61,37 +61,39 @@ public final class GmsHooks {
     private static volatile boolean notificationChannelsCreated;
 
     // Static only
     private GmsHooks() { }
 
     static Notification.Builder obtainNotificationBuilder(Context context, String channelId) {
         if (!notificationChannelsCreated) {
             createNotificationChannels(context);
             notificationChannelsCreated = true;
         }
+
         return new Notification.Builder(context, channelId);
     }
 
     private static void createNotificationChannels(Context context) {
         if (!GmsCompat.isPlayStore()) {
             return;
         }
+
         NotificationManager manager = context.getSystemService(NotificationManager.class);
         NotificationChannelGroup group = new NotificationChannelGroup(COMPAT_GROUP_ID,
                 context.getText(R.string.gmscompat_channel_group));
         manager.createNotificationChannelGroup(group);
 
         ArrayList<NotificationChannel> channels = new ArrayList<>(7);
         PlayStoreHooks.createNotificationChannel(context, channels);
 
-        for (int i = 0; i < channels.size(); ++i) {
-            channels.get(i).setGroup(COMPAT_GROUP_ID);
+        for (NotificationChannel channel : channels) {
+            channel.setGroup(COMPAT_GROUP_ID);
         }
 
         manager.createNotificationChannels(channels);
     }
 
     // GMS tries to clean up its own notification channels periodically.
     // Don't let it delete any of compat channels because that throws an exception and crashes GMS.
     // NotificationManager#deleteNotificationChannel(String)
     public static boolean skipDeleteNotificationChannel(String channelId) {
         if (!GmsCompat.isEnabled()) {
diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
index b854ac439b1e6c84aff516f56a8bd7e4883967d1..5e97ab39d8dd385c7befd6a72bd2b4e6e20e2cb0 100644
--- a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -87,21 +87,21 @@ public final class PlayStoreHooks {
             String intentAction = context.getPackageName()
                 + "." + PackageInstallerStatusForwarder.class.getName() + "."
                 + lastId.getAndIncrement();
             context.registerReceiver(sf, new IntentFilter(intentAction));
 
             return PendingIntent.getBroadcast(context, 0, new Intent(intentAction),
                     PendingIntent.FLAG_CANCEL_CURRENT |
                         PendingIntent.FLAG_MUTABLE);
         }
 
-        public void onReceive(Context br_context, Intent intent) {
+        public void onReceive(Context receiverContext, Intent intent) {
             String statusKey = PackageInstaller.EXTRA_STATUS;
             if (!intent.hasExtra(statusKey)) {
                 throw new IllegalStateException("no EXTRA_STATUS in intent " + intent);
             }
             int status = intent.getIntExtra(statusKey, 0);
 
             if (status == PackageInstaller.STATUS_PENDING_USER_ACTION) {
                 Intent confirmationIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
                 confirmationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
 
@@ -173,21 +173,21 @@ public final class PlayStoreHooks {
                 + lastId.getAndIncrement();
 
             context.registerReceiver(sf, new IntentFilter(intentAction));
 
             return PendingIntent.getBroadcast(context, 0, new Intent(intentAction),
                     PendingIntent.FLAG_CANCEL_CURRENT |
                         PendingIntent.FLAG_ONE_SHOT |
                         PendingIntent.FLAG_MUTABLE);
         }
 
-        public void onReceive(Context br_context, Intent intent) {
+        public void onReceive(Context receiverContext, Intent intent) {
             context.unregisterReceiver(this);
 
             // EXTRA_STATUS returns PackageInstaller constant,
             // EXTRA_LEGACY_STATUS returns PackageManager constant
             String statusKey = PackageInstaller.EXTRA_LEGACY_STATUS;
             if (!intent.hasExtra(statusKey)) {
                 throw new IllegalStateException("no EXTRA_LEGACY_STATUS in intent " + intent);
             }
 
             int status = intent.getIntExtra(statusKey, 0);

commit 44ac5ae11960a97bb797c6fa21d74dbaf7938872
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Sat 2022-02-19 23:56:40-0800

    gmscompat: Improve GMS package info exception handling
    
    Change-Id: Ibb74bd4de8233284d42341cb3a732cdc9107c9d7
---
 core/java/android/app/compat/gms/GmsCompat.java | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/core/java/android/app/compat/gms/GmsCompat.java b/core/java/android/app/compat/gms/GmsCompat.java
index 3096742de6f4214882af2d1ff1c93b289e7072a1..7ea1d1a22fe19332df99b9c27d4f43ac9eaa056f 100644
--- a/core/java/android/app/compat/gms/GmsCompat.java
+++ b/core/java/android/app/compat/gms/GmsCompat.java
@@ -23,20 +23,21 @@ import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageManager;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.Signature;
 import android.content.pm.SigningInfo;
 import android.os.Binder;
 import android.os.Process;
 import android.os.RemoteException;
 import android.os.UserHandle;
+import android.util.Log;
 
 import com.android.internal.gmscompat.GmsInfo;
 
 /**
  * This class provides helpers for Google Play compatibility. It allows the following apps
  * to work as regular, unprivileged user apps:
  *     - Google Play Services (Google Mobile Services, aka "GMS")
  *     - Google Services Framework
  *     - Google Play Store
  *     - All apps depending on Google Play Services
@@ -196,18 +197,19 @@ public final class GmsCompat {
             si.getApkContentsSigners(), si.getSigningCertificateHistory(),
             app.isPrivilegedApp(), pkg.sharedUserId);
     }
 
     private static boolean isGmsInstalled(Context ctx) {
         try {
             PackageInfo gmsPkg = ctx.getPackageManager()
                 .getPackageInfo(GmsInfo.PACKAGE_GMS, PackageManager.GET_SIGNING_CERTIFICATES);
             // Check signature to avoid breaking microG's implementation of Dynamite
             return isGmsApp(gmsPkg);
+        } catch (PackageManager.NameNotFoundException e) {
+            // Ignored: normal - GMS not installed
         } catch (Exception e) {
-            if (!(e instanceof PackageManager.NameNotFoundException)) {
-                e.printStackTrace();
-            }
-            return false;
+            Log.e(TAG, "Failed to get GMS package info", e);
         }
+
+        return false;
     }
 }

commit 396adeffba5fdbc52a40aaff0c3d0d16b48b949c
Author: flawedworld <flawedworld@flawed.world>
Date:   Fri 2022-02-25 01:02:26+0000

    Exclude Bluetooth app from Location indicators
---
 core/res/res/values/config.xml | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index c7d6c94045a40bdcc6b4c51bb0cdd2675e78b2f3..eb4aa283d41101a306f0a19bd7402ba428734abe 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -1745,21 +1745,23 @@
          mechanism can set it to false. -->
     <bool name="config_enableFusedLocationOverlay" translatable="false">true</bool>
     <!-- Package name providing fused location support. Used only when
          config_enableFusedLocationOverlay is false. -->
     <string name="config_fusedLocationProviderPackageName" translatable="false">com.android.location.fused</string>
 
     <!-- Default value for the ADAS GNSS Location Enabled setting if this setting has never been
          set before. -->
     <bool name="config_defaultAdasGnssLocationEnabled" translatable="false">false</bool>
 
-    <string-array name="config_locationExtraPackageNames" translatable="false"></string-array>
+    <string-array name="config_locationExtraPackageNames" translatable="false">
+     <item>com.android.bluetooth</item>
+    </string-array>
 
     <!-- The package name of the default network recommendation app.
          A network recommendation provider must:
              * Be granted the SCORE_NETWORKS permission.
              * Be granted the ACCESS_COARSE_LOCATION permission.
              * Include a Service for the android.net.scoring.RECOMMEND_NETWORKS action
                protected by the BIND_NETWORK_RECOMMENDATION_SERVICE permission.
 
          This must be set to a valid network recommendation app or empty.
      -->

commit ddd8db9425e05acadd232b7344d576d44e339a22
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Sat 2022-02-26 22:25:48+0200

    gmscompat: stop Play Store from trying to auto-update some apps
---
 core/java/android/content/pm/PackageInstaller.java | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/core/java/android/content/pm/PackageInstaller.java b/core/java/android/content/pm/PackageInstaller.java
index 6071d4e5a98c698b4e5c2a1053c12a4291d5890e..316a694a469f661f85ac5fa5ee1a9065828e293d 100644
--- a/core/java/android/content/pm/PackageInstaller.java
+++ b/core/java/android/content/pm/PackageInstaller.java
@@ -51,20 +51,21 @@ import android.os.Parcelable;
 import android.os.ParcelableException;
 import android.os.RemoteException;
 import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.system.ErrnoException;
 import android.system.Os;
 import android.text.TextUtils;
 import android.util.ArraySet;
 import android.util.ExceptionUtils;
 
+import com.android.internal.gmscompat.GmsInfo;
 import com.android.internal.gmscompat.PlayStoreHooks;
 import com.android.internal.util.IndentingPrintWriter;
 import com.android.internal.util.Preconditions;
 import com.android.internal.util.function.pooled.PooledLambda;
 
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.lang.annotation.Retention;
@@ -436,20 +437,31 @@ public class PackageInstaller {
      * @throws IOException if parameters were unsatisfiable, such as lack of
      *             disk space or unavailable media.
      * @throws SecurityException when installation services are unavailable,
      *             such as when called from a restricted user.
      * @throws IllegalArgumentException when {@link SessionParams} is invalid.
      * @return positive, non-zero unique ID that represents the created session.
      *         This ID remains consistent across device reboots until the
      *         session is finalized. IDs are not reused during a given boot.
      */
     public int createSession(@NonNull SessionParams params) throws IOException {
+        if (GmsCompat.isPlayStore()) {
+            switch (Objects.requireNonNull(params.appPackageName)) {
+                case "app.attestation.auditor":
+                case "org.grapheneos.pdfviewer":
+                case GmsInfo.PACKAGE_GSF:
+                case GmsInfo.PACKAGE_GMS:
+                case GmsInfo.PACKAGE_PLAY_STORE:
+                    throw new IllegalArgumentException("installation / updates of " + params.appPackageName + " are disallowed");
+            }
+        }
+
         try {
             return mInstaller.createSession(params, mInstallerPackageName, mAttributionTag,
                     mUserId);
         } catch (RuntimeException e) {
             ExceptionUtils.maybeUnwrapIOException(e);
             throw e;
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }

commit e8272a7575179606f946ab3089a6fbd071462e32
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Sat 2022-03-05 19:01:32+0200

    gmscompat: simplify AppIntegrityManager shim
---
 core/java/android/app/ContextImpl.java                      |  1 +
 core/java/android/app/SystemServiceRegistry.java            |  5 -----
 .../java/android/content/integrity/AppIntegrityManager.java | 13 -------------
 3 files changed, 1 insertion(+), 18 deletions(-)

diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 7dff88fa2fe2356905f410f20ef6daac102644ff..f8ba4f23b1fd64233d0c43e1c2c9d4e5cc99925f 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -2069,20 +2069,21 @@ class ContextImpl extends Context {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public Object getSystemService(String name) {
         if (GmsCompat.isEnabled()) {
             switch (name) {
                 case Context.CONTEXTHUB_SERVICE:
                 case Context.WIFI_SCANNING_SERVICE:
+                case Context.APP_INTEGRITY_SERVICE:
                     // these privileged services are null-checked by GMS
                     return null;
             }
         }
         if (vmIncorrectContextUseEnabled()) {
             // Check incorrect Context usage.
             if (WINDOW_SERVICE.equals(name) && !isUiContext()) {
                 final String errorMessage = "Tried to access visual service "
                         + SystemServiceRegistry.getSystemServiceClassName(name)
                         + " from a non-visual Context:" + getOuterContext();
diff --git a/core/java/android/app/SystemServiceRegistry.java b/core/java/android/app/SystemServiceRegistry.java
index 5cc2f5e63393aedf859049501475abcbb611141f..32ea41b2c75f553bb7546e290a3b386d8db93aae 100644
--- a/core/java/android/app/SystemServiceRegistry.java
+++ b/core/java/android/app/SystemServiceRegistry.java
@@ -19,21 +19,20 @@ package android.app;
 import android.accounts.AccountManager;
 import android.accounts.IAccountManager;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SystemApi;
 import android.app.ContextImpl.ServiceInitializationState;
 import android.app.admin.DevicePolicyManager;
 import android.app.admin.IDevicePolicyManager;
 import android.app.appsearch.AppSearchManagerFrameworkInitializer;
 import android.app.blob.BlobStoreManagerFrameworkInitializer;
-import android.app.compat.gms.GmsCompat;
 import android.app.contentsuggestions.ContentSuggestionsManager;
 import android.app.contentsuggestions.IContentSuggestionsManager;
 import android.app.job.JobSchedulerFrameworkInitializer;
 import android.app.people.PeopleManager;
 import android.app.prediction.AppPredictionManager;
 import android.app.role.RoleFrameworkInitializer;
 import android.app.search.SearchUiManager;
 import android.app.slice.SliceManager;
 import android.app.smartspace.SmartspaceManager;
 import android.app.time.TimeManager;
@@ -1398,24 +1397,20 @@ public final class SystemServiceRegistry {
                                 Context.FILE_INTEGRITY_SERVICE);
                         return new FileIntegrityManager(ctx.getOuterContext(),
                                 IFileIntegrityService.Stub.asInterface(b));
                     }});
         //CHECKSTYLE:ON IndentationCheck
         registerService(Context.APP_INTEGRITY_SERVICE, AppIntegrityManager.class,
                 new CachedServiceFetcher<AppIntegrityManager>() {
                     @Override
                     public AppIntegrityManager createService(ContextImpl ctx)
                             throws ServiceNotFoundException {
-                        if (GmsCompat.isEnabled()) {
-                            return new AppIntegrityManager(null);
-                        }
-
                         IBinder b = ServiceManager.getServiceOrThrow(Context.APP_INTEGRITY_SERVICE);
                         return new AppIntegrityManager(IAppIntegrityManager.Stub.asInterface(b));
                     }});
         registerService(Context.APP_HIBERNATION_SERVICE, AppHibernationManager.class,
                 new CachedServiceFetcher<AppHibernationManager>() {
                     @Override
                     public AppHibernationManager createService(ContextImpl ctx) {
                         IBinder b = ServiceManager.getService(Context.APP_HIBERNATION_SERVICE);
                         return b == null ? null : new AppHibernationManager(ctx);
                     }});
diff --git a/core/java/android/content/integrity/AppIntegrityManager.java b/core/java/android/content/integrity/AppIntegrityManager.java
index 52f3c2aaa6d57656a67c5191784d3b59cc58a036..1196064768e8d3ed7d15e4c84adac82652971021 100644
--- a/core/java/android/content/integrity/AppIntegrityManager.java
+++ b/core/java/android/content/integrity/AppIntegrityManager.java
@@ -13,21 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package android.content.integrity;
 
 import android.annotation.NonNull;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
-import android.app.compat.gms.GmsCompat;
 import android.content.Context;
 import android.content.IntentSender;
 import android.content.pm.ParceledListSlice;
 import android.os.RemoteException;
 
 import java.util.List;
 
 /**
  * Class for pushing rules used to check the integrity of app installs.
  *
@@ -68,55 +67,43 @@ public class AppIntegrityManager {
     /**
      * Update the rules to evaluate during install time.
      *
      * @param updateRequest request containing the data of the rule set update
      * @param statusReceiver Called when the state of the session changes. Intents sent to this
      *     receiver contain {@link #EXTRA_STATUS}. Refer to the individual status codes on how to
      *     handle them.
      */
     public void updateRuleSet(
             @NonNull RuleSet updateRequest, @NonNull IntentSender statusReceiver) {
-        if (GmsCompat.isEnabled()) {
-            return;
-        }
-
         try {
             mManager.updateRuleSet(
                     updateRequest.getVersion(),
                     new ParceledListSlice<>(updateRequest.getRules()),
                     statusReceiver);
         } catch (RemoteException e) {
             throw e.rethrowAsRuntimeException();
         }
     }
 
     /** Get the current version of the rule set. */
     @NonNull
     public String getCurrentRuleSetVersion() {
-        if (GmsCompat.isEnabled()) {
-            return "";
-        }
-
         try {
             return mManager.getCurrentRuleSetVersion();
         } catch (RemoteException e) {
             throw e.rethrowAsRuntimeException();
         }
     }
 
     /** Get the name of the package that provided the current rule set. */
     @NonNull
     public String getCurrentRuleSetProvider() {
-        if (GmsCompat.isEnabled()) {
-            return "";
-        }
-
         try {
             return mManager.getCurrentRuleSetProvider();
         } catch (RemoteException e) {
             throw e.rethrowAsRuntimeException();
         }
     }
 
     /**
      * Get current RuleSet on device.
      *

commit e049bc134be156b1f4dddbf9460eb6664110bccf
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Sat 2022-03-05 19:12:51+0200

    gmscompat: fix TOCTOU race
---
 .../android/internal/gmscompat/dynamite/client/DynamiteContext.java    | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/core/java/com/android/internal/gmscompat/dynamite/client/DynamiteContext.java b/core/java/com/android/internal/gmscompat/dynamite/client/DynamiteContext.java
index 4fd3e06f996ed2fcd2cf08c35a6f223adff8f289..ab0dd67e51eb66abb15307eb328e90ab439261ab 100644
--- a/core/java/com/android/internal/gmscompat/dynamite/client/DynamiteContext.java
+++ b/core/java/com/android/internal/gmscompat/dynamite/client/DynamiteContext.java
@@ -63,21 +63,22 @@ public final class DynamiteContext {
     }
 
     public ModuleLoadState getState() {
         return threadLocalState.get();
     }
     public void setState(ModuleLoadState state) {
         threadLocalState.set(state);
     }
 
     public IFileProxyService getService() {
-        return serviceBinder == null ? getNewBinder() : serviceBinder;
+        IFileProxyService cache = serviceBinder;
+        return cache == null ? getNewBinder() : cache;
     }
 
     private IFileProxyService getNewBinder() {
         // Request a fresh service unconditionally
         IFileProxyService binder = requestGmsService();
 
         // Register before saving to avoid race condition if GMS dies *now*
         try {
             binder.asBinder().linkToDeath(() -> {
                 Log.d(DynamiteContext.TAG, "File proxy service has died");

commit cac001328c2877a6fd034669e412640e34e3bd90
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Sat 2022-02-05 11:08:55+0200

    make DownloadManager.query() a no-op when INTERNET permission is revoked
---
 core/java/android/app/DownloadManager.java | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/core/java/android/app/DownloadManager.java b/core/java/android/app/DownloadManager.java
index cb4a16641953b206747363fab7d9a875f8c90876..85d502b40c4111e7f96aba2eddabad79975c9837 100644
--- a/core/java/android/app/DownloadManager.java
+++ b/core/java/android/app/DownloadManager.java
@@ -29,20 +29,21 @@ import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ClipDescription;
 import android.content.ContentProviderClient;
 import android.content.ContentResolver;
 import android.content.ContentUris;
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.database.Cursor;
 import android.database.CursorWrapper;
 import android.database.DatabaseUtils;
+import android.database.MatrixCursor;
 import android.net.ConnectivityManager;
 import android.net.NetworkPolicyManager;
 import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Environment;
 import android.os.FileUtils;
 import android.os.ParcelFileDescriptor;
 import android.os.RemoteException;
 import android.provider.BaseColumns;
@@ -1163,20 +1164,26 @@ public class DownloadManager {
      * @param query parameters specifying filters for this query
      * @return a Cursor over the result set of downloads, with columns consisting of all the
      * COLUMN_* constants.
      */
     public Cursor query(Query query) {
         return query(query, UNDERLYING_COLUMNS);
     }
 
     /** @hide */
     public Cursor query(Query query, String[] projection) {
+        // don't crash apps that expect INTERNET permission to be always granted
+        Context ctx = ActivityThread.currentApplication();
+        if (ctx != null && ctx.checkSelfPermission(Manifest.permission.INTERNET) != PackageManager.PERMISSION_GRANTED) {
+            // underlying provider is protected by the INTERNET permission
+            return new MatrixCursor(projection);
+        }
         Cursor underlyingCursor = query.runQuery(mResolver, projection, mBaseUri);
         if (underlyingCursor == null) {
             return null;
         }
         return new CursorTranslator(underlyingCursor, mBaseUri, mAccessFilename);
     }
 
     /**
      * Open a downloaded file for reading.  The download must have completed.
      * @param id the ID of the download

commit eb46ccdaaabd6fece362c151604a51edc01cd8d3
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Sat 2022-03-05 19:18:02+0200

    gmscompat: optimize file path check
    
    getAbsolutePath() performs needless checks
---
 .../java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java b/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java
index 5b83bb0d0b56eddef4bf06df51c23e4a8aefd0df..c1c4c12760842365ddc9bc7872813c40cbccf144 100644
--- a/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java
+++ b/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteHooks.java
@@ -123,22 +123,23 @@ public final class GmsDynamiteHooks {
         // Undo path init and re-initialize with the ByteBuffers
         return buffers;
     }
 
     // To fix false-positive "Module APK has been modified" check
     // File#lastModified()
     private static Long getFileLastModified(File file) {
         if (!GmsCompat.isDynamiteClient()) {
             return null;
         }
+
         DynamiteContext dynamiteCtx = getClientContext();
-        final String path = file.getAbsolutePath();
+        final String path = file.getPath();
 
         if (!path.startsWith(dynamiteCtx.gmsDataPrefix)) {
             return null;
         }
         long lastModified;
         try {
             lastModified = dynamiteCtx.getService().getLastModified(path);
         } catch (RemoteException e) {
             throw e.rethrowAsRuntimeException();
         }

commit 58d03ceda06a5ca061b5813de1050f675568a164
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Sat 2022-03-05 19:20:08+0200

    gmscompat: mark public ModuleLoadState fields final
---
 .../android/internal/gmscompat/dynamite/client/ModuleLoadState.java   | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/core/java/com/android/internal/gmscompat/dynamite/client/ModuleLoadState.java b/core/java/com/android/internal/gmscompat/dynamite/client/ModuleLoadState.java
index 29b39679b75d6fb524ee2e452c8eda05e5d5ca58..19a7c1279f4f6fd9aa7a95fbee63d3a648a65136 100644
--- a/core/java/com/android/internal/gmscompat/dynamite/client/ModuleLoadState.java
+++ b/core/java/com/android/internal/gmscompat/dynamite/client/ModuleLoadState.java
@@ -24,22 +24,22 @@ import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import java.util.ArrayList;
 import java.util.regex.Pattern;
 import java.util.zip.ZipEntry;
 
 /** @hide */
 public final class ModuleLoadState {
     private static final Pattern CLASSES_DEX_PATTERN = Pattern.compile("^classes\\d*\\.dex$");
 
-    public String modulePath;
-    public FileDescriptor moduleFd;
+    public final String modulePath;
+    public final FileDescriptor moduleFd;
 
     public ModuleLoadState(String modulePath, FileDescriptor moduleFd) {
         this.modulePath = modulePath;
         // Do NOT close the original fd. The Bionic linker could dup it for library loading
         // at any time. Unfortunately, this results in CloseGuard warnings, but it's more efficient
         // to just ignore them.
         this.moduleFd = moduleFd;
     }
 
     public ByteBuffer[] mapDexBuffers() throws IOException {

commit 9c5e8d1e041f7b4cfd4b0975228772b44a0fe511
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Sat 2022-02-05 11:49:40+0200

    gmscompat: account removal workaround
---
 core/java/android/app/ContextImpl.java               | 2 ++
 core/java/android/app/admin/DevicePolicyManager.java | 5 +++++
 2 files changed, 7 insertions(+)

diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index f8ba4f23b1fd64233d0c43e1c2c9d4e5cc99925f..154b4ce11966d8bdec9d4371f6748f09242a8ee6 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -2070,20 +2070,22 @@ class ContextImpl extends Context {
         }
     }
 
     @Override
     public Object getSystemService(String name) {
         if (GmsCompat.isEnabled()) {
             switch (name) {
                 case Context.CONTEXTHUB_SERVICE:
                 case Context.WIFI_SCANNING_SERVICE:
                 case Context.APP_INTEGRITY_SERVICE:
+                // used for factory reset protection
+                case Context.PERSISTENT_DATA_BLOCK_SERVICE:
                     // these privileged services are null-checked by GMS
                     return null;
             }
         }
         if (vmIncorrectContextUseEnabled()) {
             // Check incorrect Context usage.
             if (WINDOW_SERVICE.equals(name) && !isUiContext()) {
                 final String errorMessage = "Tried to access visual service "
                         + SystemServiceRegistry.getSystemServiceClassName(name)
                         + " from a non-visual Context:" + getOuterContext();
diff --git a/core/java/android/app/admin/DevicePolicyManager.java b/core/java/android/app/admin/DevicePolicyManager.java
index a7e32eef36c4dace32dfac83267a390ca0d11cf1..6d58fb96acdebd572cb086589df7b5939494cbee 100644
--- a/core/java/android/app/admin/DevicePolicyManager.java
+++ b/core/java/android/app/admin/DevicePolicyManager.java
@@ -5438,20 +5438,25 @@ public class DevicePolicyManager {
      *              {@code null} if called by the FRP management agent on device or with the
      *              permission {@link android.Manifest.permission#MASTER_CLEAR}.
      * @return The current FRP policy object or {@code null} if no policy is set.
      * @throws SecurityException if {@code admin} is not a device owner, a profile owner of
      *                           an organization-owned device or the FRP management agent.
      * @throws UnsupportedOperationException if factory reset protection is not
      *                           supported on the device.
      */
     public @Nullable FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(
             @Nullable ComponentName admin) {
+        if (GmsCompat.isEnabled()) {
+            // called during account removal to check whether it's allowed, requires privileged permissions
+            return null;
+        }
+
         throwIfParentInstance("getFactoryResetProtectionPolicy");
         if (mService != null) {
             try {
                 return mService.getFactoryResetProtectionPolicy(admin);
             } catch (RemoteException e) {
                 throw e.rethrowFromSystemServer();
             }
         }
         return null;
     }

commit 132b5885307fdd63e5ca6d60209415bc66cb792f
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Sat 2022-02-05 11:51:14+0200

    Revert "gmscompat: don't check whether Google account removal is allowed"
    
    Not needed anymore.
---
 .../java/com/android/server/accounts/AccountManagerService.java     | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java
index 5b20a29fe23cbb309b263aefbdb6f1b837c638ba..400b084ee96672c870e212fc3d7873f4b0b1922b 100644
--- a/services/core/java/com/android/server/accounts/AccountManagerService.java
+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java
@@ -2331,26 +2331,20 @@ public class AccountManagerService
         }
 
         @Override
         protected String toDebugString(long now) {
             return super.toDebugString(now) + ", removeAccount"
                     + ", account " + mAccount;
         }
 
         @Override
         public void run() throws RemoteException {
-            if ("com.google".equals(mAccount.type)) {
-                Bundle result = new Bundle();
-                result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, true);
-                onResult(result);
-                return;
-            }
             mAuthenticator.getAccountRemovalAllowed(this, mAccount);
         }
 
         @Override
         public void onResult(Bundle result) {
             Bundle.setDefusable(result, true);
             if (result != null && result.containsKey(AccountManager.KEY_BOOLEAN_RESULT)
                     && !result.containsKey(AccountManager.KEY_INTENT)) {
                 final boolean removalAllowed = result.getBoolean(AccountManager.KEY_BOOLEAN_RESULT);
                 if (removalAllowed) {

commit 62c0cf00cf0876fe80b3b1f23afef8fd880a4ccd
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Wed 2022-02-02 12:18:25+0200

    gmscompat: defer isGmsApp() check
---
 .../core/java/com/android/server/am/ActivityManagerService.java   | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index d0f340f2f89e97d9c97f4e729fbbbcc226e1623b..e8bf771b8ade341ee08429bf97ac082e075d3828 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -11961,31 +11961,31 @@ public class ActivityManagerService extends IActivityManager.Stub
 
     @Override
     public int handleIncomingUser(int callingPid, int callingUid, int userId, boolean allowAll,
             boolean requireFull, String name, String callerPackage) {
         return mUserController.handleIncomingUser(callingPid, callingUid, userId, allowAll,
                 requireFull ? ALLOW_FULL_ONLY : ALLOW_NON_FULL, name, callerPackage);
     }
 
     boolean isSingleton(String componentProcessName, ApplicationInfo aInfo,
             String className, int flags) {
-        if (GmsCompat.isGmsApp(aInfo)) {
-            return false;
-        }
-
         boolean result = false;
         // For apps that don't have pre-defined UIDs, check for permission
         if (UserHandle.getAppId(aInfo.uid) >= FIRST_APPLICATION_UID) {
             if ((flags & ServiceInfo.FLAG_SINGLE_USER) != 0) {
                 if (ActivityManager.checkUidPermission(
                         INTERACT_ACROSS_USERS,
                         aInfo.uid) != PackageManager.PERMISSION_GRANTED) {
+                    if (GmsCompat.isGmsApp(aInfo)) {
+                        return false;
+                    }
+
                     ComponentName comp = new ComponentName(aInfo.packageName, className);
                     String msg = "Permission Denial: Component " + comp.flattenToShortString()
                             + " requests FLAG_SINGLE_USER, but app does not hold "
                             + INTERACT_ACROSS_USERS;
                     Slog.w(TAG, msg);
                     throw new SecurityException(msg);
                 }
                 // Permission passed
                 result = true;
             }

commit f1d32557f485be59e282d7eea048647fda7d48a6
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Tue 2022-02-01 17:48:42+0200

    gmscompat: use correct "isApplicationUid" check
---
 core/java/android/os/Binder.java | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/core/java/android/os/Binder.java b/core/java/android/os/Binder.java
index a04f7a611facfb8a17b338a766e79ce980f8a099..967a6f7f0506ac9e0643a1839f3d88b94e9a6b9b 100644
--- a/core/java/android/os/Binder.java
+++ b/core/java/android/os/Binder.java
@@ -1145,26 +1145,29 @@ public class Binder implements IBinder {
     private volatile int mPreviousUid;
 
     // Entry point from android_util_Binder.cpp's onTransact
     @UnsupportedAppUsage
     private boolean execTransact(int code, long dataObj, long replyObj,
             int flags) {
         // At that point, the parcel request headers haven't been parsed so we do not know what
         // WorkSource the caller has set. Use calling uid as the default.
         final int callingUid = Binder.getCallingUid();
         if (GmsCompat.isEnabled()) {
-            if (callingUid >= Process.FIRST_APPLICATION_UID && callingUid != mPreviousUid) {
+            if (callingUid != mPreviousUid) {
                 // harmless race
                 mPreviousUid = callingUid;
-                GmsHooks.onBinderTransaction(Binder.getCallingPid(), callingUid);
+                if (Process.isApplicationUid(callingUid)) {
+                    GmsHooks.onBinderTransaction(Binder.getCallingPid(), callingUid);
+                }
             }
         }
+
         final long origWorkSource = ThreadLocalWorkSource.setUid(callingUid);
         try {
             return execTransactInternal(code, dataObj, replyObj, flags, callingUid);
         } finally {
             ThreadLocalWorkSource.restore(origWorkSource);
         }
     }
 
     private boolean execTransactInternal(int code, long dataObj, long replyObj, int flags,
             int callingUid) {

commit 1d8f6c9750cbd1ea6a39ba6bae83a3efcf8bd60f
Author: flawedworld <flawedworld@flawed.world>
Date:   Sat 2022-03-05 18:25:09+0000

    Always show ICCID
---
 telephony/java/android/telephony/CarrierConfigManager.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/telephony/java/android/telephony/CarrierConfigManager.java b/telephony/java/android/telephony/CarrierConfigManager.java
index 500eb7ae99dd3ac1620dff9ab3f352c3609f6ce5..d7a1b17a70628e1938e152c9cfaeae762c4950a7 100644
--- a/telephony/java/android/telephony/CarrierConfigManager.java
+++ b/telephony/java/android/telephony/CarrierConfigManager.java
@@ -5366,21 +5366,21 @@ public class CarrierConfigManager {
         sDefaults.putInt(KEY_VVM_PORT_NUMBER_INT, 0);
         sDefaults.putString(KEY_VVM_TYPE_STRING, "");
         sDefaults.putBoolean(KEY_VVM_CELLULAR_DATA_REQUIRED_BOOL, false);
         sDefaults.putString(KEY_VVM_CLIENT_PREFIX_STRING,"//VVM");
         sDefaults.putBoolean(KEY_VVM_SSL_ENABLED_BOOL,false);
         sDefaults.putStringArray(KEY_VVM_DISABLED_CAPABILITIES_STRING_ARRAY, null);
         sDefaults.putBoolean(KEY_VVM_LEGACY_MODE_ENABLED_BOOL,false);
         sDefaults.putBoolean(KEY_VVM_PREFETCH_BOOL, true);
         sDefaults.putString(KEY_CARRIER_VVM_PACKAGE_NAME_STRING, "");
         sDefaults.putStringArray(KEY_CARRIER_VVM_PACKAGE_NAME_STRING_ARRAY, null);
-        sDefaults.putBoolean(KEY_SHOW_ICCID_IN_SIM_STATUS_BOOL, false);
+        sDefaults.putBoolean(KEY_SHOW_ICCID_IN_SIM_STATUS_BOOL, true);
         sDefaults.putBoolean(KEY_SHOW_SIGNAL_STRENGTH_IN_SIM_STATUS_BOOL, true);
         sDefaults.putBoolean(KEY_INFLATE_SIGNAL_STRENGTH_BOOL, false);
         sDefaults.putBoolean(KEY_CI_ACTION_ON_SYS_UPDATE_BOOL, false);
         sDefaults.putString(KEY_CI_ACTION_ON_SYS_UPDATE_INTENT_STRING, "");
         sDefaults.putString(KEY_CI_ACTION_ON_SYS_UPDATE_EXTRA_STRING, "");
         sDefaults.putString(KEY_CI_ACTION_ON_SYS_UPDATE_EXTRA_VAL_STRING, "");
         sDefaults.putBoolean(KEY_CSP_ENABLED_BOOL, false);
         sDefaults.putBoolean(KEY_ALLOW_ADDING_APNS_BOOL, true);
         sDefaults.putStringArray(KEY_READ_ONLY_APN_TYPES_STRING_ARRAY, new String[] {""});
         sDefaults.putStringArray(KEY_READ_ONLY_APN_FIELDS_STRING_ARRAY, null);

commit 744e6c39c462db2a7c9471301b48d6524639558a
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Wed 2022-02-02 15:47:53+0200

    gmscompat: improve userId-related shims
    
    Current approach is fragile: GMS always obtains UserHandle of the primary ("Owner") user and
    tries to use it, which is a privileged operation if GMS is installed in the non-primary user profile.
    It's worked around by unconditionally replacing UserHandle with the current one in all methods that
    GMS calls, which will break each time new GMS version makes use of a new UserHandle-accepting method.
    
    With the new approach, GMS gets access only to the current UserHandle which is made
    to look like a UserHandle of the primary user.
---
 core/java/android/app/ActivityManager.java         |  7 +-
 core/java/android/app/ContextImpl.java             |  9 --
 core/java/android/os/UserHandle.java               | 10 +++
 core/java/android/os/UserManager.java              | 40 ++++-----
 .../com/android/internal/gmscompat/GmsHooks.java   | 21 -----
 .../internal/gmscompat/GmsUserHooks.java (new)     | 96 ++++++++++++++++++++++
 6 files changed, 124 insertions(+), 59 deletions(-)

diff --git a/core/java/android/app/ActivityManager.java b/core/java/android/app/ActivityManager.java
index a00e3eae01463e7bab90d30696bcb226ede89ab9..04ca851d614240fcf9ea562abf8484489807ee24 100644
--- a/core/java/android/app/ActivityManager.java
+++ b/core/java/android/app/ActivityManager.java
@@ -78,20 +78,21 @@ import android.util.ArrayMap;
 import android.util.DisplayMetrics;
 import android.util.Singleton;
 import android.util.Size;
 import android.util.TypedXmlPullParser;
 import android.util.TypedXmlSerializer;
 import android.window.TaskSnapshot;
 
 import com.android.internal.app.LocalePicker;
 import com.android.internal.app.procstats.ProcessStats;
 import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.gmscompat.GmsUserHooks;
 import com.android.internal.os.RoSystemProperties;
 import com.android.internal.os.TransferPipe;
 import com.android.internal.util.FastPrintWriter;
 import com.android.internal.util.MemInfoReader;
 import com.android.internal.util.Preconditions;
 import com.android.server.LocalServices;
 
 import java.io.FileDescriptor;
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -4037,21 +4038,21 @@ public class ActivityManager {
      * Gets the userId of the current foreground user. Requires system permissions.
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {
             "android.permission.INTERACT_ACROSS_USERS",
             "android.permission.INTERACT_ACROSS_USERS_FULL"
     })
     public static int getCurrentUser() {
         if (GmsCompat.isEnabled()) {
-            return GmsHooks.getCurrentUser();
+            return GmsUserHooks.getCurrentUser();
         }
 
         try {
             return getService().getCurrentUserId();
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /**
@@ -4285,23 +4286,23 @@ public class ActivityManager {
      * the user is in the "started" state, not "stopped" -- it is currently
      * allowed to run code through scheduled alarms, receiving broadcasts,
      * etc.  A started user may be either the current foreground user or a
      * background user; the result here does not distinguish between the two.
      * @param userId the user's id. Zero indicates the default user.
      * @hide
      */
     @UnsupportedAppUsage
     public boolean isUserRunning(int userId) {
         if (GmsCompat.isEnabled()) {
-            // GMS sees only the current user
-            return true;
+            return GmsUserHooks.isUserRunning(userId);
         }
+
         try {
             return getService().isUserRunning(userId, 0);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     /** {@hide} */
     public boolean isVrModePackageEnabled(ComponentName component) {
         try {
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 154b4ce11966d8bdec9d4371f6748f09242a8ee6..6ae0aba45f07511b5e263841360eb423ab3fc997 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -88,21 +88,20 @@ import android.util.AndroidRuntimeException;
 import android.util.ArrayMap;
 import android.util.Log;
 import android.util.Slog;
 import android.view.Display;
 import android.view.DisplayAdjustments;
 import android.view.autofill.AutofillManager.AutofillClient;
 import android.window.WindowContext;
 import android.window.WindowTokenClient;
 
 import com.android.internal.annotations.GuardedBy;
-import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.util.Preconditions;
 
 import dalvik.system.BlockGuard;
 
 import libcore.io.Memory;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
@@ -1387,22 +1386,20 @@ class ContextImpl extends Context {
                     mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType,
                     rd, initialCode, initialData, initialExtras, receiverPermissions,
                     null /*excludedPermissions=*/, appOp, options, true, false, getUserId());
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user) {
-        user = GmsHooks.getUserHandle(user);
-
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         try {
             intent.prepareToLeaveProcess(this);
             ActivityManager.getService().broadcastIntentWithFeature(
                     mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType,
                     null, Activity.RESULT_OK, null, null, null, null /*excludedPermissions=*/,
                     AppOpsManager.OP_NONE, null, false, false, user.getIdentifier());
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
@@ -1410,42 +1407,38 @@ class ContextImpl extends Context {
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user,
             String receiverPermission) {
         sendBroadcastAsUser(intent, user, receiverPermission, AppOpsManager.OP_NONE);
     }
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission,
             Bundle options) {
-        user = GmsHooks.getUserHandle(user);
-
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         String[] receiverPermissions = receiverPermission == null ? null
                 : new String[] {receiverPermission};
         try {
             intent.prepareToLeaveProcess(this);
             ActivityManager.getService().broadcastIntentWithFeature(
                     mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType,
                     null, Activity.RESULT_OK, null, null, receiverPermissions,
                     null /*excludedPermissions=*/, AppOpsManager.OP_NONE, options, false, false,
                     user.getIdentifier());
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user,
             String receiverPermission, int appOp) {
-        user = GmsHooks.getUserHandle(user);
-
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         String[] receiverPermissions = receiverPermission == null ? null
                 : new String[] {receiverPermission};
         try {
             intent.prepareToLeaveProcess(this);
             ActivityManager.getService().broadcastIntentWithFeature(
                     mMainThread.getApplicationThread(), getAttributionTag(), intent, resolvedType,
                     null, Activity.RESULT_OK, null, null, receiverPermissions,
                     null /*excludedPermissions=*/, appOp, null, false, false, user.getIdentifier());
         } catch (RemoteException e) {
@@ -1466,22 +1459,20 @@ class ContextImpl extends Context {
             String receiverPermission, int appOp, BroadcastReceiver resultReceiver,
             Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
         sendOrderedBroadcastAsUser(intent, user, receiverPermission, appOp,
                 null, resultReceiver, scheduler, initialCode, initialData, initialExtras);
     }
 
     @Override
     public void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
             String receiverPermission, int appOp, Bundle options, BroadcastReceiver resultReceiver,
             Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
-        user = GmsHooks.getUserHandle(user);
-
         IIntentReceiver rd = null;
         if (resultReceiver != null) {
             if (mPackageInfo != null) {
                 if (scheduler == null) {
                     scheduler = mMainThread.getHandler();
                 }
                 rd = mPackageInfo.getReceiverDispatcher(
                     resultReceiver, getOuterContext(), scheduler,
                     mMainThread.getInstrumentation(), false);
             } else {
diff --git a/core/java/android/os/UserHandle.java b/core/java/android/os/UserHandle.java
index 4a6216e9046a33780e3dcc915089ef3bd3377a7a..6c58c62582ef36fd010eefffebd635402f5d6c91 100644
--- a/core/java/android/os/UserHandle.java
+++ b/core/java/android/os/UserHandle.java
@@ -15,20 +15,21 @@
  */
 
 package android.os;
 
 import android.annotation.AppIdInt;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.annotation.UserIdInt;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Representation of a user on the device.
  */
 public final class UserHandle implements Parcelable {
@@ -506,29 +507,38 @@ public final class UserHandle implements Parcelable {
      * Returns true if this UserHandle refers to the owner user; false otherwise.
      * @return true if this UserHandle refers to the owner user; false otherwise.
      * @hide
      * @deprecated please use {@link #isSystem()} or check for
      * {@link android.content.pm.UserInfo#isPrimary()}
      * {@link android.content.pm.UserInfo#isAdmin()} based on your particular use case.
      */
     @Deprecated
     @SystemApi
     public boolean isOwner() {
+        if (GmsCompat.isEnabled()) {
+            return isSystem();
+        }
+
         return this.equals(OWNER);
     }
 
     /**
      * @return true if this UserHandle refers to the system user; false otherwise.
      * @hide
      */
     @SystemApi
     public boolean isSystem() {
+        if (GmsCompat.isEnabled()) {
+            // "system" user means "primary" ("Owner") user
+            return true;
+        }
+
         return this.equals(SYSTEM);
     }
 
     /** @hide */
     @UnsupportedAppUsage
     public UserHandle(@UserIdInt int userId) {
         mHandle = userId;
     }
 
     /**
diff --git a/core/java/android/os/UserManager.java b/core/java/android/os/UserManager.java
index b8179c8c3dc5b1161b00c981c3bfd2d6e0725df6..5c38d97ef45d8a244d770ad73087bec6eb6b93b0 100644
--- a/core/java/android/os/UserManager.java
+++ b/core/java/android/os/UserManager.java
@@ -52,21 +52,21 @@ import android.graphics.BitmapFactory;
 import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.location.LocationManager;
 import android.provider.Settings;
 import android.telephony.TelephonyManager;
 import android.util.AndroidException;
 import android.util.ArraySet;
 import android.view.WindowManager.LayoutParams;
 
 import com.android.internal.R;
-import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.gmscompat.GmsUserHooks;
 import com.android.internal.os.RoSystemProperties;
 import com.android.internal.util.FrameworkStatsLog;
 
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
@@ -2198,42 +2198,34 @@ public class UserManager {
 
     /**
      * Checks if a user is a guest user.
      * @return whether user is a guest user.
      * @hide
      */
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     @RequiresPermission(anyOf = {Manifest.permission.MANAGE_USERS,
             Manifest.permission.CREATE_USERS})
     public boolean isGuestUser(@UserIdInt int userId) {
-        if (GmsCompat.isEnabled()) {
-            return false;
-        }
-
         UserInfo user = getUserInfo(userId);
         return user != null && user.isGuest();
     }
 
     /**
      * Used to check if this process is running under a guest user. A guest user may be transient.
      *
      * @return whether this process is running under a guest user.
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {Manifest.permission.MANAGE_USERS,
             Manifest.permission.CREATE_USERS})
     public boolean isGuestUser() {
-        if (GmsCompat.isEnabled()) {
-            return false;
-        }
-
         UserInfo user = getUserInfo(UserHandle.myUserId());
         return user != null && user.isGuest();
     }
 
 
     /**
      * Checks if the calling app is running in a demo user. When running in a demo user,
      * apps can be more helpful to the user, or explain their features in more detail.
      *
      * @return whether the caller is a demo user.
@@ -2520,23 +2512,20 @@ public class UserManager {
                         throw re.rethrowFromSystemServer();
                     }
                 }
             };
 
     /** {@hide} */
     @UnsupportedAppUsage
     @RequiresPermission(anyOf = {Manifest.permission.MANAGE_USERS,
             Manifest.permission.INTERACT_ACROSS_USERS}, conditional = true)
     public boolean isUserUnlocked(@UserIdInt int userId) {
-        if (GmsCompat.isEnabled()) {
-            return mIsUserUnlockedCache.query(mUserId);
-        }
         return mIsUserUnlockedCache.query(userId);
     }
 
     /** {@hide} */
     public void disableIsUserUnlockedCache() {
         mIsUserUnlockedCache.disableLocal();
         mIsUserUnlockingOrUnlockedCache.disableLocal();
     }
 
     /** {@hide} */
@@ -2609,20 +2598,24 @@ public class UserManager {
     /**
      * Returns the UserInfo object describing a specific user.
      * @param userId the user handle of the user whose information is being requested.
      * @return the UserInfo object for a specific user.
      * @hide
      */
     @UnsupportedAppUsage
     @RequiresPermission(anyOf = {Manifest.permission.MANAGE_USERS,
             Manifest.permission.CREATE_USERS})
     public UserInfo getUserInfo(@UserIdInt int userId) {
+        if (GmsCompat.isEnabled()) {
+            return GmsUserHooks.getUserInfo(userId);
+        }
+
         try {
             return mService.getUserInfo(userId);
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
     }
 
     /**
      * @hide
      *
@@ -3424,24 +3417,20 @@ public class UserManager {
     }
 
     /**
      * Return the number of users currently created on the device.
      */
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.CREATE_USERS
     })
     public int getUserCount() {
-        if (GmsCompat.isEnabled()) {
-            return 1;
-        }
-
         List<UserInfo> users = getUsers();
         return users != null ? users.size() : 1;
     }
 
     /**
      * Returns information for all fully-created users on this device, including ones marked for
      * deletion.
      *
      * <p>To retrieve only users that are not marked for deletion, use {@link #getAliveUsers()}.
      *
@@ -3508,20 +3497,24 @@ public class UserManager {
      *
      * @hide
      */
     @TestApi
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.CREATE_USERS
     })
     public @NonNull List<UserInfo> getUsers(boolean excludePartial, boolean excludeDying,
             boolean excludePreCreated) {
+        if (GmsCompat.isEnabled()) {
+            return GmsUserHooks.getUsers();
+        }
+
         try {
             return mService.getUsers(excludePartial, excludeDying, excludePreCreated);
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
     }
 
     /**
      * Returns the user handles for all users on this device, based on the filtering parameters.
      *
@@ -3550,24 +3543,20 @@ public class UserManager {
      * @param excludeDying specify if the list should exclude users being removed.
      * @return the list of serial numbers of users that exist on the device.
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.CREATE_USERS
     })
     public long[] getSerialNumbersOfUsers(boolean excludeDying) {
-        if (GmsCompat.isEnabled()) {
-            return GmsHooks.getSerialNumbersOfUsers(this);
-        }
-
         List<UserInfo> users = getUsers(/* excludePartial= */ true, excludeDying,
                 /* excludePreCreated= */ true);
         long[] result = new long[users.size()];
         for (int i = 0; i < result.length; i++) {
             result[i] = users.get(i).serialNumber;
         }
         return result;
     }
 
     /**
@@ -3907,24 +3896,20 @@ public class UserManager {
      * @return the parent of the user or {@code null} if the user is not profile
      *
      * @hide
      */
     @SystemApi
     @RequiresPermission(anyOf = {
             android.Manifest.permission.MANAGE_USERS,
             android.Manifest.permission.INTERACT_ACROSS_USERS
     })
     public @Nullable UserHandle getProfileParent(@NonNull UserHandle user) {
-        if (GmsCompat.isEnabled()) {
-            return null;
-        }
-
         UserInfo info = getProfileParent(user.getIdentifier());
 
         if (info == null) {
             return null;
         }
 
         return UserHandle.of(info.id);
     }
 
     /**
@@ -4529,42 +4514,45 @@ public class UserManager {
     /**
      * Returns a serial number on this device for a given userId. User handles can be recycled
      * when deleting and creating users, but serial numbers are not reused until the device is wiped.
      * @param userId
      * @return a serial number associated with that user, or -1 if the userId is not valid.
      * @hide
      */
     @UnsupportedAppUsage
     public int getUserSerialNumber(@UserIdInt int userId) {
         if (GmsCompat.isEnabled()) {
-            // com.google.android.gms.persistent: java.lang.IllegalStateException - com.google.android.gms.gcm.GcmProxyIntentOperation.b
-            return 0;
+            return GmsUserHooks.getUserSerialNumber(userId);
         }
 
         try {
             return mService.getUserSerialNumber(userId);
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
     }
 
     /**
      * Returns a userId on this device for a given user serial number. User handles can be
      * recycled when deleting and creating users, but serial numbers are not reused until the device
      * is wiped.
      * @param userSerialNumber
      * @return the userId associated with that user serial number, or -1 if the serial number
      * is not valid.
      * @hide
      */
     @UnsupportedAppUsage
     public @UserIdInt int getUserHandle(int userSerialNumber) {
+        if (GmsCompat.isEnabled()) {
+            return GmsUserHooks.getUserHandle(userSerialNumber);
+        }
+
         try {
             return mService.getUserHandle(userSerialNumber);
         } catch (RemoteException re) {
             throw re.rethrowFromSystemServer();
         }
     }
 
     /**
      * Returns a {@link Bundle} containing any saved application restrictions for this user, for the
      * given package name. Only an application with this package name can call this method.
diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
index f52199d72596d82e11ca5415954ed1643ac94f2f..a0348b4c3c6eab4db83fba8ecdca7d317349bc1d 100644
--- a/core/java/com/android/internal/gmscompat/GmsHooks.java
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -25,22 +25,20 @@ import android.app.NotificationChannel;
 import android.app.NotificationChannelGroup;
 import android.app.NotificationManager;
 import android.app.compat.gms.GmsCompat;
 import android.content.ContentValues;
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Build;
 import android.os.Process;
 import android.os.SystemClock;
-import android.os.UserHandle;
-import android.os.UserManager;
 import android.provider.Settings;
 import android.util.Log;
 import android.util.SparseArray;
 import android.webkit.WebView;
 
 import com.android.internal.R;
 import com.android.internal.gmscompat.dynamite.GmsDynamiteHooks;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -99,32 +97,20 @@ public final class GmsHooks {
         if (!GmsCompat.isEnabled()) {
             return false;
         }
         return PlayStoreHooks.PUA_CHANNEL_ID.equals(channelId);
     }
 
     /**
      * API shims
      */
 
-    // Report a single user on the system
-    // UserManager#getSerialNumbersOfUsers(boolean)
-    public static long[] getSerialNumbersOfUsers(UserManager userManager) {
-        return new long[] { userManager.getSerialNumberForUser(Process.myUserHandle()) };
-    }
-
-    // Current user is always active
-    // ActivityManager#getCurrentUser()
-    public static int getCurrentUser() {
-        return Process.myUserHandle().getIdentifier();
-    }
-
     /**
      * Use the per-app SSAID as a random serial number for SafetyNet. This doesn't necessarily make
      * pass, but at least it retusn a valid "failed" response and stops spamming device key
      * requests.
      *
      * This isn't a privacy risk because all unprivileged apps already have access to random SSAIDs.
      */
     // Build#getSerial()
     @SuppressLint("HardwareIds")
     public static String getSerial() {
@@ -170,27 +156,20 @@ public final class GmsHooks {
             if (!Process.isIsolated()) {
                 GmsCompatApp.connect(app);
             } else {
                 Log.d(TAG, "initApplicationBeforeOnCreate: isolated process " + Application.getProcessName());
             }
         } else if (GmsCompat.isDynamiteClient()) {
             GmsDynamiteHooks.initClientApp();
         }
     }
 
-    // Redirect cross-user interactions to current user
-    // ContextImpl#sendOrderedBroadcastAsUser
-    // ContextImpl#sendBroadcastAsUser
-    public static UserHandle getUserHandle(UserHandle user) {
-        return GmsCompat.isEnabled() ? Process.myUserHandle() : user;
-    }
-
     static class RecentBinderPid implements Comparable<RecentBinderPid> {
         int pid;
         int uid;
         long lastSeen;
         volatile String[] packageNames; // lazily inited
 
         static final int MAX_MAP_SIZE = 50;
         static final int MAP_SIZE_TRIM_TO = 40;
         static final SparseArray<RecentBinderPid> map = new SparseArray(MAX_MAP_SIZE + 1);
 
diff --git a/core/java/com/android/internal/gmscompat/GmsUserHooks.java b/core/java/com/android/internal/gmscompat/GmsUserHooks.java
new file mode 100644
index 0000000000000000000000000000000000000000..db6569418c7b133bfe0af3628c57e6224b16a152
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmsUserHooks.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+import android.content.pm.UserInfo;
+import android.os.UserHandle;
+import android.os.UserManager;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * GMS tries to interact across user profiles, which requires privileged permissions.
+ * As a workaround, a pseudo-single-user environment is constructed by hiding non-current users
+ * and marking the current user as the primary ("Owner") user.
+ */
+public class GmsUserHooks {
+
+    private static int getUserId() {
+        return UserHandle.myUserId();
+    }
+
+    private static void checkUserId(int userId) {
+        if (userId != getUserId()) {
+            throw new IllegalStateException("unexpected userId " + userId);
+        }
+    }
+
+    private static int getUserSerialNumber() {
+        // GMS has several hardcoded (userSerialNumber == 0) checks
+        return 0;
+    }
+
+    private static UserInfo getUserInfo() {
+        // obtaining UserInfo is a privileged operation (even for the current user)
+        UserInfo ui = new UserInfo();
+        ui.id = getUserId();
+        ui.serialNumber = getUserSerialNumber();
+        // "system" means "primary" ("Owner") user
+        ui.userType = UserManager.USER_TYPE_FULL_SYSTEM;
+        ui.flags = UserInfo.FLAG_SYSTEM | UserInfo.FLAG_FULL;
+        return ui;
+    }
+
+    // ActivityManager#getCurrentUser()
+    public static int getCurrentUser() {
+        return getUserId();
+    }
+
+    // ActivityManager#isUserRunning(int)
+    public static boolean isUserRunning(int userId) {
+        checkUserId(userId);
+        return true;
+    }
+
+    // UserManager#getUserInfo(int)
+    public static UserInfo getUserInfo(int userId) {
+        checkUserId(userId);
+        return getUserInfo();
+    }
+
+    // UserManager#getUserHandle(int)
+    public static int getUserHandle(int userSerialNumber) {
+        if (userSerialNumber != getUserSerialNumber()) {
+            throw new IllegalStateException("unexpected userSerialNumber " + userSerialNumber);
+        }
+        return getUserId();
+    }
+
+    // UserManager#getUsers(boolean, boolean, boolean)
+    public static List<UserInfo> getUsers() {
+        return Collections.singletonList(getUserInfo());
+    }
+
+    // UserManager#getUserSerialNumber(int)
+    public static int getUserSerialNumber(int userId) {
+        checkUserId(userId);
+        return getUserSerialNumber();
+    }
+
+    private GmsUserHooks() {}
+}

commit faa60a602751b281db0473106d9de2b008ffbc4e
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Sun 2021-11-28 16:29:21-0800

    SystemUI: Import Pixel display interfaces
    
    We'll need the Pixel display interfaces to implement HBM control for
    UDFPS, but they're in the hardware/google/interfaces namespace that we
    can't import here. Add a copy of the display interfaces (as of
    android-12.0.0_r13) until we have a better solution.
    
    NB: setCompensationImageHandle(NativeHandle, String) has been removed
    because NativeHandle is a HIDL type that isn't available in a pure-AIDL
    context.
    
    Change-Id: Iee6c3eea483aa956d486fd413cbd8417c409a3ca
---
 .../hardware/pixel/display/HbmState.aidl (new)     | 25 ++++++
 .../hardware/pixel/display/IDisplay.aidl (new)     | 96 ++++++++++++++++++++++
 .../hardware/pixel/display/LbeState.aidl (new)     | 26 ++++++
 3 files changed, 147 insertions(+)

diff --git a/packages/SystemUI/src/com/google/hardware/pixel/display/HbmState.aidl b/packages/SystemUI/src/com/google/hardware/pixel/display/HbmState.aidl
new file mode 100644
index 0000000000000000000000000000000000000000..39270a2878c1fc8a2063c397183457ec67e28ae3
--- /dev/null
+++ b/packages/SystemUI/src/com/google/hardware/pixel/display/HbmState.aidl
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.hardware.pixel.display;
+
+@VintfStability
+@Backing(type="byte")
+enum HbmState {
+    OFF = 0,
+    HDR = 1,
+    SUNLIGHT = 2,
+}
diff --git a/packages/SystemUI/src/com/google/hardware/pixel/display/IDisplay.aidl b/packages/SystemUI/src/com/google/hardware/pixel/display/IDisplay.aidl
new file mode 100644
index 0000000000000000000000000000000000000000..5787cd5c26ca5fccc7226ed9683ea4eed2f68ef5
--- /dev/null
+++ b/packages/SystemUI/src/com/google/hardware/pixel/display/IDisplay.aidl
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.hardware.pixel.display;
+
+import com.google.hardware.pixel.display.HbmState;
+import com.google.hardware.pixel.display.LbeState;
+
+interface IDisplay {
+    /**
+     * Query Display High Brightness Mode Supported
+     *
+     * @return true if HBM is supported on this platform.
+     *         If false, HBM is not supported.
+     */
+    boolean isHbmSupported();
+
+    /**
+     * Set Display High Brightness Mode
+     *
+     * @param state to be queried.
+     */
+    void setHbmState(in HbmState state);
+
+    /**
+     * Get Display High Brightness Mode State
+     *
+     * @return state of display high brightness mode
+     */
+    HbmState getHbmState();
+
+    /**
+     * Query Display Local Brightness Enhancement Supported
+     *
+     * @return true if LBE is supported on this platform.
+     *         If false, LBE is not supported.
+     */
+    boolean isLbeSupported();
+
+    /**
+     * Set Display Local Brightness Enhancement
+     *
+     * @param state to be queried.
+     */
+    void setLbeState(in LbeState state);
+
+    /**
+     * Set Display Local Brightness Enhancement Ambient Light
+     *
+     * @param ambientLux the proper ambient light in Lux.
+     *        The value is equal to zero or above zero.
+     */
+    void setLbeAmbientLight(in int ambientLux);
+
+    /**
+     * Get Display Local Brightness Enhancement State
+     *
+     * @return state of display local brightness enhancement
+     */
+    LbeState getLbeState();
+
+    /**
+     * Query Display Local High Brightness Mode Supported
+     *
+     * @return true if LHBM is supported on this platform.
+     *         If false, LHBM is not supported.
+     */
+    boolean isLhbmSupported();
+
+    /**
+     * Set Display Local High Brightness Mode
+     *
+     * @param enabled true if LHBM should be enabled, false otherwise.
+     */
+    void setLhbmState(in boolean enabled);
+
+    /**
+     * Get Display Local High Brightness Mode State
+     *
+     * @return true if LHBM is ON, false otherwise.
+     */
+    boolean getLhbmState();
+}
diff --git a/packages/SystemUI/src/com/google/hardware/pixel/display/LbeState.aidl b/packages/SystemUI/src/com/google/hardware/pixel/display/LbeState.aidl
new file mode 100644
index 0000000000000000000000000000000000000000..810dcc7c5f14fdec394daf3fb11ec0d3e56cceee
--- /dev/null
+++ b/packages/SystemUI/src/com/google/hardware/pixel/display/LbeState.aidl
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.hardware.pixel.display;
+
+@VintfStability
+@Backing(type="byte")
+enum LbeState {
+    OFF = 0,
+    NORMAL = 1,
+    HIGH_BRIGHTNESS = 2,
+    POWER_SAVE = 3,
+}

commit 6b6baff149a1340335d8309d284c9808953b5d26
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Sun 2021-11-28 16:41:10-0800

    SystemUI: Add HBM provider for UDFPS on Pixel devices
    
    This implements high brightness mode (HBM) control for the under-display
    fingerprint sensor on Pixel devices. It enables and disables local HBM
    through the Pixel display HAL, similar to Google's implementation in the
    stock OS.
    
    Blocking IPC calls to the display HAL are done on a background thread to
    avoid causing frame drops by blocking the main thread, but callbacks are
    always run on the main thread as specified by the UdfpsHbmProvider docs.
    Care is taken to avoid enabling LHBM when it's already enabled and vice
    versa, as doing so causes the display HAL's request to time out and
    throw an exception.
    
    For simplicity, global HBM is not supported as it has never been used in
    production on Pixel devices.
    
    Change-Id: I8d301c7e1ce54ee8ffd987708b6f0e2bf115f7ef
---
 .../systemui/PixelUdfpsHbmProvider.kt (new)        | 146 +++++++++++++++++++++
 1 file changed, 146 insertions(+)

diff --git a/packages/SystemUI/src/org/protonaosp/systemui/PixelUdfpsHbmProvider.kt b/packages/SystemUI/src/org/protonaosp/systemui/PixelUdfpsHbmProvider.kt
new file mode 100644
index 0000000000000000000000000000000000000000..76f410c500218e8ac7e2c6eb3551467a097796d8
--- /dev/null
+++ b/packages/SystemUI/src/org/protonaosp/systemui/PixelUdfpsHbmProvider.kt
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2021 The ProtonAOSP Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.protonaosp.systemui
+
+import android.hardware.display.DisplayManager
+import android.os.Handler
+import android.os.IBinder
+import android.os.ServiceManager
+import android.view.Surface
+import com.android.systemui.biometrics.AuthController
+import com.android.systemui.biometrics.UdfpsHbmProvider
+import com.android.systemui.biometrics.UdfpsHbmTypes
+import com.android.systemui.dagger.SysUISingleton
+import com.android.systemui.dagger.qualifiers.DisplayId
+import com.android.systemui.dagger.qualifiers.Main
+import com.android.systemui.dagger.qualifiers.UiBackground
+import com.google.hardware.pixel.display.IDisplay
+import java.util.concurrent.Executor
+import javax.inject.Inject
+
+@SysUISingleton
+class PixelUdfpsHbmProvider @Inject constructor(
+    @Main private val handler: Handler,
+    @UiBackground private val bgExecutor: Executor,
+    @DisplayId private val displayId: Int,
+    private val authController: AuthController,
+    private val displayManager: DisplayManager,
+) : UdfpsHbmProvider, IBinder.DeathRecipient, DisplayManager.DisplayListener {
+    private var displayHal = ServiceManager.waitForDeclaredService(PIXEL_DISPLAY_HAL).let { binder ->
+        binder.linkToDeath(this, 0)
+        IDisplay.Stub.asInterface(binder)
+    }
+
+    private val peakRefreshRate = displayManager.getDisplay(displayId).supportedModes
+        .maxOf { it.refreshRate }
+    private val currentRefreshRate: Float
+        get() = displayManager.getDisplay(displayId).refreshRate
+
+    // Used by both main and UI background threads
+    @Volatile private var pendingEnable = false
+    @Volatile private var pendingEnableCallback: Runnable? = null
+
+    init {
+        // Listen for refresh rate changes
+        displayManager.registerDisplayListener(this, handler)
+    }
+
+    override fun enableHbm(hbmType: Int, surface: Surface?, onHbmEnabled: Runnable?) {
+        if (hbmType != HBM_TYPE) {
+            return
+        }
+
+        // Run the callback and skip enabling if already enabled
+        // (otherwise it may fail, similar to disabling)
+        if (displayHal.getLhbmState()) {
+            onHbmEnabled?.run()
+            return
+        }
+
+        // Takes 20-30 ms, so switch to background
+        bgExecutor.execute {
+            // Request HbmSVManager to lock the refresh rate. On the Pixel 6 Pro (raven), LHBM only
+            // works at peak refresh rate.
+            authController.udfpsHbmListener?.onHbmEnabled(hbmType, displayId)
+
+            if (currentRefreshRate == peakRefreshRate) {
+                // Enable immediately if refresh rate is correct
+                doPendingEnable(onHbmEnabled)
+            } else {
+                // Otherwise, queue it and wait for the refresh rate update callback
+                pendingEnable = true
+                pendingEnableCallback = onHbmEnabled
+            }
+        }
+    }
+
+    private fun doPendingEnable(callback: Runnable? = null) {
+        displayHal?.setLhbmState(true)
+        // Make sure callback runs on main thread
+        (callback ?: pendingEnableCallback)?.let { handler.post(it) }
+
+        pendingEnable = false
+        pendingEnableCallback = null // to avoid leaking memory
+    }
+
+    override fun disableHbm(onHbmDisabled: Runnable?) {
+        // If there's a pending enable, clear it and skip the disable request entirely.
+        // Otherwise, HBM will be disabled before the enable - while it's already disabled, which
+        // causes the display HAL call to throw an exception.
+        if (pendingEnable) {
+            pendingEnable = false
+            pendingEnableCallback = null
+            return
+        }
+
+        // Also bail out if HBM is already disabled *and* no enable is pending.
+        // This can happen sometimes if the user spams taps on the UDFPS icon.
+        if (!displayHal.getLhbmState()) {
+            return
+        }
+
+        // Takes 10-20 ms, so switch to background
+        bgExecutor.execute {
+            displayHal?.setLhbmState(false)
+            // Unlock refresh rate
+            handler.post { authController.udfpsHbmListener?.onHbmDisabled(HBM_TYPE, displayId) }
+
+            onHbmDisabled?.let { handler.post(it) }
+        }
+    }
+
+    override fun onDisplayAdded(displayId: Int) = Unit
+    override fun onDisplayRemoved(displayId: Int) = Unit
+    override fun onDisplayChanged(displayId: Int) {
+        // Dispatch pending enable if we were waiting for the refresh rate to change
+        if (pendingEnable && displayId == this.displayId && currentRefreshRate == peakRefreshRate) {
+            doPendingEnable()
+        }
+    }
+
+    override fun binderDied() {
+        displayHal = null
+    }
+
+    companion object {
+        // Descriptor for Pixel display HAL's AIDL service
+        private const val PIXEL_DISPLAY_HAL = "com.google.hardware.pixel.display.IDisplay/default"
+
+        // For simplicity, we only support local HBM as that's the only mode used in production
+        private const val HBM_TYPE = UdfpsHbmTypes.LOCAL_HBM
+    }
+}

commit 79a4a37ee7b84b7f364ce2e78b833ed6bc642200
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Sun 2021-11-28 16:49:04-0800

    SystemUI: Use Pixel UDFPS HBM provider
    
    This provides an implementation of the optional UdfpsHbmProvider
    interface on Pixel devices.
    
    Change-Id: I774179781ac2a432907b2f90205ef510e88dccea
---
 .../SystemUI/src/com/android/systemui/dagger/SystemUIModule.java    | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/packages/SystemUI/src/com/android/systemui/dagger/SystemUIModule.java b/packages/SystemUI/src/com/android/systemui/dagger/SystemUIModule.java
index 12786f278a1642423c9fc8fe1df770885abd3597..d188370fd7afa9269a4b77a732d2f38cfb2b49b7 100644
--- a/packages/SystemUI/src/com/android/systemui/dagger/SystemUIModule.java
+++ b/packages/SystemUI/src/com/android/systemui/dagger/SystemUIModule.java
@@ -78,20 +78,22 @@ import com.android.systemui.user.UserModule;
 import com.android.systemui.util.concurrency.SysUIConcurrencyModule;
 import com.android.systemui.util.dagger.UtilModule;
 import com.android.systemui.util.sensors.SensorModule;
 import com.android.systemui.util.settings.SettingsUtilModule;
 import com.android.systemui.util.time.SystemClock;
 import com.android.systemui.util.time.SystemClockImpl;
 import com.android.systemui.wallet.dagger.WalletModule;
 import com.android.systemui.wmshell.BubblesManager;
 import com.android.wm.shell.bubbles.Bubbles;
 
+import org.protonaosp.systemui.PixelUdfpsHbmProvider;
+
 import java.util.Optional;
 import java.util.concurrent.Executor;
 
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.Module;
 import dagger.Provides;
 
 /**
  * A dagger module for injecting components of System UI that are not overridden by the System UI
@@ -171,20 +173,24 @@ public abstract class SystemUIModule {
 
     @BindsOptionalOf
     abstract Recents optionalRecents();
 
     @BindsOptionalOf
     abstract StatusBar optionalStatusBar();
 
     @BindsOptionalOf
     abstract UdfpsHbmProvider optionalUdfpsHbmProvider();
 
+    @SysUISingleton
+    @Binds
+    abstract UdfpsHbmProvider bindUdfpsHbmProvider(PixelUdfpsHbmProvider provider);
+
     @SysUISingleton
     @Binds
     abstract SystemClock bindSystemClock(SystemClockImpl systemClock);
 
     @Provides
     static SystemUIFactory getSystemUIFactory() {
         return SystemUIFactory.getInstance();
     }
 
     @SysUISingleton

commit 72a86b15def9299c23d03a41082304feb7d31344
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Sun 2022-03-06 22:30:38+0200

    gmscompat: document PhenotypeFlag provider workaround
---
 core/java/android/app/ApplicationPackageManager.java | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index 019857fd0b218219b0ebf9fbdd9573858f05a6fa..14f8c7a25380d4955b275fba7791b46e65362d3d 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -453,26 +453,29 @@ public class ApplicationPackageManager extends PackageManager {
     @Override
     public ApplicationInfo getApplicationInfoAsUser(String packageName, int flags, int userId)
             throws NameNotFoundException {
         ApplicationInfo ai = getApplicationInfoAsUserCached(
                         packageName,
                         updateFlagsForApplication(flags, userId),
                         userId);
         if (ai == null) {
             throw new NameNotFoundException(packageName);
         }
+
         if (GmsCompat.isPlayServices()) {
             if (GmsInfo.PACKAGE_GMS.equals(packageName)) {
-                // checked when on-demand Dynamite modules are requested
+                // checked before accessing com.google.android.gms.phenotype content provider
+                // PhenotypeFlags will always return their default values if these flags aren't set
                 ai.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
             }
         }
+
         return maybeAdjustApplicationInfo(ai);
     }
 
     private static ApplicationInfo maybeAdjustApplicationInfo(ApplicationInfo info) {
         // If we're dealing with a multi-arch application that has both
         // 32 and 64 bit shared libraries, we might need to choose the secondary
         // depending on what the current runtime's instruction set is.
         if (info.primaryCpuAbi != null && info.secondaryCpuAbi != null) {
             final String runtimeIsa = VMRuntime.getRuntime().vmInstructionSet();
 

commit a6fa12a363e4c21103ffcf194ddf87889afe38dc
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Sun 2022-03-06 22:38:07+0200

    gmscompat: fix location service regression
---
 core/java/android/content/ContentResolver.java | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/core/java/android/content/ContentResolver.java b/core/java/android/content/ContentResolver.java
index 65e8f48a3c6eb8d748e3d693df38c2fd3aceef7a..75837cc1515c12fa704f944ce351f59817f50e63 100644
--- a/core/java/android/content/ContentResolver.java
+++ b/core/java/android/content/ContentResolver.java
@@ -34,20 +34,21 @@ import android.app.UriGrantsManager;
 import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.res.AssetFileDescriptor;
 import android.content.res.Resources;
 import android.database.ContentObserver;
 import android.database.CrossProcessCursorWrapper;
 import android.database.Cursor;
 import android.database.IContentObserver;
+import android.database.MatrixCursor;
 import android.graphics.Bitmap;
 import android.graphics.ImageDecoder;
 import android.graphics.ImageDecoder.ImageInfo;
 import android.graphics.ImageDecoder.Source;
 import android.graphics.Matrix;
 import android.graphics.Point;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.Icon;
 import android.net.Uri;
 import android.os.Build;
@@ -1187,20 +1188,28 @@ public abstract class ContentResolver implements ContentInterface {
      *         <code>null</code> if the underlying content provider returns <code>null</code>,
      *         or if it crashes.
      * @see Cursor
      */
     @Override
     public final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri,
             @Nullable String[] projection, @Nullable Bundle queryArgs,
             @Nullable CancellationSignal cancellationSignal) {
         Objects.requireNonNull(uri, "uri");
 
+        if (GmsCompat.isEnabled()) {
+            if ("content://com.google.android.gms.phenotype/com.google.android.location".equals(uri.toString())) {
+                // keep PhenotypeFlags of the location service at their default values
+                // (updated flags degrade its speed and accuracy for unknown reasons)
+                return new MatrixCursor(projection);
+            }
+        }
+
         try {
             if (mWrapped != null) {
                 return mWrapped.query(uri, projection, queryArgs, cancellationSignal);
             }
         } catch (RemoteException e) {
             return null;
         }
 
         IContentProvider unstableProvider = acquireUnstableProvider(uri);
         if (unstableProvider == null) {

commit 40c2c324181bbd0ac60bc31385a5a46cf8d04047
Author: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date:   Mon 2022-03-07 16:22:16+0200

    gmscompat: hide privileged FontManager service
---
 core/java/android/app/ContextImpl.java | 1 +
 1 file changed, 1 insertion(+)

diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 6ae0aba45f07511b5e263841360eb423ab3fc997..5543f6d3edaac3cb5cb6c1c0d7a73ad4eaeb3534 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -2063,20 +2063,21 @@ class ContextImpl extends Context {
 
     @Override
     public Object getSystemService(String name) {
         if (GmsCompat.isEnabled()) {
             switch (name) {
                 case Context.CONTEXTHUB_SERVICE:
                 case Context.WIFI_SCANNING_SERVICE:
                 case Context.APP_INTEGRITY_SERVICE:
                 // used for factory reset protection
                 case Context.PERSISTENT_DATA_BLOCK_SERVICE:
+                case Context.FONT_SERVICE:
                     // these privileged services are null-checked by GMS
                     return null;
             }
         }
         if (vmIncorrectContextUseEnabled()) {
             // Check incorrect Context usage.
             if (WINDOW_SERVICE.equals(name) && !isUiContext()) {
                 final String errorMessage = "Tried to access visual service "
                         + SystemServiceRegistry.getSystemServiceClassName(name)
                         + " from a non-visual Context:" + getOuterContext();

commit 7b05f30c64b09d07896377b2a7f7440a3804f31d
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Mon 2022-03-07 21:46:29+0000

    use black wallpaper by default
---
 core/res/res/drawable-nodpi/default_wallpaper.png   | Bin 738385 -> 235 bytes
 .../drawable-sw600dp-nodpi/default_wallpaper.png    | Bin 2774036 -> 625 bytes
 .../drawable-sw720dp-nodpi/default_wallpaper.png    | Bin 4958722 -> 974 bytes
 3 files changed, 0 insertions(+), 0 deletions(-)

diff --git a/core/res/res/drawable-nodpi/default_wallpaper.png b/core/res/res/drawable-nodpi/default_wallpaper.png
index 5152972d2a80a4a832f5d292bdb398f17c77821e..d60ef83a86e37501e9aecdff42c6cd3609e54355 100644
Binary files a/core/res/res/drawable-nodpi/default_wallpaper.png and b/core/res/res/drawable-nodpi/default_wallpaper.png differ
diff --git a/core/res/res/drawable-sw600dp-nodpi/default_wallpaper.png b/core/res/res/drawable-sw600dp-nodpi/default_wallpaper.png
index 26376fb87cbefcbce469e1b984cff0341723e09a..7b7e940d10638a06fed603050803533e160d3bc2 100644
Binary files a/core/res/res/drawable-sw600dp-nodpi/default_wallpaper.png and b/core/res/res/drawable-sw600dp-nodpi/default_wallpaper.png differ
diff --git a/core/res/res/drawable-sw720dp-nodpi/default_wallpaper.png b/core/res/res/drawable-sw720dp-nodpi/default_wallpaper.png
index 490ebeeb75c1a4a9bf941f5c497a064fe5bfb63a..68e63312cfa8371060748249e09fe19ee3da9d7a 100644
Binary files a/core/res/res/drawable-sw720dp-nodpi/default_wallpaper.png and b/core/res/res/drawable-sw720dp-nodpi/default_wallpaper.png differ

commit a6560e1a46a3dd7bebce86a0f9bafa18035fcdc2
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Tue 2021-10-05 21:01:09-0700

    SystemUI: Require unlocking to use sensitive QS tiles
    
    - Airplane mode
    - Battery saver
    - Bluetooth
    - Cellular
    - DataSaver
    - Hotspot
    - NFC
    - Rotation lock
    - Wi-Fi
    - Work mode
    
    This is the same idea as the following commits from GrapheneOS, but
    simplified to reduce changes made to each individual QS tile:
    
    commit 45670099ed63c9fbde6ff1bd13d27b674416d21d
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:22:41 2020 -0700
    
        require unlocking to use work mode tile
    
    commit 4b7c9559dfba84e10142fcd53b3edac9c75b0748
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:21:16 2020 -0700
    
        require unlocking to use battery saver tile
    
    commit f45c24a4728531441c60320eda0a4fce4285de06
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:19:36 2020 -0700
    
        require unlocking to use cellular quick tile
    
    commit c18f6f868aee5b8f27fcc1966089f814f9f89ab2
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:15:46 2020 -0700
    
        require unlocking to use hotspot quick tile
    
    commit 442c94e1ee499eed467863362f8eb62bb88027a4
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:13:58 2020 -0700
    
        require unlocking to use data saver quick tile
    
    commit cf84259708f9bf650c8494e16025725b1bfa5e23
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:11:58 2020 -0700
    
        require unlocking to use rotation lock quick tile
    
    commit 61eb5a6392c53e4d44cb91cdb4df27c3055ef439
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:08:33 2020 -0700
    
        require unlocking to use Wi-Fi quick tile
    
    commit ad122f0a5a46e2445b5866d3ff83fdc7623b76f6
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:05:18 2020 -0700
    
        require unlocking to use airplane mode quick tile
    
    commit a3686b6f905fb734b3a4f6db545e8a3ef3fc3cc7
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 17:02:20 2020 -0700
    
        require unlocking to use Bluetooth quick tile
    
    commit 3046535a40f53835eb0b57d4c12a29828ba90f30
    Author: inthewaves <inthewaves@pm.me>
    Date:   Thu Sep 10 16:47:59 2020 -0700
    
        require unlocking to use NFC quick tile
    
    Change-Id: I515f4bdd30f84a4a76f4807afcf3cc5a3ce42fa9
---
 .../systemui/qs/tiles/AirplaneModeTile.java        | 14 ++++--
 .../systemui/qs/tiles/BatterySaverTile.java        | 14 ++++--
 .../android/systemui/qs/tiles/BluetoothTile.java   | 14 ++++--
 .../android/systemui/qs/tiles/CellularTile.java    | 14 ++++--
 .../android/systemui/qs/tiles/DataSaverTile.java   | 14 ++++--
 .../com/android/systemui/qs/tiles/HotspotTile.java | 14 ++++--
 .../src/com/android/systemui/qs/tiles/NfcTile.java | 14 ++++--
 .../systemui/qs/tiles/RotationLockTile.java        | 14 ++++--
 .../systemui/qs/tiles/SecureQSTile.kt (new)        | 58 ++++++++++++++++++++++
 .../com/android/systemui/qs/tiles/WifiTile.java    | 14 ++++--
 .../android/systemui/qs/tiles/WorkModeTile.java    | 14 ++++--
 11 files changed, 158 insertions(+), 40 deletions(-)

diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/AirplaneModeTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/AirplaneModeTile.java
index 22cd6f86b16529d2a6a7aff7766c744d658797f4..f76966030528fd08427eeab7c82756d5966ee746 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/AirplaneModeTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/AirplaneModeTile.java
@@ -41,68 +41,74 @@ import com.android.systemui.broadcast.BroadcastDispatcher;
 import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.GlobalSetting;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import javax.inject.Inject;
 
 import dagger.Lazy;
 
 /** Quick settings tile: Airplane mode **/
-public class AirplaneModeTile extends QSTileImpl<BooleanState> {
+public class AirplaneModeTile extends SecureQSTile<BooleanState> {
     private final Icon mIcon = ResourceIcon.get(com.android.internal.R.drawable.ic_qs_airplane);
     private final GlobalSetting mSetting;
     private final BroadcastDispatcher mBroadcastDispatcher;
     private final Lazy<ConnectivityManager> mLazyConnectivityManager;
 
     private boolean mListening;
 
     @Inject
     public AirplaneModeTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
             BroadcastDispatcher broadcastDispatcher,
-            Lazy<ConnectivityManager> lazyConnectivityManager
+            Lazy<ConnectivityManager> lazyConnectivityManager,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mBroadcastDispatcher = broadcastDispatcher;
         mLazyConnectivityManager = lazyConnectivityManager;
 
         mSetting = new GlobalSetting(mContext, mHandler, Global.AIRPLANE_MODE_ON) {
             @Override
             protected void handleValueChanged(int value) {
                 // mHandler is the background handler so calling this is OK
                 handleRefreshState(value);
             }
         };
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
-    public void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         boolean airplaneModeEnabled = mState.value;
         MetricsLogger.action(mContext, getMetricsCategory(), !airplaneModeEnabled);
         if (!airplaneModeEnabled && TelephonyProperties.in_ecm_mode().orElse(false)) {
             mActivityStarter.postStartActivityDismissingKeyguard(
                     new Intent(TelephonyManager.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS), 0);
             return;
         }
         setEnabled(!airplaneModeEnabled);
     }
 
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/BatterySaverTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/BatterySaverTile.java
index e3024fa0eddc4dce9dc72a6415343193ae558c8e..f68572bc3e758f0e92fe95cbe8157bdbee38b218 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/BatterySaverTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/BatterySaverTile.java
@@ -33,25 +33,26 @@ import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.SecureSetting;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.policy.BatteryController;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.systemui.util.settings.SecureSettings;
 
 import javax.inject.Inject;
 
-public class BatterySaverTile extends QSTileImpl<BooleanState> implements
+public class BatterySaverTile extends SecureQSTile<BooleanState> implements
         BatteryController.BatteryStateChangeCallback {
 
     private final BatteryController mBatteryController;
     @VisibleForTesting
     protected final SecureSetting mSetting;
 
     private int mLevel;
     private boolean mPowerSave;
     private boolean mCharging;
     private boolean mPluggedIn;
@@ -62,24 +63,25 @@ public class BatterySaverTile extends QSTileImpl<BooleanState> implements
     public BatterySaverTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
             BatteryController batteryController,
-            SecureSettings secureSettings
+            SecureSettings secureSettings,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mBatteryController = batteryController;
         mBatteryController.observe(getLifecycle(), this);
         int currentUser = host.getUserContext().getUserId();
         mSetting = new SecureSetting(
                 secureSettings,
                 mHandler,
                 Secure.LOW_POWER_WARNING_ACKNOWLEDGED,
                 currentUser
         ) {
             @Override
@@ -116,21 +118,25 @@ public class BatterySaverTile extends QSTileImpl<BooleanState> implements
         super.handleSetListening(listening);
         mSetting.setListening(listening);
     }
 
     @Override
     public Intent getLongClickIntent() {
         return new Intent(Intent.ACTION_POWER_USAGE_SUMMARY);
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         if (getState().state == Tile.STATE_UNAVAILABLE) {
             return;
         }
         mBatteryController.setPowerSaveMode(!mPowerSave);
     }
 
     @Override
     public CharSequence getTileLabel() {
         return mContext.getString(R.string.battery_detail_switch_title);
     }
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/BluetoothTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/BluetoothTile.java
index 65b6617c5a25212ea2f67ee4fa9b76767a8d28b0..7c24a8c9c10e587731945fc4f94270fa22f40a9b 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/BluetoothTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/BluetoothTile.java
@@ -46,65 +46,71 @@ import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.DetailAdapter;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSDetailItems;
 import com.android.systemui.qs.QSDetailItems.Item;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.policy.BluetoothController;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Bluetooth **/
-public class BluetoothTile extends QSTileImpl<BooleanState> {
+public class BluetoothTile extends SecureQSTile<BooleanState> {
     private static final Intent BLUETOOTH_SETTINGS = new Intent(Settings.ACTION_BLUETOOTH_SETTINGS);
 
     private final BluetoothController mController;
     private final BluetoothDetailAdapter mDetailAdapter;
 
     @Inject
     public BluetoothTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
-            BluetoothController bluetoothController
+            BluetoothController bluetoothController,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mController = bluetoothController;
         mDetailAdapter = (BluetoothDetailAdapter) createDetailAdapter();
         mController.observe(getLifecycle(), mCallback);
     }
 
     @Override
     public DetailAdapter getDetailAdapter() {
         return mDetailAdapter;
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         // Secondary clicks are header clicks, just toggle.
         final boolean isEnabled = mState.value;
         // Immediately enter transient enabling state when turning bluetooth on.
         refreshState(isEnabled ? null : ARG_SHOW_TRANSIENT_ENABLING);
         mController.setBluetoothEnabled(!isEnabled);
     }
 
     @Override
     public Intent getLongClickIntent() {
         return new Intent(Settings.ACTION_BLUETOOTH_SETTINGS);
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java
index e5601f29af0bde768c91111af890c97d567124fa..e7ed5575e3029babc93b3aafe336adf1a4ce32f6 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/CellularTile.java
@@ -55,47 +55,49 @@ import com.android.systemui.plugins.qs.QSTile.SignalState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.SignalTileView;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.connectivity.IconState;
 import com.android.systemui.statusbar.connectivity.MobileDataIndicators;
 import com.android.systemui.statusbar.connectivity.NetworkController;
 import com.android.systemui.statusbar.connectivity.SignalCallback;
 import com.android.systemui.statusbar.phone.SystemUIDialog;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Cellular **/
-public class CellularTile extends QSTileImpl<SignalState> {
+public class CellularTile extends SecureQSTile<SignalState> {
     private static final String ENABLE_SETTINGS_DATA_PLAN = "enable.settings.data.plan";
 
     private final NetworkController mController;
     private final DataUsageController mDataController;
     private final CellularDetailAdapter mDetailAdapter;
 
     private final CellSignalCallback mSignalCallback = new CellSignalCallback();
 
     @Inject
     public CellularTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
-            NetworkController networkController
+            NetworkController networkController,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mController = networkController;
         mDataController = mController.getMobileDataController();
         mDetailAdapter = new CellularDetailAdapter();
         mController.observe(getLifecycle(), mSignalCallback);
     }
 
     @Override
     public SignalState newTileState() {
         return new SignalState();
     }
@@ -112,21 +114,25 @@ public class CellularTile extends QSTileImpl<SignalState> {
 
     @Override
     public Intent getLongClickIntent() {
         if (getState().state == Tile.STATE_UNAVAILABLE) {
             return new Intent(Settings.ACTION_WIRELESS_SETTINGS);
         }
         return getCellularSettingIntent();
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         if (getState().state == Tile.STATE_UNAVAILABLE) {
             return;
         }
         if (mDataController.isMobileDataEnabled()) {
             maybeShowDisableDialog();
         } else {
             mDataController.setMobileDataEnabled(true);
         }
     }
 
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/DataSaverTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/DataSaverTile.java
index a2577d6e7f6021308fc97cee3e16c96743686a74..591d318894916a9ac5ed72fe454b46ae63b4acc3 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/DataSaverTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/DataSaverTile.java
@@ -33,60 +33,66 @@ import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.phone.SystemUIDialog;
 import com.android.systemui.statusbar.policy.DataSaverController;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import javax.inject.Inject;
 
-public class DataSaverTile extends QSTileImpl<BooleanState> implements
+public class DataSaverTile extends SecureQSTile<BooleanState> implements
         DataSaverController.Listener{
 
     private final DataSaverController mDataSaverController;
     private final DialogLaunchAnimator mDialogLaunchAnimator;
 
     @Inject
     public DataSaverTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
             DataSaverController dataSaverController,
-            DialogLaunchAnimator dialogLaunchAnimator
+            DialogLaunchAnimator dialogLaunchAnimator,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mDataSaverController = dataSaverController;
         mDialogLaunchAnimator = dialogLaunchAnimator;
         mDataSaverController.observe(getLifecycle(), this);
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
     public Intent getLongClickIntent() {
         return new Intent(Settings.ACTION_DATA_SAVER_SETTINGS);
     }
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         if (mState.value
                 || Prefs.getBoolean(mContext, Prefs.Key.QS_DATA_SAVER_DIALOG_SHOWN, false)) {
             // Do it right away.
             toggleDataSaver();
             return;
         }
 
         // Show a dialog to confirm first. Dialogs shown by the DialogLaunchAnimator must be created
         // and shown on the main thread, so we post it to the UI handler.
         mUiHandler.post(() -> {
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java
index 87edc2cf8bac0c2f3942c3f8a9d279d3031d4cfb..04742b53321c70577bfa1898127bd60e5c95092f 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/HotspotTile.java
@@ -35,49 +35,51 @@ import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.policy.DataSaverController;
 import com.android.systemui.statusbar.policy.HotspotController;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Hotspot **/
-public class HotspotTile extends QSTileImpl<BooleanState> {
+public class HotspotTile extends SecureQSTile<BooleanState> {
 
     private final Icon mEnabledStatic = ResourceIcon.get(R.drawable.ic_hotspot);
 
     private final HotspotController mHotspotController;
     private final DataSaverController mDataSaverController;
 
     private final HotspotAndDataSaverCallbacks mCallbacks = new HotspotAndDataSaverCallbacks();
     private boolean mListening;
 
     @Inject
     public HotspotTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
             HotspotController hotspotController,
-            DataSaverController dataSaverController
+            DataSaverController dataSaverController,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mHotspotController = hotspotController;
         mDataSaverController = dataSaverController;
         mHotspotController.observe(this, mCallbacks);
         mDataSaverController.observe(this, mCallbacks);
     }
 
     @Override
     public boolean isAvailable() {
         return mHotspotController.isHotspotSupported();
     }
@@ -101,21 +103,25 @@ public class HotspotTile extends QSTileImpl<BooleanState> {
     public Intent getLongClickIntent() {
         return new Intent(Settings.ACTION_WIFI_TETHER_SETTING);
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         final boolean isEnabled = mState.value;
         if (!isEnabled && mDataSaverController.isDataSaverEnabled()) {
             return;
         }
         // Immediately enter transient enabling state when turning hotspot on.
         refreshState(isEnabled ? null : ARG_SHOW_TRANSIENT_ENABLING);
         mHotspotController.setHotspotEnabled(!isEnabled);
     }
 
     @Override
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java
index b9bc0e5ca814756708a38ec0b35ac2994ebb7353..1bd913ea9496b0b08274c338583bbc7457e6c269 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/NfcTile.java
@@ -38,48 +38,50 @@ import com.android.systemui.R;
 import com.android.systemui.broadcast.BroadcastDispatcher;
 import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Enable/Disable NFC **/
-public class NfcTile extends QSTileImpl<BooleanState> {
+public class NfcTile extends SecureQSTile<BooleanState> {
 
     private static final String NFC = "nfc";
     private final Icon mIcon = ResourceIcon.get(R.drawable.ic_qs_nfc);
 
     private NfcAdapter mAdapter;
     private BroadcastDispatcher mBroadcastDispatcher;
 
     private boolean mListening;
 
     @Inject
     public NfcTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
-            BroadcastDispatcher broadcastDispatcher
+            BroadcastDispatcher broadcastDispatcher,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mBroadcastDispatcher = broadcastDispatcher;
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
     public void handleSetListening(boolean listening) {
@@ -107,21 +109,25 @@ public class NfcTile extends QSTileImpl<BooleanState> {
     @Override
     protected void handleUserSwitch(int newUserId) {
     }
 
     @Override
     public Intent getLongClickIntent() {
         return new Intent(Settings.ACTION_NFC_SETTINGS);
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         if (getAdapter() == null) {
             return;
         }
         if (!getAdapter().isEnabled()) {
             getAdapter().enable();
         } else {
             getAdapter().disable();
         }
     }
 
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/RotationLockTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/RotationLockTile.java
index 0bbb5bdd851aeaa2a66a9f3c1d878486d7ca4854..c28d09f80f742f7289be9164b556b97bb18acbcb 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/RotationLockTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/RotationLockTile.java
@@ -33,61 +33,67 @@ import com.android.internal.logging.nano.MetricsProto.MetricsEvent;
 import com.android.systemui.R;
 import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.systemui.statusbar.policy.RotationLockController;
 import com.android.systemui.statusbar.policy.RotationLockController.RotationLockControllerCallback;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Rotation **/
-public class RotationLockTile extends QSTileImpl<BooleanState> {
+public class RotationLockTile extends SecureQSTile<BooleanState> {
 
     private final Icon mIcon = ResourceIcon.get(com.android.internal.R.drawable.ic_qs_auto_rotate);
     private final RotationLockController mController;
 
     @Inject
     public RotationLockTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
-            RotationLockController rotationLockController
+            RotationLockController rotationLockController,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mController = rotationLockController;
         mController.observe(this, mCallback);
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
     public Intent getLongClickIntent() {
         return new Intent(Settings.ACTION_AUTO_ROTATE_SETTINGS);
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         final boolean newState = !mState.value;
         mController.setRotationLocked(!newState);
         refreshState(newState);
     }
 
     @Override
     public CharSequence getTileLabel() {
         return getState().label;
     }
 
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/SecureQSTile.kt b/packages/SystemUI/src/com/android/systemui/qs/tiles/SecureQSTile.kt
new file mode 100644
index 0000000000000000000000000000000000000000..30a5461fbb597bcf46bb107c1176559564bf2bc1
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/SecureQSTile.kt
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.systemui.qs.tiles
+
+import android.os.Handler
+import android.os.Looper
+import android.view.View
+import com.android.systemui.plugins.qs.QSTile
+import com.android.systemui.qs.QSHost
+import com.android.systemui.plugins.FalsingManager
+import com.android.internal.logging.MetricsLogger
+import com.android.systemui.plugins.ActivityStarter
+import com.android.systemui.plugins.statusbar.StatusBarStateController
+import com.android.systemui.qs.logging.QSLogger
+import com.android.systemui.statusbar.policy.KeyguardStateController
+import com.android.systemui.qs.tileimpl.QSTileImpl
+
+internal abstract class SecureQSTile<TState : QSTile.State> protected constructor(
+    host: QSHost, backgroundLooper: Looper, mainHandler: Handler, falsingManager: FalsingManager,
+    metricsLogger: MetricsLogger, statusBarStateController: StatusBarStateController,
+    activityStarter: ActivityStarter, qsLogger: QSLogger,
+    private val mKeyguard: KeyguardStateController,
+) : QSTileImpl<TState>(
+    host, backgroundLooper, mainHandler, falsingManager, metricsLogger, statusBarStateController,
+    activityStarter, qsLogger,
+) {
+    abstract override fun newTileState(): TState
+
+    protected abstract fun handleClick(view: View?, keyguardShowing: Boolean)
+
+    override fun handleClick(view: View?) {
+        handleClick(view, mKeyguard.isMethodSecure && mKeyguard.isShowing)
+    }
+
+    protected fun checkKeyguard(view: View?, keyguardShowing: Boolean): Boolean {
+        return if (keyguardShowing) {
+            mActivityStarter.postQSRunnableDismissingKeyguard {
+                handleClick(view, false)
+            }
+            true
+        } else {
+            false
+        }
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/WifiTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/WifiTile.java
index e79ca0c9321278b7ea1bea8a41c78c9999879ab1..89cebab4fda4a792097a02a3c1fde91e833e62c1 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/WifiTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/WifiTile.java
@@ -51,28 +51,29 @@ import com.android.systemui.qs.QSDetailItems;
 import com.android.systemui.qs.QSDetailItems.Item;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSIconViewImpl;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.connectivity.AccessPointController;
 import com.android.systemui.statusbar.connectivity.NetworkController;
 import com.android.systemui.statusbar.connectivity.SignalCallback;
 import com.android.systemui.statusbar.connectivity.WifiIcons;
 import com.android.systemui.statusbar.connectivity.WifiIndicators;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.wifitrackerlib.WifiEntry;
 
 import java.util.List;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Wifi **/
-public class WifiTile extends QSTileImpl<SignalState> {
+public class WifiTile extends SecureQSTile<SignalState> {
     private static final Intent WIFI_SETTINGS = new Intent(Settings.ACTION_WIFI_SETTINGS);
 
     protected final NetworkController mController;
     private final AccessPointController mWifiController;
     private final WifiDetailAdapter mDetailAdapter;
     private final QSTile.SignalState mStateBeforeClick = newTileState();
 
     protected final WifiSignalCallback mSignalCallback = new WifiSignalCallback();
     private boolean mExpectDisabled;
 
@@ -80,24 +81,25 @@ public class WifiTile extends QSTileImpl<SignalState> {
     public WifiTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
             NetworkController networkController,
-            AccessPointController accessPointController
+            AccessPointController accessPointController,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mController = networkController;
         mWifiController = accessPointController;
         mDetailAdapter = (WifiDetailAdapter) createDetailAdapter();
         mController.observe(getLifecycle(), mSignalCallback);
         mStateBeforeClick.spec = "wifi";
     }
 
     @Override
     public SignalState newTileState() {
         return new SignalState();
@@ -126,21 +128,25 @@ public class WifiTile extends QSTileImpl<SignalState> {
     public QSIconView createTileView(Context context) {
         return new AlphaControlledSignalTileView(context);
     }
 
     @Override
     public Intent getLongClickIntent() {
         return WIFI_SETTINGS;
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         // Secondary clicks are header clicks, just toggle.
         mState.copyTo(mStateBeforeClick);
         boolean wifiEnabled = mState.value;
         // Immediately enter transient state when turning on wifi.
         refreshState(wifiEnabled ? null : ARG_SHOW_TRANSIENT_ENABLING);
         mController.setWifiEnabled(!wifiEnabled);
         mExpectDisabled = wifiEnabled;
         if (mExpectDisabled) {
             mHandler.postDelayed(() -> {
                 if (mExpectDisabled) {
diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/WorkModeTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/WorkModeTile.java
index 8df8c63702c3671a7c5e2bfb2edc2efb2388c17d..7fc1726632eaa8cba0eedd25840a4f080a75c40a 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/WorkModeTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/WorkModeTile.java
@@ -32,60 +32,66 @@ import com.android.systemui.R;
 import com.android.systemui.dagger.qualifiers.Background;
 import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSTile.BooleanState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.statusbar.phone.ManagedProfileController;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Work profile on/off */
-public class WorkModeTile extends QSTileImpl<BooleanState> implements
+public class WorkModeTile extends SecureQSTile<BooleanState> implements
         ManagedProfileController.Callback {
     private final Icon mIcon = ResourceIcon.get(R.drawable.stat_sys_managed_profile_status);
 
     private final ManagedProfileController mProfileController;
 
     @Inject
     public WorkModeTile(
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
-            ManagedProfileController managedProfileController
+            ManagedProfileController managedProfileController,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mProfileController = managedProfileController;
         mProfileController.observe(getLifecycle(), this);
     }
 
     @Override
     public BooleanState newTileState() {
         return new BooleanState();
     }
 
     @Override
     public Intent getLongClickIntent() {
         return new Intent(Settings.ACTION_MANAGED_PROFILE_SETTINGS);
     }
 
     @Override
-    public void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
+
         mProfileController.setWorkModeEnabled(!mState.value);
     }
 
     @Override
     public boolean isAvailable() {
         return mProfileController.hasActiveProfile();
     }
 
     @Override
     public void onManagedProfileChanged() {

commit 3fab3dd27bb9a6591e03784a0ab05a442ccb4352
Author: flawedworld <flawedworld@flawed.world>
Date:   Thu 2021-12-09 16:24:47+0000

    SystemUI: Require unlocking to use Internet quick tile
---
 .../src/com/android/systemui/qs/tiles/InternetTile.java     | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/packages/SystemUI/src/com/android/systemui/qs/tiles/InternetTile.java b/packages/SystemUI/src/com/android/systemui/qs/tiles/InternetTile.java
index cd81b4a11703b0068f5ef5291e0c18575d776ef8..61be4e7ccd4041d237da5f31fd49a0fbda16087d 100644
--- a/packages/SystemUI/src/com/android/systemui/qs/tiles/InternetTile.java
+++ b/packages/SystemUI/src/com/android/systemui/qs/tiles/InternetTile.java
@@ -46,35 +46,36 @@ import com.android.systemui.dagger.qualifiers.Main;
 import com.android.systemui.plugins.ActivityStarter;
 import com.android.systemui.plugins.FalsingManager;
 import com.android.systemui.plugins.qs.QSIconView;
 import com.android.systemui.plugins.qs.QSTile.SignalState;
 import com.android.systemui.plugins.statusbar.StatusBarStateController;
 import com.android.systemui.qs.AlphaControlledSignalTileView;
 import com.android.systemui.qs.QSHost;
 import com.android.systemui.qs.logging.QSLogger;
 import com.android.systemui.qs.tileimpl.QSTileImpl;
 import com.android.systemui.qs.tiles.dialog.InternetDialogFactory;
+import com.android.systemui.statusbar.policy.KeyguardStateController;
 import com.android.systemui.statusbar.connectivity.AccessPointController;
 import com.android.systemui.statusbar.connectivity.IconState;
 import com.android.systemui.statusbar.connectivity.MobileDataIndicators;
 import com.android.systemui.statusbar.connectivity.NetworkController;
 import com.android.systemui.statusbar.connectivity.SignalCallback;
 import com.android.systemui.statusbar.connectivity.WifiIcons;
 import com.android.systemui.statusbar.connectivity.WifiIndicators;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 
 import javax.inject.Inject;
 
 /** Quick settings tile: Internet **/
-public class InternetTile extends QSTileImpl<SignalState> {
+public class InternetTile extends SecureQSTile<SignalState> {
     private static final Intent WIFI_SETTINGS = new Intent(Settings.ACTION_WIFI_SETTINGS);
 
     protected final NetworkController mController;
     private final AccessPointController mAccessPointController;
     private final DataUsageController mDataController;
     // The last updated tile state, 0: mobile, 1: wifi, 2: ethernet.
     private int mLastTileState = -1;
 
     protected final InternetSignalCallback mSignalCallback = new InternetSignalCallback();
     private final InternetDialogFactory mInternetDialogFactory;
@@ -85,24 +86,25 @@ public class InternetTile extends QSTileImpl<SignalState> {
             QSHost host,
             @Background Looper backgroundLooper,
             @Main Handler mainHandler,
             FalsingManager falsingManager,
             MetricsLogger metricsLogger,
             StatusBarStateController statusBarStateController,
             ActivityStarter activityStarter,
             QSLogger qsLogger,
             NetworkController networkController,
             AccessPointController accessPointController,
-            InternetDialogFactory internetDialogFactory
+            InternetDialogFactory internetDialogFactory,
+            KeyguardStateController keyguardStateController
     ) {
         super(host, backgroundLooper, mainHandler, falsingManager, metricsLogger,
-                statusBarStateController, activityStarter, qsLogger);
+                statusBarStateController, activityStarter, qsLogger, keyguardStateController);
         mInternetDialogFactory = internetDialogFactory;
         mHandler = mainHandler;
         mController = networkController;
         mAccessPointController = accessPointController;
         mDataController = mController.getMobileDataController();
         mController.observe(getLifecycle(), mSignalCallback);
     }
 
     @Override
     public SignalState newTileState() {
@@ -115,21 +117,24 @@ public class InternetTile extends QSTileImpl<SignalState> {
     public QSIconView createTileView(Context context) {
         return new AlphaControlledSignalTileView(context);
     }
 
     @Override
     public Intent getLongClickIntent() {
         return WIFI_SETTINGS;
     }
 
     @Override
-    protected void handleClick(@Nullable View view) {
+    protected void handleClick(@Nullable View view, boolean keyguardShowing) {
+        if (checkKeyguard(view, keyguardShowing)) {
+            return;
+        }
         mHandler.post(() -> mInternetDialogFactory.create(true,
                 mAccessPointController.canConfigMobileData(),
                 mAccessPointController.canConfigWifi(), view));
     }
 
     @Override
     public CharSequence getTileLabel() {
         return mContext.getString(R.string.quick_settings_internet_label);
     }
 

commit 7c199609940c092eb093fa998c705ef3df8d6b0f
Author: Danny Lin <danny@kdrag0n.dev>
Date:   Mon 2022-03-07 22:07:14+0000

    colors: Switch to GrapheneOS blue color palette for Material You
    
    Generated with Android 12 Extensions v9.0.0-test2 [1] using #1565C0
    (light link accent color from GrapheneOS website) as a seed color,
    with all other settings left at themelib [2] and colorkt [3] defaults.
    
    [1] https://github.com/kdrag0n/android12-extensions/
    [2] https://github.com/ProtonAOSP/android_external_themelib
    [3] https://github.com/kdrag0n/colorkt
---
 core/res/res/values/colors.xml | 110 ++++++++++++++++++++---------------------
 1 file changed, 55 insertions(+), 55 deletions(-)

diff --git a/core/res/res/values/colors.xml b/core/res/res/values/colors.xml
index 59d6005ba19348e6415a88d5cb09a2aa5fafd1fc..b8debe007ce6f20594e712179365efad08521ec7 100644
--- a/core/res/res/values/colors.xml
+++ b/core/res/res/values/colors.xml
@@ -241,211 +241,211 @@
     <!-- Color for personal app suspension notification button text and icon tint. -->
     <color name="personal_apps_suspension_notification_color">#1A73E8</color>
 
     <color name="conversation_important_highlight">#F9AB00</color>
 
     <!-- Lightest shade of the accent color used by the system. White.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_accent1_0">#ffffff</color>
     <!-- Shade of the accent system color at 99% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_10">#F9FCFF</color>
+    <color name="system_accent1_10">#fafcff</color>
     <!-- Shade of the accent system color at 95% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_50">#E0F3FF</color>
+    <color name="system_accent1_50">#e5f1ff</color>
     <!-- Shade of the accent system color at 90% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_100">#C1E8FF</color>
+    <color name="system_accent1_100">#cbe2ff</color>
     <!-- Shade of the accent system color at 80% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_200">#76D1FF</color>
+    <color name="system_accent1_200">#95c4ff</color>
     <!-- Shade of the accent system color at 70% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_300">#4BB6E8</color>
+    <color name="system_accent1_300">#5ba2ff</color>
     <!-- Shade of the accent system color at 60% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_400">#219BCC</color>
+    <color name="system_accent1_400">#3884e7</color>
     <!-- Shade of the accent system color at 49.6% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_500">#007FAC</color>
+    <color name="system_accent1_500">#1b69c5</color>
     <!-- Shade of the accent system color at 40% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_600">#00668B</color>
+    <color name="system_accent1_600">#0053a3</color>
     <!-- Shade of the accent system color at 30% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_700">#004C69</color>
+    <color name="system_accent1_700">#003f7b</color>
     <!-- Shade of the accent system color at 20% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_800">#003549</color>
+    <color name="system_accent1_800">#002b55</color>
     <!-- Shade of the accent system color at 10% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent1_900">#001E2C</color>
+    <color name="system_accent1_900">#001933</color>
     <!-- Darkest shade of the accent color used by the system. Black.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_accent1_1000">#000000</color>
 
     <!-- Lightest shade of the secondary accent color used by the system. White.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_accent2_0">#ffffff</color>
     <!-- Shade of the secondary accent system color at 99% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_10">#F9FCFF</color>
+    <color name="system_accent2_10">#fafcff</color>
     <!-- Shade of the secondary accent system color at 95% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_50">#E0F3FF</color>
+    <color name="system_accent2_50">#e5f1ff</color>
     <!-- Shade of the secondary accent system color at 90% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_100">#D1E5F4</color>
+    <color name="system_accent2_100">#cee2fb</color>
     <!-- Shade of the secondary accent system color at 80% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_200">#B5CAD7</color>
+    <color name="system_accent2_200">#b4c6dd</color>
     <!-- Shade of the secondary accent system color at 70% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_300">#9AAEBB</color>
+    <color name="system_accent2_300">#9aabc0</color>
     <!-- Shade of the secondary accent system color at 60% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_400">#8094A0</color>
+    <color name="system_accent2_400">#8090a4</color>
     <!-- Shade of the secondary accent system color at 49.6% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_500">#657985</color>
+    <color name="system_accent2_500">#677688</color>
     <!-- Shade of the secondary accent system color at 40% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_600">#4E616C</color>
+    <color name="system_accent2_600">#505e6f</color>
     <!-- Shade of the secondary accent system color at 30% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_700">#374955</color>
+    <color name="system_accent2_700">#394656</color>
     <!-- Shade of the secondary accent system color at 20% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_800">#20333D</color>
+    <color name="system_accent2_800">#23303f</color>
     <!-- Shade of the secondary accent system color at 10% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent2_900">#091E28</color>
+    <color name="system_accent2_900">#0d1b29</color>
     <!-- Darkest shade of the secondary accent color used by the system. Black.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_accent2_1000">#000000</color>
 
     <!-- Lightest shade of the tertiary accent color used by the system. White.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_accent3_0">#ffffff</color>
     <!-- Shade of the tertiary accent system color at 99% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_10">#FFFBFF</color>
+    <color name="system_accent3_10">#fffaff</color>
     <!-- Shade of the tertiary accent system color at 95% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_50">#F5EEFF</color>
+    <color name="system_accent3_50">#fce8ff</color>
     <!-- Shade of the tertiary accent system color at 90% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_100">#E6DEFF</color>
+    <color name="system_accent3_100">#f8d0ff</color>
     <!-- Shade of the tertiary accent system color at 80% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_200">#CAC1EA</color>
+    <color name="system_accent3_200">#eba3f8</color>
     <!-- Shade of the tertiary accent system color at 70% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_300">#AEA6CE</color>
+    <color name="system_accent3_300">#ce8ad9</color>
     <!-- Shade of the tertiary accent system color at 60% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_400">#938CB1</color>
+    <color name="system_accent3_400">#b071bb</color>
     <!-- Shade of the tertiary accent system color at 49% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_500">#787296</color>
+    <color name="system_accent3_500">#93589d</color>
     <!-- Shade of the tertiary accent system color at 40% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_600">#605A7C</color>
+    <color name="system_accent3_600">#794183</color>
     <!-- Shade of the tertiary accent system color at 30% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_700">#484264</color>
+    <color name="system_accent3_700">#5f2968</color>
     <!-- Shade of the tertiary accent system color at 20% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_800">#322C4C</color>
+    <color name="system_accent3_800">#470e4f</color>
     <!-- Shade of the tertiary accent system color at 10% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_accent3_900">#1D1736</color>
+    <color name="system_accent3_900">#2d0033</color>
     <!-- Darkest shade of the tertiary accent color used by the system. Black.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_accent3_1000">#000000</color>
 
     <!-- Lightest shade of the neutral color used by the system. White.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_neutral1_0">#ffffff</color>
     <!-- Shade of the neutral system color at 99% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_10">#FCFCFF</color>
+    <color name="system_neutral1_10">#fafcff</color>
     <!-- Shade of the neutral system color at 95% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_50">#F0F0F3</color>
+    <color name="system_neutral1_50">#ebf1f7</color>
     <!-- Shade of the neutral system color at 90% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_100">#E1E3E5</color>
+    <color name="system_neutral1_100">#dde2e9</color>
     <!-- Shade of the neutral system color at 80% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_200">#C5C7C9</color>
+    <color name="system_neutral1_200">#c2c6cc</color>
     <!-- Shade of the neutral system color at 70% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_300">#AAABAE</color>
+    <color name="system_neutral1_300">#a7abb1</color>
     <!-- Shade of the neutral system color at 60% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_400">#8F9193</color>
+    <color name="system_neutral1_400">#8c9196</color>
     <!-- Shade of the neutral system color at 49% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_500">#747679</color>
+    <color name="system_neutral1_500">#72767b</color>
     <!-- Shade of the neutral system color at 40% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_600">#5C5F61</color>
+    <color name="system_neutral1_600">#5b5e63</color>
     <!-- Shade of the neutral system color at 30% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_700">#454749</color>
+    <color name="system_neutral1_700">#43474b</color>
     <!-- Shade of the neutral system color at 20% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_800">#2E3133</color>
+    <color name="system_neutral1_800">#2d3034</color>
     <!-- Shade of the neutral system color at 10% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral1_900">#191C1E</color>
+    <color name="system_neutral1_900">#181c1f</color>
     <!-- Darkest shade of the neutral color used by the system. Black.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_neutral1_1000">#000000</color>
 
     <!-- Lightest shade of the secondary neutral color used by the system. White.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_neutral2_0">#ffffff</color>
     <!-- Shade of the secondary neutral system color at 99% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_10">#F9FCFF</color>
+    <color name="system_neutral2_10">#fafcff</color>
     <!-- Shade of the secondary neutral system color at 95% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_50">#EBF1F8</color>
+    <color name="system_neutral2_50">#e6f1fd</color>
     <!-- Shade of the secondary neutral system color at 90% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_100">#DCE3E9</color>
+    <color name="system_neutral2_100">#d9e2ef</color>
     <!-- Shade of the secondary neutral system color at 80% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_200">#C0C7CD</color>
+    <color name="system_neutral2_200">#bdc6d2</color>
     <!-- Shade of the secondary neutral system color at 70% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_300">#A5ACB2</color>
+    <color name="system_neutral2_300">#a2abb6</color>
     <!-- Shade of the secondary neutral system color at 60% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_400">#8A9297</color>
+    <color name="system_neutral2_400">#88919a</color>
     <!-- Shade of the secondary neutral system color at 49% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_500">#70777C</color>
+    <color name="system_neutral2_500">#6e767f</color>
     <!-- Shade of the secondary neutral system color at 40% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_600">#585F65</color>
+    <color name="system_neutral2_600">#575e67</color>
     <!-- Shade of the secondary neutral system color at 30% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_700">#40484D</color>
+    <color name="system_neutral2_700">#40474f</color>
     <!-- Shade of the secondary neutral system color at 20% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_800">#2A3136</color>
+    <color name="system_neutral2_800">#2a3038</color>
     <!-- Shade of the secondary neutral system color at 10% perceptual luminance (L* in L*a*b* color space).
      This value can be overlaid at runtime by OverlayManager RROs. -->
-    <color name="system_neutral2_900">#161C20</color>
+    <color name="system_neutral2_900">#151b23</color>
     <!-- Darkest shade of the secondary neutral color used by the system. Black.
      This value can be overlaid at runtime by OverlayManager RROs. -->
     <color name="system_neutral2_1000">#000000</color>
 
     <!-- Accessibility shortcut icon background color -->
     <color name="accessibility_feature_background">#5F6368</color> <!-- Google grey 700 -->
     <color name="accessibility_magnification_background">#F50D60</color>
     <color name="accessibility_daltonizer_background">#00BCD4</color>
     <color name="accessibility_color_inversion_background">#546E7A</color>
 </resources>

commit 872d78095486862a991da73193b154820d14fed9
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Mon 2022-03-07 22:59:23-0500

    attempt to fix PIN scrambling
---
 .../src/com/android/keyguard/KeyguardPINView.java       | 17 ++++++-----------
 1 file changed, 6 insertions(+), 11 deletions(-)

diff --git a/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java b/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
index 199c9f8946df97065a1f4753b3b7a67516296d31..5c93dfcb6822b97b5566be6d1d02908bb344b6d4 100644
--- a/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
+++ b/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java
@@ -167,33 +167,28 @@ public class KeyguardPINView extends KeyguardPinBasedInputView {
                 new View[]{
                         null, mEcaView, null
                 }};
 
         boolean scramblePin = Settings.Secure.getIntForUser(mContext.getContentResolver(),
                 Settings.Secure.SCRAMBLE_PIN_LAYOUT, 0, ActivityManager.getCurrentUser()) == 1;
 
         if (scramblePin) {
             List<Integer> digits = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0);
             Collections.shuffle(digits, new SecureRandom());
-            LinearLayout container = (LinearLayout) findViewById(R.id.pin_container);
+            ConstraintLayout container = (ConstraintLayout) findViewById(R.id.pin_container);
             int finished = 0;
             for (int i = 0; i < container.getChildCount(); i++) {
-                if (container.getChildAt(i) instanceof LinearLayout) {
-                    LinearLayout nestedLayout = ((LinearLayout) container.getChildAt(i));
-                    for (int j = 0; j < nestedLayout.getChildCount(); j++){
-                        View view = nestedLayout.getChildAt(j);
-                        if (view.getClass() == NumPadKey.class) {
-                            NumPadKey key = (NumPadKey) view;
-                            key.setDigit(digits.get(finished));
-                            finished++;
-                        }
-                    }
+                View view = container.getChildAt(i);
+                if (view.getClass() == NumPadKey.class) {
+                    NumPadKey key = (NumPadKey) view;
+                    key.setDigit(digits.get(finished));
+                    finished++;
                 }
             }
         }
     }
 
     @Override
     public int getWrongPasswordStringId() {
         return R.string.kg_wrong_pin;
     }
 

commit 0d7bab0277bde7b1ecd75f7f4ef85e77619b9e10 (HEAD, tag: SP2A.220305.012.2022030801, m/master)
Author: Daniel Micay <danielmicay@gmail.com>
Date:   Tue 2022-03-08 02:09:57-0500

    disable monet by default
    
    We need to add an opt-in toggle for this feature since we don't want it
    enabled by default. We don't think people want the color scheme based on
    their wallpaper by default. The resulting color scheme is accessible to
    apps so it can be used to fingerprint a user based on their wallpaper,
    including from a nested work profile.
---
 packages/SystemUI/res/values/flags.xml                      | 2 +-
 packages/SystemUI/src/com/android/systemui/flags/Flags.java | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/packages/SystemUI/res/values/flags.xml b/packages/SystemUI/res/values/flags.xml
index c598097cd5aff804021f00a449cc247171903002..1b9fc39d40136d9b1a12c8ebe50c72d479e5e82d 100644
--- a/packages/SystemUI/res/values/flags.xml
+++ b/packages/SystemUI/res/values/flags.xml
@@ -11,19 +11,19 @@
   ~ Unless required by applicable law or agreed to in writing, software
   ~ distributed under the License is distributed on an "AS IS" BASIS,
   ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
 
 <resources>
     <bool name="are_flags_overrideable">false</bool>
 
-    <bool name="flag_monet">true</bool>
+    <bool name="flag_monet">false</bool>
 
     <!-- People Tile flag -->
     <bool name="flag_conversations">false</bool>
 
     <bool name="flag_charging_ripple">false</bool>
 
     <bool name="flag_smartspace">false</bool>
 </resources>
diff --git a/packages/SystemUI/src/com/android/systemui/flags/Flags.java b/packages/SystemUI/src/com/android/systemui/flags/Flags.java
index c33aa9e5ee28e72fae439d5e76ae7512e7c9f0b0..d51766f9efab725c229f6f716c3e2b92998b6775 100644
--- a/packages/SystemUI/src/com/android/systemui/flags/Flags.java
+++ b/packages/SystemUI/src/com/android/systemui/flags/Flags.java
@@ -102,21 +102,21 @@ public class Flags {
 
     public static final BooleanFlag ONGOING_CALL_IN_IMMERSIVE =
             new BooleanFlag(701, true);
 
     public static final BooleanFlag ONGOING_CALL_IN_IMMERSIVE_CHIP_TAP =
             new BooleanFlag(702, true);
 
     /***************************************/
     // 800 - general visual/theme
     public static final BooleanFlag MONET =
-            new BooleanFlag(800, true, R.bool.flag_monet);
+            new BooleanFlag(800, false, R.bool.flag_monet);
 
     // Pay no attention to the reflection behind the curtain.
     // ========================== Curtain ==========================
     // |                                                           |
     // |  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  |
     private static Map<Integer, Flag<?>> sFlagMap;
     static Map<Integer, Flag<?>> collectFlags() {
         if (sFlagMap != null) {
             return sFlagMap;
         }
